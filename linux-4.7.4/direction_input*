./sound/ppc/pmac.c:67:	rec->space = dma_alloc_coherent(&chip->pdev->dev, rsize,
./sound/ppc/pmac.c:84:		dma_free_coherent(&chip->pdev->dev, rsize, rec->space, rec->dma_base);
./sound/ppc/pmac.c:102:	if (rate > chip->freq_table[0])
./sound/ppc/pmac.c:105:	for (i = 0; i < chip->num_freqs; i++, ok >>= 1) {
./sound/ppc/pmac.c:108:		if (rate >= chip->freq_table[i])
./sound/ppc/pmac.c:148:		return &chip->playback;
./sound/ppc/pmac.c:150:		return &chip->capture;
./sound/ppc/pmac.c:175:	out_le32(&chip->awacs->control, chip->control_mask | (chip->rate_index << 8));
./sound/ppc/pmac.c:176:	out_le32(&chip->awacs->byteswap, chip->format == SNDRV_PCM_FORMAT_S16_LE ? 1 : 0);
./sound/ppc/pmac.c:177:	if (chip->set_format)
./sound/ppc/pmac.c:178:		chip->set_format(chip);
./sound/ppc/pmac.c:231:	chip->rate_index = rate_index;
./sound/ppc/pmac.c:232:	chip->format = runtime->format;
./sound/ppc/pmac.c:240:	spin_lock_irq(&chip->reg_lock);
./sound/ppc/pmac.c:242:	chip->extra_dma.cmds->command = cpu_to_le16(DBDMA_STOP);
./sound/ppc/pmac.c:243:	snd_pmac_dma_set_command(rec, &chip->extra_dma);
./sound/ppc/pmac.c:245:	spin_unlock_irq(&chip->reg_lock);
./sound/ppc/pmac.c:247:	spin_lock_irq(&chip->reg_lock);
./sound/ppc/pmac.c:265:	spin_unlock_irq(&chip->reg_lock);
./sound/ppc/pmac.c:287:		spin_lock(&chip->reg_lock);
./sound/ppc/pmac.c:296:		spin_unlock(&chip->reg_lock);
./sound/ppc/pmac.c:301:		spin_lock(&chip->reg_lock);
./sound/ppc/pmac.c:307:		spin_unlock(&chip->reg_lock);
./sound/ppc/pmac.c:349:	return snd_pmac_pcm_prepare(chip, &chip->playback, subs);
./sound/ppc/pmac.c:356:	return snd_pmac_pcm_trigger(chip, &chip->playback, subs, cmd);
./sound/ppc/pmac.c:362:	return snd_pmac_pcm_pointer(chip, &chip->playback, subs);
./sound/ppc/pmac.c:373:	return snd_pmac_pcm_prepare(chip, &chip->capture, subs);
./sound/ppc/pmac.c:380:	return snd_pmac_pcm_trigger(chip, &chip->capture, subs, cmd);
./sound/ppc/pmac.c:386:	return snd_pmac_pcm_pointer(chip, &chip->capture, subs);
./sound/ppc/pmac.c:468:	spin_lock(&chip->reg_lock);
./sound/ppc/pmac.c:499:			spin_unlock(&chip->reg_lock);
./sound/ppc/pmac.c:501:			spin_lock(&chip->reg_lock);
./sound/ppc/pmac.c:504:	spin_unlock(&chip->reg_lock);
./sound/ppc/pmac.c:562:	for (i = chip->num_freqs - 1; i >= 0; i--) {
./sound/ppc/pmac.c:564:			freq_table[num_freqs++] = chip->freq_table[i];
./sound/ppc/pmac.c:592:	for (i = 0; i < chip->num_freqs; i++)
./sound/ppc/pmac.c:593:		if (chip->freqs_ok & (1 << i))
./sound/ppc/pmac.c:595:				snd_pcm_rate_to_rate_bit(chip->freq_table[i]);
./sound/ppc/pmac.c:598:	for (i = 0; i < chip->num_freqs; i++) {
./sound/ppc/pmac.c:599:		if (chip->freqs_ok & (1 << i)) {
./sound/ppc/pmac.c:600:			runtime->hw.rate_max = chip->freq_table[i];
./sound/ppc/pmac.c:604:	for (i = chip->num_freqs - 1; i >= 0; i--) {
./sound/ppc/pmac.c:605:		if (chip->freqs_ok & (1 << i)) {
./sound/ppc/pmac.c:606:			runtime->hw.rate_min = chip->freq_table[i];
./sound/ppc/pmac.c:610:	runtime->hw.formats = chip->formats_ok;
./sound/ppc/pmac.c:611:	if (chip->can_capture) {
./sound/ppc/pmac.c:612:		if (! chip->can_duplex)
./sound/ppc/pmac.c:645:	astr->cur_freqs = chip->freqs_ok;
./sound/ppc/pmac.c:646:	astr->cur_formats = chip->formats_ok;
./sound/ppc/pmac.c:656:	return snd_pmac_pcm_open(chip, &chip->playback, subs);
./sound/ppc/pmac.c:664:	return snd_pmac_pcm_open(chip, &chip->capture, subs);
./sound/ppc/pmac.c:671:	return snd_pmac_pcm_close(chip, &chip->playback, subs);
./sound/ppc/pmac.c:678:	return snd_pmac_pcm_close(chip, &chip->capture, subs);
./sound/ppc/pmac.c:712:	if (! chip->can_capture)
./sound/ppc/pmac.c:714:	err = snd_pcm_new(chip->card, chip->card->driver, 0, 1, num_captures, &pcm);
./sound/ppc/pmac.c:719:	if (chip->can_capture)
./sound/ppc/pmac.c:724:	strcpy(pcm->name, chip->card->shortname);
./sound/ppc/pmac.c:725:	chip->pcm = pcm;
./sound/ppc/pmac.c:727:	chip->formats_ok = SNDRV_PCM_FMTBIT_S16_BE;
./sound/ppc/pmac.c:728:	if (chip->can_byte_swap)
./sound/ppc/pmac.c:729:		chip->formats_ok |= SNDRV_PCM_FMTBIT_S16_LE;
./sound/ppc/pmac.c:731:	chip->playback.cur_formats = chip->formats_ok;
./sound/ppc/pmac.c:732:	chip->capture.cur_formats = chip->formats_ok;
./sound/ppc/pmac.c:733:	chip->playback.cur_freqs = chip->freqs_ok;
./sound/ppc/pmac.c:734:	chip->capture.cur_freqs = chip->freqs_ok;
./sound/ppc/pmac.c:738:					      &chip->pdev->dev,
./sound/ppc/pmac.c:747:	out_le32(&chip->playback.dma->control, (RUN|PAUSE|FLUSH|WAKE|DEAD) << 16);
./sound/ppc/pmac.c:748:	snd_pmac_wait_ack(&chip->playback);
./sound/ppc/pmac.c:749:	out_le32(&chip->capture.dma->control, (RUN|PAUSE|FLUSH|WAKE|DEAD) << 16);
./sound/ppc/pmac.c:750:	snd_pmac_wait_ack(&chip->capture);
./sound/ppc/pmac.c:759:	struct pmac_stream *rec = &chip->playback;
./sound/ppc/pmac.c:762:	chip->extra_dma.cmds->req_count = cpu_to_le16(bytes);
./sound/ppc/pmac.c:763:	chip->extra_dma.cmds->xfer_status = cpu_to_le16(0);
./sound/ppc/pmac.c:764:	chip->extra_dma.cmds->cmd_dep = cpu_to_le32(chip->extra_dma.addr);
./sound/ppc/pmac.c:765:	chip->extra_dma.cmds->phy_addr = cpu_to_le32(addr);
./sound/ppc/pmac.c:766:	chip->extra_dma.cmds->command = cpu_to_le16(OUTPUT_MORE + BR_ALWAYS);
./sound/ppc/pmac.c:767:	out_le32(&chip->awacs->control,
./sound/ppc/pmac.c:768:		 (in_le32(&chip->awacs->control) & ~0x1f00)
./sound/ppc/pmac.c:770:	out_le32(&chip->awacs->byteswap, 0);
./sound/ppc/pmac.c:771:	snd_pmac_dma_set_command(rec, &chip->extra_dma);
./sound/ppc/pmac.c:777:	snd_pmac_dma_stop(&chip->playback);
./sound/ppc/pmac.c:778:	chip->extra_dma.cmds->command = cpu_to_le16(DBDMA_STOP);
./sound/ppc/pmac.c:790:	snd_pmac_pcm_update(chip, &chip->playback);
./sound/ppc/pmac.c:799:	snd_pmac_pcm_update(chip, &chip->capture);
./sound/ppc/pmac.c:808:	int ctrl = in_le32(&chip->awacs->control);
./sound/ppc/pmac.c:813:		if (chip->update_automute)
./sound/ppc/pmac.c:814:			chip->update_automute(chip, 1);
./sound/ppc/pmac.c:817:		int err = (in_le32(&chip->awacs->codec_stat) & MASK_ERRCODE) >> 16;
./sound/ppc/pmac.c:818:		if (err && chip->model <= PMAC_SCREAMER)
./sound/ppc/pmac.c:822:	out_le32(&chip->awacs->control, ctrl);
./sound/ppc/pmac.c:833:		ppc_md.feature_call(PMAC_FTR_SOUND_CHIP_ENABLE, chip->node, 0, enable);
./sound/ppc/pmac.c:843:	if (chip->initialized) {
./sound/ppc/pmac.c:846:		out_le32(&chip->awacs->control, in_le32(&chip->awacs->control) & 0xfff);
./sound/ppc/pmac.c:849:	if (chip->node)
./sound/ppc/pmac.c:853:	if (chip->mixer_free)
./sound/ppc/pmac.c:854:		chip->mixer_free(chip);
./sound/ppc/pmac.c:859:	if (chip->irq >= 0)
./sound/ppc/pmac.c:860:		free_irq(chip->irq, (void*)chip);
./sound/ppc/pmac.c:861:	if (chip->tx_irq >= 0)
./sound/ppc/pmac.c:862:		free_irq(chip->tx_irq, (void*)chip);
./sound/ppc/pmac.c:863:	if (chip->rx_irq >= 0)
./sound/ppc/pmac.c:864:		free_irq(chip->rx_irq, (void*)chip);
./sound/ppc/pmac.c:865:	snd_pmac_dbdma_free(chip, &chip->playback.cmd);
./sound/ppc/pmac.c:866:	snd_pmac_dbdma_free(chip, &chip->capture.cmd);
./sound/ppc/pmac.c:867:	snd_pmac_dbdma_free(chip, &chip->extra_dma);
./sound/ppc/pmac.c:869:	iounmap(chip->macio_base);
./sound/ppc/pmac.c:870:	iounmap(chip->latch_base);
./sound/ppc/pmac.c:871:	iounmap(chip->awacs);
./sound/ppc/pmac.c:872:	iounmap(chip->playback.dma);
./sound/ppc/pmac.c:873:	iounmap(chip->capture.dma);
./sound/ppc/pmac.c:875:	if (chip->node) {
./sound/ppc/pmac.c:878:			if (chip->requested & (1 << i))
./sound/ppc/pmac.c:879:				release_mem_region(chip->rsrc[i].start,
./sound/ppc/pmac.c:880:						   resource_size(&chip->rsrc[i]));
./sound/ppc/pmac.c:884:	pci_dev_put(chip->pdev);
./sound/ppc/pmac.c:885:	of_node_put(chip->node);
./sound/ppc/pmac.c:910:	for (mio = chip->node->parent; mio; mio = mio->parent) {
./sound/ppc/pmac.c:913:				chip->can_byte_swap = 0;
./sound/ppc/pmac.c:921:		chip->can_byte_swap = 0 ;
./sound/ppc/pmac.c:924:		chip->can_duplex = 0;
./sound/ppc/pmac.c:942:	chip->subframe = 0;
./sound/ppc/pmac.c:943:	chip->revision = 0;
./sound/ppc/pmac.c:944:	chip->freqs_ok = 0xff; /* all ok */
./sound/ppc/pmac.c:945:	chip->model = PMAC_AWACS;
./sound/ppc/pmac.c:946:	chip->can_byte_swap = 1;
./sound/ppc/pmac.c:947:	chip->can_duplex = 1;
./sound/ppc/pmac.c:948:	chip->can_capture = 1;
./sound/ppc/pmac.c:949:	chip->num_freqs = ARRAY_SIZE(awacs_freqs);
./sound/ppc/pmac.c:950:	chip->freq_table = awacs_freqs;
./sound/ppc/pmac.c:951:	chip->pdev = NULL;
./sound/ppc/pmac.c:953:	chip->control_mask = MASK_IEPC | MASK_IEE | 0x11; /* default */
./sound/ppc/pmac.c:958:		chip->is_pbook_3400 = 1;
./sound/ppc/pmac.c:961:		chip->is_pbook_G3 = 1;
./sound/ppc/pmac.c:962:	chip->node = of_find_node_by_name(NULL, "awacs");
./sound/ppc/pmac.c:963:	sound = of_node_get(chip->node);
./sound/ppc/pmac.c:969:	if (!chip->node)
./sound/ppc/pmac.c:970:		chip->node = of_find_node_by_name(NULL, "davbus");
./sound/ppc/pmac.c:975:	if (! chip->node) {
./sound/ppc/pmac.c:976:		chip->node = of_find_node_by_name(NULL, "i2s-a");
./sound/ppc/pmac.c:977:		if (chip->node && chip->node->parent &&
./sound/ppc/pmac.c:978:		    chip->node->parent->parent) {
./sound/ppc/pmac.c:979:			if (of_device_is_compatible(chip->node->parent->parent,
./sound/ppc/pmac.c:981:				chip->is_k2 = 1;
./sound/ppc/pmac.c:984:	if (! chip->node)
./sound/ppc/pmac.c:989:			if (sound->parent == chip->node)
./sound/ppc/pmac.c:993:		of_node_put(chip->node);
./sound/ppc/pmac.c:994:		chip->node = NULL;
./sound/ppc/pmac.c:999:		chip->subframe = *prop;
./sound/ppc/pmac.c:1008:		of_node_put(chip->node);
./sound/ppc/pmac.c:1009:		chip->node = NULL;
./sound/ppc/pmac.c:1014:		chip->model = PMAC_SCREAMER;
./sound/ppc/pmac.c:1015:		// chip->can_byte_swap = 0; /* FIXME: check this */
./sound/ppc/pmac.c:1018:		chip->model = PMAC_BURGUNDY;
./sound/ppc/pmac.c:1019:		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
./sound/ppc/pmac.c:1022:		chip->model = PMAC_DACA;
./sound/ppc/pmac.c:1023:		chip->can_capture = 0;  /* no capture */
./sound/ppc/pmac.c:1024:		chip->can_duplex = 0;
./sound/ppc/pmac.c:1025:		// chip->can_byte_swap = 0; /* FIXME: check this */
./sound/ppc/pmac.c:1026:		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
./sound/ppc/pmac.c:1029:		chip->model = PMAC_TUMBLER;
./sound/ppc/pmac.c:1030:		chip->can_capture = of_machine_is_compatible("PowerMac4,2")
./sound/ppc/pmac.c:1036:		chip->can_duplex = 0;
./sound/ppc/pmac.c:1037:		// chip->can_byte_swap = 0; /* FIXME: check this */
./sound/ppc/pmac.c:1038:		chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
./sound/ppc/pmac.c:1039:		chip->freq_table = tumbler_freqs;
./sound/ppc/pmac.c:1040:		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
./sound/ppc/pmac.c:1043:		chip->model = PMAC_SNAPPER;
./sound/ppc/pmac.c:1044:		// chip->can_byte_swap = 0; /* FIXME: check this */
./sound/ppc/pmac.c:1045:		chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
./sound/ppc/pmac.c:1046:		chip->freq_table = tumbler_freqs;
./sound/ppc/pmac.c:1047:		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
./sound/ppc/pmac.c:1051:		chip->device_id = *prop;
./sound/ppc/pmac.c:1053:	chip->has_iic = (dn != NULL);
./sound/ppc/pmac.c:1059:	macio = macio_find(chip->node, macio_unknown);
./sound/ppc/pmac.c:1068:				chip->pdev = pdev;
./sound/ppc/pmac.c:1073:	if (chip->pdev == NULL)
./sound/ppc/pmac.c:1086:		chip->freqs_ok = 0;
./sound/ppc/pmac.c:1092:			for (i = 0; i < chip->num_freqs; ++i) {
./sound/ppc/pmac.c:1093:				if (r == chip->freq_table[i]) {
./sound/ppc/pmac.c:1094:					chip->freqs_ok |= (1 << i);
./sound/ppc/pmac.c:1101:		chip->freqs_ok = 1;
./sound/ppc/pmac.c:1116:	ucontrol->value.integer.value[0] = chip->auto_mute;
./sound/ppc/pmac.c:1124:	if (ucontrol->value.integer.value[0] != chip->auto_mute) {
./sound/ppc/pmac.c:1125:		chip->auto_mute = !!ucontrol->value.integer.value[0];
./sound/ppc/pmac.c:1126:		if (chip->update_automute)
./sound/ppc/pmac.c:1127:			chip->update_automute(chip, 1);
./sound/ppc/pmac.c:1137:	if (chip->detect_headphone)
./sound/ppc/pmac.c:1138:		ucontrol->value.integer.value[0] = chip->detect_headphone(chip);
./sound/ppc/pmac.c:1162:	chip->auto_mute = 1;
./sound/ppc/pmac.c:1163:	err = snd_ctl_add(chip->card, snd_ctl_new1(&auto_mute_controls[0], chip));
./sound/ppc/pmac.c:1168:	chip->hp_detect_ctl = snd_ctl_new1(&auto_mute_controls[1], chip);
./sound/ppc/pmac.c:1169:	return snd_ctl_add(chip->card, chip->hp_detect_ctl);
./sound/ppc/pmac.c:1192:	chip->card = card;
./sound/ppc/pmac.c:1194:	spin_lock_init(&chip->reg_lock);
./sound/ppc/pmac.c:1195:	chip->irq = chip->tx_irq = chip->rx_irq = -1;
./sound/ppc/pmac.c:1197:	chip->playback.stream = SNDRV_PCM_STREAM_PLAYBACK;
./sound/ppc/pmac.c:1198:	chip->capture.stream = SNDRV_PCM_STREAM_CAPTURE;
./sound/ppc/pmac.c:1203:	if (snd_pmac_dbdma_alloc(chip, &chip->playback.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
./sound/ppc/pmac.c:1204:	    snd_pmac_dbdma_alloc(chip, &chip->capture.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
./sound/ppc/pmac.c:1205:	    snd_pmac_dbdma_alloc(chip, &chip->extra_dma, 2) < 0 ||
./sound/ppc/pmac.c:1211:	np = chip->node;
./sound/ppc/pmac.c:1212:	chip->requested = 0;
./sound/ppc/pmac.c:1213:	if (chip->is_k2) {
./sound/ppc/pmac.c:1218:						   &chip->rsrc[i])) {
./sound/ppc/pmac.c:1224:			if (request_mem_region(chip->rsrc[i].start,
./sound/ppc/pmac.c:1225:					       resource_size(&chip->rsrc[i]),
./sound/ppc/pmac.c:1229:				       i, rnames[i], &chip->rsrc[i]);
./sound/ppc/pmac.c:1233:			chip->requested |= (1 << i);
./sound/ppc/pmac.c:1235:		ctrl_addr = chip->rsrc[0].start;
./sound/ppc/pmac.c:1236:		txdma_addr = chip->rsrc[1].start;
./sound/ppc/pmac.c:1243:						   &chip->rsrc[i])) {
./sound/ppc/pmac.c:1249:			if (request_mem_region(chip->rsrc[i].start,
./sound/ppc/pmac.c:1250:					       resource_size(&chip->rsrc[i]),
./sound/ppc/pmac.c:1254:				       i, rnames[i], &chip->rsrc[i]);
./sound/ppc/pmac.c:1258:			chip->requested |= (1 << i);
./sound/ppc/pmac.c:1260:		ctrl_addr = chip->rsrc[0].start;
./sound/ppc/pmac.c:1261:		txdma_addr = chip->rsrc[1].start;
./sound/ppc/pmac.c:1262:		rxdma_addr = chip->rsrc[2].start;
./sound/ppc/pmac.c:1265:	chip->awacs = ioremap(ctrl_addr, 0x1000);
./sound/ppc/pmac.c:1266:	chip->playback.dma = ioremap(txdma_addr, 0x100);
./sound/ppc/pmac.c:1267:	chip->capture.dma = ioremap(rxdma_addr, 0x100);
./sound/ppc/pmac.c:1268:	if (chip->model <= PMAC_BURGUNDY) {
./sound/ppc/pmac.c:1277:		chip->irq = irq;
./sound/ppc/pmac.c:1285:	chip->tx_irq = irq;
./sound/ppc/pmac.c:1292:	chip->rx_irq = irq;
./sound/ppc/pmac.c:1297:	if (chip->model <= PMAC_BURGUNDY)
./sound/ppc/pmac.c:1298:		out_le32(&chip->awacs->control, chip->control_mask);
./sound/ppc/pmac.c:1303:	if (chip->is_pbook_3400) {
./sound/ppc/pmac.c:1311:		chip->latch_base = ioremap (0xf301a000, 0x1000);
./sound/ppc/pmac.c:1312:		in_8(chip->latch_base + 0x190);
./sound/ppc/pmac.c:1313:	} else if (chip->is_pbook_G3) {
./sound/ppc/pmac.c:1315:		for (mio = chip->node->parent; mio; mio = mio->parent) {
./sound/ppc/pmac.c:1319:					chip->macio_base =
./sound/ppc/pmac.c:1332:		if (chip->macio_base)
./sound/ppc/pmac.c:1333:			out_8(chip->macio_base + 0x37, 3);
./sound/ppc/pmac.c:1365:	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
./sound/ppc/pmac.c:1366:	if (chip->suspend)
./sound/ppc/pmac.c:1367:		chip->suspend(chip);
./sound/ppc/pmac.c:1368:	snd_pcm_suspend_all(chip->pcm);
./sound/ppc/pmac.c:1369:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/pmac.c:1371:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/pmac.c:1372:	if (chip->irq >= 0)
./sound/ppc/pmac.c:1373:		disable_irq(chip->irq);
./sound/ppc/pmac.c:1374:	if (chip->tx_irq >= 0)
./sound/ppc/pmac.c:1375:		disable_irq(chip->tx_irq);
./sound/ppc/pmac.c:1376:	if (chip->rx_irq >= 0)
./sound/ppc/pmac.c:1377:		disable_irq(chip->rx_irq);
./sound/ppc/pmac.c:1384:	if (chip->resume)
./sound/ppc/pmac.c:1385:		chip->resume(chip);
./sound/ppc/pmac.c:1387:	if (chip->macio_base && chip->is_pbook_G3)
./sound/ppc/pmac.c:1388:		out_8(chip->macio_base + 0x37, 3);
./sound/ppc/pmac.c:1389:	else if (chip->is_pbook_3400)
./sound/ppc/pmac.c:1390:		in_8(chip->latch_base + 0x190);
./sound/ppc/pmac.c:1394:	if (chip->irq >= 0)
./sound/ppc/pmac.c:1395:		enable_irq(chip->irq);
./sound/ppc/pmac.c:1396:	if (chip->tx_irq >= 0)
./sound/ppc/pmac.c:1397:		enable_irq(chip->tx_irq);
./sound/ppc/pmac.c:1398:	if (chip->rx_irq >= 0)
./sound/ppc/pmac.c:1399:		enable_irq(chip->rx_irq);
./sound/ppc/pmac.c:1401:	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
./sound/ppc/powermac.c:69:	switch (chip->model) {
./sound/ppc/powermac.c:74:			card->shortname, chip->device_id, chip->subframe);
./sound/ppc/powermac.c:82:			card->shortname, chip->device_id, chip->subframe);
./sound/ppc/powermac.c:88:		name_ext = chip->model == PMAC_TUMBLER ? "Tumbler" : "Snapper";
./sound/ppc/powermac.c:92:			card->shortname, chip->device_id, chip->subframe);
./sound/ppc/powermac.c:98:		name_ext = chip->model == PMAC_SCREAMER ? "Screamer" : "AWACS";
./sound/ppc/powermac.c:101:		if (chip->is_pbook_3400)
./sound/ppc/powermac.c:103:		else if (chip->is_pbook_G3)
./sound/ppc/powermac.c:108:			card->shortname, name_ext, chip->revision);
./sound/ppc/powermac.c:113:		snd_printk(KERN_ERR "unsupported hardware %d\n", chip->model);
./sound/ppc/powermac.c:121:	chip->initialized = 1;
./sound/ppc/awacs.c:51:	while (!(in_le32(&chip->awacs->codec_stat) & MASK_VALID)) {
./sound/ppc/awacs.c:68:	if (chip->model == PMAC_SCREAMER)
./sound/ppc/awacs.c:70:	out_le32(&chip->awacs->codec_ctrl, val | (chip->subframe << 22));
./sound/ppc/awacs.c:71:	while (in_le32(&chip->awacs->codec_ctrl) & MASK_NEWECMD) {
./sound/ppc/awacs.c:83:	chip->awacs_reg[reg] = val;
./sound/ppc/awacs.c:96:	if (chip->model != PMAC_SCREAMER)
./sound/ppc/awacs.c:102:	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
./sound/ppc/awacs.c:103:	if (chip->manufacturer == 0x1)
./sound/ppc/awacs.c:107:				   chip->awacs_reg[1] | MASK_RECALIBRATE |
./sound/ppc/awacs.c:109:	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
./sound/ppc/awacs.c:110:	snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
./sound/ppc/awacs.c:123:	chip->awacs_reg[1] &= ~MASK_SAMPLERATE;
./sound/ppc/awacs.c:124:	chip->awacs_reg[1] |= chip->rate_index << 3;
./sound/ppc/awacs.c:125:	snd_pmac_awacs_write_reg(chip, 1, chip->awacs_reg[1]);
./sound/ppc/awacs.c:155:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/awacs.c:156:	vol[0] = (chip->awacs_reg[reg] >> lshift) & 0xf;
./sound/ppc/awacs.c:157:	vol[1] = chip->awacs_reg[reg] & 0xf;
./sound/ppc/awacs.c:158:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/awacs.c:189:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/awacs.c:190:	oldval = chip->awacs_reg[reg];
./sound/ppc/awacs.c:196:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/awacs.c:221:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/awacs.c:222:	val = (chip->awacs_reg[reg] >> shift) & 1;
./sound/ppc/awacs.c:223:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/awacs.c:241:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/awacs.c:242:	val = chip->awacs_reg[reg] & ~mask;
./sound/ppc/awacs.c:245:	changed = chip->awacs_reg[reg] != val;
./sound/ppc/awacs.c:248:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/awacs.c:321:	struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:325:	chip->mixer_data = NULL;
./sound/ppc/awacs.c:326:	chip->mixer_free = NULL;
./sound/ppc/awacs.c:348:	struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:361:	struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:375:	struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:390:	struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:414:	struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:425:	struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:453:	struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:463:	struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:558:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/awacs.c:559:	if (chip->awacs_reg[6] & MASK_MIC_BOOST)
./sound/ppc/awacs.c:561:	if (chip->awacs_reg[0] & MASK_GAINLINE)
./sound/ppc/awacs.c:563:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/awacs.c:576:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/awacs.c:577:	val0 = chip->awacs_reg[0] & ~MASK_GAINLINE;
./sound/ppc/awacs.c:578:	val6 = chip->awacs_reg[6] & ~MASK_MIC_BOOST;
./sound/ppc/awacs.c:583:	if (val0 != chip->awacs_reg[0]) {
./sound/ppc/awacs.c:587:	if (val6 != chip->awacs_reg[6]) {
./sound/ppc/awacs.c:591:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/awacs.c:721:		err = snd_ctl_add(chip->card, snd_ctl_new1(&mixers[i], chip));
./sound/ppc/awacs.c:734:	snd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);
./sound/ppc/awacs.c:735:	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
./sound/ppc/awacs.c:736:	snd_pmac_awacs_write_noreg(chip, 2, chip->awacs_reg[2]);
./sound/ppc/awacs.c:737:	snd_pmac_awacs_write_noreg(chip, 4, chip->awacs_reg[4]);
./sound/ppc/awacs.c:738:	if (chip->model == PMAC_SCREAMER) {
./sound/ppc/awacs.c:739:		snd_pmac_awacs_write_noreg(chip, 5, chip->awacs_reg[5]);
./sound/ppc/awacs.c:740:		snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
./sound/ppc/awacs.c:741:		snd_pmac_awacs_write_noreg(chip, 7, chip->awacs_reg[7]);
./sound/ppc/awacs.c:748:	snd_pmac_awacs_write_noreg(chip, 1, (chip->awacs_reg[1]
./sound/ppc/awacs.c:758:			chip->awacs_reg[1] & ~MASK_PAROUT);
./sound/ppc/awacs.c:763:	if (chip->model == PMAC_SCREAMER) {
./sound/ppc/awacs.c:766:		snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
./sound/ppc/awacs.c:770:	if (chip->mixer_data) {
./sound/ppc/awacs.c:771:		struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:802:	return (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;
./sound/ppc/awacs.c:821:	if (chip->auto_mute) {
./sound/ppc/awacs.c:823:		if (chip->mixer_data) {
./sound/ppc/awacs.c:824:			struct awacs_amp *amp = chip->mixer_data;
./sound/ppc/awacs.c:838:			int reg = chip->awacs_reg[1]
./sound/ppc/awacs.c:855:			if (do_notify && reg == chip->awacs_reg[1])
./sound/ppc/awacs.c:860:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/ppc/awacs.c:861:				       &chip->master_sw_ctl->id);
./sound/ppc/awacs.c:862:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/ppc/awacs.c:863:				       &chip->speaker_sw_ctl->id);
./sound/ppc/awacs.c:864:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/ppc/awacs.c:865:				       &chip->hp_detect_ctl->id);
./sound/ppc/awacs.c:894:	chip->awacs_reg[0] = MASK_MUX_CD | 0xff | MASK_GAINLINE;
./sound/ppc/awacs.c:895:	chip->awacs_reg[1] = MASK_CMUTE | MASK_AMUTE;
./sound/ppc/awacs.c:897:	if (chip->has_iic || chip->device_id == 0x5 ||
./sound/ppc/awacs.c:898:	    /* chip->_device_id == 0x8 || */
./sound/ppc/awacs.c:899:	    chip->device_id == 0xb)
./sound/ppc/awacs.c:900:		chip->awacs_reg[1] |= MASK_PAROUT;
./sound/ppc/awacs.c:906:	chip->awacs_reg[2] = vol;
./sound/ppc/awacs.c:907:	chip->awacs_reg[4] = vol;
./sound/ppc/awacs.c:908:	if (chip->model == PMAC_SCREAMER) {
./sound/ppc/awacs.c:910:		chip->awacs_reg[5] = vol;
./sound/ppc/awacs.c:912:		chip->awacs_reg[6] = MASK_MIC_BOOST;
./sound/ppc/awacs.c:913:		chip->awacs_reg[7] = 0;
./sound/ppc/awacs.c:917:	chip->manufacturer = (in_le32(&chip->awacs->codec_stat) >> 8) & 0xf;
./sound/ppc/awacs.c:920:	chip->revision = (in_le32(&chip->awacs->codec_stat) >> 12) & 0xf;
./sound/ppc/awacs.c:922:	if (chip->revision == 3 && chip->has_iic && CHECK_CUDA_AMP()) {
./sound/ppc/awacs.c:926:		chip->mixer_data = amp;
./sound/ppc/awacs.c:927:		chip->mixer_free = awacs_amp_free;
./sound/ppc/awacs.c:936:	if (chip->hp_stat_mask == 0) {
./sound/ppc/awacs.c:938:		switch (chip->model) {
./sound/ppc/awacs.c:940:			chip->hp_stat_mask = pm7500 || pm5500 ? MASK_HDPCONN
./sound/ppc/awacs.c:944:			switch (chip->device_id) {
./sound/ppc/awacs.c:947:				chip->hp_stat_mask = imac
./sound/ppc/awacs.c:955:				chip->hp_stat_mask = MASK_LOCONN;
./sound/ppc/awacs.c:958:				chip->hp_stat_mask = MASK_HDPCONN;
./sound/ppc/awacs.c:971:	strcpy(chip->card->mixername, "PowerMac AWACS");
./sound/ppc/awacs.c:979:	else if (chip->model == PMAC_SCREAMER || pm5500)
./sound/ppc/awacs.c:999:		err = snd_ctl_add(chip->card,
./sound/ppc/awacs.c:1007:		err = snd_ctl_add(chip->card,
./sound/ppc/awacs.c:1025:	chip->master_sw_ctl = snd_ctl_new1((pm7500 || imac || g4agp || lombard)
./sound/ppc/awacs.c:1030:	err = snd_ctl_add(chip->card, chip->master_sw_ctl);
./sound/ppc/awacs.c:1034:	if (chip->mixer_data) {
./sound/ppc/awacs.c:1046:		chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_hp_sw,
./sound/ppc/awacs.c:1048:		err = snd_ctl_add(chip->card, chip->master_sw_ctl);
./sound/ppc/awacs.c:1051:		chip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_spk_sw,
./sound/ppc/awacs.c:1053:		err = snd_ctl_add(chip->card, chip->speaker_sw_ctl);
./sound/ppc/awacs.c:1060:		err = snd_ctl_add(chip->card,
./sound/ppc/awacs.c:1065:		chip->speaker_sw_ctl = snd_ctl_new1(imac1
./sound/ppc/awacs.c:1070:		err = snd_ctl_add(chip->card, chip->speaker_sw_ctl);
./sound/ppc/awacs.c:1079:						 chip->master_sw_ctl);
./sound/ppc/awacs.c:1083:						  chip->speaker_sw_ctl);
./sound/ppc/awacs.c:1086:		err = snd_ctl_add(chip->card, vmaster_sw);
./sound/ppc/awacs.c:1097:		err = snd_ctl_add(chip->card, vmaster_vol);
./sound/ppc/awacs.c:1110:	else if (chip->model == PMAC_SCREAMER)
./sound/ppc/awacs.c:1127:	chip->set_format = snd_pmac_awacs_set_format;
./sound/ppc/awacs.c:1129:	chip->suspend = snd_pmac_awacs_suspend;
./sound/ppc/awacs.c:1130:	chip->resume = snd_pmac_awacs_resume;
./sound/ppc/awacs.c:1136:	chip->detect_headphone = snd_pmac_awacs_detect_headphone;
./sound/ppc/awacs.c:1137:	chip->update_automute = snd_pmac_awacs_update_automute;
./sound/ppc/awacs.c:1140:	if (chip->model == PMAC_SCREAMER) {
./sound/ppc/awacs.c:1141:		snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
./sound/ppc/awacs.c:1142:		snd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);
./sound/ppc/daca.c:100:	if (! (mix = chip->mixer_data))
./sound/ppc/daca.c:113:	if (! (mix = chip->mixer_data))
./sound/ppc/daca.c:139:	if (! (mix = chip->mixer_data))
./sound/ppc/daca.c:154:	if (! (mix = chip->mixer_data))
./sound/ppc/daca.c:178:	if (! (mix = chip->mixer_data))
./sound/ppc/daca.c:191:	if (! (mix = chip->mixer_data))
./sound/ppc/daca.c:227:	struct pmac_daca *mix = chip->mixer_data;
./sound/ppc/daca.c:238:	struct pmac_daca *mix = chip->mixer_data;
./sound/ppc/daca.c:243:	chip->mixer_data = NULL;
./sound/ppc/daca.c:257:	chip->mixer_data = mix;
./sound/ppc/daca.c:258:	chip->mixer_free = daca_cleanup;
./sound/ppc/daca.c:270:	strcpy(chip->card->mixername, "PowerMac DACA");
./sound/ppc/daca.c:273:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&daca_mixers[i], chip))) < 0)
./sound/ppc/daca.c:278:	chip->resume = daca_resume;
./sound/ppc/burgundy.c:35:	while ((in_le32(&chip->awacs->codec_ctrl) & MASK_NEWECMD) && timeout--)
./sound/ppc/burgundy.c:46:	while (!(in_le32(&chip->awacs->codec_stat) & MASK_EXTEND) && timeout--)
./sound/ppc/burgundy.c:51:	while ((in_le32(&chip->awacs->codec_stat) & MASK_EXTEND) && timeout--)
./sound/ppc/burgundy.c:60:	out_le32(&chip->awacs->codec_ctrl, addr + 0x200c00 + (val & 0xff));
./sound/ppc/burgundy.c:62:	out_le32(&chip->awacs->codec_ctrl, addr + 0x200d00 +((val>>8) & 0xff));
./sound/ppc/burgundy.c:64:	out_le32(&chip->awacs->codec_ctrl, addr + 0x200e00 +((val>>16) & 0xff));
./sound/ppc/burgundy.c:66:	out_le32(&chip->awacs->codec_ctrl, addr + 0x200f00 +((val>>24) & 0xff));
./sound/ppc/burgundy.c:76:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/burgundy.c:78:	out_le32(&chip->awacs->codec_ctrl, addr + 0x100000);
./sound/ppc/burgundy.c:81:	val += (in_le32(&chip->awacs->codec_stat) >> 4) & 0xff;
./sound/ppc/burgundy.c:83:	out_le32(&chip->awacs->codec_ctrl, addr + 0x100100);
./sound/ppc/burgundy.c:86:	val += ((in_le32(&chip->awacs->codec_stat)>>4) & 0xff) <<8;
./sound/ppc/burgundy.c:88:	out_le32(&chip->awacs->codec_ctrl, addr + 0x100200);
./sound/ppc/burgundy.c:91:	val += ((in_le32(&chip->awacs->codec_stat)>>4) & 0xff) <<16;
./sound/ppc/burgundy.c:93:	out_le32(&chip->awacs->codec_ctrl, addr + 0x100300);
./sound/ppc/burgundy.c:96:	val += ((in_le32(&chip->awacs->codec_stat)>>4) & 0xff) <<24;
./sound/ppc/burgundy.c:98:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/burgundy.c:107:	out_le32(&chip->awacs->codec_ctrl, addr + 0x300000 + (val & 0xff));
./sound/ppc/burgundy.c:117:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/burgundy.c:119:	out_le32(&chip->awacs->codec_ctrl, addr + 0x100000);
./sound/ppc/burgundy.c:122:	val += (in_le32(&chip->awacs->codec_stat) >> 4) & 0xff;
./sound/ppc/burgundy.c:124:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/burgundy.c:578:	return (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;
./sound/ppc/burgundy.c:583:	if (chip->auto_mute) {
./sound/ppc/burgundy.c:605:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/ppc/burgundy.c:606:				       &chip->master_sw_ctl->id);
./sound/ppc/burgundy.c:607:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/ppc/burgundy.c:608:				       &chip->speaker_sw_ctl->id);
./sound/ppc/burgundy.c:609:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/ppc/burgundy.c:610:				       &chip->hp_detect_ctl->id);
./sound/ppc/burgundy.c:626:	if ((in_le32(&chip->awacs->codec_ctrl) & MASK_ERRCODE) == 0xf0000) {
./sound/ppc/burgundy.c:668:	if (chip->hp_stat_mask == 0) {
./sound/ppc/burgundy.c:671:			chip->hp_stat_mask = BURGUNDY_HPDETECT_IMAC_UPPER
./sound/ppc/burgundy.c:675:			chip->hp_stat_mask = BURGUNDY_HPDETECT_PMAC_BACK;
./sound/ppc/burgundy.c:680:	strcpy(chip->card->mixername, "PowerMac Burgundy");
./sound/ppc/burgundy.c:683:		err = snd_ctl_add(chip->card,
./sound/ppc/burgundy.c:690:		err = snd_ctl_add(chip->card,
./sound/ppc/burgundy.c:696:	chip->master_sw_ctl = snd_ctl_new1(imac
./sound/ppc/burgundy.c:699:	err = snd_ctl_add(chip->card, chip->master_sw_ctl);
./sound/ppc/burgundy.c:702:	chip->master_sw_ctl = snd_ctl_new1(imac
./sound/ppc/burgundy.c:705:	err = snd_ctl_add(chip->card, chip->master_sw_ctl);
./sound/ppc/burgundy.c:709:		chip->master_sw_ctl = snd_ctl_new1(
./sound/ppc/burgundy.c:711:		err = snd_ctl_add(chip->card, chip->master_sw_ctl);
./sound/ppc/burgundy.c:715:	chip->speaker_sw_ctl = snd_ctl_new1(imac
./sound/ppc/burgundy.c:718:	err = snd_ctl_add(chip->card, chip->speaker_sw_ctl);
./sound/ppc/burgundy.c:726:	chip->detect_headphone = snd_pmac_burgundy_detect_headphone;
./sound/ppc/burgundy.c:727:	chip->update_automute = snd_pmac_burgundy_update_automute;
./sound/ppc/tumbler.c:270:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:281:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:305:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:316:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:410:		chip->model == PMAC_TUMBLER ? TAS3001_DRC_MAX : TAS3004_DRC_MAX;
./sound/ppc/tumbler.c:419:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:433:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:436:	if (chip->model == PMAC_TUMBLER) {
./sound/ppc/tumbler.c:446:		if (chip->model == PMAC_TUMBLER)
./sound/ppc/tumbler.c:459:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:472:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:477:		if (chip->model == PMAC_TUMBLER)
./sound/ppc/tumbler.c:541:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:556:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:686:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:702:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:733:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:759:	if (chip->update_automute && chip->auto_mute)
./sound/ppc/tumbler.c:762:	if (! (mix = chip->mixer_data))
./sound/ppc/tumbler.c:809:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:819:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:939:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:949:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:963:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/ppc/tumbler.c:980:	mix = chip->mixer_data;
./sound/ppc/tumbler.c:993:				   chip->master_sw_ctl);
./sound/ppc/tumbler.c:996:				   chip->lineout_sw_ctl);
./sound/ppc/tumbler.c:1000:			   chip->speaker_sw_ctl);
./sound/ppc/tumbler.c:1004:			   chip->speaker_sw_ctl);
./sound/ppc/tumbler.c:1008:			   chip->master_sw_ctl);
./sound/ppc/tumbler.c:1011:				   chip->lineout_sw_ctl);
./sound/ppc/tumbler.c:1014:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/ppc/tumbler.c:1015:				       &chip->hp_detect_ctl->id);
./sound/ppc/tumbler.c:1020:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/ppc/tumbler.c:1021:			       &chip->drc_sw_ctl->id);
./sound/ppc/tumbler.c:1022:	if (chip->model == PMAC_TUMBLER)
./sound/ppc/tumbler.c:1034:	if (chip->auto_mute) {
./sound/ppc/tumbler.c:1036:		mix = chip->mixer_data;
./sound/ppc/tumbler.c:1050:	if (chip->update_automute && chip->initialized) {
./sound/ppc/tumbler.c:1051:		chip->update_automute(chip, 1);
./sound/ppc/tumbler.c:1172:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:1201:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:1217:	if (chip->model == PMAC_SNAPPER) {
./sound/ppc/tumbler.c:1231:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:1244:	if (chip->model == PMAC_TUMBLER) {
./sound/ppc/tumbler.c:1259:	if (chip->update_automute)
./sound/ppc/tumbler.c:1260:		chip->update_automute(chip, 0);
./sound/ppc/tumbler.c:1278:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:1330:	struct pmac_tumbler *mix = chip->mixer_data;
./sound/ppc/tumbler.c:1344:	chip->mixer_data = NULL;
./sound/ppc/tumbler.c:1363:	chip->mixer_data = mix;
./sound/ppc/tumbler.c:1364:	chip->mixer_free = tumbler_cleanup;
./sound/ppc/tumbler.c:1368:	for (np = chip->node->child; np; np = np->sibling) {
./sound/ppc/tumbler.c:1398:	if (chip->model == PMAC_TUMBLER) {
./sound/ppc/tumbler.c:1414:	sprintf(chip->card->mixername, "PowerMac %s", chipname);
./sound/ppc/tumbler.c:1416:	if (chip->model == PMAC_TUMBLER) {
./sound/ppc/tumbler.c:1418:			if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&tumbler_mixers[i], chip))) < 0)
./sound/ppc/tumbler.c:1423:			if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snapper_mixers[i], chip))) < 0)
./sound/ppc/tumbler.c:1427:	chip->master_sw_ctl = snd_ctl_new1(&tumbler_hp_sw, chip);
./sound/ppc/tumbler.c:1428:	if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
./sound/ppc/tumbler.c:1430:	chip->speaker_sw_ctl = snd_ctl_new1(&tumbler_speaker_sw, chip);
./sound/ppc/tumbler.c:1431:	if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
./sound/ppc/tumbler.c:1434:		chip->lineout_sw_ctl = snd_ctl_new1(&tumbler_lineout_sw, chip);
./sound/ppc/tumbler.c:1435:		if ((err = snd_ctl_add(chip->card, chip->lineout_sw_ctl)) < 0)
./sound/ppc/tumbler.c:1438:	chip->drc_sw_ctl = snd_ctl_new1(&tumbler_drc_sw, chip);
./sound/ppc/tumbler.c:1439:	if ((err = snd_ctl_add(chip->card, chip->drc_sw_ctl)) < 0)
./sound/ppc/tumbler.c:1443:	if (chip->model == PMAC_TUMBLER)
./sound/ppc/tumbler.c:1448:	if (chip->model == PMAC_TUMBLER)
./sound/ppc/tumbler.c:1454:	chip->suspend = tumbler_suspend;
./sound/ppc/tumbler.c:1455:	chip->resume = tumbler_resume;
./sound/ppc/tumbler.c:1465:	chip->detect_headphone = tumbler_detect_headphone;
./sound/ppc/tumbler.c:1466:	chip->update_automute = tumbler_update_automute;
./sound/ppc/beep.c:48:	struct pmac_beep *beep = chip->beep;
./sound/ppc/beep.c:121:	if (! chip || (beep = chip->beep) == NULL)
./sound/ppc/beep.c:125:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/beep.c:128:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/beep.c:132:	beep_speed = snd_pmac_rate_index(chip, &chip->playback, BEEP_SRATE);
./sound/ppc/beep.c:133:	srate = chip->freq_table[beep_speed];
./sound/ppc/beep.c:138:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/beep.c:139:	if (chip->playback.running || chip->capture.running || beep->running) {
./sound/ppc/beep.c:140:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/beep.c:144:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/beep.c:164:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/ppc/beep.c:166:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/ppc/beep.c:188:	if (snd_BUG_ON(!chip->beep))
./sound/ppc/beep.c:190:	ucontrol->value.integer.value[0] = chip->beep->volume;
./sound/ppc/beep.c:199:	if (snd_BUG_ON(!chip->beep))
./sound/ppc/beep.c:201:	oval = chip->beep->volume;
./sound/ppc/beep.c:205:	chip->beep->volume = nval;
./sound/ppc/beep.c:206:	return oval != chip->beep->volume;
./sound/ppc/beep.c:229:	dmabuf = dma_alloc_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,
./sound/ppc/beep.c:246:	input_dev->dev.parent = &chip->pdev->dev;
./sound/ppc/beep.c:255:	err = snd_ctl_add(chip->card, beep_ctl);
./sound/ppc/beep.c:259:	chip->beep = beep;
./sound/ppc/beep.c:267: fail2:	snd_ctl_remove(chip->card, beep_ctl);
./sound/ppc/beep.c:270:		dma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,
./sound/ppc/beep.c:278:	if (chip->beep) {
./sound/ppc/beep.c:279:		input_unregister_device(chip->beep->dev);
./sound/ppc/beep.c:280:		dma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,
./sound/ppc/beep.c:281:				  chip->beep->buf, chip->beep->addr);
./sound/ppc/beep.c:282:		kfree(chip->beep);
./sound/ppc/beep.c:283:		chip->beep = NULL;
./sound/drivers/vx/vx_pcm.c:421:	data_mode = (chip->uer_bits & IEC958_AES0_NONAUDIO) != 0;
./sound/drivers/vx/vx_pcm.c:534:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_pcm.c:538:	if (snd_BUG_ON(audio >= chip->audio_outs))
./sound/drivers/vx/vx_pcm.c:542:	pipe = chip->playback_pipes[audio];
./sound/drivers/vx/vx_pcm.c:548:		chip->playback_pipes[audio] = pipe;
./sound/drivers/vx/vx_pcm.c:554:	chip->playback_pipes[audio] = pipe;
./sound/drivers/vx/vx_pcm.c:557:	runtime->hw.period_bytes_min = chip->ibl.size;
./sound/drivers/vx/vx_pcm.c:581:		chip->playback_pipes[pipe->number] = NULL;
./sound/drivers/vx/vx_pcm.c:646:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_pcm.c:651:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_pcm.c:697:	if (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))
./sound/drivers/vx/vx_pcm.c:701:							  chip->ibl.size)) < 0)
./sound/drivers/vx/vx_pcm.c:717:	if (pipe->running && ! (chip->chip_status & VX_STAT_IS_STALE)) {
./sound/drivers/vx/vx_pcm.c:736:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_pcm.c:755:		chip->pcm_running++;
./sound/drivers/vx/vx_pcm.c:763:		chip->pcm_running--;
./sound/drivers/vx/vx_pcm.c:819:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_pcm.c:822:	data_mode = (chip->uer_bits & IEC958_AES0_NONAUDIO) != 0;
./sound/drivers/vx/vx_pcm.c:841:	if (chip->pcm_running && chip->freq != runtime->rate) {
./sound/drivers/vx/vx_pcm.c:843:			   "from the current %d\n", runtime->rate, chip->freq);
./sound/drivers/vx/vx_pcm.c:926:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_pcm.c:930:	if (snd_BUG_ON(audio >= chip->audio_ins))
./sound/drivers/vx/vx_pcm.c:936:	chip->capture_pipes[audio] = pipe;
./sound/drivers/vx/vx_pcm.c:939:	if (chip->audio_monitor_active[audio]) {
./sound/drivers/vx/vx_pcm.c:940:		pipe_out_monitoring = chip->playback_pipes[audio];
./sound/drivers/vx/vx_pcm.c:946:			chip->playback_pipes[audio] = pipe_out_monitoring;
./sound/drivers/vx/vx_pcm.c:953:		vx_set_monitor_level(chip, audio, chip->audio_monitor[audio],
./sound/drivers/vx/vx_pcm.c:954:				     chip->audio_monitor_active[audio]);
./sound/drivers/vx/vx_pcm.c:956:		vx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],
./sound/drivers/vx/vx_pcm.c:957:				     chip->audio_monitor_active[audio+1]); 
./sound/drivers/vx/vx_pcm.c:963:	runtime->hw.period_bytes_min = chip->ibl.size;
./sound/drivers/vx/vx_pcm.c:985:	chip->capture_pipes[pipe->number] = NULL;
./sound/drivers/vx/vx_pcm.c:996:			chip->playback_pipes[pipe->number] = NULL;
./sound/drivers/vx/vx_pcm.c:1018:	if (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))
./sound/drivers/vx/vx_pcm.c:1121:		vx_init_rmh(&chip->irq_rmh, CMD_ASYNC);
./sound/drivers/vx/vx_pcm.c:1123:			chip->irq_rmh.Cmd[0] |= 0x00000001;	/* SEL_ASYNC_EVENTS */
./sound/drivers/vx/vx_pcm.c:1125:			chip->irq_rmh.Cmd[0] |= 0x00000002;	/* SEL_END_OF_BUF_EVENTS */
./sound/drivers/vx/vx_pcm.c:1127:		if (vx_send_msg(chip, &chip->irq_rmh) < 0) {
./sound/drivers/vx/vx_pcm.c:1133:		while (i < chip->irq_rmh.LgStat) {
./sound/drivers/vx/vx_pcm.c:1135:			p = chip->irq_rmh.Stat[i] & MASK_FIRST_FIELD;
./sound/drivers/vx/vx_pcm.c:1136:			capture = (chip->irq_rmh.Stat[i] & 0x400000) ? 1 : 0;
./sound/drivers/vx/vx_pcm.c:1137:			eob = (chip->irq_rmh.Stat[i] & 0x800000) ? 1 : 0;
./sound/drivers/vx/vx_pcm.c:1144:					buf = chip->irq_rmh.Stat[i];
./sound/drivers/vx/vx_pcm.c:1149:			if (snd_BUG_ON(p < 0 || p >= chip->audio_outs))
./sound/drivers/vx/vx_pcm.c:1151:			pipe = chip->playback_pipes[p];
./sound/drivers/vx/vx_pcm.c:1160:	for (i = 0; i < chip->audio_ins; i++) {
./sound/drivers/vx/vx_pcm.c:1161:		pipe = chip->capture_pipes[i];
./sound/drivers/vx/vx_pcm.c:1182:	chip->audio_outs = rmh.Stat[0] & MASK_FIRST_FIELD;
./sound/drivers/vx/vx_pcm.c:1183:	chip->audio_ins = (rmh.Stat[0] >> (FIELD_SIZE*2)) & MASK_FIRST_FIELD;
./sound/drivers/vx/vx_pcm.c:1184:	chip->audio_info = rmh.Stat[1];
./sound/drivers/vx/vx_pcm.c:1187:	chip->playback_pipes = kcalloc(chip->audio_outs, sizeof(struct vx_pipe *), GFP_KERNEL);
./sound/drivers/vx/vx_pcm.c:1188:	if (!chip->playback_pipes)
./sound/drivers/vx/vx_pcm.c:1190:	chip->capture_pipes = kcalloc(chip->audio_ins, sizeof(struct vx_pipe *), GFP_KERNEL);
./sound/drivers/vx/vx_pcm.c:1191:	if (!chip->capture_pipes) {
./sound/drivers/vx/vx_pcm.c:1192:		kfree(chip->playback_pipes);
./sound/drivers/vx/vx_pcm.c:1196:	preferred = chip->ibl.size;
./sound/drivers/vx/vx_pcm.c:1197:	chip->ibl.size = 0;
./sound/drivers/vx/vx_pcm.c:1198:	vx_set_ibl(chip, &chip->ibl); /* query the info */
./sound/drivers/vx/vx_pcm.c:1200:		chip->ibl.size = ((preferred + chip->ibl.granularity - 1) /
./sound/drivers/vx/vx_pcm.c:1201:				  chip->ibl.granularity) * chip->ibl.granularity;
./sound/drivers/vx/vx_pcm.c:1202:		if (chip->ibl.size > chip->ibl.max_size)
./sound/drivers/vx/vx_pcm.c:1203:			chip->ibl.size = chip->ibl.max_size;
./sound/drivers/vx/vx_pcm.c:1205:		chip->ibl.size = chip->ibl.min_size; /* set to the minimum */
./sound/drivers/vx/vx_pcm.c:1206:	vx_set_ibl(chip, &chip->ibl);
./sound/drivers/vx/vx_pcm.c:1218:	chip->pcm[pcm->device] = NULL;
./sound/drivers/vx/vx_pcm.c:1219:	kfree(chip->playback_pipes);
./sound/drivers/vx/vx_pcm.c:1220:	chip->playback_pipes = NULL;
./sound/drivers/vx/vx_pcm.c:1221:	kfree(chip->capture_pipes);
./sound/drivers/vx/vx_pcm.c:1222:	chip->capture_pipes = NULL;
./sound/drivers/vx/vx_pcm.c:1237:	for (i = 0; i < chip->hw->num_codecs; i++) {
./sound/drivers/vx/vx_pcm.c:1239:		outs = chip->audio_outs > i * 2 ? 1 : 0;
./sound/drivers/vx/vx_pcm.c:1240:		ins = chip->audio_ins > i * 2 ? 1 : 0;
./sound/drivers/vx/vx_pcm.c:1243:		err = snd_pcm_new(chip->card, "VX PCM", i,
./sound/drivers/vx/vx_pcm.c:1256:		strcpy(pcm->name, chip->card->shortname);
./sound/drivers/vx/vx_pcm.c:1257:		chip->pcm[i] = pcm;
./sound/drivers/vx/vx_hwdep.c:71:		if (! fw_files[chip->type][i])
./sound/drivers/vx/vx_hwdep.c:73:		sprintf(path, "vx/%s", fw_files[chip->type][i]);
./sound/drivers/vx/vx_hwdep.c:74:		if (request_firmware(&fw, path, chip->dev)) {
./sound/drivers/vx/vx_hwdep.c:78:		err = chip->ops->load_dsp(chip, i, fw);
./sound/drivers/vx/vx_hwdep.c:84:			chip->chip_status |= VX_STAT_XILINX_LOADED;
./sound/drivers/vx/vx_hwdep.c:86:		chip->firmware[i] = fw;
./sound/drivers/vx/vx_hwdep.c:100:	if (chip->ops->add_controls)
./sound/drivers/vx/vx_hwdep.c:101:		if ((err = chip->ops->add_controls(chip)) < 0)
./sound/drivers/vx/vx_hwdep.c:104:	chip->chip_status |= VX_STAT_DEVICE_INIT;
./sound/drivers/vx/vx_hwdep.c:105:	chip->chip_status |= VX_STAT_CHIP_INIT;
./sound/drivers/vx/vx_hwdep.c:107:	return snd_card_register(chip->card);
./sound/drivers/vx/vx_hwdep.c:116:		release_firmware(chip->firmware[i]);
./sound/drivers/vx/vx_mixer.c:35:	if (snd_BUG_ON(!chip->ops->write_codec))
./sound/drivers/vx/vx_mixer.c:38:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_mixer.c:41:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_mixer.c:42:	chip->ops->write_codec(chip, codec, data);
./sound/drivers/vx/vx_mixer.c:43:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_mixer.c:106:	left  = chip->hw->output_level_max - left;
./sound/drivers/vx/vx_mixer.c:107:	right = chip->hw->output_level_max - right;
./sound/drivers/vx/vx_mixer.c:109:	if (chip->ops->akm_write) {
./sound/drivers/vx/vx_mixer.c:110:		chip->ops->akm_write(chip, XX_CODEC_LEVEL_LEFT_REGISTER, left);
./sound/drivers/vx/vx_mixer.c:111:		chip->ops->akm_write(chip, XX_CODEC_LEVEL_RIGHT_REGISTER, right);
./sound/drivers/vx/vx_mixer.c:131:	for (i = 0; i < chip->hw->num_codecs; i++) {
./sound/drivers/vx/vx_mixer.c:132:		if (chip->ops->akm_write)
./sound/drivers/vx/vx_mixer.c:133:			chip->ops->akm_write(chip, XX_CODEC_DAC_CONTROL_REGISTER, mute); /* XXX */
./sound/drivers/vx/vx_mixer.c:146:	int port = chip->type >= VX_TYPE_VXPOCKET ? 0x75 : 0x65;
./sound/drivers/vx/vx_mixer.c:148:	chip->ops->reset_codec(chip);
./sound/drivers/vx/vx_mixer.c:151:	if (! chip->ops->akm_write) {
./sound/drivers/vx/vx_mixer.c:153:		for (i = 0; i < chip->hw->num_codecs; i++) {
./sound/drivers/vx/vx_mixer.c:166:	for (i = 0; i < chip->hw->num_codecs; i++) {
./sound/drivers/vx/vx_mixer.c:167:		chip->output_level[i][0] = 0;
./sound/drivers/vx/vx_mixer.c:168:		chip->output_level[i][1] = 0;
./sound/drivers/vx/vx_mixer.c:179:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_mixer.c:182:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_mixer.c:183:	chip->ops->change_audio_source(chip, src);
./sound/drivers/vx/vx_mixer.c:184:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_mixer.c:194:	if (chip->audio_source_target == chip->audio_source ||
./sound/drivers/vx/vx_mixer.c:195:	    chip->pcm_running)
./sound/drivers/vx/vx_mixer.c:197:	vx_change_audio_source(chip, chip->audio_source_target);
./sound/drivers/vx/vx_mixer.c:198:	chip->audio_source = chip->audio_source_target;
./sound/drivers/vx/vx_mixer.c:222:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_mixer.c:292:	chip->audio_monitor[audio] = level;
./sound/drivers/vx/vx_mixer.c:293:	chip->audio_monitor_active[audio] = active;
./sound/drivers/vx/vx_mixer.c:308:	chip->audio_active[audio] = active;
./sound/drivers/vx/vx_mixer.c:322:	chip->audio_gain[capture][audio] = level;
./sound/drivers/vx/vx_mixer.c:334:	memset(chip->audio_gain, 0, sizeof(chip->audio_gain));
./sound/drivers/vx/vx_mixer.c:335:	memset(chip->audio_active, 0, sizeof(chip->audio_active));
./sound/drivers/vx/vx_mixer.c:336:	memset(chip->audio_monitor, 0, sizeof(chip->audio_monitor));
./sound/drivers/vx/vx_mixer.c:337:	memset(chip->audio_monitor_active, 0, sizeof(chip->audio_monitor_active));
./sound/drivers/vx/vx_mixer.c:340:		for (i = 0; i < chip->hw->num_ins * 2; i++) {
./sound/drivers/vx/vx_mixer.c:350:			chip->audio_gain[c][i] = CVAL_0DB;
./sound/drivers/vx/vx_mixer.c:351:			chip->audio_monitor[i] = CVAL_0DB;
./sound/drivers/vx/vx_mixer.c:380:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_mixer.c:419:	uinfo->value.integer.max = chip->hw->output_level_max;
./sound/drivers/vx/vx_mixer.c:427:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:428:	ucontrol->value.integer.value[0] = chip->output_level[codec][0];
./sound/drivers/vx/vx_mixer.c:429:	ucontrol->value.integer.value[1] = chip->output_level[codec][1];
./sound/drivers/vx/vx_mixer.c:430:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:440:	vmax = chip->hw->output_level_max;
./sound/drivers/vx/vx_mixer.c:445:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:446:	if (val[0] != chip->output_level[codec][0] ||
./sound/drivers/vx/vx_mixer.c:447:	    val[1] != chip->output_level[codec][1]) {
./sound/drivers/vx/vx_mixer.c:449:		chip->output_level[codec][0] = val[0];
./sound/drivers/vx/vx_mixer.c:450:		chip->output_level[codec][1] = val[1];
./sound/drivers/vx/vx_mixer.c:451:		mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:454:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:482:	if (chip->type >= VX_TYPE_VXPOCKET)
./sound/drivers/vx/vx_mixer.c:491:	ucontrol->value.enumerated.item[0] = chip->audio_source_target;
./sound/drivers/vx/vx_mixer.c:499:	if (chip->type >= VX_TYPE_VXPOCKET) {
./sound/drivers/vx/vx_mixer.c:506:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:507:	if (chip->audio_source_target != ucontrol->value.enumerated.item[0]) {
./sound/drivers/vx/vx_mixer.c:508:		chip->audio_source_target = ucontrol->value.enumerated.item[0];
./sound/drivers/vx/vx_mixer.c:510:		mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:513:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:540:	ucontrol->value.enumerated.item[0] = chip->clock_mode;
./sound/drivers/vx/vx_mixer.c:550:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:551:	if (chip->clock_mode != ucontrol->value.enumerated.item[0]) {
./sound/drivers/vx/vx_mixer.c:552:		chip->clock_mode = ucontrol->value.enumerated.item[0];
./sound/drivers/vx/vx_mixer.c:553:		vx_set_clock(chip, chip->freq);
./sound/drivers/vx/vx_mixer.c:554:		mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:557:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:587:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:588:	ucontrol->value.integer.value[0] = chip->audio_gain[capture][audio];
./sound/drivers/vx/vx_mixer.c:589:	ucontrol->value.integer.value[1] = chip->audio_gain[capture][audio+1];
./sound/drivers/vx/vx_mixer.c:590:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:605:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:606:	if (val[0] != chip->audio_gain[capture][audio] ||
./sound/drivers/vx/vx_mixer.c:607:	    val[1] != chip->audio_gain[capture][audio+1]) {
./sound/drivers/vx/vx_mixer.c:610:		mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:613:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:622:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:623:	ucontrol->value.integer.value[0] = chip->audio_monitor[audio];
./sound/drivers/vx/vx_mixer.c:624:	ucontrol->value.integer.value[1] = chip->audio_monitor[audio+1];
./sound/drivers/vx/vx_mixer.c:625:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:640:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:641:	if (val[0] != chip->audio_monitor[audio] ||
./sound/drivers/vx/vx_mixer.c:642:	    val[1] != chip->audio_monitor[audio+1]) {
./sound/drivers/vx/vx_mixer.c:644:				     chip->audio_monitor_active[audio]);
./sound/drivers/vx/vx_mixer.c:646:				     chip->audio_monitor_active[audio+1]);
./sound/drivers/vx/vx_mixer.c:647:		mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:650:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:661:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:662:	ucontrol->value.integer.value[0] = chip->audio_active[audio];
./sound/drivers/vx/vx_mixer.c:663:	ucontrol->value.integer.value[1] = chip->audio_active[audio+1];
./sound/drivers/vx/vx_mixer.c:664:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:673:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:674:	if (ucontrol->value.integer.value[0] != chip->audio_active[audio] ||
./sound/drivers/vx/vx_mixer.c:675:	    ucontrol->value.integer.value[1] != chip->audio_active[audio+1]) {
./sound/drivers/vx/vx_mixer.c:680:		mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:683:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:692:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:693:	ucontrol->value.integer.value[0] = chip->audio_monitor_active[audio];
./sound/drivers/vx/vx_mixer.c:694:	ucontrol->value.integer.value[1] = chip->audio_monitor_active[audio+1];
./sound/drivers/vx/vx_mixer.c:695:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:704:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:705:	if (ucontrol->value.integer.value[0] != chip->audio_monitor_active[audio] ||
./sound/drivers/vx/vx_mixer.c:706:	    ucontrol->value.integer.value[1] != chip->audio_monitor_active[audio+1]) {
./sound/drivers/vx/vx_mixer.c:707:		vx_set_monitor_level(chip, audio, chip->audio_monitor[audio],
./sound/drivers/vx/vx_mixer.c:709:		vx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],
./sound/drivers/vx/vx_mixer.c:711:		mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:714:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:770:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:771:	ucontrol->value.iec958.status[0] = (chip->uer_bits >> 0) & 0xff;
./sound/drivers/vx/vx_mixer.c:772:	ucontrol->value.iec958.status[1] = (chip->uer_bits >> 8) & 0xff;
./sound/drivers/vx/vx_mixer.c:773:	ucontrol->value.iec958.status[2] = (chip->uer_bits >> 16) & 0xff;
./sound/drivers/vx/vx_mixer.c:774:	ucontrol->value.iec958.status[3] = (chip->uer_bits >> 24) & 0xff;
./sound/drivers/vx/vx_mixer.c:775:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:797:	mutex_lock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:798:	if (chip->uer_bits != val) {
./sound/drivers/vx/vx_mixer.c:799:		chip->uer_bits = val;
./sound/drivers/vx/vx_mixer.c:801:		mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:804:	mutex_unlock(&chip->mixer_mutex);
./sound/drivers/vx/vx_mixer.c:916:	struct snd_card *card = chip->card;
./sound/drivers/vx/vx_mixer.c:922:	for (i = 0; i < chip->hw->num_outs; i++) {
./sound/drivers/vx/vx_mixer.c:925:		temp.tlv.p = chip->hw->output_level_db_scale;
./sound/drivers/vx/vx_mixer.c:931:	for (i = 0; i < chip->hw->num_outs; i++) {
./sound/drivers/vx/vx_mixer.c:955:	for (i = 0; i < chip->hw->num_outs; i++) {
./sound/drivers/vx/vx_mixer.c:978:		for (i = 0; i < chip->hw->num_ins; i++) {
./sound/drivers/vx/vx_core.c:245:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_core.c:350:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_core.c:352:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_core.c:372:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_core.c:409:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_core.c:411:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_core.c:483:	vx_init_rmh(&chip->irq_rmh, CMD_TEST_IT);
./sound/drivers/vx/vx_core.c:484:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_core.c:485:	err = vx_send_msg_nolock(chip, &chip->irq_rmh);
./sound/drivers/vx/vx_core.c:489:		*ret = chip->irq_rmh.Stat[0];
./sound/drivers/vx/vx_core.c:490:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_core.c:503:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_core.c:549:	if (! (chip->chip_status & VX_STAT_CHIP_INIT) ||
./sound/drivers/vx/vx_core.c:550:	    (chip->chip_status & VX_STAT_IS_STALE))
./sound/drivers/vx/vx_core.c:563:	if (snd_BUG_ON(!chip->ops->reset_board))
./sound/drivers/vx/vx_core.c:567:	chip->audio_source = VX_AUDIO_SRC_LINE;
./sound/drivers/vx/vx_core.c:569:		chip->audio_source_target = chip->audio_source;
./sound/drivers/vx/vx_core.c:570:		chip->clock_source = INTERNAL_QUARTZ;
./sound/drivers/vx/vx_core.c:571:		chip->clock_mode = VX_CLOCK_MODE_AUTO;
./sound/drivers/vx/vx_core.c:572:		chip->freq = 48000;
./sound/drivers/vx/vx_core.c:573:		chip->uer_detected = VX_UER_MODE_NOT_PRESENT;
./sound/drivers/vx/vx_core.c:574:		chip->uer_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
./sound/drivers/vx/vx_core.c:577:	chip->ops->reset_board(chip, cold_reset);
./sound/drivers/vx/vx_core.c:581:	vx_set_internal_clock(chip, chip->freq);
./sound/drivers/vx/vx_core.c:593:	vx_set_iec958_status(chip, chip->uer_bits);
./sound/drivers/vx/vx_core.c:610:	snd_iprintf(buffer, "%s\n", chip->card->longname);
./sound/drivers/vx/vx_core.c:612:		    chip->chip_status & VX_STAT_XILINX_LOADED ? "Loaded" : "No");
./sound/drivers/vx/vx_core.c:614:		    chip->chip_status & VX_STAT_DEVICE_INIT ? "Yes" : "No");
./sound/drivers/vx/vx_core.c:616:	if (chip->audio_info & VX_AUDIO_INFO_REAL_TIME)
./sound/drivers/vx/vx_core.c:618:	if (chip->audio_info & VX_AUDIO_INFO_OFFLINE)
./sound/drivers/vx/vx_core.c:620:	if (chip->audio_info & VX_AUDIO_INFO_MPEG1)
./sound/drivers/vx/vx_core.c:622:	if (chip->audio_info & VX_AUDIO_INFO_MPEG2)
./sound/drivers/vx/vx_core.c:624:	if (chip->audio_info & VX_AUDIO_INFO_LINEAR_8)
./sound/drivers/vx/vx_core.c:626:	if (chip->audio_info & VX_AUDIO_INFO_LINEAR_16)
./sound/drivers/vx/vx_core.c:628:	if (chip->audio_info & VX_AUDIO_INFO_LINEAR_24)
./sound/drivers/vx/vx_core.c:632:		    audio_src_vxp[chip->audio_source] :
./sound/drivers/vx/vx_core.c:633:		    audio_src_vx2[chip->audio_source]);
./sound/drivers/vx/vx_core.c:634:	snd_iprintf(buffer, "Clock Mode: %s\n", clock_mode[chip->clock_mode]);
./sound/drivers/vx/vx_core.c:635:	snd_iprintf(buffer, "Clock Source: %s\n", clock_src[chip->clock_source]);
./sound/drivers/vx/vx_core.c:636:	snd_iprintf(buffer, "Frequency: %d\n", chip->freq);
./sound/drivers/vx/vx_core.c:637:	snd_iprintf(buffer, "Detected Frequency: %d\n", chip->freq_detected);
./sound/drivers/vx/vx_core.c:638:	snd_iprintf(buffer, "Detected UER type: %s\n", uer_type[chip->uer_detected]);
./sound/drivers/vx/vx_core.c:640:		    chip->ibl.min_size, chip->ibl.max_size, chip->ibl.size,
./sound/drivers/vx/vx_core.c:641:		    chip->ibl.granularity);
./sound/drivers/vx/vx_core.c:648:	if (! snd_card_proc_new(chip->card, "vx-status", &entry))
./sound/drivers/vx/vx_core.c:661:	int cold_reset = !(chip->chip_status & VX_STAT_DEVICE_INIT);
./sound/drivers/vx/vx_core.c:737:	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
./sound/drivers/vx/vx_core.c:738:	chip->chip_status |= VX_STAT_IN_SUSPEND;
./sound/drivers/vx/vx_core.c:739:	for (i = 0; i < chip->hw->num_codecs; i++)
./sound/drivers/vx/vx_core.c:740:		snd_pcm_suspend_all(chip->pcm[i]);
./sound/drivers/vx/vx_core.c:754:	chip->chip_status &= ~VX_STAT_CHIP_INIT;
./sound/drivers/vx/vx_core.c:757:		if (! chip->firmware[i])
./sound/drivers/vx/vx_core.c:759:		err = chip->ops->load_dsp(chip, i, chip->firmware[i]);
./sound/drivers/vx/vx_core.c:766:	chip->chip_status |= VX_STAT_CHIP_INIT;
./sound/drivers/vx/vx_core.c:767:	chip->chip_status &= ~VX_STAT_IN_SUSPEND;
./sound/drivers/vx/vx_core.c:769:	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
./sound/drivers/vx/vx_core.c:802:	mutex_init(&chip->lock);
./sound/drivers/vx/vx_core.c:803:	chip->irq = -1;
./sound/drivers/vx/vx_core.c:804:	chip->hw = hw;
./sound/drivers/vx/vx_core.c:805:	chip->type = hw->type;
./sound/drivers/vx/vx_core.c:806:	chip->ops = ops;
./sound/drivers/vx/vx_core.c:807:	mutex_init(&chip->mixer_mutex);
./sound/drivers/vx/vx_core.c:809:	chip->card = card;
./sound/drivers/vx/vx_uer.c:65:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_uer.c:66:	if (chip->type >= VX_TYPE_VXPOCKET) {
./sound/drivers/vx/vx_uer.c:75:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_uer.c:87:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_uer.c:95:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_uer.c:194:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_uer.c:195:	chip->ops->set_clock_source(chip, source);
./sound/drivers/vx/vx_uer.c:196:	chip->clock_source = source;
./sound/drivers/vx/vx_uer.c:197:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_uer.c:213:	mutex_lock(&chip->lock);
./sound/drivers/vx/vx_uer.c:221:	mutex_unlock(&chip->lock);
./sound/drivers/vx/vx_uer.c:233:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_uer.c:248:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_uer.c:254:	if (chip->clock_mode == VX_CLOCK_MODE_EXTERNAL ||
./sound/drivers/vx/vx_uer.c:255:	    (chip->clock_mode == VX_CLOCK_MODE_AUTO &&
./sound/drivers/vx/vx_uer.c:256:	     chip->audio_source == VX_AUDIO_SRC_DIGITAL)) {
./sound/drivers/vx/vx_uer.c:257:		if (chip->clock_source != UER_SYNC) {
./sound/drivers/vx/vx_uer.c:262:	} else if (chip->clock_mode == VX_CLOCK_MODE_INTERNAL ||
./sound/drivers/vx/vx_uer.c:263:		   (chip->clock_mode == VX_CLOCK_MODE_AUTO &&
./sound/drivers/vx/vx_uer.c:264:		    chip->audio_source != VX_AUDIO_SRC_DIGITAL)) {
./sound/drivers/vx/vx_uer.c:265:		if (chip->clock_source != INTERNAL_QUARTZ) {
./sound/drivers/vx/vx_uer.c:269:		if (chip->freq == freq)
./sound/drivers/vx/vx_uer.c:275:	if (chip->freq == freq)
./sound/drivers/vx/vx_uer.c:277:	chip->freq = freq;
./sound/drivers/vx/vx_uer.c:290:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/drivers/vx/vx_uer.c:293:	if (chip->clock_source == INTERNAL_QUARTZ)
./sound/drivers/vx/vx_uer.c:298:	freq = vx_read_uer_status(chip, &chip->uer_detected);
./sound/drivers/vx/vx_uer.c:306:		chip->freq_detected = freq;
./sound/drivers/pcsp/pcsp.c:163:	snd_card_free(chip->card);
./sound/drivers/pcsp/pcsp.c:187:	pcspkr_input_remove(chip->input_dev);
./sound/drivers/pcsp/pcsp.c:203:	snd_pcm_suspend_all(chip->pcm);
./sound/drivers/pcsp/pcsp_lib.c:51:	if (chip->thalf) {
./sound/drivers/pcsp/pcsp_lib.c:52:		outb(chip->val61, 0x61);
./sound/drivers/pcsp/pcsp_lib.c:53:		chip->thalf = 0;
./sound/drivers/pcsp/pcsp_lib.c:54:		return chip->ns_rem;
./sound/drivers/pcsp/pcsp_lib.c:57:	substream = chip->playback_substream;
./sound/drivers/pcsp/pcsp_lib.c:63:	val = runtime->dma_area[chip->playback_ptr + chip->fmt_size - 1];
./sound/drivers/pcsp/pcsp_lib.c:64:	if (chip->is_signed)
./sound/drivers/pcsp/pcsp_lib.c:68:	if (timer_cnt && chip->enable) {
./sound/drivers/pcsp/pcsp_lib.c:71:			outb_p(chip->val61, 0x61);
./sound/drivers/pcsp/pcsp_lib.c:73:			outb(chip->val61 ^ 1, 0x61);
./sound/drivers/pcsp/pcsp_lib.c:75:			outb(chip->val61 ^ 2, 0x61);
./sound/drivers/pcsp/pcsp_lib.c:76:			chip->thalf = 1;
./sound/drivers/pcsp/pcsp_lib.c:81:	chip->ns_rem = PCSP_PERIOD_NS();
./sound/drivers/pcsp/pcsp_lib.c:82:	ns = (chip->thalf ? PCSP_CALC_NS(timer_cnt) : chip->ns_rem);
./sound/drivers/pcsp/pcsp_lib.c:83:	chip->ns_rem -= ns;
./sound/drivers/pcsp/pcsp_lib.c:95:	substream = chip->playback_substream;
./sound/drivers/pcsp/pcsp_lib.c:102:	spin_lock_irqsave(&chip->substream_lock, flags);
./sound/drivers/pcsp/pcsp_lib.c:103:	chip->playback_ptr += PCSP_INDEX_INC() * chip->fmt_size;
./sound/drivers/pcsp/pcsp_lib.c:104:	periods_elapsed = chip->playback_ptr - chip->period_ptr;
./sound/drivers/pcsp/pcsp_lib.c:109:			chip->playback_ptr, period_bytes, buffer_bytes);
./sound/drivers/pcsp/pcsp_lib.c:116:	chip->playback_ptr %= buffer_bytes;
./sound/drivers/pcsp/pcsp_lib.c:119:		chip->period_ptr += periods_elapsed * period_bytes;
./sound/drivers/pcsp/pcsp_lib.c:120:		chip->period_ptr %= buffer_bytes;
./sound/drivers/pcsp/pcsp_lib.c:122:	spin_unlock_irqrestore(&chip->substream_lock, flags);
./sound/drivers/pcsp/pcsp_lib.c:134:	if (!atomic_read(&chip->timer_active) || !chip->playback_substream)
./sound/drivers/pcsp/pcsp_lib.c:137:	pointer_update = !chip->thalf;
./sound/drivers/pcsp/pcsp_lib.c:157:	if (atomic_read(&chip->timer_active)) {
./sound/drivers/pcsp/pcsp_lib.c:163:	chip->val61 = inb(0x61) | 0x03;
./sound/drivers/pcsp/pcsp_lib.c:166:	atomic_set(&chip->timer_active, 1);
./sound/drivers/pcsp/pcsp_lib.c:167:	chip->thalf = 0;
./sound/drivers/pcsp/pcsp_lib.c:178:	if (!atomic_read(&chip->timer_active))
./sound/drivers/pcsp/pcsp_lib.c:181:	atomic_set(&chip->timer_active, 0);
./sound/drivers/pcsp/pcsp_lib.c:185:	outb(chip->val61 & 0xFC, 0x61);
./sound/drivers/pcsp/pcsp_lib.c:197:	hrtimer_cancel(&chip->timer);
./sound/drivers/pcsp/pcsp_lib.c:208:	chip->playback_substream = NULL;
./sound/drivers/pcsp/pcsp_lib.c:239:	chip->playback_ptr = 0;
./sound/drivers/pcsp/pcsp_lib.c:240:	chip->period_ptr = 0;
./sound/drivers/pcsp/pcsp_lib.c:241:	chip->fmt_size =
./sound/drivers/pcsp/pcsp_lib.c:243:	chip->is_signed = snd_pcm_format_signed(substream->runtime->format);
./sound/drivers/pcsp/pcsp_lib.c:252:			chip->fmt_size);
./sound/drivers/pcsp/pcsp_lib.c:282:	spin_lock(&chip->substream_lock);
./sound/drivers/pcsp/pcsp_lib.c:283:	pos = chip->playback_ptr;
./sound/drivers/pcsp/pcsp_lib.c:284:	spin_unlock(&chip->substream_lock);
./sound/drivers/pcsp/pcsp_lib.c:317:	if (atomic_read(&chip->timer_active)) {
./sound/drivers/pcsp/pcsp_lib.c:322:	chip->playback_substream = substream;
./sound/drivers/pcsp/pcsp_lib.c:341:	err = snd_pcm_new(chip->card, "pcspeaker", 0, 1, 0, &chip->pcm);
./sound/drivers/pcsp/pcsp_lib.c:345:	snd_pcm_set_ops(chip->pcm, SNDRV_PCM_STREAM_PLAYBACK,
./sound/drivers/pcsp/pcsp_lib.c:348:	chip->pcm->private_data = chip;
./sound/drivers/pcsp/pcsp_lib.c:349:	chip->pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;
./sound/drivers/pcsp/pcsp_lib.c:350:	strcpy(chip->pcm->name, "pcsp");
./sound/drivers/pcsp/pcsp_lib.c:352:	snd_pcm_lib_preallocate_pages_for_all(chip->pcm,
./sound/drivers/pcsp/pcsp_mixer.c:27:	ucontrol->value.integer.value[0] = chip->enable;
./sound/drivers/pcsp/pcsp_mixer.c:37:	if (enab != chip->enable) {
./sound/drivers/pcsp/pcsp_mixer.c:38:		chip->enable = enab;
./sound/drivers/pcsp/pcsp_mixer.c:50:	uinfo->value.enumerated.items = chip->max_treble + 1;
./sound/drivers/pcsp/pcsp_mixer.c:51:	if (uinfo->value.enumerated.item > chip->max_treble)
./sound/drivers/pcsp/pcsp_mixer.c:52:		uinfo->value.enumerated.item = chip->max_treble;
./sound/drivers/pcsp/pcsp_mixer.c:62:	ucontrol->value.enumerated.item[0] = chip->treble;
./sound/drivers/pcsp/pcsp_mixer.c:72:	if (treble != chip->treble) {
./sound/drivers/pcsp/pcsp_mixer.c:73:		chip->treble = treble;
./sound/drivers/pcsp/pcsp_mixer.c:96:	ucontrol->value.integer.value[0] = chip->pcspkr;
./sound/drivers/pcsp/pcsp_mixer.c:106:	if (spkr != chip->pcspkr) {
./sound/drivers/pcsp/pcsp_mixer.c:107:		chip->pcspkr = spkr;
./sound/drivers/pcsp/pcsp_mixer.c:135:	struct snd_card *card = chip->card;
./sound/drivers/pcsp/pcsp_mixer.c:147:	struct snd_card *card = chip->card;
./sound/drivers/dummy.c:1038:	if (!snd_card_proc_new(chip->card, "dummy_pcm", &entry)) {
./sound/drivers/mtpav.c:174: *  where X = chip->num_ports
./sound/drivers/mtpav.c:186:	else if (subdev < chip->num_ports)
./sound/drivers/mtpav.c:188:	else if (subdev < chip->num_ports * 2)
./sound/drivers/mtpav.c:189:		return subdev - chip->num_ports + 0x09; /* remote port */
./sound/drivers/mtpav.c:190:	else if (subdev == chip->num_ports * 2 + MTPAV_PIDX_COMPUTER)
./sound/drivers/mtpav.c:192:	else if (subdev == chip->num_ports + MTPAV_PIDX_ADAT)
./sound/drivers/mtpav.c:201:		return chip->num_ports + MTPAV_PIDX_BROADCAST;
./sound/drivers/mtpav.c:204:		if (p >= chip->num_ports)
./sound/drivers/mtpav.c:208:		p = hwport - 0x09 + chip->num_ports;
./sound/drivers/mtpav.c:209:		if (p >= chip->num_ports * 2)
./sound/drivers/mtpav.c:210:			p = chip->num_ports;
./sound/drivers/mtpav.c:213:		return chip->num_ports + MTPAV_PIDX_COMPUTER;
./sound/drivers/mtpav.c:215:		return chip->num_ports + MTPAV_PIDX_ADAT;
./sound/drivers/mtpav.c:227:		rval = inb(chip->port + SREG);
./sound/drivers/mtpav.c:230:		rval = inb(chip->port + CREG);
./sound/drivers/mtpav.c:243:		outb(val, chip->port + reg);
./sound/drivers/mtpav.c:415:	spin_lock_irqsave(&chip->spinlock, flags);
./sound/drivers/mtpav.c:417:	mod_timer(&chip->timer, 1 + jiffies);
./sound/drivers/mtpav.c:419:	for (p = 0; p <= chip->num_ports * 2 + MTPAV_PIDX_BROADCAST; p++) {
./sound/drivers/mtpav.c:420:		struct mtpav_port *portp = &chip->ports[p];
./sound/drivers/mtpav.c:424:	spin_unlock_irqrestore(&chip->spinlock, flags);
./sound/drivers/mtpav.c:430:	mod_timer(&chip->timer, 1 + jiffies);
./sound/drivers/mtpav.c:436:	del_timer(&chip->timer);
./sound/drivers/mtpav.c:623:	if (substream->number >= 0 && substream->number < chip->num_ports)
./sound/drivers/mtpav.c:624:		sprintf(substream->name, "MTP direct %d", (substream->number % chip->num_ports) + 1);
./sound/drivers/mtpav.c:625:	else if (substream->number >= 8 && substream->number < chip->num_ports * 2)
./sound/drivers/mtpav.c:626:		sprintf(substream->name, "MTP remote %d", (substream->number % chip->num_ports) + 1);
./sound/drivers/mtpav.c:627:	else if (substream->number == chip->num_ports * 2)
./sound/drivers/mtpav.c:629:	else if (substream->number == chip->num_ports * 2 + 1)
./sound/pci/pcxhr/pcxhr_core.c:1329:			for (j = 0; j < chip->nb_streams_capt; j++)
./sound/pci/pcxhr/pcxhr_core.c:1331:						&chip->capture_stream[j],
./sound/pci/pcxhr/pcxhr_core.c:1336:			for (j = 0; j < chip->nb_streams_play; j++)
./sound/pci/pcxhr/pcxhr_core.c:1338:						&chip->playback_stream[j],
./sound/pci/pcxhr/pcxhr_hwdep.c:251:		if (chip->nb_streams_play) {
./sound/pci/pcxhr/pcxhr_hwdep.c:252:			pipe = &chip->playback_pipe;
./sound/pci/pcxhr/pcxhr_hwdep.c:256:			for(j = 0; j < chip->nb_streams_play; j++)
./sound/pci/pcxhr/pcxhr_hwdep.c:257:				chip->playback_stream[j].pipe = pipe;
./sound/pci/pcxhr/pcxhr_hwdep.c:259:		for (j = 0; j < chip->nb_streams_capt; j++) {
./sound/pci/pcxhr/pcxhr_hwdep.c:260:			pipe = &chip->capture_pipe[j];
./sound/pci/pcxhr/pcxhr_hwdep.c:264:			chip->capture_stream[j].pipe = pipe;
./sound/pci/pcxhr/pcxhr_hwdep.c:280:		if (chip->nb_streams_play)
./sound/pci/pcxhr/pcxhr_hwdep.c:281:			playback_mask |= 1 << chip->playback_pipe.first_audio;
./sound/pci/pcxhr/pcxhr_hwdep.c:282:		for (j = 0; j < chip->nb_streams_capt; j++)
./sound/pci/pcxhr/pcxhr_hwdep.c:283:			capture_mask |= 1 << chip->capture_pipe[j].first_audio;
./sound/pci/pcxhr/pcxhr_hwdep.c:342:			if ((err = pcxhr_create_mixer(chip->mgr)) < 0)
./sound/pci/pcxhr/pcxhr_hwdep.c:345:		if ((err = snd_card_register(chip->card)) < 0)
./sound/pci/pcxhr/pcxhr_mix22.c:549:	dev_dbg(chip->card->dev,
./sound/pci/pcxhr/pcxhr_mix22.c:555:		if (chip->analog_capture_active) {
./sound/pci/pcxhr/pcxhr_mix22.c:556:			level_l = chip->analog_capture_volume[0];
./sound/pci/pcxhr/pcxhr_mix22.c:557:			level_r = chip->analog_capture_volume[1];
./sound/pci/pcxhr/pcxhr_mix22.c:562:		if (chip->mic_active)
./sound/pci/pcxhr/pcxhr_mix22.c:563:			level_mic = chip->mic_volume;
./sound/pci/pcxhr/pcxhr_mix22.c:566:		return hr222_set_hw_capture_level(chip->mgr,
./sound/pci/pcxhr/pcxhr_mix22.c:570:		if (chip->analog_playback_active[channel])
./sound/pci/pcxhr/pcxhr_mix22.c:571:			vol = chip->analog_playback_volume[channel];
./sound/pci/pcxhr/pcxhr_mix22.c:574:		return hr222_set_hw_playback_level(chip->mgr, channel, vol);
./sound/pci/pcxhr/pcxhr_mix22.c:590:	chip->mgr->xlx_cfg &= ~(PCXHR_CFG_SRC_MASK |
./sound/pci/pcxhr/pcxhr_mix22.c:594:	if (chip->audio_capture_source == SOURCE_DIGISRC) {
./sound/pci/pcxhr/pcxhr_mix22.c:595:		chip->mgr->xlx_cfg |= PCXHR_CFG_SRC_MASK;
./sound/pci/pcxhr/pcxhr_mix22.c:598:		if (chip->audio_capture_source == SOURCE_DIGITAL)
./sound/pci/pcxhr/pcxhr_mix22.c:602:		chip->mgr->xlx_cfg |=  PCXHR_CFG_DATAIN_SEL_MASK;
./sound/pci/pcxhr/pcxhr_mix22.c:603:		if (chip->mgr->board_has_aes1) {
./sound/pci/pcxhr/pcxhr_mix22.c:605:			chip->mgr->xlx_cfg |= PCXHR_CFG_DATA_UER1_SEL_MASK;
./sound/pci/pcxhr/pcxhr_mix22.c:607:		/* chip->mic_active = 0; */
./sound/pci/pcxhr/pcxhr_mix22.c:608:		/* chip->analog_capture_active = 0; */
./sound/pci/pcxhr/pcxhr_mix22.c:611:		chip->analog_capture_active = 0;
./sound/pci/pcxhr/pcxhr_mix22.c:612:		chip->mic_active = 0;
./sound/pci/pcxhr/pcxhr_mix22.c:613:		if (chip->audio_capture_source == SOURCE_LINE ||
./sound/pci/pcxhr/pcxhr_mix22.c:614:		    chip->audio_capture_source == SOURCE_LINEMIC) {
./sound/pci/pcxhr/pcxhr_mix22.c:615:			if (chip->analog_capture_active == 0)
./sound/pci/pcxhr/pcxhr_mix22.c:617:			chip->analog_capture_active = 1;
./sound/pci/pcxhr/pcxhr_mix22.c:619:		if (chip->audio_capture_source == SOURCE_MIC ||
./sound/pci/pcxhr/pcxhr_mix22.c:620:		    chip->audio_capture_source == SOURCE_LINEMIC) {
./sound/pci/pcxhr/pcxhr_mix22.c:621:			if (chip->mic_active == 0)
./sound/pci/pcxhr/pcxhr_mix22.c:623:			chip->mic_active = 1;
./sound/pci/pcxhr/pcxhr_mix22.c:631:	PCXHR_OUTPB(chip->mgr, PCXHR_XLX_CFG, chip->mgr->xlx_cfg);
./sound/pci/pcxhr/pcxhr_mix22.c:641:	unsigned char mask = chip->mgr->board_has_aes1 ?
./sound/pci/pcxhr/pcxhr_mix22.c:645:		PCXHR_OUTPB(chip->mgr, PCXHR_XLX_RUER, idx++); /* idx < 192 */
./sound/pci/pcxhr/pcxhr_mix22.c:647:		if (PCXHR_INPB(chip->mgr, PCXHR_XLX_CSUER) & mask)
./sound/pci/pcxhr/pcxhr_mix22.c:650:	dev_dbg(chip->card->dev, "read iec958 AES %d byte %d = 0x%x\n",
./sound/pci/pcxhr/pcxhr_mix22.c:651:		    chip->chip_idx, aes_idx, temp);
./sound/pci/pcxhr/pcxhr_mix22.c:662:	unsigned char old_bits = chip->aes_bits[aes_idx];
./sound/pci/pcxhr/pcxhr_mix22.c:667:			PCXHR_OUTPB(chip->mgr, PCXHR_XLX_RUER, idx);
./sound/pci/pcxhr/pcxhr_mix22.c:669:			PCXHR_OUTPB(chip->mgr, PCXHR_XLX_CSUER, new_bits&0x01 ?
./sound/pci/pcxhr/pcxhr_mix22.c:676:	chip->aes_bits[aes_idx] = aes_bits;
./sound/pci/pcxhr/pcxhr_mix22.c:726:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:727:	ucontrol->value.integer.value[0] = chip->mic_volume;
./sound/pci/pcxhr/pcxhr_mix22.c:728:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:737:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:738:	if (chip->mic_volume != ucontrol->value.integer.value[0]) {
./sound/pci/pcxhr/pcxhr_mix22.c:740:		chip->mic_volume = ucontrol->value.integer.value[0];
./sound/pci/pcxhr/pcxhr_mix22.c:743:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:776:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:777:	ucontrol->value.integer.value[0] = chip->mic_boost;
./sound/pci/pcxhr/pcxhr_mix22.c:778:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:787:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:788:	if (chip->mic_boost != ucontrol->value.integer.value[0]) {
./sound/pci/pcxhr/pcxhr_mix22.c:790:		chip->mic_boost = ucontrol->value.integer.value[0];
./sound/pci/pcxhr/pcxhr_mix22.c:791:		hr222_micro_boost(chip->mgr, chip->mic_boost);
./sound/pci/pcxhr/pcxhr_mix22.c:793:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:816:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:817:	ucontrol->value.integer.value[0] = chip->phantom_power;
./sound/pci/pcxhr/pcxhr_mix22.c:818:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:828:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:830:	if (chip->phantom_power != power) {
./sound/pci/pcxhr/pcxhr_mix22.c:831:		hr222_phantom_power(chip->mgr, power);
./sound/pci/pcxhr/pcxhr_mix22.c:832:		chip->phantom_power = power;
./sound/pci/pcxhr/pcxhr_mix22.c:835:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mix22.c:851:	if (!chip->mgr->board_has_mic)
./sound/pci/pcxhr/pcxhr_mix22.c:855:	err = snd_ctl_add(chip->card, snd_ctl_new1(&hr222_control_mic_level,
./sound/pci/pcxhr/pcxhr_mix22.c:860:	err = snd_ctl_add(chip->card, snd_ctl_new1(&hr222_control_mic_boost,
./sound/pci/pcxhr/pcxhr_mix22.c:865:	err = snd_ctl_add(chip->card, snd_ctl_new1(&hr222_phantom_power_switch,
./sound/pci/pcxhr/pcxhr.c:515:			dev_err(chip->card->dev,
./sound/pci/pcxhr/pcxhr.c:538:	err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr.c:540:		dev_err(chip->card->dev,
./sound/pci/pcxhr/pcxhr.c:586:		dev_err(chip->card->dev,
./sound/pci/pcxhr/pcxhr.c:591:	sample_rate = chip->mgr->sample_rate;
./sound/pci/pcxhr/pcxhr.c:611:		if (DSP_EXT_CMD_SET(chip->mgr))
./sound/pci/pcxhr/pcxhr.c:618:	if (DSP_EXT_CMD_SET(chip->mgr)) {
./sound/pci/pcxhr/pcxhr.c:629:	err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr.c:631:		dev_err(chip->card->dev,
./sound/pci/pcxhr/pcxhr.c:646:	dev_dbg(chip->card->dev,
./sound/pci/pcxhr/pcxhr.c:649:		chip->chip_idx, (void *)(long)subs->runtime->dma_addr,
./sound/pci/pcxhr/pcxhr.c:667:	err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr.c:669:		dev_err(chip->card->dev,
./sound/pci/pcxhr/pcxhr.c:685:	err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr.c:690:	dev_dbg(chip->card->dev, "PIPE_SAMPLE_COUNT = %lx\n", *sample_count);
./sound/pci/pcxhr/pcxhr.c:723:		for (j = 0; j < chip->nb_streams_capt; j++) {
./sound/pci/pcxhr/pcxhr.c:724:			if (pcxhr_stream_scheduled_get_pipe(&chip->capture_stream[j], &pipe))
./sound/pci/pcxhr/pcxhr.c:727:		for (j = 0; j < chip->nb_streams_play; j++) {
./sound/pci/pcxhr/pcxhr.c:728:			if (pcxhr_stream_scheduled_get_pipe(&chip->playback_stream[j], &pipe)) {
./sound/pci/pcxhr/pcxhr.c:760:		for (j = 0; j < chip->nb_streams_capt; j++) {
./sound/pci/pcxhr/pcxhr.c:761:			stream = &chip->capture_stream[j];
./sound/pci/pcxhr/pcxhr.c:767:		for (j = 0; j < chip->nb_streams_play; j++) {
./sound/pci/pcxhr/pcxhr.c:768:			stream = &chip->playback_stream[j];
./sound/pci/pcxhr/pcxhr.c:779:		for (j = 0; j < chip->nb_streams_capt; j++) {
./sound/pci/pcxhr/pcxhr.c:780:			stream = &chip->capture_stream[j];
./sound/pci/pcxhr/pcxhr.c:784:		for (j = 0; j < chip->nb_streams_play; j++) {
./sound/pci/pcxhr/pcxhr.c:785:			stream = &chip->playback_stream[j];
./sound/pci/pcxhr/pcxhr.c:808:		for(j = 0; j < chip->nb_streams_capt; j++) {
./sound/pci/pcxhr/pcxhr.c:809:			stream = &chip->capture_stream[j];
./sound/pci/pcxhr/pcxhr.c:813:		for (j = 0; j < chip->nb_streams_play; j++) {
./sound/pci/pcxhr/pcxhr.c:814:			stream = &chip->playback_stream[j];
./sound/pci/pcxhr/pcxhr.c:846:		dev_dbg(chip->card->dev, "SNDRV_PCM_TRIGGER_START\n");
./sound/pci/pcxhr/pcxhr.c:856:			pcxhr_start_linked_stream(chip->mgr);
./sound/pci/pcxhr/pcxhr.c:859:			dev_dbg(chip->card->dev, "Only one Substream %c %d\n",
./sound/pci/pcxhr/pcxhr.c:874:		dev_dbg(chip->card->dev, "SNDRV_PCM_TRIGGER_STOP\n");
./sound/pci/pcxhr/pcxhr.c:917:	struct pcxhr_mgr *mgr = chip->mgr;
./sound/pci/pcxhr/pcxhr.c:920:	dev_dbg(chip->card->dev,
./sound/pci/pcxhr/pcxhr.c:954:	struct pcxhr_mgr *mgr = chip->mgr;
./sound/pci/pcxhr/pcxhr.c:1019:	struct pcxhr_mgr       *mgr = chip->mgr;
./sound/pci/pcxhr/pcxhr.c:1030:		dev_dbg(chip->card->dev, "pcxhr_open playback chip%d subs%d\n",
./sound/pci/pcxhr/pcxhr.c:1031:			    chip->chip_idx, subs->number);
./sound/pci/pcxhr/pcxhr.c:1032:		stream = &chip->playback_stream[subs->number];
./sound/pci/pcxhr/pcxhr.c:1034:		dev_dbg(chip->card->dev, "pcxhr_open capture chip%d subs%d\n",
./sound/pci/pcxhr/pcxhr.c:1035:			    chip->chip_idx, subs->number);
./sound/pci/pcxhr/pcxhr.c:1040:		stream = &chip->capture_stream[subs->number];
./sound/pci/pcxhr/pcxhr.c:1044:		dev_err(chip->card->dev, "pcxhr_open chip%d subs%d in use\n",
./sound/pci/pcxhr/pcxhr.c:1045:			   chip->chip_idx, subs->number);
./sound/pci/pcxhr/pcxhr.c:1105:	struct pcxhr_mgr *mgr = chip->mgr;
./sound/pci/pcxhr/pcxhr.c:1110:	dev_dbg(chip->card->dev, "pcxhr_close chip%d subs%d\n",
./sound/pci/pcxhr/pcxhr.c:1111:		    chip->chip_idx, subs->number);
./sound/pci/pcxhr/pcxhr.c:1136:	mutex_lock(&chip->mgr->lock);
./sound/pci/pcxhr/pcxhr.c:1142:	mutex_unlock(&chip->mgr->lock);
./sound/pci/pcxhr/pcxhr.c:1168:	sprintf(name, "pcxhr %d", chip->chip_idx);
./sound/pci/pcxhr/pcxhr.c:1169:	if ((err = snd_pcm_new(chip->card, name, 0,
./sound/pci/pcxhr/pcxhr.c:1170:			       chip->nb_streams_play,
./sound/pci/pcxhr/pcxhr.c:1171:			       chip->nb_streams_capt, &pcm)) < 0) {
./sound/pci/pcxhr/pcxhr.c:1172:		dev_err(chip->card->dev, "cannot create pcm %s\n", name);
./sound/pci/pcxhr/pcxhr.c:1177:	if (chip->nb_streams_play)
./sound/pci/pcxhr/pcxhr.c:1179:	if (chip->nb_streams_capt)
./sound/pci/pcxhr/pcxhr.c:1187:					      snd_dma_pci_data(chip->mgr->pci),
./sound/pci/pcxhr/pcxhr.c:1189:	chip->pcm = pcm;
./sound/pci/pcxhr/pcxhr.c:1223:	chip->card = card;
./sound/pci/pcxhr/pcxhr.c:1224:	chip->chip_idx = idx;
./sound/pci/pcxhr/pcxhr.c:1225:	chip->mgr = mgr;
./sound/pci/pcxhr/pcxhr.c:1229:		chip->nb_streams_play = PCXHR_PLAYBACK_STREAMS;
./sound/pci/pcxhr/pcxhr.c:1233:			chip->nb_streams_capt = 2;	/* 2 mono streams */
./sound/pci/pcxhr/pcxhr.c:1235:			chip->nb_streams_capt = 1;	/* or 1 stereo stream */
./sound/pci/pcxhr/pcxhr.c:1253:	struct pcxhr_mgr *mgr = chip->mgr;
./sound/pci/pcxhr/pcxhr.c:1324:	struct pcxhr_mgr *mgr = chip->mgr;
./sound/pci/pcxhr/pcxhr.c:1366:	struct pcxhr_mgr *mgr = chip->mgr;
./sound/pci/pcxhr/pcxhr.c:1383:	struct pcxhr_mgr *mgr = chip->mgr;
./sound/pci/pcxhr/pcxhr.c:1411:	struct pcxhr_mgr *mgr = chip->mgr;
./sound/pci/pcxhr/pcxhr.c:1461:	if (! snd_card_proc_new(chip->card, "info", &entry))
./sound/pci/pcxhr/pcxhr.c:1463:	if (! snd_card_proc_new(chip->card, "sync", &entry))
./sound/pci/pcxhr/pcxhr.c:1466:	if (chip->mgr->is_hr_stereo &&
./sound/pci/pcxhr/pcxhr.c:1467:	    !snd_card_proc_new(chip->card, "gpio", &entry)) {
./sound/pci/pcxhr/pcxhr.c:1472:	if (!snd_card_proc_new(chip->card, "ltc", &entry))
./sound/pci/pcxhr/pcxhr_mixer.c:61:		rmh.cmd[2] = chip->analog_capture_volume[channel];
./sound/pci/pcxhr/pcxhr_mixer.c:64:		if (chip->analog_playback_active[channel])
./sound/pci/pcxhr/pcxhr_mixer.c:65:			vol = chip->analog_playback_volume[channel];
./sound/pci/pcxhr/pcxhr_mixer.c:71:	rmh.cmd[1]  = 1 << ((2 * chip->chip_idx) + channel);	/* audio mask */
./sound/pci/pcxhr/pcxhr_mixer.c:73:	err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr_mixer.c:75:		dev_dbg(chip->card->dev,
./sound/pci/pcxhr/pcxhr_mixer.c:78:			   chip->chip_idx, is_capture, err);
./sound/pci/pcxhr/pcxhr_mixer.c:95:	    if (chip->mgr->is_hr_stereo) {
./sound/pci/pcxhr/pcxhr_mixer.c:107:	    if (chip->mgr->is_hr_stereo) {
./sound/pci/pcxhr/pcxhr_mixer.c:126:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:128:	  ucontrol->value.integer.value[0] = chip->analog_playback_volume[0];
./sound/pci/pcxhr/pcxhr_mixer.c:129:	  ucontrol->value.integer.value[1] = chip->analog_playback_volume[1];
./sound/pci/pcxhr/pcxhr_mixer.c:131:	  ucontrol->value.integer.value[0] = chip->analog_capture_volume[0];
./sound/pci/pcxhr/pcxhr_mixer.c:132:	  ucontrol->value.integer.value[1] = chip->analog_capture_volume[1];
./sound/pci/pcxhr/pcxhr_mixer.c:134:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:145:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:150:			&chip->analog_capture_volume[i] :
./sound/pci/pcxhr/pcxhr_mixer.c:151:			&chip->analog_playback_volume[i];
./sound/pci/pcxhr/pcxhr_mixer.c:153:			if (chip->mgr->is_hr_stereo) {
./sound/pci/pcxhr/pcxhr_mixer.c:163:			if (chip->mgr->is_hr_stereo) {
./sound/pci/pcxhr/pcxhr_mixer.c:176:			if (chip->mgr->is_hr_stereo)
./sound/pci/pcxhr/pcxhr_mixer.c:184:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:208:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:209:	ucontrol->value.integer.value[0] = chip->analog_playback_active[0];
./sound/pci/pcxhr/pcxhr_mixer.c:210:	ucontrol->value.integer.value[1] = chip->analog_playback_active[1];
./sound/pci/pcxhr/pcxhr_mixer.c:211:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:220:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:222:		if (chip->analog_playback_active[i] !=
./sound/pci/pcxhr/pcxhr_mixer.c:224:			chip->analog_playback_active[i] =
./sound/pci/pcxhr/pcxhr_mixer.c:228:			if (chip->mgr->is_hr_stereo)
./sound/pci/pcxhr/pcxhr_mixer.c:234:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:263:	struct pcxhr_pipe *pipe = &chip->playback_pipe;
./sound/pci/pcxhr/pcxhr_mixer.c:266:	if (chip->digital_playback_active[idx][0])
./sound/pci/pcxhr/pcxhr_mixer.c:267:		left = chip->digital_playback_volume[idx][0];
./sound/pci/pcxhr/pcxhr_mixer.c:270:	if (chip->digital_playback_active[idx][1])
./sound/pci/pcxhr/pcxhr_mixer.c:271:		right = chip->digital_playback_volume[idx][1];
./sound/pci/pcxhr/pcxhr_mixer.c:286:	err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr_mixer.c:288:		dev_dbg(chip->card->dev, "error update_playback_stream_level "
./sound/pci/pcxhr/pcxhr_mixer.c:289:			   "card(%d) err(%x)\n", chip->chip_idx, err);
./sound/pci/pcxhr/pcxhr_mixer.c:310:		pipe = &chip->capture_pipe[0];
./sound/pci/pcxhr/pcxhr_mixer.c:312:		pipe = &chip->playback_pipe;
./sound/pci/pcxhr/pcxhr_mixer.c:324:		rmh.cmd[2] = chip->digital_capture_volume[channel];
./sound/pci/pcxhr/pcxhr_mixer.c:331:		rmh.cmd[2] = chip->monitoring_volume[channel] << 10;
./sound/pci/pcxhr/pcxhr_mixer.c:332:		if (chip->monitoring_active[channel] == 0)
./sound/pci/pcxhr/pcxhr_mixer.c:337:	err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr_mixer.c:339:		dev_dbg(chip->card->dev,
./sound/pci/pcxhr/pcxhr_mixer.c:341:			   chip->chip_idx, err);
./sound/pci/pcxhr/pcxhr_mixer.c:368:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:370:		stored_volume = chip->digital_capture_volume;
./sound/pci/pcxhr/pcxhr_mixer.c:372:		stored_volume = chip->digital_playback_volume[idx];
./sound/pci/pcxhr/pcxhr_mixer.c:375:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:389:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:391:		stored_volume = chip->digital_capture_volume;
./sound/pci/pcxhr/pcxhr_mixer.c:393:		stored_volume = chip->digital_playback_volume[idx];
./sound/pci/pcxhr/pcxhr_mixer.c:408:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:432:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:433:	ucontrol->value.integer.value[0] = chip->digital_playback_active[idx][0];
./sound/pci/pcxhr/pcxhr_mixer.c:434:	ucontrol->value.integer.value[1] = chip->digital_playback_active[idx][1];
./sound/pci/pcxhr/pcxhr_mixer.c:435:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:447:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:450:		if (chip->digital_playback_active[j][i] !=
./sound/pci/pcxhr/pcxhr_mixer.c:452:			chip->digital_playback_active[j][i] =
./sound/pci/pcxhr/pcxhr_mixer.c:459:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:481:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:482:	ucontrol->value.integer.value[0] = chip->monitoring_volume[0];
./sound/pci/pcxhr/pcxhr_mixer.c:483:	ucontrol->value.integer.value[1] = chip->monitoring_volume[1];
./sound/pci/pcxhr/pcxhr_mixer.c:484:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:495:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:497:		if (chip->monitoring_volume[i] !=
./sound/pci/pcxhr/pcxhr_mixer.c:499:			chip->monitoring_volume[i] =
./sound/pci/pcxhr/pcxhr_mixer.c:501:			if (chip->monitoring_active[i])
./sound/pci/pcxhr/pcxhr_mixer.c:508:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:531:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:532:	ucontrol->value.integer.value[0] = chip->monitoring_active[0];
./sound/pci/pcxhr/pcxhr_mixer.c:533:	ucontrol->value.integer.value[1] = chip->monitoring_active[1];
./sound/pci/pcxhr/pcxhr_mixer.c:534:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:545:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:547:		if (chip->monitoring_active[i] !=
./sound/pci/pcxhr/pcxhr_mixer.c:549:			chip->monitoring_active[i] =
./sound/pci/pcxhr/pcxhr_mixer.c:561:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:591:	switch (chip->chip_idx) {
./sound/pci/pcxhr/pcxhr_mixer.c:598:	if (chip->audio_capture_source != 0) {
./sound/pci/pcxhr/pcxhr_mixer.c:604:	pcxhr_write_io_num_reg_cont(chip->mgr, mask, reg, &changed);
./sound/pci/pcxhr/pcxhr_mixer.c:608:		rmh.cmd[0] |= (1 << chip->chip_idx);
./sound/pci/pcxhr/pcxhr_mixer.c:609:		err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr_mixer.c:613:	if (chip->mgr->board_aes_in_192k) {
./sound/pci/pcxhr/pcxhr_mixer.c:617:		for (i = 0; (i < 4) && (i < chip->mgr->capture_chips); i++) {
./sound/pci/pcxhr/pcxhr_mixer.c:618:			if (chip->mgr->chip[i]->audio_capture_source == 2)
./sound/pci/pcxhr/pcxhr_mixer.c:626:		err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr_mixer.c:629:		if (chip->audio_capture_source == 2)
./sound/pci/pcxhr/pcxhr_mixer.c:638:		err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr_mixer.c:643:		err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr_mixer.c:658:	if (chip->mgr->board_has_aes1) {
./sound/pci/pcxhr/pcxhr_mixer.c:660:		if (chip->mgr->board_has_mic)
./sound/pci/pcxhr/pcxhr_mixer.c:670:	ucontrol->value.enumerated.item[0] = chip->audio_capture_source;
./sound/pci/pcxhr/pcxhr_mixer.c:680:	if (chip->mgr->board_has_aes1) {
./sound/pci/pcxhr/pcxhr_mixer.c:682:		if (chip->mgr->board_has_mic)
./sound/pci/pcxhr/pcxhr_mixer.c:687:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:688:	if (chip->audio_capture_source != ucontrol->value.enumerated.item[0]) {
./sound/pci/pcxhr/pcxhr_mixer.c:689:		chip->audio_capture_source = ucontrol->value.enumerated.item[0];
./sound/pci/pcxhr/pcxhr_mixer.c:690:		if (chip->mgr->is_hr_stereo)
./sound/pci/pcxhr/pcxhr_mixer.c:696:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:873:	switch (chip->chip_idx) {
./sound/pci/pcxhr/pcxhr_mixer.c:881:	if (chip->mgr->board_aes_in_192k) {
./sound/pci/pcxhr/pcxhr_mixer.c:906:	err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr_mixer.c:910:	if (chip->mgr->board_aes_in_192k) {
./sound/pci/pcxhr/pcxhr_mixer.c:921:	dev_dbg(chip->card->dev, "read iec958 AES %d byte %d = 0x%x\n",
./sound/pci/pcxhr/pcxhr_mixer.c:922:		    chip->chip_idx, aes_idx, temp);
./sound/pci/pcxhr/pcxhr_mixer.c:934:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:937:			aes_bits = chip->aes_bits[i];
./sound/pci/pcxhr/pcxhr_mixer.c:939:			if (chip->mgr->is_hr_stereo)
./sound/pci/pcxhr/pcxhr_mixer.c:950:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:968:	unsigned char old_bits = chip->aes_bits[aes_idx];
./sound/pci/pcxhr/pcxhr_mixer.c:973:			cmd = chip->chip_idx & 0x03;      /* chip index 0..3 */
./sound/pci/pcxhr/pcxhr_mixer.c:974:			if (chip->chip_idx > 3)
./sound/pci/pcxhr/pcxhr_mixer.c:983:			dev_dbg(chip->card->dev,
./sound/pci/pcxhr/pcxhr_mixer.c:985:				    chip->chip_idx, aes_idx, i, cmd);
./sound/pci/pcxhr/pcxhr_mixer.c:986:			err = pcxhr_send_msg(chip->mgr, &rmh);
./sound/pci/pcxhr/pcxhr_mixer.c:993:	chip->aes_bits[aes_idx] = aes_bits;
./sound/pci/pcxhr/pcxhr_mixer.c:1004:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:1006:		if (ucontrol->value.iec958.status[i] != chip->aes_bits[i]) {
./sound/pci/pcxhr/pcxhr_mixer.c:1007:			if (chip->mgr->is_hr_stereo)
./sound/pci/pcxhr/pcxhr_mixer.c:1016:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/pcxhr/pcxhr_mixer.c:1057:		if (chip->nb_streams_play) {
./sound/pci/pcxhr/pcxhr_mixer.c:1061:				chip->digital_playback_active[j][i] = 1;
./sound/pci/pcxhr/pcxhr_mixer.c:1062:				chip->digital_playback_volume[j][i] =
./sound/pci/pcxhr/pcxhr_mixer.c:1068:			chip->aes_bits[0] = (IEC958_AES0_PROFESSIONAL |
./sound/pci/pcxhr/pcxhr_mixer.c:1074:			chip->analog_playback_active[i] = 1;
./sound/pci/pcxhr/pcxhr_mixer.c:1075:			if (chip->mgr->is_hr_stereo)
./sound/pci/pcxhr/pcxhr_mixer.c:1076:				chip->analog_playback_volume[i] =
./sound/pci/pcxhr/pcxhr_mixer.c:1079:				chip->analog_playback_volume[i] =
./sound/pci/pcxhr/pcxhr_mixer.c:1085:			if (chip->mgr->is_hr_stereo)
./sound/pci/pcxhr/pcxhr_mixer.c:1088:		if (chip->nb_streams_capt) {
./sound/pci/pcxhr/pcxhr_mixer.c:1090:			chip->digital_capture_volume[i] =
./sound/pci/pcxhr/pcxhr_mixer.c:1092:			chip->analog_capture_active = 1;
./sound/pci/pcxhr/pcxhr_mixer.c:1097:			if (chip->mgr->is_hr_stereo)
./sound/pci/pcxhr/pcxhr_mixer.c:1098:				chip->analog_capture_volume[i] =
./sound/pci/pcxhr/pcxhr_mixer.c:1101:				chip->analog_capture_volume[i] =
./sound/pci/pcxhr/pcxhr_mixer.c:1107:			if (chip->mgr->is_hr_stereo)
./sound/pci/pcxhr/pcxhr_mixer.c:1127:		if (chip->nb_streams_play) {
./sound/pci/pcxhr/pcxhr_mixer.c:1136:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1142:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1152:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1157:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1163:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1169:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1175:		if (chip->nb_streams_capt) {
./sound/pci/pcxhr/pcxhr_mixer.c:1185:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1195:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1201:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1207:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1213:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1226:		if (chip->nb_streams_capt > 0 && chip->nb_streams_play > 0) {
./sound/pci/pcxhr/pcxhr_mixer.c:1228:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1233:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1241:			err = snd_ctl_add(chip->card,
./sound/pci/pcxhr/pcxhr_mixer.c:1248:			err = snd_ctl_add(chip->card,
./sound/pci/emu10k1/p16v.c:630:	if (chip->p16v_buffer.area) {
./sound/pci/emu10k1/p16v.c:631:		snd_dma_free_pages(&chip->p16v_buffer);
./sound/pci/emu10k1/p16v.c:633:		dev_dbg(chip->card->dev, "period lables free: %p\n",
./sound/pci/emu10k1/p16v.c:634:			   &chip->p16v_buffer);
./sound/pci/emu10k1/emu10k1x.c:228:// definition of the chip-specific record
./sound/pci/emu10k1/emu10k1x.c:744:	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
./sound/pci/emu10k1/emu10k1x.c:751:	return snd_ac97_mixer(pbus, &ac97, &chip->ac97);
./sound/pci/emu10k1/emu10k1x.c:758:	outl(0, chip->port + INTE);
./sound/pci/emu10k1/emu10k1x.c:760:	outl(HCFG_LOCKSOUNDCACHE, chip->port + HCFG);
./sound/pci/emu10k1/emu10k1x.c:763:	if (chip->irq >= 0)
./sound/pci/emu10k1/emu10k1x.c:764:		free_irq(chip->irq, chip);
./sound/pci/emu10k1/emu10k1x.c:767:	release_and_free_resource(chip->res_port);
./sound/pci/emu10k1/emu10k1x.c:770:	if (chip->dma_buffer.area) {
./sound/pci/emu10k1/emu10k1x.c:771:		snd_dma_free_pages(&chip->dma_buffer);
./sound/pci/emu10k1/emu10k1x.c:774:	pci_disable_device(chip->pci);
./sound/pci/emu10k1/emu10k1x.c:792:	struct emu10k1x_voice *pvoice = chip->voices;
./sound/pci/emu10k1/emu10k1x.c:796:	status = inl(chip->port + IPR);
./sound/pci/emu10k1/emu10k1x.c:803:		struct emu10k1x_voice *cap_voice = &chip->capture_voice;
./sound/pci/emu10k1/emu10k1x.c:825:		if (chip->midi.interrupt)
./sound/pci/emu10k1/emu10k1x.c:826:			chip->midi.interrupt(chip, status);
./sound/pci/emu10k1/emu10k1x.c:832:	outl(status, chip->port + IPR);
./sound/pci/emu10k1/emu10k1x.c:834:	/* dev_dbg(chip->card->dev, "interrupt %08x\n", status); */
./sound/pci/emu10k1/emu10k1x.c:929:	chip->card = card;
./sound/pci/emu10k1/emu10k1x.c:930:	chip->pci = pci;
./sound/pci/emu10k1/emu10k1x.c:931:	chip->irq = -1;
./sound/pci/emu10k1/emu10k1x.c:933:	spin_lock_init(&chip->emu_lock);
./sound/pci/emu10k1/emu10k1x.c:934:	spin_lock_init(&chip->voice_lock);
./sound/pci/emu10k1/emu10k1x.c:936:	chip->port = pci_resource_start(pci, 0);
./sound/pci/emu10k1/emu10k1x.c:937:	if ((chip->res_port = request_region(chip->port, 8,
./sound/pci/emu10k1/emu10k1x.c:940:			chip->port);
./sound/pci/emu10k1/emu10k1x.c:951:	chip->irq = pci->irq;
./sound/pci/emu10k1/emu10k1x.c:954:			       4 * 1024, &chip->dma_buffer) < 0) {
./sound/pci/emu10k1/emu10k1x.c:961:	chip->revision = pci->revision;
./sound/pci/emu10k1/emu10k1x.c:962:	pci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);
./sound/pci/emu10k1/emu10k1x.c:963:	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);
./sound/pci/emu10k1/emu10k1x.c:964:	dev_info(card->dev, "Model %04x Rev %08x Serial %08x\n", chip->model,
./sound/pci/emu10k1/emu10k1x.c:965:		   chip->revision, chip->serial);
./sound/pci/emu10k1/emu10k1x.c:967:	outl(0, chip->port + INTE);	
./sound/pci/emu10k1/emu10k1x.c:970:		chip->voices[ch].emu = chip;
./sound/pci/emu10k1/emu10k1x.c:971:		chip->voices[ch].number = ch;
./sound/pci/emu10k1/emu10k1x.c:989:			       chip->spdif_bits[0] = 
./sound/pci/emu10k1/emu10k1x.c:995:			       chip->spdif_bits[1] = 
./sound/pci/emu10k1/emu10k1x.c:1001:			       chip->spdif_bits[2] = 
./sound/pci/emu10k1/emu10k1x.c:1011:	outl(HCFG_LOCKSOUNDCACHE|HCFG_AUDIOENABLE, chip->port+HCFG);
./sound/pci/emu10k1/emu10k1x.c:1610:		card->shortname, chip->port, chip->irq);
./sound/pci/via82xx_modem.c:289:		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/via82xx_modem.c:386:	dev_err(chip->card->dev, "codec_ready: codec %i is not ready [0x%x]\n",
./sound/pci/via82xx_modem.c:447:			dev_err(chip->card->dev,
./sound/pci/via82xx_modem.c:490:	if (! (status & chip->intr_mask)) {
./sound/pci/via82xx_modem.c:496:	spin_lock(&chip->reg_lock);
./sound/pci/via82xx_modem.c:497:	for (i = 0; i < chip->num_devs; i++) {
./sound/pci/via82xx_modem.c:498:		struct viadev *viadev = &chip->devs[i];
./sound/pci/via82xx_modem.c:504:			spin_unlock(&chip->reg_lock);
./sound/pci/via82xx_modem.c:506:			spin_lock(&chip->reg_lock);
./sound/pci/via82xx_modem.c:510:	spin_unlock(&chip->reg_lock);
./sound/pci/via82xx_modem.c:577:		dev_err(chip->card->dev,
./sound/pci/via82xx_modem.c:583:		dev_dbg(chip->card->dev,
./sound/pci/via82xx_modem.c:590:			dev_dbg(chip->card->dev,
./sound/pci/via82xx_modem.c:603:				dev_dbg(chip->card->dev,
./sound/pci/via82xx_modem.c:629:	spin_lock(&chip->reg_lock);
./sound/pci/via82xx_modem.c:641:	spin_unlock(&chip->reg_lock);
./sound/pci/via82xx_modem.c:660:	err = build_via_table(viadev, substream, chip->pci,
./sound/pci/via82xx_modem.c:666:	snd_ac97_write(chip->ac97, AC97_LINE1_RATE, params_rate(hw_params));
./sound/pci/via82xx_modem.c:667:	snd_ac97_write(chip->ac97, AC97_LINE1_LEVEL, 0);
./sound/pci/via82xx_modem.c:681:	clean_via_table(viadev, substream, chip->pci);
./sound/pci/via82xx_modem.c:692:	snd_via82xx_codec_ready(chip, chip->ac97_secondary);
./sound/pci/via82xx_modem.c:695:	snd_via82xx_codec_ready(chip, chip->ac97_secondary);
./sound/pci/via82xx_modem.c:778:	struct viadev *viadev = &chip->devs[chip->playback_devno + substream->number];
./sound/pci/via82xx_modem.c:789:	struct viadev *viadev = &chip->devs[chip->capture_devno + substream->pcm->device];
./sound/pci/via82xx_modem.c:836:	chip->devs[idx].reg_offset = reg_offset;
./sound/pci/via82xx_modem.c:837:	chip->devs[idx].direction = direction;
./sound/pci/via82xx_modem.c:838:	chip->devs[idx].port = chip->port + reg_offset;
./sound/pci/via82xx_modem.c:849:	chip->playback_devno = 0;
./sound/pci/via82xx_modem.c:850:	chip->capture_devno = 1;
./sound/pci/via82xx_modem.c:851:	chip->num_devs = 2;
./sound/pci/via82xx_modem.c:852:	chip->intr_mask = 0x330000; /* FLAGS | EOL for MR, MW */
./sound/pci/via82xx_modem.c:854:	err = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);
./sound/pci/via82xx_modem.c:861:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx_modem.c:862:	chip->pcms[0] = pcm;
./sound/pci/via82xx_modem.c:867:							 snd_dma_pci_data(chip->pci),
./sound/pci/via82xx_modem.c:883:	chip->ac97_bus = NULL;
./sound/pci/via82xx_modem.c:889:	chip->ac97 = NULL;
./sound/pci/via82xx_modem.c:903:	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)
./sound/pci/via82xx_modem.c:905:	chip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;
./sound/pci/via82xx_modem.c:906:	chip->ac97_bus->clock = chip->ac97_clock;
./sound/pci/via82xx_modem.c:911:	ac97.pci = chip->pci;
./sound/pci/via82xx_modem.c:913:	ac97.num = chip->ac97_secondary;
./sound/pci/via82xx_modem.c:915:	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
./sound/pci/via82xx_modem.c:930:	snd_iprintf(buffer, "%s\n\n", chip->card->longname);
./sound/pci/via82xx_modem.c:932:		snd_iprintf(buffer, "%02x: %08x\n", i, inl(chip->port + i));
./sound/pci/via82xx_modem.c:940:	if (! snd_card_proc_new(chip->card, "via82xx", &entry))
./sound/pci/via82xx_modem.c:954:	pci_read_config_byte(chip->pci, VIA_MC97_CTRL, &pval);
./sound/pci/via82xx_modem.c:956:		pci_write_config_byte(chip->pci, 0x44, pval|VIA_MC97_CTRL_INIT);
./sound/pci/via82xx_modem.c:960:	pci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);
./sound/pci/via82xx_modem.c:963:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,
./sound/pci/via82xx_modem.c:969:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, 0x00);
./sound/pci/via82xx_modem.c:973:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,
./sound/pci/via82xx_modem.c:978:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);
./sound/pci/via82xx_modem.c:982:	pci_read_config_byte(chip->pci, VIA_ACLINK_CTRL, &pval);
./sound/pci/via82xx_modem.c:985:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);
./sound/pci/via82xx_modem.c:992:		pci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);
./sound/pci/via82xx_modem.c:999:		dev_err(chip->card->dev,
./sound/pci/via82xx_modem.c:1011:			chip->ac97_secondary = 1;
./sound/pci/via82xx_modem.c:1021:	// pci_write_config_byte(chip->pci, VIA_FM_NMI_CTRL, 0);
./sound/pci/via82xx_modem.c:1040:		snd_pcm_suspend_all(chip->pcms[i]);
./sound/pci/via82xx_modem.c:1041:	for (i = 0; i < chip->num_devs; i++)
./sound/pci/via82xx_modem.c:1042:		snd_via82xx_channel_reset(chip, &chip->devs[i]);
./sound/pci/via82xx_modem.c:1043:	synchronize_irq(chip->irq);
./sound/pci/via82xx_modem.c:1044:	snd_ac97_suspend(chip->ac97);
./sound/pci/via82xx_modem.c:1056:	snd_ac97_resume(chip->ac97);
./sound/pci/via82xx_modem.c:1058:	for (i = 0; i < chip->num_devs; i++)
./sound/pci/via82xx_modem.c:1059:		snd_via82xx_channel_reset(chip, &chip->devs[i]);
./sound/pci/via82xx_modem.c:1075:	if (chip->irq < 0)
./sound/pci/via82xx_modem.c:1078:	for (i = 0; i < chip->num_devs; i++)
./sound/pci/via82xx_modem.c:1079:		snd_via82xx_channel_reset(chip, &chip->devs[i]);
./sound/pci/via82xx_modem.c:1082:	if (chip->irq >= 0)
./sound/pci/via82xx_modem.c:1083:		free_irq(chip->irq, chip);
./sound/pci/via82xx_modem.c:1084:	pci_release_regions(chip->pci);
./sound/pci/via82xx_modem.c:1085:	pci_disable_device(chip->pci);
./sound/pci/via82xx_modem.c:1117:	spin_lock_init(&chip->reg_lock);
./sound/pci/via82xx_modem.c:1118:	chip->card = card;
./sound/pci/via82xx_modem.c:1119:	chip->pci = pci;
./sound/pci/via82xx_modem.c:1120:	chip->irq = -1;
./sound/pci/via82xx_modem.c:1127:	chip->port = pci_resource_start(pci, 0);
./sound/pci/via82xx_modem.c:1134:	chip->irq = pci->irq;
./sound/pci/via82xx_modem.c:1136:		chip->ac97_clock = ac97_clock;
./sound/pci/via82xx_modem.c:1137:	synchronize_irq(chip->irq);
./sound/pci/via82xx_modem.c:1195:	for (i = 0; i < chip->num_devs; i++)
./sound/pci/via82xx_modem.c:1196:		snd_via82xx_channel_reset(chip, &chip->devs[i]);
./sound/pci/via82xx_modem.c:1199:		card->shortname, chip->port, chip->irq);
./sound/pci/azt3328.c:414:	outb(value, chip->ctrl_io + reg);
./sound/pci/azt3328.c:420:	return inb(chip->ctrl_io + reg);
./sound/pci/azt3328.c:426:	return inw(chip->ctrl_io + reg);
./sound/pci/azt3328.c:432:	outw(value, chip->ctrl_io + reg);
./sound/pci/azt3328.c:438:	outl(value, chip->ctrl_io + reg);
./sound/pci/azt3328.c:444:	outb(value, chip->game_io + reg);
./sound/pci/azt3328.c:450:	outw(value, chip->game_io + reg);
./sound/pci/azt3328.c:456:	return inb(chip->game_io + reg);
./sound/pci/azt3328.c:462:	return inw(chip->game_io + reg);
./sound/pci/azt3328.c:468:	outw(value, chip->mixer_io + reg);
./sound/pci/azt3328.c:474:	return inw(chip->mixer_io + reg);
./sound/pci/azt3328.c:484:	unsigned long portbase = chip->mixer_io + reg + 1;
./sound/pci/azt3328.c:536:	dev_warn(chip->card->dev,
./sound/pci/azt3328.c:672:	dev_dbg(chip->card->dev, "snd_azf3328_mixer_ac97_read reg_ac97 %u\n",
./sound/pci/azt3328.c:731:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:785:	ac97.pci = chip->pci;
./sound/pci/azt3328.c:793:	rc = snd_ac97_bus(chip->card, 0, &ops, NULL, &bus);
./sound/pci/azt3328.c:795:		rc = snd_ac97_mixer(bus, &ac97, &chip->ac97);
./sound/pci/azt3328.c:802:		dev_err(chip->card->dev, "AC97 init failed, err %d!\n", rc);
./sound/pci/azt3328.c:818:	unsigned long portbase = chip->mixer_io + reg;
./sound/pci/azt3328.c:969:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:1008:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:1073:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:1106:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:1193:	if (snd_BUG_ON(!chip || !chip->card))
./sound/pci/azt3328.c:1196:	card = chip->card;
./sound/pci/azt3328.c:1212:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(sw, chip))) < 0)
./sound/pci/azt3328.c:1331:		chip->shadow_reg_ctrl_6AH |= bitmask;
./sound/pci/azt3328.c:1333:		chip->shadow_reg_ctrl_6AH &= ~bitmask;
./sound/pci/azt3328.c:1334:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:1336:		bitmask, do_mask, chip->shadow_reg_ctrl_6AH);
./sound/pci/azt3328.c:1337:	snd_azf3328_ctrl_outw(chip, IDX_IO_6AH, chip->shadow_reg_ctrl_6AH);
./sound/pci/azt3328.c:1343:	dev_dbg(chip->card->dev, "codec_enable %d\n", enable);
./sound/pci/azt3328.c:1357:	struct snd_azf3328_codec_data *codec = &chip->codecs[codec_type];
./sound/pci/azt3328.c:1360:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:1384:				((!chip->codecs[peer_codecs[codec_type].other1]
./sound/pci/azt3328.c:1386:			     &&  (!chip->codecs[peer_codecs[codec_type].other2]
./sound/pci/azt3328.c:1430:		dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:1491:		dev_dbg(chip->card->dev, "START PCM %s\n", codec->name);
./sound/pci/azt3328.c:1558:		dev_dbg(chip->card->dev, "PCM STARTED %s\n", codec->name);
./sound/pci/azt3328.c:1561:		dev_dbg(chip->card->dev, "PCM RESUME %s\n", codec->name);
./sound/pci/azt3328.c:1573:		dev_dbg(chip->card->dev, "PCM STOP %s\n", codec->name);
./sound/pci/azt3328.c:1609:		dev_dbg(chip->card->dev, "PCM STOPPED %s\n", codec->name);
./sound/pci/azt3328.c:1612:		dev_dbg(chip->card->dev, "PCM SUSPEND %s\n", codec->name);
./sound/pci/azt3328.c:1666:		chip->game_io+IDX_GAME_HWCONFIG,
./sound/pci/azt3328.c:1678:		chip->game_io+IDX_GAME_HWCONFIG,
./sound/pci/azt3328.c:1690:		chip->game_io+IDX_GAME_HWCONFIG,
./sound/pci/azt3328.c:1695:		chip->game_io+IDX_GAME_HWCONFIG,
./sound/pci/azt3328.c:1716:	dev_dbg(chip->card->dev, "gameport irq\n");
./sound/pci/azt3328.c:1728:	dev_dbg(chip->card->dev, "gameport_open, mode %d\n", mode);
./sound/pci/azt3328.c:1751:	dev_dbg(chip->card->dev, "gameport_close\n");
./sound/pci/azt3328.c:1771:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/azt3328.c:1787:		for (i = 0; i < ARRAY_SIZE(chip->axes); ++i) {
./sound/pci/azt3328.c:1792:			chip->axes[i] = snd_azf3328_game_inw(
./sound/pci/azt3328.c:1808:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/azt3328.c:1810:	for (i = 0; i < ARRAY_SIZE(chip->axes); i++) {
./sound/pci/azt3328.c:1811:		axes[i] = chip->axes[i];
./sound/pci/azt3328.c:1816:	dev_dbg(chip->card->dev, "cooked_read: axes %d %d %d %d buttons %d\n",
./sound/pci/azt3328.c:1827:	chip->gameport = gp = gameport_allocate_port();
./sound/pci/azt3328.c:1829:		dev_err(chip->card->dev, "cannot alloc memory for gameport\n");
./sound/pci/azt3328.c:1834:	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
./sound/pci/azt3328.c:1835:	gameport_set_dev_parent(gp, &chip->pci->dev);
./sound/pci/azt3328.c:1836:	gp->io = chip->game_io;
./sound/pci/azt3328.c:1851:	gameport_register_port(chip->gameport);
./sound/pci/azt3328.c:1859:	if (chip->gameport) {
./sound/pci/azt3328.c:1860:		gameport_unregister_port(chip->gameport);
./sound/pci/azt3328.c:1861:		chip->gameport = NULL;
./sound/pci/azt3328.c:1873:	dev_warn(chip->card->dev, "huh, game port IRQ occurred!?\n");
./sound/pci/azt3328.c:1882:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:1913:			dev_dbg(chip->card->dev, "%s period done (#%x), @ %x\n",
./sound/pci/azt3328.c:1919:			dev_warn(chip->card->dev, "irq handler problem!\n");
./sound/pci/azt3328.c:1941:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:1947:		/* dev_dbg(chip->card->dev, "timer %ld\n",
./sound/pci/azt3328.c:1951:		if (chip->timer)
./sound/pci/azt3328.c:1952:			snd_timer_interrupt(chip->timer, chip->timer->sticks);
./sound/pci/azt3328.c:1954:                spin_lock(&chip->reg_lock);
./sound/pci/azt3328.c:1956:		spin_unlock(&chip->reg_lock);
./sound/pci/azt3328.c:1957:		dev_dbg(chip->card->dev, "timer IRQ\n");
./sound/pci/azt3328.c:1961:		snd_azf3328_pcm_interrupt(chip, chip->codecs, status);
./sound/pci/azt3328.c:1969:		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
./sound/pci/azt3328.c:1973:		dev_dbg(chip->card->dev, "MPU401 IRQ\n");
./sound/pci/azt3328.c:2049:	struct snd_azf3328_codec_data *codec = &chip->codecs[codec_type];
./sound/pci/azt3328.c:2135:	err = snd_pcm_new(chip->card, "AZF3328 DSP", AZF_PCMDEV_STD,
./sound/pci/azt3328.c:2146:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/azt3328.c:2148:	chip->pcm[AZF_CODEC_PLAYBACK] = pcm;
./sound/pci/azt3328.c:2149:	chip->pcm[AZF_CODEC_CAPTURE] = pcm;
./sound/pci/azt3328.c:2152:						snd_dma_pci_data(chip->pci),
./sound/pci/azt3328.c:2155:	err = snd_pcm_new(chip->card, "AZF3328 I2S OUT", AZF_PCMDEV_I2S_OUT,
./sound/pci/azt3328.c:2164:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/azt3328.c:2165:	chip->pcm[AZF_CODEC_I2S_OUT] = pcm;
./sound/pci/azt3328.c:2168:						snd_dma_pci_data(chip->pci),
./sound/pci/azt3328.c:2200:		dev_dbg(chip->card->dev, "delay was too low (%d)!\n", delay);
./sound/pci/azt3328.c:2203:	dev_dbg(chip->card->dev, "setting timer countdown value %d\n", delay);
./sound/pci/azt3328.c:2205:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/azt3328.c:2207:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/azt3328.c:2218:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/azt3328.c:2227:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/azt3328.c:2259:	tid.card = chip->card->number;
./sound/pci/azt3328.c:2266:	err = snd_timer_new(chip->card, "AZF3328", &tid, &timer);
./sound/pci/azt3328.c:2274:	chip->timer = timer;
./sound/pci/azt3328.c:2289:	if (chip->irq < 0)
./sound/pci/azt3328.c:2294:	snd_azf3328_timer_stop(chip->timer);
./sound/pci/azt3328.c:2298:	if (chip->irq >= 0)
./sound/pci/azt3328.c:2299:		free_irq(chip->irq, chip);
./sound/pci/azt3328.c:2300:	pci_release_regions(chip->pci);
./sound/pci/azt3328.c:2301:	pci_disable_device(chip->pci);
./sound/pci/azt3328.c:2342:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:2345:		chip->ctrl_io, chip->game_io, chip->mpu_io,
./sound/pci/azt3328.c:2346:		chip->opl3_io, chip->mixer_io, chip->irq);
./sound/pci/azt3328.c:2348:	dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:2358:		dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:2359:			"mpu_io 0x%04x\n", inb(chip->mpu_io + tmp));
./sound/pci/azt3328.c:2362:		dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:2367:		dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:2379:		dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:2384:		dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:2415:	spin_lock_init(&chip->reg_lock);
./sound/pci/azt3328.c:2416:	chip->card = card;
./sound/pci/azt3328.c:2417:	chip->pci = pci;
./sound/pci/azt3328.c:2418:	chip->irq = -1;
./sound/pci/azt3328.c:2434:	chip->ctrl_io  = pci_resource_start(pci, 0);
./sound/pci/azt3328.c:2435:	chip->game_io  = pci_resource_start(pci, 1);
./sound/pci/azt3328.c:2436:	chip->mpu_io   = pci_resource_start(pci, 2);
./sound/pci/azt3328.c:2437:	chip->opl3_io  = pci_resource_start(pci, 3);
./sound/pci/azt3328.c:2438:	chip->mixer_io = pci_resource_start(pci, 4);
./sound/pci/azt3328.c:2440:	codec_setup = &chip->codecs[AZF_CODEC_PLAYBACK];
./sound/pci/azt3328.c:2441:	codec_setup->io_base = chip->ctrl_io + AZF_IO_OFFS_CODEC_PLAYBACK;
./sound/pci/azt3328.c:2442:	codec_setup->lock = &chip->reg_lock;
./sound/pci/azt3328.c:2446:	codec_setup = &chip->codecs[AZF_CODEC_CAPTURE];
./sound/pci/azt3328.c:2447:	codec_setup->io_base = chip->ctrl_io + AZF_IO_OFFS_CODEC_CAPTURE;
./sound/pci/azt3328.c:2448:	codec_setup->lock = &chip->reg_lock;
./sound/pci/azt3328.c:2452:	codec_setup = &chip->codecs[AZF_CODEC_I2S_OUT];
./sound/pci/azt3328.c:2453:	codec_setup->io_base = chip->ctrl_io + AZF_IO_OFFS_CODEC_I2S_OUT;
./sound/pci/azt3328.c:2454:	codec_setup->lock = &chip->reg_lock;
./sound/pci/azt3328.c:2464:	chip->irq = pci->irq;
./sound/pci/azt3328.c:2466:	synchronize_irq(chip->irq);
./sound/pci/azt3328.c:2486:			 &chip->codecs[codec_type];
./sound/pci/azt3328.c:2550:		MPU401_HW_AZT2320, chip->mpu_io,
./sound/pci/azt3328.c:2552:		-1, &chip->rmidi
./sound/pci/azt3328.c:2556:				chip->mpu_io
./sound/pci/azt3328.c:2569:	if (snd_opl3_create(card, chip->opl3_io, chip->opl3_io+2,
./sound/pci/azt3328.c:2572:			   chip->opl3_io, chip->opl3_io+2
./sound/pci/azt3328.c:2586:		card->shortname, chip->ctrl_io, chip->irq);
./sound/pci/azt3328.c:2635:		dev_dbg(chip->card->dev, "suspend: io 0x%04lx: 0x%08x\n",
./sound/pci/azt3328.c:2653:		dev_dbg(chip->card->dev,
./sound/pci/azt3328.c:2665:	snd_ac97_suspend(chip->ac97);
./sound/pci/azt3328.c:2667:	snd_azf3328_suspend_regs(chip, chip->mixer_io,
./sound/pci/azt3328.c:2668:		ARRAY_SIZE(chip->saved_regs_mixer), chip->saved_regs_mixer);
./sound/pci/azt3328.c:2680:	snd_ac97_resume(chip->ac97);
./sound/pci/azt3328.c:2682:	snd_azf3328_resume_regs(chip, chip->saved_regs_mixer, chip->mixer_io,
./sound/pci/azt3328.c:2683:					ARRAY_SIZE(chip->saved_regs_mixer));
./sound/pci/azt3328.c:2689:	outw(((u16 *)chip->saved_regs_mixer)[1], chip->mixer_io + 2);
./sound/pci/azt3328.c:2703:	snd_pcm_suspend_all(chip->pcm[AZF_CODEC_PLAYBACK]);
./sound/pci/azt3328.c:2704:	snd_pcm_suspend_all(chip->pcm[AZF_CODEC_I2S_OUT]);
./sound/pci/azt3328.c:2708:	snd_azf3328_suspend_regs(chip, chip->ctrl_io,
./sound/pci/azt3328.c:2709:		ARRAY_SIZE(chip->saved_regs_ctrl), chip->saved_regs_ctrl);
./sound/pci/azt3328.c:2712:	saved_regs_ctrl_u16 = (u16 *)chip->saved_regs_ctrl;
./sound/pci/azt3328.c:2713:	saved_regs_ctrl_u16[IDX_IO_6AH / 2] = chip->shadow_reg_ctrl_6AH;
./sound/pci/azt3328.c:2715:	snd_azf3328_suspend_regs(chip, chip->game_io,
./sound/pci/azt3328.c:2716:		ARRAY_SIZE(chip->saved_regs_game), chip->saved_regs_game);
./sound/pci/azt3328.c:2717:	snd_azf3328_suspend_regs(chip, chip->mpu_io,
./sound/pci/azt3328.c:2718:		ARRAY_SIZE(chip->saved_regs_mpu), chip->saved_regs_mpu);
./sound/pci/azt3328.c:2719:	snd_azf3328_suspend_regs(chip, chip->opl3_io,
./sound/pci/azt3328.c:2720:		ARRAY_SIZE(chip->saved_regs_opl3), chip->saved_regs_opl3);
./sound/pci/azt3328.c:2730:	snd_azf3328_resume_regs(chip, chip->saved_regs_game, chip->game_io,
./sound/pci/azt3328.c:2731:					ARRAY_SIZE(chip->saved_regs_game));
./sound/pci/azt3328.c:2732:	snd_azf3328_resume_regs(chip, chip->saved_regs_mpu, chip->mpu_io,
./sound/pci/azt3328.c:2733:					ARRAY_SIZE(chip->saved_regs_mpu));
./sound/pci/azt3328.c:2734:	snd_azf3328_resume_regs(chip, chip->saved_regs_opl3, chip->opl3_io,
./sound/pci/azt3328.c:2735:					ARRAY_SIZE(chip->saved_regs_opl3));
./sound/pci/azt3328.c:2739:	snd_azf3328_resume_regs(chip, chip->saved_regs_ctrl, chip->ctrl_io,
./sound/pci/azt3328.c:2740:					ARRAY_SIZE(chip->saved_regs_ctrl));
./sound/pci/ca0106/ca0106_mixer.c:910:		chip->saved_vol[i] =
./sound/pci/ca0106/ca0106_mixer.c:922:				     chip->saved_vol[i]);
./sound/pci/ca0106/ca0106_mixer.c:926:	ca0106_set_i2c_capture_source(chip, chip->i2c_capture_source, 1);
./sound/pci/ca0106/ca0106_mixer.c:929:	if (chip->details->i2c_adc)
./sound/pci/ca0106/ca0106_main.c:512:	if (chip->spdif_str_bits[idx] != chip->spdif_bits[idx]) {
./sound/pci/ca0106/ca0106_main.c:513:		chip->spdif_str_bits[idx] = chip->spdif_bits[idx];
./sound/pci/ca0106/ca0106_main.c:515:				     chip->spdif_str_bits[idx]);
./sound/pci/ca0106/ca0106_main.c:533:		dev_dbg(chip->card->dev, "ca0106: unknown channel_id %d\n",
./sound/pci/ca0106/ca0106_main.c:542:	if (chip->details->spi_dac) {
./sound/pci/ca0106/ca0106_main.c:543:		const int dac = snd_ca0106_channel_dac(chip, chip->details,
./sound/pci/ca0106/ca0106_main.c:550:			chip->spi_dac_reg[reg] &= ~bit;
./sound/pci/ca0106/ca0106_main.c:553:			chip->spi_dac_reg[reg] |= bit;
./sound/pci/ca0106/ca0106_main.c:554:		return snd_ca0106_spi_write(chip, chip->spi_dac_reg[reg]);
./sound/pci/ca0106/ca0106_main.c:564:        struct snd_ca0106_channel *channel = &(chip->playback_channels[channel_id]);
./sound/pci/ca0106/ca0106_main.c:587:	dev_dbg(chip->card->dev, "open:channel_id=%d, chip=%p, channel=%p\n",
./sound/pci/ca0106/ca0106_main.c:616:	chip->playback_channels[epcm->channel_id].use = 0;
./sound/pci/ca0106/ca0106_main.c:657:        struct snd_ca0106_channel *channel = &(chip->capture_channels[channel_id]);
./sound/pci/ca0106/ca0106_main.c:664:		dev_err(chip->card->dev,
./sound/pci/ca0106/ca0106_main.c:682:	dev_dbg(chip->card->dev, "open:channel_id=%d, chip=%p, channel=%p\n",
./sound/pci/ca0106/ca0106_main.c:701:	chip->capture_channels[epcm->channel_id].use = 0;
./sound/pci/ca0106/ca0106_main.c:1237:	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
./sound/pci/ca0106/ca0106_main.c:1244:	return snd_ac97_mixer(pbus, &ac97, &chip->ac97);
./sound/pci/ca0106/ca0106_main.c:1251:	if (chip->res_port != NULL) {
./sound/pci/ca0106/ca0106_main.c:1255:	if (chip->irq >= 0)
./sound/pci/ca0106/ca0106_main.c:1256:		free_irq(chip->irq, chip);
./sound/pci/ca0106/ca0106_main.c:1259:	if (chip->buffer.area)
./sound/pci/ca0106/ca0106_main.c:1260:		snd_dma_free_pages(&chip->buffer);
./sound/pci/ca0106/ca0106_main.c:1264:	release_and_free_resource(chip->res_port);
./sound/pci/ca0106/ca0106_main.c:1266:	pci_disable_device(chip->pci);
./sound/pci/ca0106/ca0106_main.c:1287:	status = inl(chip->port + IPR);
./sound/pci/ca0106/ca0106_main.c:1300:		pchannel = &(chip->playback_channels[i]);
./sound/pci/ca0106/ca0106_main.c:1316:		pchannel = &(chip->capture_channels[i]);
./sound/pci/ca0106/ca0106_main.c:1333:	if (chip->midi.dev_id &&
./sound/pci/ca0106/ca0106_main.c:1334:	    (status & (chip->midi.ipr_tx|chip->midi.ipr_rx))) {
./sound/pci/ca0106/ca0106_main.c:1335:		if (chip->midi.interrupt)
./sound/pci/ca0106/ca0106_main.c:1336:			chip->midi.interrupt(&chip->midi, status);
./sound/pci/ca0106/ca0106_main.c:1338:			chip->midi.interrupt_disable(&chip->midi, chip->midi.tx_enable | chip->midi.rx_enable);
./sound/pci/ca0106/ca0106_main.c:1342:	outl(status, chip->port+IPR);
./sound/pci/ca0106/ca0106_main.c:1474:	outl(0, chip->port + INTE);
./sound/pci/ca0106/ca0106_main.c:1496:		chip->spdif_str_bits[0] = chip->spdif_bits[0] = def_bits;
./sound/pci/ca0106/ca0106_main.c:1497:		chip->spdif_str_bits[1] = chip->spdif_bits[1] = def_bits;
./sound/pci/ca0106/ca0106_main.c:1498:		chip->spdif_str_bits[2] = chip->spdif_bits[2] = def_bits;
./sound/pci/ca0106/ca0106_main.c:1499:		chip->spdif_str_bits[3] = chip->spdif_bits[3] = def_bits;
./sound/pci/ca0106/ca0106_main.c:1502:	snd_ca0106_ptr_write(chip, SPCS1, 0, chip->spdif_str_bits[1]);
./sound/pci/ca0106/ca0106_main.c:1503:	snd_ca0106_ptr_write(chip, SPCS0, 0, chip->spdif_str_bits[0]);
./sound/pci/ca0106/ca0106_main.c:1504:	snd_ca0106_ptr_write(chip, SPCS2, 0, chip->spdif_str_bits[2]);
./sound/pci/ca0106/ca0106_main.c:1505:	snd_ca0106_ptr_write(chip, SPCS3, 0, chip->spdif_str_bits[3]);
./sound/pci/ca0106/ca0106_main.c:1511:        outb(AC97_REC_GAIN, chip->port + AC97ADDRESS);
./sound/pci/ca0106/ca0106_main.c:1512:        outw(0x8000, chip->port + AC97DATA);
./sound/pci/ca0106/ca0106_main.c:1530:	chip->spdif_enable = 0; /* Set digital SPDIF output off */
./sound/pci/ca0106/ca0106_main.c:1561:	if (chip->details->i2c_adc == 1) {
./sound/pci/ca0106/ca0106_main.c:1566:			chip->capture_source = 3;
./sound/pci/ca0106/ca0106_main.c:1567:	} else if (chip->details->ac97 == 1) {
./sound/pci/ca0106/ca0106_main.c:1572:			chip->capture_source = 4;
./sound/pci/ca0106/ca0106_main.c:1578:			chip->capture_source = 3;
./sound/pci/ca0106/ca0106_main.c:1581:	if (chip->details->gpio_type == 2) {
./sound/pci/ca0106/ca0106_main.c:1586:		outl(0x0, chip->port+GPIO);
./sound/pci/ca0106/ca0106_main.c:1587:		/* outl(0x00f0e000, chip->port+GPIO); */ /* Analog */
./sound/pci/ca0106/ca0106_main.c:1588:		outl(0x005f5301, chip->port+GPIO); /* Analog */
./sound/pci/ca0106/ca0106_main.c:1589:	} else if (chip->details->gpio_type == 1) {
./sound/pci/ca0106/ca0106_main.c:1594:		outl(0x0, chip->port+GPIO);
./sound/pci/ca0106/ca0106_main.c:1595:		/* outl(0x00f0e000, chip->port+GPIO); */ /* Analog */
./sound/pci/ca0106/ca0106_main.c:1596:		outl(0x005f5301, chip->port+GPIO); /* Analog */
./sound/pci/ca0106/ca0106_main.c:1598:		outl(0x0, chip->port+GPIO);
./sound/pci/ca0106/ca0106_main.c:1599:		outl(0x005f03a3, chip->port+GPIO); /* Analog */
./sound/pci/ca0106/ca0106_main.c:1600:		/* outl(0x005f02a2, chip->port+GPIO); */ /* SPDIF */
./sound/pci/ca0106/ca0106_main.c:1604:	/* outl(HCFG_LOCKSOUNDCACHE|HCFG_AUDIOENABLE, chip->port+HCFG); */
./sound/pci/ca0106/ca0106_main.c:1606:	/* outl(0x00001409, chip->port+HCFG); */
./sound/pci/ca0106/ca0106_main.c:1607:	/* outl(0x00000009, chip->port+HCFG); */
./sound/pci/ca0106/ca0106_main.c:1609:	outl(HCFG_AC97 | HCFG_AUDIOENABLE, chip->port+HCFG);
./sound/pci/ca0106/ca0106_main.c:1611:	if (chip->details->i2c_adc == 1) {
./sound/pci/ca0106/ca0106_main.c:1621:			chip->i2c_capture_volume[n][0] = 0xcf;
./sound/pci/ca0106/ca0106_main.c:1622:			chip->i2c_capture_volume[n][1] = 0xcf;
./sound/pci/ca0106/ca0106_main.c:1624:		chip->i2c_capture_source = 2; /* Line in */
./sound/pci/ca0106/ca0106_main.c:1629:	if (chip->details->spi_dac) {
./sound/pci/ca0106/ca0106_main.c:1638:			if (reg < ARRAY_SIZE(chip->spi_dac_reg))
./sound/pci/ca0106/ca0106_main.c:1639:				chip->spi_dac_reg[reg] = spi_dac_init[n];
./sound/pci/ca0106/ca0106_main.c:1651:	outl(0, chip->port + INTE);
./sound/pci/ca0106/ca0106_main.c:1655:	/* outl(HCFG_LOCKSOUNDCACHE, chip->port + HCFG); */
./sound/pci/ca0106/ca0106_main.c:1656:	outl(0, chip->port + HCFG);
./sound/pci/ca0106/ca0106_main.c:1692:	chip->card = card;
./sound/pci/ca0106/ca0106_main.c:1693:	chip->pci = pci;
./sound/pci/ca0106/ca0106_main.c:1694:	chip->irq = -1;
./sound/pci/ca0106/ca0106_main.c:1696:	spin_lock_init(&chip->emu_lock);
./sound/pci/ca0106/ca0106_main.c:1698:	chip->port = pci_resource_start(pci, 0);
./sound/pci/ca0106/ca0106_main.c:1699:	chip->res_port = request_region(chip->port, 0x20, "snd_ca0106");
./sound/pci/ca0106/ca0106_main.c:1700:	if (!chip->res_port) {
./sound/pci/ca0106/ca0106_main.c:1712:	chip->irq = pci->irq;
./sound/pci/ca0106/ca0106_main.c:1716:				1024, &chip->buffer) < 0) {
./sound/pci/ca0106/ca0106_main.c:1723:	pci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);
./sound/pci/ca0106/ca0106_main.c:1724:	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);
./sound/pci/ca0106/ca0106_main.c:1726:	       chip->model, pci->revision, chip->serial);
./sound/pci/ca0106/ca0106_main.c:1734:		} else if (c->serial == chip->serial)
./sound/pci/ca0106/ca0106_main.c:1737:	chip->details = c;
./sound/pci/ca0106/ca0106_main.c:1741:		       c->name, chip->serial, subsystem[dev]);
./sound/pci/ca0106/ca0106_main.c:1745:		c->name, chip->port, chip->irq);
./sound/pci/ca0106/ca0106_main.c:1798:		midi =  &chip->midi2;
./sound/pci/ca0106/ca0106_main.c:1806:		midi =  &chip->midi;
./sound/pci/ca0106/ca0106_main.c:1872:	if (chip->details->ac97 == 1) {
./sound/pci/ca0106/ca0106_main.c:1919:		snd_pcm_suspend_all(chip->pcm[i]);
./sound/pci/ca0106/ca0106_main.c:1920:	if (chip->details->ac97)
./sound/pci/ca0106/ca0106_main.c:1921:		snd_ac97_suspend(chip->ac97);
./sound/pci/ca0106/ca0106_main.c:1936:	if (chip->details->ac97)
./sound/pci/ca0106/ca0106_main.c:1937:		snd_ac97_resume(chip->ac97);
./sound/pci/ca0106/ca0106_main.c:1939:	if (chip->details->spi_dac) {
./sound/pci/ca0106/ca0106_main.c:1940:		for (i = 0; i < ARRAY_SIZE(chip->spi_dac_reg); i++)
./sound/pci/ca0106/ca0106_main.c:1941:			snd_ca0106_spi_write(chip, chip->spi_dac_reg[i]);
./sound/pci/lx6464es/lx_core.c:72:	void __iomem *base_address = chip->port_dsp_bar;
./sound/pci/lx6464es/lx_core.c:129:	void __iomem *base_address = chip->port_plx_remapped;
./sound/pci/lx6464es/lx_core.c:277:		dev_err(chip->card->dev, "PIOSendMessage eReg_CSM %x\n", reg);
./sound/pci/lx6464es/lx_core.c:298:	dev_warn(chip->card->dev, "TIMEOUT lx_message_send_atomic! "
./sound/pci/lx6464es/lx_core.c:310:		dev_err(chip->card->dev, "rmh error: %08x\n", reg);
./sound/pci/lx6464es/lx_core.c:317:		dev_warn(chip->card->dev, "lx_message_send: dsp timeout\n");
./sound/pci/lx6464es/lx_core.c:321:		dev_warn(chip->card->dev, "lx_message_send: dsp crashed\n");
./sound/pci/lx6464es/lx_core.c:336:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:338:	lx_message_init(&chip->rmh, CMD_01_GET_SYS_CFG);
./sound/pci/lx6464es/lx_core.c:339:	ret = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:341:	*rdsp_version = chip->rmh.stat[1];
./sound/pci/lx6464es/lx_core.c:342:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:353:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:355:	lx_message_init(&chip->rmh, CMD_01_GET_SYS_CFG);
./sound/pci/lx6464es/lx_core.c:356:	ret = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:359:		freq_raw = chip->rmh.stat[0] >> FREQ_FIELD_OFFSET;
./sound/pci/lx6464es/lx_core.c:371:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:373:	*rfreq = frequency * chip->freq_ratio;
./sound/pci/lx6464es/lx_core.c:386:	chip->mac_address[5] = ((u8 *)(&maclsb))[0];
./sound/pci/lx6464es/lx_core.c:387:	chip->mac_address[4] = ((u8 *)(&maclsb))[1];
./sound/pci/lx6464es/lx_core.c:388:	chip->mac_address[3] = ((u8 *)(&maclsb))[2];
./sound/pci/lx6464es/lx_core.c:389:	chip->mac_address[2] = ((u8 *)(&macmsb))[0];
./sound/pci/lx6464es/lx_core.c:390:	chip->mac_address[1] = ((u8 *)(&macmsb))[1];
./sound/pci/lx6464es/lx_core.c:391:	chip->mac_address[0] = ((u8 *)(&macmsb))[2];
./sound/pci/lx6464es/lx_core.c:401:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:403:	lx_message_init(&chip->rmh, CMD_02_SET_GRANULARITY);
./sound/pci/lx6464es/lx_core.c:404:	chip->rmh.cmd[0] |= gran;
./sound/pci/lx6464es/lx_core.c:406:	ret = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:407:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:415:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:417:	lx_message_init(&chip->rmh, CMD_04_GET_EVENT);
./sound/pci/lx6464es/lx_core.c:418:	chip->rmh.stat_len = 9;	/* we don't necessarily need the full length */
./sound/pci/lx6464es/lx_core.c:420:	ret = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:423:		memcpy(data, chip->rmh.stat, chip->rmh.stat_len * sizeof(u32));
./sound/pci/lx6464es/lx_core.c:425:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:441:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:442:	lx_message_init(&chip->rmh, CMD_06_ALLOCATE_PIPE);
./sound/pci/lx6464es/lx_core.c:444:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:445:	chip->rmh.cmd[0] |= channels;
./sound/pci/lx6464es/lx_core.c:447:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:448:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:451:		dev_err(chip->card->dev, "could not allocate pipe\n");
./sound/pci/lx6464es/lx_core.c:461:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:462:	lx_message_init(&chip->rmh, CMD_07_RELEASE_PIPE);
./sound/pci/lx6464es/lx_core.c:464:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:466:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:467:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:486:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:487:	lx_message_init(&chip->rmh, CMD_08_ASK_BUFFERS);
./sound/pci/lx6464es/lx_core.c:489:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:491:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:496:			u32 stat = chip->rmh.stat[i];
./sound/pci/lx6464es/lx_core.c:508:		dev_dbg(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:512:			for (i = 0; i != chip->rmh.stat_len; ++i)
./sound/pci/lx6464es/lx_core.c:513:				dev_dbg(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:515:					    chip->rmh.stat[i],
./sound/pci/lx6464es/lx_core.c:516:					    chip->rmh.stat[i] & MASK_DATA_SIZE);
./sound/pci/lx6464es/lx_core.c:520:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:530:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:531:	lx_message_init(&chip->rmh, CMD_09_STOP_PIPE);
./sound/pci/lx6464es/lx_core.c:533:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:535:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:537:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:546:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:547:	lx_message_init(&chip->rmh, CMD_0B_TOGGLE_PIPE_STATE);
./sound/pci/lx6464es/lx_core.c:549:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:551:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:553:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:591:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:592:	lx_message_init(&chip->rmh, CMD_0A_GET_PIPE_SPL_COUNT);
./sound/pci/lx6464es/lx_core.c:594:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:595:	chip->rmh.stat_len = 2;	/* need all words here! */
./sound/pci/lx6464es/lx_core.c:597:	err = lx_message_send_atomic(chip, &chip->rmh); /* don't sleep! */
./sound/pci/lx6464es/lx_core.c:600:		dev_err(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:603:		*rsample_count = ((u64)(chip->rmh.stat[0] & MASK_SPL_COUNT_HI)
./sound/pci/lx6464es/lx_core.c:605:			+ chip->rmh.stat[1]; /* lo part */
./sound/pci/lx6464es/lx_core.c:608:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:617:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:618:	lx_message_init(&chip->rmh, CMD_0A_GET_PIPE_SPL_COUNT);
./sound/pci/lx6464es/lx_core.c:620:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:622:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:625:		dev_err(chip->card->dev, "could not query pipe's state\n");
./sound/pci/lx6464es/lx_core.c:627:		*rstate = (chip->rmh.stat[0] >> PSTATE_OFFSET) & 0x0F;
./sound/pci/lx6464es/lx_core.c:629:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:673:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:674:	lx_message_init(&chip->rmh, CMD_13_SET_STREAM_STATE);
./sound/pci/lx6464es/lx_core.c:676:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:677:	chip->rmh.cmd[0] |= state;
./sound/pci/lx6464es/lx_core.c:679:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:680:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:693:		dev_err(chip->card->dev, "channel count mismatch: %d vs %d",
./sound/pci/lx6464es/lx_core.c:696:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:697:	lx_message_init(&chip->rmh, CMD_0C_DEF_STREAM);
./sound/pci/lx6464es/lx_core.c:699:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:703:		chip->rmh.cmd[0] |= (STREAM_FMT_16b << STREAM_FMT_OFFSET);
./sound/pci/lx6464es/lx_core.c:707:		chip->rmh.cmd[0] |= (STREAM_FMT_intel << STREAM_FMT_OFFSET);
./sound/pci/lx6464es/lx_core.c:709:	chip->rmh.cmd[0] |= channels-1;
./sound/pci/lx6464es/lx_core.c:711:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:712:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:723:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:724:	lx_message_init(&chip->rmh, CMD_0E_GET_STREAM_SPL_COUNT);
./sound/pci/lx6464es/lx_core.c:726:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:728:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:730:	*rstate = (chip->rmh.stat[0] & SF_START) ? START_STATE : PAUSE_STATE;
./sound/pci/lx6464es/lx_core.c:732:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:742:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:743:	lx_message_init(&chip->rmh, CMD_0E_GET_STREAM_SPL_COUNT);
./sound/pci/lx6464es/lx_core.c:745:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:747:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:749:	*r_bytepos = ((u64) (chip->rmh.stat[0] & MASK_SPL_COUNT_HI)
./sound/pci/lx6464es/lx_core.c:751:		+ chip->rmh.stat[1]; /* lo part */
./sound/pci/lx6464es/lx_core.c:753:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:765:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:766:	lx_message_init(&chip->rmh, CMD_0F_UPDATE_BUFFER);
./sound/pci/lx6464es/lx_core.c:768:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:769:	chip->rmh.cmd[0] |= BF_NOTIFY_EOB; /* request interrupt notification */
./sound/pci/lx6464es/lx_core.c:773:	chip->rmh.cmd[1] = buffer_size & MASK_DATA_SIZE;
./sound/pci/lx6464es/lx_core.c:774:	chip->rmh.cmd[2] = buf_address_lo;
./sound/pci/lx6464es/lx_core.c:777:		chip->rmh.cmd_len = 4;
./sound/pci/lx6464es/lx_core.c:778:		chip->rmh.cmd[3] = buf_address_hi;
./sound/pci/lx6464es/lx_core.c:779:		chip->rmh.cmd[0] |= BF_64BITS_ADR;
./sound/pci/lx6464es/lx_core.c:782:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:785:		*r_buffer_index = chip->rmh.stat[0];
./sound/pci/lx6464es/lx_core.c:790:		dev_err(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:794:		dev_err(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:798:		dev_err(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:802:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:812:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:813:	lx_message_init(&chip->rmh, CMD_11_CANCEL_BUFFER);
./sound/pci/lx6464es/lx_core.c:815:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:816:	chip->rmh.cmd[0] |= MASK_BUFFER_ID; /* ask for the current buffer: the
./sound/pci/lx6464es/lx_core.c:819:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:822:		*r_buffer_size = chip->rmh.stat[0]  & MASK_DATA_SIZE;
./sound/pci/lx6464es/lx_core.c:824:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:834:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:835:	lx_message_init(&chip->rmh, CMD_11_CANCEL_BUFFER);
./sound/pci/lx6464es/lx_core.c:837:	chip->rmh.cmd[0] |= pipe_cmd;
./sound/pci/lx6464es/lx_core.c:838:	chip->rmh.cmd[0] |= buffer_index;
./sound/pci/lx6464es/lx_core.c:840:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:842:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:858:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:859:	lx_message_init(&chip->rmh, CMD_0D_SET_MUTE);
./sound/pci/lx6464es/lx_core.c:861:	chip->rmh.cmd[0] |= PIPE_INFO_TO_CMD(is_capture, 0);
./sound/pci/lx6464es/lx_core.c:863:	chip->rmh.cmd[1] = (u32)(mute_mask >> (u64)32);	       /* hi part */
./sound/pci/lx6464es/lx_core.c:864:	chip->rmh.cmd[2] = (u32)(mute_mask & (u64)0xFFFFFFFF); /* lo part */
./sound/pci/lx6464es/lx_core.c:866:	dev_dbg(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:867:		"mute %x %x %x\n", chip->rmh.cmd[0], chip->rmh.cmd[1],
./sound/pci/lx6464es/lx_core.c:868:		   chip->rmh.cmd[2]);
./sound/pci/lx6464es/lx_core.c:870:	err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:872:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:901:	mutex_lock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:905:		lx_message_init(&chip->rmh, CMD_12_GET_PEAK);
./sound/pci/lx6464es/lx_core.c:906:		chip->rmh.cmd[0] |= PIPE_INFO_TO_CMD(is_capture, i);
./sound/pci/lx6464es/lx_core.c:908:		err = lx_message_send_atomic(chip, &chip->rmh);
./sound/pci/lx6464es/lx_core.c:911:			s0 = peak_map[chip->rmh.stat[0] & 0x0F];
./sound/pci/lx6464es/lx_core.c:912:			s1 = peak_map[(chip->rmh.stat[0] >>  4) & 0xf];
./sound/pci/lx6464es/lx_core.c:913:			s2 = peak_map[(chip->rmh.stat[0] >>  8) & 0xf];
./sound/pci/lx6464es/lx_core.c:914:			s3 = peak_map[(chip->rmh.stat[0] >>  12) & 0xf];
./sound/pci/lx6464es/lx_core.c:926:	mutex_unlock(&chip->msg_lock);
./sound/pci/lx6464es/lx_core.c:976:		/* dev_dbg(chip->card->dev, "interrupt: async event pending\n"); */
./sound/pci/lx6464es/lx_core.c:1018:		dev_dbg(chip->card->dev, "interrupt: EOBI pending %llx\n",
./sound/pci/lx6464es/lx_core.c:1024:		dev_dbg(chip->card->dev, "interrupt: EOBO pending %llx\n",
./sound/pci/lx6464es/lx_core.c:1059:	dev_dbg(chip->card->dev, "->lx_interrupt_request_new_buffer\n");
./sound/pci/lx6464es/lx_core.c:1061:	mutex_lock(&chip->lock);
./sound/pci/lx6464es/lx_core.c:1064:	dev_dbg(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:1070:	dev_dbg(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:1075:	mutex_unlock(&chip->lock);
./sound/pci/lx6464es/lx_core.c:1087:	dev_dbg(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:1091:		dev_dbg(chip->card->dev, "IRQ_NONE\n");
./sound/pci/lx6464es/lx_core.c:1099:		dev_dbg(chip->card->dev, "interrupt: EOBI\n");
./sound/pci/lx6464es/lx_core.c:1102:		dev_dbg(chip->card->dev, "interrupt: EOBO\n");
./sound/pci/lx6464es/lx_core.c:1105:		dev_dbg(chip->card->dev, "interrupt: URUN\n");
./sound/pci/lx6464es/lx_core.c:1108:		dev_dbg(chip->card->dev, "interrupt: ORUN\n");
./sound/pci/lx6464es/lx_core.c:1112:		chip->irqsrc = irqsrc;
./sound/pci/lx6464es/lx_core.c:1122:		dev_dbg(chip->card->dev, "interrupt requests escmd handling\n");
./sound/pci/lx6464es/lx_core.c:1137:	err = lx_interrupt_handle_async_events(chip, chip->irqsrc,
./sound/pci/lx6464es/lx_core.c:1142:		dev_err(chip->card->dev, "error handling async events\n");
./sound/pci/lx6464es/lx_core.c:1145:		struct lx_stream *lx_stream = &chip->capture_stream;
./sound/pci/lx6464es/lx_core.c:1147:		dev_dbg(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:1151:			dev_err(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:1157:		struct lx_stream *lx_stream = &chip->playback_stream;
./sound/pci/lx6464es/lx_core.c:1159:		dev_dbg(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:1163:			dev_err(chip->card->dev,
./sound/pci/lx6464es/lx_core.c:1190:	dev_dbg(chip->card->dev, "->lx_irq_enable\n");
./sound/pci/lx6464es/lx_core.c:1196:	dev_dbg(chip->card->dev, "->lx_irq_disable\n");
./sound/pci/lx6464es/lx6464es.c:115:	dev_dbg(chip->card->dev, "allocating pipe for %d channels\n", channels);
./sound/pci/lx6464es/lx6464es.c:118:		dev_err(chip->card->dev, LXP "allocating pipe failed\n");
./sound/pci/lx6464es/lx6464es.c:124:		dev_err(chip->card->dev, "setting granularity to %ld failed\n",
./sound/pci/lx6464es/lx6464es.c:139:	dev_dbg(chip->card->dev, "setting stream format\n");
./sound/pci/lx6464es/lx6464es.c:142:		dev_err(chip->card->dev, "setting stream format failed\n");
./sound/pci/lx6464es/lx6464es.c:146:	dev_dbg(chip->card->dev, "starting pipe\n");
./sound/pci/lx6464es/lx6464es.c:149:		dev_err(chip->card->dev, "starting pipe failed\n");
./sound/pci/lx6464es/lx6464es.c:153:	dev_dbg(chip->card->dev, "waiting for pipe to start\n");
./sound/pci/lx6464es/lx6464es.c:156:		dev_err(chip->card->dev, "waiting for pipe failed\n");
./sound/pci/lx6464es/lx6464es.c:170:	dev_dbg(chip->card->dev, "pausing pipe\n");
./sound/pci/lx6464es/lx6464es.c:173:		dev_err(chip->card->dev, "pausing pipe failed\n");
./sound/pci/lx6464es/lx6464es.c:177:	dev_dbg(chip->card->dev, "waiting for pipe to become idle\n");
./sound/pci/lx6464es/lx6464es.c:180:		dev_err(chip->card->dev, "waiting for pipe failed\n");
./sound/pci/lx6464es/lx6464es.c:184:	dev_dbg(chip->card->dev, "stopping pipe\n");
./sound/pci/lx6464es/lx6464es.c:187:		dev_err(chip->card->dev, "stopping pipe failed\n");
./sound/pci/lx6464es/lx6464es.c:201:	dev_dbg(chip->card->dev, "releasing pipe\n");
./sound/pci/lx6464es/lx6464es.c:204:		dev_err(chip->card->dev, "releasing pipe failed\n");
./sound/pci/lx6464es/lx6464es.c:219:	dev_dbg(chip->card->dev, "->lx_pcm_open\n");
./sound/pci/lx6464es/lx6464es.c:220:	mutex_lock(&chip->setup_mutex);
./sound/pci/lx6464es/lx6464es.c:230:		dev_warn(chip->card->dev, "could not constrain periods\n");
./sound/pci/lx6464es/lx6464es.c:236:	board_rate = chip->board_sample_rate;
./sound/pci/lx6464es/lx6464es.c:241:		dev_warn(chip->card->dev, "could not constrain periods\n");
./sound/pci/lx6464es/lx6464es.c:251:		dev_warn(chip->card->dev,
./sound/pci/lx6464es/lx6464es.c:265:	mutex_unlock(&chip->setup_mutex);
./sound/pci/lx6464es/lx6464es.c:266:	dev_dbg(chip->card->dev, "<-lx_pcm_open, %d\n", err);
./sound/pci/lx6464es/lx6464es.c:284:	struct lx_stream *lx_stream = is_capture ? &chip->capture_stream :
./sound/pci/lx6464es/lx6464es.c:285:		&chip->playback_stream;
./sound/pci/lx6464es/lx6464es.c:287:	dev_dbg(chip->card->dev, "->lx_pcm_stream_pointer\n");
./sound/pci/lx6464es/lx6464es.c:289:	mutex_lock(&chip->lock);
./sound/pci/lx6464es/lx6464es.c:291:	mutex_unlock(&chip->lock);
./sound/pci/lx6464es/lx6464es.c:293:	dev_dbg(chip->card->dev, "stream_pointer at %ld\n", pos);
./sound/pci/lx6464es/lx6464es.c:303:	dev_dbg(chip->card->dev, "->lx_pcm_prepare\n");
./sound/pci/lx6464es/lx6464es.c:305:	mutex_lock(&chip->setup_mutex);
./sound/pci/lx6464es/lx6464es.c:307:	if (chip->hardware_running[is_capture]) {
./sound/pci/lx6464es/lx6464es.c:310:			dev_err(chip->card->dev, "failed to stop hardware. "
./sound/pci/lx6464es/lx6464es.c:317:			dev_err(chip->card->dev, "failed to close hardware. "
./sound/pci/lx6464es/lx6464es.c:323:	dev_dbg(chip->card->dev, "opening hardware\n");
./sound/pci/lx6464es/lx6464es.c:326:		dev_err(chip->card->dev, "failed to open hardware. "
./sound/pci/lx6464es/lx6464es.c:333:		dev_err(chip->card->dev, "failed to start hardware. "
./sound/pci/lx6464es/lx6464es.c:338:	chip->hardware_running[is_capture] = 1;
./sound/pci/lx6464es/lx6464es.c:340:	if (chip->board_sample_rate != substream->runtime->rate) {
./sound/pci/lx6464es/lx6464es.c:342:			chip->board_sample_rate = substream->runtime->rate;
./sound/pci/lx6464es/lx6464es.c:346:	mutex_unlock(&chip->setup_mutex);
./sound/pci/lx6464es/lx6464es.c:356:	dev_dbg(chip->card->dev, "->lx_pcm_hw_params\n");
./sound/pci/lx6464es/lx6464es.c:358:	mutex_lock(&chip->setup_mutex);
./sound/pci/lx6464es/lx6464es.c:365:		chip->capture_stream.stream = substream;
./sound/pci/lx6464es/lx6464es.c:367:		chip->playback_stream.stream = substream;
./sound/pci/lx6464es/lx6464es.c:369:	mutex_unlock(&chip->setup_mutex);
./sound/pci/lx6464es/lx6464es.c:391:	dev_dbg(chip->card->dev, "->lx_pcm_hw_free\n");
./sound/pci/lx6464es/lx6464es.c:392:	mutex_lock(&chip->setup_mutex);
./sound/pci/lx6464es/lx6464es.c:394:	if (chip->hardware_running[is_capture]) {
./sound/pci/lx6464es/lx6464es.c:397:			dev_err(chip->card->dev, "failed to stop hardware. "
./sound/pci/lx6464es/lx6464es.c:404:			dev_err(chip->card->dev, "failed to close hardware. "
./sound/pci/lx6464es/lx6464es.c:409:		chip->hardware_running[is_capture] = 0;
./sound/pci/lx6464es/lx6464es.c:415:		chip->capture_stream.stream = NULL;
./sound/pci/lx6464es/lx6464es.c:417:		chip->playback_stream.stream = NULL;
./sound/pci/lx6464es/lx6464es.c:420:	mutex_unlock(&chip->setup_mutex);
./sound/pci/lx6464es/lx6464es.c:448:		dev_dbg(chip->card->dev, "starting: needed %d, freed %d\n",
./sound/pci/lx6464es/lx6464es.c:455:		dev_dbg(chip->card->dev, "starting: buffer index %x on 0x%lx (%d bytes)\n",
./sound/pci/lx6464es/lx6464es.c:461:	dev_dbg(chip->card->dev, "starting: needed %d, freed %d\n", needed, freed);
./sound/pci/lx6464es/lx6464es.c:463:	dev_dbg(chip->card->dev, "starting: starting stream\n");
./sound/pci/lx6464es/lx6464es.c:466:		dev_err(chip->card->dev, "couldn't start stream\n");
./sound/pci/lx6464es/lx6464es.c:478:	dev_dbg(chip->card->dev, "stopping: stopping stream\n");
./sound/pci/lx6464es/lx6464es.c:481:		dev_err(chip->card->dev, "couldn't stop stream\n");
./sound/pci/lx6464es/lx6464es.c:509:	mutex_lock(&chip->lock);
./sound/pci/lx6464es/lx6464es.c:524:	lx_trigger_dispatch_stream(chip, &chip->capture_stream);
./sound/pci/lx6464es/lx6464es.c:525:	lx_trigger_dispatch_stream(chip, &chip->playback_stream);
./sound/pci/lx6464es/lx6464es.c:528:	mutex_unlock(&chip->lock);
./sound/pci/lx6464es/lx6464es.c:537:	struct lx_stream *stream = is_capture ? &chip->capture_stream :
./sound/pci/lx6464es/lx6464es.c:538:		&chip->playback_stream;
./sound/pci/lx6464es/lx6464es.c:540:	dev_dbg(chip->card->dev, "->lx_pcm_trigger\n");
./sound/pci/lx6464es/lx6464es.c:547:	dev_dbg(chip->card->dev, "->snd_lx6464es_free\n");
./sound/pci/lx6464es/lx6464es.c:551:	if (chip->irq >= 0)
./sound/pci/lx6464es/lx6464es.c:552:		free_irq(chip->irq, chip);
./sound/pci/lx6464es/lx6464es.c:554:	iounmap(chip->port_dsp_bar);
./sound/pci/lx6464es/lx6464es.c:555:	ioport_unmap(chip->port_plx_remapped);
./sound/pci/lx6464es/lx6464es.c:557:	pci_release_regions(chip->pci);
./sound/pci/lx6464es/lx6464es.c:558:	pci_disable_device(chip->pci);
./sound/pci/lx6464es/lx6464es.c:576:	dev_dbg(chip->card->dev, "->lx_init_xilinx_reset\n");
./sound/pci/lx6464es/lx6464es.c:596:			dev_dbg(chip->card->dev, "xilinx reset done\n");
./sound/pci/lx6464es/lx6464es.c:597:			dev_dbg(chip->card->dev, "xilinx took %d loops\n", i);
./sound/pci/lx6464es/lx6464es.c:617:	dev_dbg(chip->card->dev, "->lx_init_xilinx_test\n");
./sound/pci/lx6464es/lx6464es.c:625:		dev_err(chip->card->dev, "Problem: Reg_CSM %x.\n", reg);
./sound/pci/lx6464es/lx6464es.c:632:			dev_err(chip->card->dev, "Error: Reg_CSM %x.\n", reg);
./sound/pci/lx6464es/lx6464es.c:637:	dev_dbg(chip->card->dev, "Xilinx/MicroBlaze access test successful\n");
./sound/pci/lx6464es/lx6464es.c:654:	dev_dbg(chip->card->dev, "->lx_init_ethersound\n");
./sound/pci/lx6464es/lx6464es.c:656:	chip->freq_ratio = FREQ_RATIO_SINGLE_MODE;
./sound/pci/lx6464es/lx6464es.c:668:			dev_dbg(chip->card->dev, "ethersound initialized after %dms\n",
./sound/pci/lx6464es/lx6464es.c:674:	dev_warn(chip->card->dev,
./sound/pci/lx6464es/lx6464es.c:679:	dev_dbg(chip->card->dev, "ethersound initialized\n");
./sound/pci/lx6464es/lx6464es.c:689:	dev_dbg(chip->card->dev, "->lx_init_get_version_features\n");
./sound/pci/lx6464es/lx6464es.c:696:		dev_info(chip->card->dev, "DSP version: V%02d.%02d #%d\n",
./sound/pci/lx6464es/lx6464es.c:710:			chip->board_sample_rate = freq;
./sound/pci/lx6464es/lx6464es.c:711:		dev_dbg(chip->card->dev, "actual clock frequency %d\n", freq);
./sound/pci/lx6464es/lx6464es.c:713:		dev_err(chip->card->dev, "DSP corrupted \n");
./sound/pci/lx6464es/lx6464es.c:725:	dev_dbg(chip->card->dev, "->lx_set_granularity\n");
./sound/pci/lx6464es/lx6464es.c:733:	if (snapped_gran == chip->pcm_granularity)
./sound/pci/lx6464es/lx6464es.c:738:		dev_warn(chip->card->dev, "could not set granularity\n");
./sound/pci/lx6464es/lx6464es.c:743:		dev_err(chip->card->dev, "snapped blocksize to %d\n", snapped_gran);
./sound/pci/lx6464es/lx6464es.c:745:	dev_dbg(chip->card->dev, "set blocksize on board %d\n", snapped_gran);
./sound/pci/lx6464es/lx6464es.c:746:	chip->pcm_granularity = snapped_gran;
./sound/pci/lx6464es/lx6464es.c:757:	dev_dbg(chip->card->dev, "->lx_init_dsp\n");
./sound/pci/lx6464es/lx6464es.c:759:	dev_dbg(chip->card->dev, "initialize board\n");
./sound/pci/lx6464es/lx6464es.c:764:	dev_dbg(chip->card->dev, "testing board\n");
./sound/pci/lx6464es/lx6464es.c:769:	dev_dbg(chip->card->dev, "initialize ethersound configuration\n");
./sound/pci/lx6464es/lx6464es.c:782:		if (chip->mac_address[0] || chip->mac_address[1] || chip->mac_address[2] ||
./sound/pci/lx6464es/lx6464es.c:783:		    chip->mac_address[3] || chip->mac_address[4] || chip->mac_address[5])
./sound/pci/lx6464es/lx6464es.c:790:	dev_dbg(chip->card->dev, "mac address ready read after: %dms\n", i);
./sound/pci/lx6464es/lx6464es.c:791:	dev_info(chip->card->dev,
./sound/pci/lx6464es/lx6464es.c:793:		   chip->mac_address[0], chip->mac_address[1], chip->mac_address[2],
./sound/pci/lx6464es/lx6464es.c:794:		   chip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);
./sound/pci/lx6464es/lx6464es.c:802:	chip->playback_mute = 0;
./sound/pci/lx6464es/lx6464es.c:843:	err = snd_pcm_new(chip->card, (char *)card_name, 0,
./sound/pci/lx6464es/lx6464es.c:858:						    snd_dma_pci_data(chip->pci),
./sound/pci/lx6464es/lx6464es.c:863:	chip->pcm = pcm;
./sound/pci/lx6464es/lx6464es.c:864:	chip->capture_stream.is_capture = 1;
./sound/pci/lx6464es/lx6464es.c:883:	ucontrol->value.integer.value[0] = chip->playback_mute;
./sound/pci/lx6464es/lx6464es.c:892:	int current_value = chip->playback_mute;
./sound/pci/lx6464es/lx6464es.c:896:		chip->playback_mute = !current_value;
./sound/pci/lx6464es/lx6464es.c:998:	chip->card = card;
./sound/pci/lx6464es/lx6464es.c:999:	chip->pci = pci;
./sound/pci/lx6464es/lx6464es.c:1000:	chip->irq = -1;
./sound/pci/lx6464es/lx6464es.c:1003:	mutex_init(&chip->lock);
./sound/pci/lx6464es/lx6464es.c:1004:	mutex_init(&chip->msg_lock);
./sound/pci/lx6464es/lx6464es.c:1005:	mutex_init(&chip->setup_mutex);
./sound/pci/lx6464es/lx6464es.c:1013:	chip->port_plx = pci_resource_start(pci, 1);
./sound/pci/lx6464es/lx6464es.c:1014:	chip->port_plx_remapped = ioport_map(chip->port_plx,
./sound/pci/lx6464es/lx6464es.c:1018:	chip->port_dsp_bar = pci_ioremap_bar(pci, 2);
./sound/pci/lx6464es/lx6464es.c:1026:	chip->irq = pci->irq;
./sound/pci/lx6464es/lx6464es.c:1099:		chip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);
./sound/pci/lx6464es/lx6464es.c:1102:		chip->mac_address[0], chip->mac_address[1], chip->mac_address[2],
./sound/pci/lx6464es/lx6464es.c:1103:		chip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);
./sound/pci/lx6464es/lx6464es.c:1106:		card->shortname, chip->port_plx,
./sound/pci/lx6464es/lx6464es.c:1107:		chip->port_dsp_bar, chip->irq);
./sound/pci/lx6464es/lx6464es.c:1113:	dev_dbg(chip->card->dev, "initialization successful\n");
./sound/pci/mixart/mixart.c:238:			pipe = &(chip->pipe_in_ana);  /* analog inputs */
./sound/pci/mixart/mixart.c:240:			pipe = &(chip->pipe_in_dig); /* digital inputs */
./sound/pci/mixart/mixart.c:246:			pipe = &(chip->pipe_out_ana);  /* analog outputs */
./sound/pci/mixart/mixart.c:248:			pipe = &(chip->pipe_out_dig);  /* digital outputs */
./sound/pci/mixart/mixart.c:267:		dev_dbg(chip->card->dev,
./sound/pci/mixart/mixart.c:269:			chip->chip_idx, pcm_number);
./sound/pci/mixart/mixart.c:297:			j = (chip->chip_idx * MIXART_MAX_STREAM_PER_CARD) + (pcm_number * (MIXART_PLAYBACK_STREAMS + MIXART_CAPTURE_STREAMS)) + i;
./sound/pci/mixart/mixart.c:302:			flowinfo = (struct mixart_flowinfo *)chip->mgr->flowinfo.area;
./sound/pci/mixart/mixart.c:303:			flowinfo[j].bufferinfo_array_phy_address = (u32)chip->mgr->bufferinfo.addr + (j * sizeof(struct mixart_bufferinfo));
./sound/pci/mixart/mixart.c:306:			bufferinfo = (struct mixart_bufferinfo *)chip->mgr->bufferinfo.area;
./sound/pci/mixart/mixart.c:311:			bufferinfo[j].buffer_id = (chip->chip_idx << MIXART_NOTIFY_CARD_OFFSET) + (pcm_number << MIXART_NOTIFY_PCM_OFFSET ) + i;
./sound/pci/mixart/mixart.c:317:		err = snd_mixart_send_msg(chip->mgr, &request, sizeof(buf->sgroup_resp), &buf->sgroup_resp);
./sound/pci/mixart/mixart.c:319:			dev_err(chip->card->dev,
./sound/pci/mixart/mixart.c:422:	return snd_mixart_send_msg_nonblock(chip->mgr, &request);
./sound/pci/mixart/mixart.c:497:	dev_dbg(chip->card->dev, "snd_mixart_prepare\n");
./sound/pci/mixart/mixart.c:499:	mixart_sync_nonblock_events(chip->mgr);
./sound/pci/mixart/mixart.c:503:	if(chip->mgr->ref_count_rate == 1)
./sound/pci/mixart/mixart.c:504:		chip->mgr->sample_rate = subs->runtime->rate;
./sound/pci/mixart/mixart.c:508:		if( mixart_set_clock(chip->mgr, stream->pipe, subs->runtime->rate) )
./sound/pci/mixart/mixart.c:531:	stream_param.sampling_freq = chip->mgr->sample_rate;
./sound/pci/mixart/mixart.c:565:		dev_err(chip->card->dev,
./sound/pci/mixart/mixart.c:570:	dev_dbg(chip->card->dev,
./sound/pci/mixart/mixart.c:589:	err = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);
./sound/pci/mixart/mixart.c:591:		dev_err(chip->card->dev,
./sound/pci/mixart/mixart.c:607:	struct mixart_mgr *mgr = chip->mgr;
./sound/pci/mixart/mixart.c:644:		int i = (chip->chip_idx * MIXART_MAX_STREAM_PER_CARD) + (stream->pcm_number * (MIXART_PLAYBACK_STREAMS+MIXART_CAPTURE_STREAMS)) + subs->number;
./sound/pci/mixart/mixart.c:649:		bufferinfo = (struct mixart_bufferinfo *)chip->mgr->bufferinfo.area;
./sound/pci/mixart/mixart.c:654:		dev_dbg(chip->card->dev,
./sound/pci/mixart/mixart.c:669:	mixart_sync_nonblock_events(chip->mgr);
./sound/pci/mixart/mixart.c:724:	struct mixart_mgr        *mgr = chip->mgr;
./sound/pci/mixart/mixart.c:734:	if ( pcm == chip->pcm ) {
./sound/pci/mixart/mixart.c:738:		snd_BUG_ON(pcm != chip->pcm_dig);
./sound/pci/mixart/mixart.c:742:	dev_dbg(chip->card->dev,
./sound/pci/mixart/mixart.c:744:		chip->chip_idx, pcm_number, subs->number);
./sound/pci/mixart/mixart.c:747:	stream = &(chip->playback_stream[pcm_number][subs->number]);
./sound/pci/mixart/mixart.c:751:		dev_err(chip->card->dev,
./sound/pci/mixart/mixart.c:753:			chip->chip_idx, pcm_number, subs->number);
./sound/pci/mixart/mixart.c:767:	err = mixart_set_pipe_state(chip->mgr, pipe, 1);
./sound/pci/mixart/mixart.c:769:		dev_err(chip->card->dev, "error starting pipe!\n");
./sound/pci/mixart/mixart.c:770:		snd_mixart_kill_ref_pipe(chip->mgr, pipe, 0);
./sound/pci/mixart/mixart.c:803:	struct mixart_mgr        *mgr = chip->mgr;
./sound/pci/mixart/mixart.c:813:	if ( pcm == chip->pcm ) {
./sound/pci/mixart/mixart.c:817:		snd_BUG_ON(pcm != chip->pcm_dig);
./sound/pci/mixart/mixart.c:824:	dev_dbg(chip->card->dev, "snd_mixart_capture_open C%d/P%d/Sub%d\n",
./sound/pci/mixart/mixart.c:825:		chip->chip_idx, pcm_number, subs->number);
./sound/pci/mixart/mixart.c:828:	stream = &(chip->capture_stream[pcm_number]);
./sound/pci/mixart/mixart.c:832:		dev_err(chip->card->dev,
./sound/pci/mixart/mixart.c:834:			chip->chip_idx, pcm_number, subs->number);
./sound/pci/mixart/mixart.c:848:	err = mixart_set_pipe_state(chip->mgr, pipe, 1);
./sound/pci/mixart/mixart.c:850:		dev_err(chip->card->dev, "error starting pipe!\n");
./sound/pci/mixart/mixart.c:851:		snd_mixart_kill_ref_pipe(chip->mgr, pipe, 0);
./sound/pci/mixart/mixart.c:885:	struct mixart_mgr *mgr = chip->mgr;
./sound/pci/mixart/mixart.c:890:	dev_dbg(chip->card->dev, "snd_mixart_close C%d/P%d/Sub%d\n",
./sound/pci/mixart/mixart.c:891:		chip->chip_idx, stream->pcm_number, subs->number);
./sound/pci/mixart/mixart.c:901:		dev_err(chip->card->dev,
./sound/pci/mixart/mixart.c:903:			chip->chip_idx, stream->pcm_number);
./sound/pci/mixart/mixart.c:959:				(chip->chip_idx + 1) << 24;
./sound/pci/mixart/mixart.c:963:					      snd_dma_pci_data(chip->mgr->pci), 32*1024, 32*1024);
./sound/pci/mixart/mixart.c:974:	sprintf(name, "miXart analog %d", chip->chip_idx);
./sound/pci/mixart/mixart.c:975:	if ((err = snd_pcm_new(chip->card, name, MIXART_PCM_ANALOG,
./sound/pci/mixart/mixart.c:978:		dev_err(chip->card->dev,
./sound/pci/mixart/mixart.c:979:			"cannot create the analog pcm %d\n", chip->chip_idx);
./sound/pci/mixart/mixart.c:994:	chip->pcm = pcm;
./sound/pci/mixart/mixart.c:1007:	sprintf(name, "miXart AES/EBU %d", chip->chip_idx);
./sound/pci/mixart/mixart.c:1008:	if ((err = snd_pcm_new(chip->card, name, MIXART_PCM_DIGITAL,
./sound/pci/mixart/mixart.c:1011:		dev_err(chip->card->dev,
./sound/pci/mixart/mixart.c:1012:			"cannot create the digital pcm %d\n", chip->chip_idx);
./sound/pci/mixart/mixart.c:1027:	chip->pcm_dig = pcm;
./sound/pci/mixart/mixart.c:1060:	chip->card = card;
./sound/pci/mixart/mixart.c:1061:	chip->chip_idx = idx;
./sound/pci/mixart/mixart.c:1062:	chip->mgr = mgr;
./sound/pci/mixart/mixart.c:1081:	if(chip->mgr->board_type == MIXART_DAUGHTER_TYPE_AES) {
./sound/pci/mixart/mixart.c:1189:	snd_iprintf(buffer, "Digigram miXart (alsa card %d)\n\n", chip->chip_idx);
./sound/pci/mixart/mixart.c:1192:	if (chip->mgr->dsp_loaded & ( 1 << MIXART_MOTHERBOARD_ELF_INDEX)) {
./sound/pci/mixart/mixart.c:1194:		switch (chip->mgr->board_type ) {
./sound/pci/mixart/mixart.c:1205:		ref = readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_SYSTEM_LOAD_OFFSET));
./sound/pci/mixart/mixart.c:1208:			u32 mailbox   = 100 * readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_MAILBX_LOAD_OFFSET)) / ref;
./sound/pci/mixart/mixart.c:1209:			u32 streaming = 100 * readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_STREAM_LOAD_OFFSET)) / ref;
./sound/pci/mixart/mixart.c:1210:			u32 interr    = 100 * readl_be( MIXART_MEM( chip->mgr, MIXART_PSEUDOREG_PERF_INTERR_LOAD_OFFSET)) / ref;
./sound/pci/mixart/mixart.c:1224:	if (! snd_card_proc_new(chip->card, "board_info", &entry)) {
./sound/pci/mixart/mixart.c:1229:	if (! snd_card_proc_new(chip->card, "mixart_BA0", &entry)) {
./sound/pci/mixart/mixart.c:1231:		entry->private_data = chip->mgr;	
./sound/pci/mixart/mixart.c:1235:	if (! snd_card_proc_new(chip->card, "mixart_BA1", &entry)) {
./sound/pci/mixart/mixart.c:1237:		entry->private_data = chip->mgr;
./sound/pci/mixart/mixart_mixer.c:315:			io_level.level[i].analog_level = mixart_analog_level[chip->analog_capture_volume[i]];
./sound/pci/mixart/mixart_mixer.c:317:			if(chip->analog_playback_active[i])
./sound/pci/mixart/mixart_mixer.c:318:				io_level.level[i].analog_level = mixart_analog_level[chip->analog_playback_volume[i]];
./sound/pci/mixart/mixart_mixer.c:324:	if(is_capture)	request.uid = chip->uid_in_analog_physio;
./sound/pci/mixart/mixart_mixer.c:325:	else		request.uid = chip->uid_out_analog_physio;
./sound/pci/mixart/mixart_mixer.c:330:	err = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);
./sound/pci/mixart/mixart_mixer.c:332:		dev_dbg(chip->card->dev,
./sound/pci/mixart/mixart_mixer.c:334:			chip->chip_idx, is_capture, resp.error_code);
./sound/pci/mixart/mixart_mixer.c:360:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:362:		ucontrol->value.integer.value[0] = chip->analog_playback_volume[0];
./sound/pci/mixart/mixart_mixer.c:363:		ucontrol->value.integer.value[1] = chip->analog_playback_volume[1];
./sound/pci/mixart/mixart_mixer.c:365:		ucontrol->value.integer.value[0] = chip->analog_capture_volume[0];
./sound/pci/mixart/mixart_mixer.c:366:		ucontrol->value.integer.value[1] = chip->analog_capture_volume[1];
./sound/pci/mixart/mixart_mixer.c:368:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:378:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:383:			&chip->analog_capture_volume[i] :
./sound/pci/mixart/mixart_mixer.c:384:			&chip->analog_playback_volume[i];
./sound/pci/mixart/mixart_mixer.c:401:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:425:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:426:	ucontrol->value.integer.value[0] = chip->analog_playback_active[0];
./sound/pci/mixart/mixart_mixer.c:427:	ucontrol->value.integer.value[1] = chip->analog_playback_active[1];
./sound/pci/mixart/mixart_mixer.c:428:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:436:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:438:		if (chip->analog_playback_active[i] !=
./sound/pci/mixart/mixart_mixer.c:440:			chip->analog_playback_active[i] =
./sound/pci/mixart/mixart_mixer.c:447:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:737:		pipe = &chip->pipe_out_dig;	/* AES playback */
./sound/pci/mixart/mixart_mixer.c:740:		pipe = &chip->pipe_out_ana;	/* analog playback */
./sound/pci/mixart/mixart_mixer.c:750:		if(chip->digital_playback_active[idx][i])
./sound/pci/mixart/mixart_mixer.c:751:			volume[i] = chip->digital_playback_volume[idx][i];
./sound/pci/mixart/mixart_mixer.c:765:	err = snd_mixart_send_msg(chip->mgr, &request, sizeof(status), &status);
./sound/pci/mixart/mixart_mixer.c:767:		dev_dbg(chip->card->dev,
./sound/pci/mixart/mixart_mixer.c:769:			chip->chip_idx, status);
./sound/pci/mixart/mixart_mixer.c:785:		pipe = &chip->pipe_in_dig;
./sound/pci/mixart/mixart_mixer.c:788:		pipe = &chip->pipe_in_ana;
./sound/pci/mixart/mixart_mixer.c:802:		set_level.level[i].digital_level = mixart_digital_level[chip->digital_capture_volume[idx][i]];
./sound/pci/mixart/mixart_mixer.c:810:	err = snd_mixart_send_msg(chip->mgr, &request, sizeof(status), &status);
./sound/pci/mixart/mixart_mixer.c:812:		dev_dbg(chip->card->dev,
./sound/pci/mixart/mixart_mixer.c:814:			chip->chip_idx, status);
./sound/pci/mixart/mixart_mixer.c:841:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:843:		if(is_aes)	stored_volume = chip->digital_capture_volume[1];	/* AES capture */
./sound/pci/mixart/mixart_mixer.c:844:		else		stored_volume = chip->digital_capture_volume[0];	/* analog capture */
./sound/pci/mixart/mixart_mixer.c:847:		if(is_aes)	stored_volume = chip->digital_playback_volume[MIXART_PLAYBACK_STREAMS + idx]; /* AES playback */
./sound/pci/mixart/mixart_mixer.c:848:		else		stored_volume = chip->digital_playback_volume[idx];	/* analog playback */
./sound/pci/mixart/mixart_mixer.c:852:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:865:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:868:			stored_volume = chip->digital_capture_volume[1];
./sound/pci/mixart/mixart_mixer.c:870:			stored_volume = chip->digital_capture_volume[0];
./sound/pci/mixart/mixart_mixer.c:874:			stored_volume = chip->digital_playback_volume[MIXART_PLAYBACK_STREAMS + idx];
./sound/pci/mixart/mixart_mixer.c:876:			stored_volume = chip->digital_playback_volume[idx];
./sound/pci/mixart/mixart_mixer.c:894:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:919:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:922:	ucontrol->value.integer.value[0] = chip->digital_playback_active[idx][0];
./sound/pci/mixart/mixart_mixer.c:923:	ucontrol->value.integer.value[1] = chip->digital_playback_active[idx][1];
./sound/pci/mixart/mixart_mixer.c:924:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:936:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:941:		if (chip->digital_playback_active[j][i] !=
./sound/pci/mixart/mixart_mixer.c:943:			chip->digital_playback_active[j][i] =
./sound/pci/mixart/mixart_mixer.c:950:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:970:	if(chip->pipe_out_ana.status == PIPE_UNDEFINED)
./sound/pci/mixart/mixart_mixer.c:973:	if(!channel)	request.uid = chip->pipe_out_ana.uid_left_connector;
./sound/pci/mixart/mixart_mixer.c:974:	else		request.uid = chip->pipe_out_ana.uid_right_connector;
./sound/pci/mixart/mixart_mixer.c:981:	audio_level.monitor_level = mixart_digital_level[chip->monitoring_volume[channel!=0]];
./sound/pci/mixart/mixart_mixer.c:982:	audio_level.monitor_mute1 = !chip->monitoring_active[channel!=0];
./sound/pci/mixart/mixart_mixer.c:984:	err = snd_mixart_send_msg(chip->mgr, &request, sizeof(resp), &resp);
./sound/pci/mixart/mixart_mixer.c:986:		dev_dbg(chip->card->dev,
./sound/pci/mixart/mixart_mixer.c:988:			chip->chip_idx, resp);
./sound/pci/mixart/mixart_mixer.c:1001:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:1002:	ucontrol->value.integer.value[0] = chip->monitoring_volume[0];
./sound/pci/mixart/mixart_mixer.c:1003:	ucontrol->value.integer.value[1] = chip->monitoring_volume[1];
./sound/pci/mixart/mixart_mixer.c:1004:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:1013:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:1015:		if (chip->monitoring_volume[i] !=
./sound/pci/mixart/mixart_mixer.c:1017:			chip->monitoring_volume[i] =
./sound/pci/mixart/mixart_mixer.c:1023:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:1045:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:1046:	ucontrol->value.integer.value[0] = chip->monitoring_active[0];
./sound/pci/mixart/mixart_mixer.c:1047:	ucontrol->value.integer.value[1] = chip->monitoring_active[1];
./sound/pci/mixart/mixart_mixer.c:1048:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:1057:	mutex_lock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:1059:		if (chip->monitoring_active[i] !=
./sound/pci/mixart/mixart_mixer.c:1061:			chip->monitoring_active[i] =
./sound/pci/mixart/mixart_mixer.c:1068:		int allocate = chip->monitoring_active[0] ||
./sound/pci/mixart/mixart_mixer.c:1069:			chip->monitoring_active[1];
./sound/pci/mixart/mixart_mixer.c:1082:			snd_mixart_kill_ref_pipe(chip->mgr,
./sound/pci/mixart/mixart_mixer.c:1083:						 &chip->pipe_in_ana, 1);
./sound/pci/mixart/mixart_mixer.c:1085:			snd_mixart_kill_ref_pipe(chip->mgr,
./sound/pci/mixart/mixart_mixer.c:1086:						 &chip->pipe_out_ana, 1);
./sound/pci/mixart/mixart_mixer.c:1090:	mutex_unlock(&chip->mgr->mixer_mutex);
./sound/pci/mixart/mixart_mixer.c:1108:	if(chip->chip_idx < 2) {
./sound/pci/mixart/mixart_mixer.c:1130:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1133:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&mixart_control_output_switch, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1141:			if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1149:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1155:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1162:			if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1168:			if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1174:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1180:			if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&temp, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1185:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&mixart_control_monitor_vol, chip))) < 0)
./sound/pci/mixart/mixart_mixer.c:1187:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&mixart_control_monitor_sw, chip))) < 0)
./sound/pci/mixart/mixart_core.c:480:						stream = &chip->capture_stream[pcm_number];
./sound/pci/mixart/mixart_core.c:482:						stream = &chip->playback_stream[pcm_number][sub_number];
./sound/pci/mixart/mixart_hwdep.c:547:			if ((err = snd_mixart_create_mixer(chip->mgr)) < 0)
./sound/pci/mixart/mixart_hwdep.c:551:		if ((err = snd_card_register(chip->card)) < 0)
./sound/pci/cs4281.c:517:        writel(val, chip->ba0 + offset);
./sound/pci/cs4281.c:522:        return readl(chip->ba0 + offset);
./sound/pci/cs4281.c:567:	dev_err(chip->card->dev,
./sound/pci/cs4281.c:628:	dev_err(chip->card->dev,
./sound/pci/cs4281.c:648:	dev_err(chip->card->dev,
./sound/pci/cs4281.c:673:	spin_lock(&chip->reg_lock);
./sound/pci/cs4281.c:700:		spin_unlock(&chip->reg_lock);
./sound/pci/cs4281.c:706:	spin_unlock(&chip->reg_lock);
./sound/pci/cs4281.c:762:	rec_mono = (chip->dma[1].valDMR & BA0_DMR_MONO) == BA0_DMR_MONO;
./sound/pci/cs4281.c:763:	snd_cs4281_pokeBA0(chip, BA0_SRCSA, (chip->src_left_play_slot << 0) |
./sound/pci/cs4281.c:764:					    (chip->src_right_play_slot << 8) |
./sound/pci/cs4281.c:765:					    (chip->src_left_rec_slot << 16) |
./sound/pci/cs4281.c:766:					    ((rec_mono ? 31 : chip->src_right_rec_slot) << 24));
./sound/pci/cs4281.c:770:		if (dma->left_slot == chip->src_left_play_slot) {
./sound/pci/cs4281.c:772:			snd_BUG_ON(dma->right_slot != chip->src_right_play_slot);
./sound/pci/cs4281.c:776:		if (dma->left_slot == chip->src_left_rec_slot) {
./sound/pci/cs4281.c:778:			snd_BUG_ON(dma->right_slot != chip->src_right_rec_slot);
./sound/pci/cs4281.c:816:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:818:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:828:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:830:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:841:	dev_dbg(chip->card->dev,
./sound/pci/cs4281.c:906:	dma = &chip->dma[0];
./sound/pci/cs4281.c:925:	dma = &chip->dma[1];
./sound/pci/cs4281.c:981:	err = snd_pcm_new(chip->card, "CS4281", device, 1, 1, &pcm);
./sound/pci/cs4281.c:991:	chip->pcm = pcm;
./sound/pci/cs4281.c:994:					      snd_dma_pci_data(chip->pci), 64*1024, 512*1024);
./sound/pci/cs4281.c:1083:	chip->ac97_bus = NULL;
./sound/pci/cs4281.c:1090:		chip->ac97_secondary = NULL;
./sound/pci/cs4281.c:1092:		chip->ac97 = NULL;
./sound/pci/cs4281.c:1097:	struct snd_card *card = chip->card;
./sound/pci/cs4281.c:1105:	if ((err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus)) < 0)
./sound/pci/cs4281.c:1107:	chip->ac97_bus->private_free = snd_cs4281_mixer_free_ac97_bus;
./sound/pci/cs4281.c:1112:	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
./sound/pci/cs4281.c:1114:	if (chip->dual_codec) {
./sound/pci/cs4281.c:1116:		if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97_secondary)) < 0)
./sound/pci/cs4281.c:1137:	snd_iprintf(buffer, "Spurious half IRQs   : %u\n", chip->spurious_dhtc_irq);
./sound/pci/cs4281.c:1138:	snd_iprintf(buffer, "Spurious end IRQs    : %u\n", chip->spurious_dtc_irq);
./sound/pci/cs4281.c:1148:	if (copy_to_user_fromio(buf, chip->ba0 + pos, count))
./sound/pci/cs4281.c:1160:	if (copy_to_user_fromio(buf, chip->ba1 + pos, count))
./sound/pci/cs4281.c:1177:	if (! snd_card_proc_new(chip->card, "cs4281", &entry))
./sound/pci/cs4281.c:1179:	if (! snd_card_proc_new(chip->card, "cs4281_BA0", &entry)) {
./sound/pci/cs4281.c:1185:	if (! snd_card_proc_new(chip->card, "cs4281_BA1", &entry)) {
./sound/pci/cs4281.c:1265:	chip->gameport = gp = gameport_allocate_port();
./sound/pci/cs4281.c:1267:		dev_err(chip->card->dev,
./sound/pci/cs4281.c:1273:	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
./sound/pci/cs4281.c:1274:	gameport_set_dev_parent(gp, &chip->pci->dev);
./sound/pci/cs4281.c:1291:	if (chip->gameport) {
./sound/pci/cs4281.c:1292:		gameport_unregister_port(chip->gameport);
./sound/pci/cs4281.c:1293:		chip->gameport = NULL;
./sound/pci/cs4281.c:1305:	if (chip->irq >= 0)
./sound/pci/cs4281.c:1306:		synchronize_irq(chip->irq);
./sound/pci/cs4281.c:1315:	pci_set_power_state(chip->pci, PCI_D3hot);
./sound/pci/cs4281.c:1317:	if (chip->irq >= 0)
./sound/pci/cs4281.c:1318:		free_irq(chip->irq, chip);
./sound/pci/cs4281.c:1319:	iounmap(chip->ba0);
./sound/pci/cs4281.c:1320:	iounmap(chip->ba1);
./sound/pci/cs4281.c:1321:	pci_release_regions(chip->pci);
./sound/pci/cs4281.c:1322:	pci_disable_device(chip->pci);
./sound/pci/cs4281.c:1356:	spin_lock_init(&chip->reg_lock);
./sound/pci/cs4281.c:1357:	chip->card = card;
./sound/pci/cs4281.c:1358:	chip->pci = pci;
./sound/pci/cs4281.c:1359:	chip->irq = -1;
./sound/pci/cs4281.c:1365:	chip->dual_codec = dual_codec;
./sound/pci/cs4281.c:1372:	chip->ba0_addr = pci_resource_start(pci, 0);
./sound/pci/cs4281.c:1373:	chip->ba1_addr = pci_resource_start(pci, 1);
./sound/pci/cs4281.c:1375:	chip->ba0 = pci_ioremap_bar(pci, 0);
./sound/pci/cs4281.c:1376:	chip->ba1 = pci_ioremap_bar(pci, 1);
./sound/pci/cs4281.c:1377:	if (!chip->ba0 || !chip->ba1) {
./sound/pci/cs4281.c:1388:	chip->irq = pci->irq;
./sound/pci/cs4281.c:1424:			dev_err(chip->card->dev,
./sound/pci/cs4281.c:1436:		dev_err(chip->card->dev,
./sound/pci/cs4281.c:1441:		dev_err(chip->card->dev,
./sound/pci/cs4281.c:1473:	if (chip->dual_codec)
./sound/pci/cs4281.c:1480:			   (chip->dual_codec ? BA0_SERMC_TCID(chip->dual_codec) : BA0_SERMC_TCID(1)) |
./sound/pci/cs4281.c:1504:	dev_err(chip->card->dev, "DLLRDY not seen\n");
./sound/pci/cs4281.c:1530:	dev_err(chip->card->dev,
./sound/pci/cs4281.c:1536:	if (chip->dual_codec) {
./sound/pci/cs4281.c:1543:		dev_info(chip->card->dev,
./sound/pci/cs4281.c:1545:		chip->dual_codec = 0;
./sound/pci/cs4281.c:1574:	dev_err(chip->card->dev, "never read ISV3 and ISV4 from AC'97\n");
./sound/pci/cs4281.c:1589:		struct cs4281_dma *dma = &chip->dma[tmp];
./sound/pci/cs4281.c:1607:	chip->src_left_play_slot = 0;	/* AC'97 left PCM playback (3) */
./sound/pci/cs4281.c:1608:	chip->src_right_play_slot = 1;	/* AC'97 right PCM playback (4) */
./sound/pci/cs4281.c:1609:	chip->src_left_rec_slot = 10;	/* AC'97 left PCM record (3) */
./sound/pci/cs4281.c:1610:	chip->src_right_rec_slot = 11;	/* AC'97 right PCM record (4) */
./sound/pci/cs4281.c:1613:	chip->dma[0].valFCR = BA0_FCR_FEN | BA0_FCR_LS(0) |
./sound/pci/cs4281.c:1616:		              BA0_FCR_OF(chip->dma[0].fifo_offset);
./sound/pci/cs4281.c:1617:	snd_cs4281_pokeBA0(chip, chip->dma[0].regFCR, chip->dma[0].valFCR);
./sound/pci/cs4281.c:1618:	snd_cs4281_pokeBA0(chip, BA0_SRCSA, (chip->src_left_play_slot << 0) |
./sound/pci/cs4281.c:1619:					    (chip->src_right_play_slot << 8) |
./sound/pci/cs4281.c:1620:					    (chip->src_left_rec_slot << 16) |
./sound/pci/cs4281.c:1621:					    (chip->src_right_rec_slot << 24));
./sound/pci/cs4281.c:1637:	synchronize_irq(chip->irq);
./sound/pci/cs4281.c:1648:	snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr | BA0_MIDCR_MRST);
./sound/pci/cs4281.c:1650:	snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1657:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:1658: 	chip->midcr |= BA0_MIDCR_RXE;
./sound/pci/cs4281.c:1659:	chip->midi_input = substream;
./sound/pci/cs4281.c:1660:	if (!(chip->uartm & CS4281_MODE_OUTPUT)) {
./sound/pci/cs4281.c:1663:		snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1665:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:1673:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:1674:	chip->midcr &= ~(BA0_MIDCR_RXE | BA0_MIDCR_RIE);
./sound/pci/cs4281.c:1675:	chip->midi_input = NULL;
./sound/pci/cs4281.c:1676:	if (!(chip->uartm & CS4281_MODE_OUTPUT)) {
./sound/pci/cs4281.c:1679:		snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1681:	chip->uartm &= ~CS4281_MODE_INPUT;
./sound/pci/cs4281.c:1682:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:1690:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:1691:	chip->uartm |= CS4281_MODE_OUTPUT;
./sound/pci/cs4281.c:1692:	chip->midcr |= BA0_MIDCR_TXE;
./sound/pci/cs4281.c:1693:	chip->midi_output = substream;
./sound/pci/cs4281.c:1694:	if (!(chip->uartm & CS4281_MODE_INPUT)) {
./sound/pci/cs4281.c:1697:		snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1699:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:1707:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:1708:	chip->midcr &= ~(BA0_MIDCR_TXE | BA0_MIDCR_TIE);
./sound/pci/cs4281.c:1709:	chip->midi_output = NULL;
./sound/pci/cs4281.c:1710:	if (!(chip->uartm & CS4281_MODE_INPUT)) {
./sound/pci/cs4281.c:1713:		snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1715:	chip->uartm &= ~CS4281_MODE_OUTPUT;
./sound/pci/cs4281.c:1716:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs4281.c:1725:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs4281.c:1727:		if ((chip->midcr & BA0_MIDCR_RIE) == 0) {
./sound/pci/cs4281.c:1728:			chip->midcr |= BA0_MIDCR_RIE;
./sound/pci/cs4281.c:1729:			snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1732:		if (chip->midcr & BA0_MIDCR_RIE) {
./sound/pci/cs4281.c:1733:			chip->midcr &= ~BA0_MIDCR_RIE;
./sound/pci/cs4281.c:1734:			snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1737:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs4281.c:1746:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs4281.c:1748:		if ((chip->midcr & BA0_MIDCR_TIE) == 0) {
./sound/pci/cs4281.c:1749:			chip->midcr |= BA0_MIDCR_TIE;
./sound/pci/cs4281.c:1751:			while ((chip->midcr & BA0_MIDCR_TIE) &&
./sound/pci/cs4281.c:1754:					chip->midcr &= ~BA0_MIDCR_TIE;
./sound/pci/cs4281.c:1759:			snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1762:		if (chip->midcr & BA0_MIDCR_TIE) {
./sound/pci/cs4281.c:1763:			chip->midcr &= ~BA0_MIDCR_TIE;
./sound/pci/cs4281.c:1764:			snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1767:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs4281.c:1789:	if ((err = snd_rawmidi_new(chip->card, "CS4281", device, 1, 1, &rmidi)) < 0)
./sound/pci/cs4281.c:1796:	chip->rmidi = rmidi;
./sound/pci/cs4281.c:1821:				cdma = &chip->dma[dma];
./sound/pci/cs4281.c:1822:				spin_lock(&chip->reg_lock);
./sound/pci/cs4281.c:1830:					chip->spurious_dhtc_irq++;
./sound/pci/cs4281.c:1831:					spin_unlock(&chip->reg_lock);
./sound/pci/cs4281.c:1836:					chip->spurious_dtc_irq++;
./sound/pci/cs4281.c:1837:					spin_unlock(&chip->reg_lock);
./sound/pci/cs4281.c:1840:				spin_unlock(&chip->reg_lock);
./sound/pci/cs4281.c:1845:	if ((status & BA0_HISR_MIDI) && chip->rmidi) {
./sound/pci/cs4281.c:1848:		spin_lock(&chip->reg_lock);
./sound/pci/cs4281.c:1851:			if ((chip->midcr & BA0_MIDCR_RIE) == 0)
./sound/pci/cs4281.c:1853:			snd_rawmidi_receive(chip->midi_input, &c, 1);
./sound/pci/cs4281.c:1856:			if ((chip->midcr & BA0_MIDCR_TIE) == 0)
./sound/pci/cs4281.c:1858:			if (snd_rawmidi_transmit(chip->midi_output, &c, 1) != 1) {
./sound/pci/cs4281.c:1859:				chip->midcr &= ~BA0_MIDCR_TIE;
./sound/pci/cs4281.c:1860:				snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs4281.c:1865:		spin_unlock(&chip->reg_lock);
./sound/pci/cs4281.c:1886:		port = chip->ba0 + BA0_B1AP; /* right port */
./sound/pci/cs4281.c:1888:		port = chip->ba0 + BA0_B0AP; /* left port */
./sound/pci/cs4281.c:1956:		chip->ba0_addr,
./sound/pci/cs4281.c:1957:		chip->irq);
./sound/pci/cs4281.c:2005:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/cs4281.c:2007:	snd_ac97_suspend(chip->ac97);
./sound/pci/cs4281.c:2008:	snd_ac97_suspend(chip->ac97_secondary);
./sound/pci/cs4281.c:2020:			chip->suspend_regs[i] = snd_cs4281_peekBA0(chip, saved_regs[i]);
./sound/pci/cs4281.c:2056:			snd_cs4281_pokeBA0(chip, saved_regs[i], chip->suspend_regs[i]);
./sound/pci/cs4281.c:2058:	snd_ac97_resume(chip->ac97);
./sound/pci/cs4281.c:2059:	snd_ac97_resume(chip->ac97_secondary);
./sound/pci/als4000.c:274:	 * NOTE: assumes chip->mixer_lock to be locked externally already!
./sound/pci/als4000.c:282:	/* NOTE: assumes chip->mixer_lock to be locked externally already! */
./sound/pci/als4000.c:290:	if (!(chip->mode & SB_RATE_LOCK)) {
./sound/pci/als4000.c:390:	chip->capture_format = snd_als4000_get_format(runtime);
./sound/pci/als4000.c:395:	if (chip->capture_format & ALS4000_FORMAT_16BIT)
./sound/pci/als4000.c:399:	spin_lock_irq(&chip->reg_lock);
./sound/pci/als4000.c:402:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/als4000.c:403:	spin_lock_irq(&chip->mixer_lock);
./sound/pci/als4000.c:406:	spin_unlock_irq(&chip->mixer_lock);
./sound/pci/als4000.c:417:	chip->playback_format = snd_als4000_get_format(runtime);
./sound/pci/als4000.c:422:	if (chip->playback_format & ALS4000_FORMAT_16BIT)
./sound/pci/als4000.c:432:	spin_lock_irq(&chip->reg_lock);
./sound/pci/als4000.c:443:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/als4000.c:454:	   chip->mode non-atomic update gets consistently protected
./sound/pci/als4000.c:459:	spin_lock(&chip->mixer_lock);
./sound/pci/als4000.c:463:		chip->mode |= SB_RATE_LOCK_CAPTURE;
./sound/pci/als4000.c:469:		chip->mode &= ~SB_RATE_LOCK_CAPTURE;
./sound/pci/als4000.c:477:	spin_unlock(&chip->mixer_lock);
./sound/pci/als4000.c:486:	spin_lock(&chip->reg_lock);
./sound/pci/als4000.c:490:		chip->mode |= SB_RATE_LOCK_PLAYBACK;
./sound/pci/als4000.c:496:		chip->mode &= ~SB_RATE_LOCK_PLAYBACK;
./sound/pci/als4000.c:502:	spin_unlock(&chip->reg_lock);
./sound/pci/als4000.c:511:	spin_lock(&chip->reg_lock);	
./sound/pci/als4000.c:513:	spin_unlock(&chip->reg_lock);
./sound/pci/als4000.c:523:	spin_lock(&chip->reg_lock);	
./sound/pci/als4000.c:525:	spin_unlock(&chip->reg_lock);
./sound/pci/als4000.c:551:	pci_irqstatus = snd_als4k_iobase_readb(chip->alt_port,
./sound/pci/als4000.c:554:	 && (chip->playback_substream)) /* playback */
./sound/pci/als4000.c:555:		snd_pcm_period_elapsed(chip->playback_substream);
./sound/pci/als4000.c:557:	 && (chip->capture_substream)) /* capturing */
./sound/pci/als4000.c:558:		snd_pcm_period_elapsed(chip->capture_substream);
./sound/pci/als4000.c:560:	 && (chip->rmidi)) /* MPU401 interrupt */
./sound/pci/als4000.c:561:		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
./sound/pci/als4000.c:563:	snd_als4k_iobase_writeb(chip->alt_port,
./sound/pci/als4000.c:566:	spin_lock(&chip->mixer_lock);
./sound/pci/als4000.c:569:	spin_unlock(&chip->mixer_lock);
./sound/pci/als4000.c:576:		inb(chip->mpu_port);
./sound/pci/als4000.c:578:		snd_als4k_iobase_readb(chip->alt_port,
./sound/pci/als4000.c:581:	/* dev_dbg(chip->card->dev, "als4000: irq 0x%04x 0x%04x\n",
./sound/pci/als4000.c:640:	chip->playback_substream = substream;
./sound/pci/als4000.c:649:	chip->playback_substream = NULL;
./sound/pci/als4000.c:659:	chip->capture_substream = substream;
./sound/pci/als4000.c:668:	chip->capture_substream = NULL;
./sound/pci/als4000.c:702:	err = snd_pcm_new(chip->card, "ALS4000 DSP", device, 1, 1, &pcm);
./sound/pci/als4000.c:710:	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/als4000.c:713:	chip->pcm = pcm;
./sound/pci/als4000.c:747:	spin_lock_irq(&chip->mixer_lock);
./sound/pci/als4000.c:756:	spin_unlock_irq(&chip->mixer_lock);
./sound/pci/als4000.c:758:	spin_lock_irq(&chip->reg_lock);
./sound/pci/als4000.c:769:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/als4000.c:921:	chip->pci = pci;
./sound/pci/als4000.c:922:	chip->alt_port = iobase;
./sound/pci/als4000.c:929:		card->shortname, chip->alt_port, chip->irq);
./sound/pci/als4000.c:935:					-1, &chip->rmidi)) < 0) {
./sound/pci/als4000.c:997:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/cmipci.c:1024:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cmipci.c:1026:		ucontrol->value.iec958.status[i] = (chip->dig_status >> (i * 8)) & 0xff;
./sound/pci/cmipci.c:1027:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cmipci.c:1039:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cmipci.c:1042:	change = val != chip->dig_status;
./sound/pci/cmipci.c:1043:	chip->dig_status = val;
./sound/pci/cmipci.c:1044:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cmipci.c:1098:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cmipci.c:1100:		ucontrol->value.iec958.status[i] = (chip->dig_pcm_status >> (i * 8)) & 0xff;
./sound/pci/cmipci.c:1101:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cmipci.c:1113:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cmipci.c:1116:	change = val != chip->dig_pcm_status;
./sound/pci/cmipci.c:1117:	chip->dig_pcm_status = val;
./sound/pci/cmipci.c:1118:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cmipci.c:2500:			if (chip->spdif_playback_avail)
./sound/pci/cmipci.c:2503:			if (chip->spdif_playback_avail)
./sound/pci/cmipci.c:2507:	chip->spdif_playback_enabled = ucontrol->value.integer.value[0];
./sound/pci/intel8x0.c:462:	return ioread8(chip->bmaddr + offset);
./sound/pci/intel8x0.c:467:	return ioread16(chip->bmaddr + offset);
./sound/pci/intel8x0.c:472:	return ioread32(chip->bmaddr + offset);
./sound/pci/intel8x0.c:477:	iowrite8(val, chip->bmaddr + offset);
./sound/pci/intel8x0.c:482:	iowrite16(val, chip->bmaddr + offset);
./sound/pci/intel8x0.c:487:	iowrite32(val, chip->bmaddr + offset);
./sound/pci/intel8x0.c:496:	return ioread16(chip->addr + offset);
./sound/pci/intel8x0.c:501:	iowrite16(val, chip->addr + offset);
./sound/pci/intel8x0.c:518:	if (chip->in_sdin_init) {
./sound/pci/intel8x0.c:521:		codec = chip->codec_isr_bits;
./sound/pci/intel8x0.c:523:		codec = chip->codec_bit[chip->ac97_sdin[codec]];
./sound/pci/intel8x0.c:530:	if (chip->buggy_semaphore)
./sound/pci/intel8x0.c:544:	dev_err(chip->card->dev,
./sound/pci/intel8x0.c:559:		if (! chip->in_ac97_init)
./sound/pci/intel8x0.c:560:			dev_err(chip->card->dev,
./sound/pci/intel8x0.c:575:		if (! chip->in_ac97_init)
./sound/pci/intel8x0.c:576:			dev_err(chip->card->dev,
./sound/pci/intel8x0.c:585:				  ~(chip->codec_ready_bits | ICH_GSCI));
./sound/pci/intel8x0.c:586:			if (! chip->in_ac97_init)
./sound/pci/intel8x0.c:587:				dev_err(chip->card->dev,
./sound/pci/intel8x0.c:606:				  ~(chip->codec_ready_bits | ICH_GSCI));
./sound/pci/intel8x0.c:622:	if (! chip->in_ac97_init)
./sound/pci/intel8x0.c:623:		dev_warn(chip->card->dev, "AC97 codec ready timeout.\n");
./sound/pci/intel8x0.c:630:	if (chip->buggy_semaphore)
./sound/pci/intel8x0.c:634:	if (! time && ! chip->in_ac97_init)
./sound/pci/intel8x0.c:635:		dev_warn(chip->card->dev, "ali_codec_semaphore timeout\n");
./sound/pci/intel8x0.c:704:			dev_dbg(chip->card->dev, "bdbar[%i] = 0x%x [0x%x]\n",
./sound/pci/intel8x0.c:716:	dev_dbg(chip->card->dev,
./sound/pci/intel8x0.c:755:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/intel8x0.c:775:	if (! chip->in_measurement)
./sound/pci/intel8x0.c:785:	dev_dbg(chip->card->dev,
./sound/pci/intel8x0.c:796:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/intel8x0.c:811:	status = igetdword(chip, chip->int_sta_reg);
./sound/pci/intel8x0.c:815:	if ((status & chip->int_sta_mask) == 0) {
./sound/pci/intel8x0.c:818:			iputdword(chip, chip->int_sta_reg, status);
./sound/pci/intel8x0.c:819:			if (! chip->buggy_irq)
./sound/pci/intel8x0.c:825:	for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0.c:826:		ichdev = &chip->ichd[i];
./sound/pci/intel8x0.c:832:	iputdword(chip, chip->int_sta_reg, status & chip->int_sta_mask);
./sound/pci/intel8x0.c:943:	if (chip->fix_nocache && ichdev->page_attr_changed) {
./sound/pci/intel8x0.c:950:	if (chip->fix_nocache) {
./sound/pci/intel8x0.c:966:		if (ichdev->ichd == ICHD_PCMOUT && chip->spdif_idx < 0)
./sound/pci/intel8x0.c:982:	if (chip->fix_nocache && ichdev->page_attr_changed) {
./sound/pci/intel8x0.c:995:	spin_lock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:996:	switch (chip->device_type) {
./sound/pci/intel8x0.c:1024:		if (chip->device_type == DEVICE_NFORCE) {
./sound/pci/intel8x0.c:1030:				spin_unlock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:1032:				spin_lock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:1034:		} else if (chip->device_type == DEVICE_INTEL_ICH4) {
./sound/pci/intel8x0.c:1041:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:1055:		if (chip->device_type == DEVICE_INTEL_ICH4)
./sound/pci/intel8x0.c:1070:	spin_lock(&chip->reg_lock);
./sound/pci/intel8x0.c:1088:		if (chip->inside_vm)
./sound/pci/intel8x0.c:1110:	spin_unlock(&chip->reg_lock);
./sound/pci/intel8x0.c:1177:	if (chip->device_type == DEVICE_SIS) {
./sound/pci/intel8x0.c:1193:	err = snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_PCMOUT]);
./sound/pci/intel8x0.c:1197:	if (chip->multi8) {
./sound/pci/intel8x0.c:1202:	} else if (chip->multi6) {
./sound/pci/intel8x0.c:1206:	} else if (chip->multi4) {
./sound/pci/intel8x0.c:1211:	if (chip->dra) {
./sound/pci/intel8x0.c:1214:	if (chip->smp20bit) {
./sound/pci/intel8x0.c:1225:	chip->ichd[ICHD_PCMOUT].substream = NULL;
./sound/pci/intel8x0.c:1233:	return snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_PCMIN]);
./sound/pci/intel8x0.c:1240:	chip->ichd[ICHD_PCMIN].substream = NULL;
./sound/pci/intel8x0.c:1248:	return snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_MIC]);
./sound/pci/intel8x0.c:1255:	chip->ichd[ICHD_MIC].substream = NULL;
./sound/pci/intel8x0.c:1263:	return snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_MIC2]);
./sound/pci/intel8x0.c:1270:	chip->ichd[ICHD_MIC2].substream = NULL;
./sound/pci/intel8x0.c:1278:	return snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_PCM2IN]);
./sound/pci/intel8x0.c:1285:	chip->ichd[ICHD_PCM2IN].substream = NULL;
./sound/pci/intel8x0.c:1292:	int idx = chip->device_type == DEVICE_NFORCE ? NVD_SPBAR : ICHD_SPBAR;
./sound/pci/intel8x0.c:1294:	return snd_intel8x0_pcm_open(substream, &chip->ichd[idx]);
./sound/pci/intel8x0.c:1300:	int idx = chip->device_type == DEVICE_NFORCE ? NVD_SPBAR : ICHD_SPBAR;
./sound/pci/intel8x0.c:1302:	chip->ichd[idx].substream = NULL;
./sound/pci/intel8x0.c:1311:	spin_lock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:1316:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:1318:	return snd_intel8x0_pcm_open(substream, &chip->ichd[ALID_AC97SPDIFOUT]);
./sound/pci/intel8x0.c:1326:	chip->ichd[ALID_AC97SPDIFOUT].substream = NULL;
./sound/pci/intel8x0.c:1327:	spin_lock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:1331:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:1341:	return snd_intel8x0_pcm_open(substream, &chip->ichd[ALID_SPDIFIN]);
./sound/pci/intel8x0.c:1348:	chip->ichd[ALID_SPDIFIN].substream = NULL;
./sound/pci/intel8x0.c:1356:	return snd_intel8x0_pcm_open(substream, &chip->ichd[ALID_SPDIFOUT]);
./sound/pci/intel8x0.c:1363:	chip->ichd[ALID_SPDIFOUT].substream = NULL;
./sound/pci/intel8x0.c:1522:	err = snd_pcm_new(chip->card, name, device,
./sound/pci/intel8x0.c:1536:		sprintf(pcm->name, "%s - %s", chip->card->shortname, rec->suffix);
./sound/pci/intel8x0.c:1538:		strcpy(pcm->name, chip->card->shortname);
./sound/pci/intel8x0.c:1539:	chip->pcm[device] = pcm;
./sound/pci/intel8x0.c:1542:					      snd_dma_pci_data(chip->pci),
./sound/pci/intel8x0.c:1549:		if (chip->multi8)
./sound/pci/intel8x0.c:1551:		else if (chip->multi6)
./sound/pci/intel8x0.c:1553:		else if (chip->multi4)
./sound/pci/intel8x0.c:1561:		chip->ac97[0]->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;
./sound/pci/intel8x0.c:1664:	switch (chip->device_type) {
./sound/pci/intel8x0.c:1692:			if (! chip->ichd[rec->ac97_idx].pcm)
./sound/pci/intel8x0.c:1701:	chip->pcm_devs = device;
./sound/pci/intel8x0.c:1713:	chip->ac97_bus = NULL;
./sound/pci/intel8x0.c:1719:	chip->ac97[ac97->num] = NULL;
./sound/pci/intel8x0.c:2217:	chip->spdif_idx = -1; /* use PCMOUT (or disabled) */
./sound/pci/intel8x0.c:2219:		switch (chip->device_type) {
./sound/pci/intel8x0.c:2221:			chip->spdif_idx = NVD_SPBAR;
./sound/pci/intel8x0.c:2224:			chip->spdif_idx = ALID_AC97SPDIFOUT;
./sound/pci/intel8x0.c:2227:			chip->spdif_idx = ICHD_SPBAR;
./sound/pci/intel8x0.c:2232:	chip->in_ac97_init = 1;
./sound/pci/intel8x0.c:2238:	if (chip->xbox)
./sound/pci/intel8x0.c:2240:	if (chip->device_type != DEVICE_ALI) {
./sound/pci/intel8x0.c:2243:		chip->in_sdin_init = 1;
./sound/pci/intel8x0.c:2245:		for (i = 0; i < chip->max_codecs; i++) {
./sound/pci/intel8x0.c:2246:			if (! (glob_sta & chip->codec_bit[i]))
./sound/pci/intel8x0.c:2248:			if (chip->device_type == DEVICE_INTEL_ICH4) {
./sound/pci/intel8x0.c:2250:				chip->ac97_sdin[codecs] =
./sound/pci/intel8x0.c:2252:				if (snd_BUG_ON(chip->ac97_sdin[codecs] >= 3))
./sound/pci/intel8x0.c:2253:					chip->ac97_sdin[codecs] = 0;
./sound/pci/intel8x0.c:2255:				chip->ac97_sdin[codecs] = i;
./sound/pci/intel8x0.c:2258:		chip->in_sdin_init = 0;
./sound/pci/intel8x0.c:2275:	if ((err = snd_ac97_bus(chip->card, 0, ops, chip, &pbus)) < 0)
./sound/pci/intel8x0.c:2281:	if (chip->device_type == DEVICE_ALI)
./sound/pci/intel8x0.c:2285:	chip->ac97_bus = pbus;
./sound/pci/intel8x0.c:2286:	chip->ncodecs = codecs;
./sound/pci/intel8x0.c:2288:	ac97.pci = chip->pci;
./sound/pci/intel8x0.c:2291:		if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97[i])) < 0) {
./sound/pci/intel8x0.c:2293:				dev_err(chip->card->dev,
./sound/pci/intel8x0.c:2300:	snd_ac97_tune_hardware(chip->ac97[0], ac97_quirks, quirk_override);
./sound/pci/intel8x0.c:2302:	if (chip->device_type == DEVICE_INTEL_ICH4)
./sound/pci/intel8x0.c:2306:	if (chip->device_type != DEVICE_INTEL_ICH4)
./sound/pci/intel8x0.c:2308:	if (chip->spdif_idx < 0)
./sound/pci/intel8x0.c:2313:	chip->ichd[ICHD_PCMOUT].pcm = &pbus->pcms[0];
./sound/pci/intel8x0.c:2314:	chip->ichd[ICHD_PCMIN].pcm = &pbus->pcms[1];
./sound/pci/intel8x0.c:2315:	chip->ichd[ICHD_MIC].pcm = &pbus->pcms[2];
./sound/pci/intel8x0.c:2316:	if (chip->spdif_idx >= 0)
./sound/pci/intel8x0.c:2317:		chip->ichd[chip->spdif_idx].pcm = &pbus->pcms[3];
./sound/pci/intel8x0.c:2318:	if (chip->device_type == DEVICE_INTEL_ICH4) {
./sound/pci/intel8x0.c:2319:		chip->ichd[ICHD_PCM2IN].pcm = &pbus->pcms[4];
./sound/pci/intel8x0.c:2320:		chip->ichd[ICHD_MIC2].pcm = &pbus->pcms[5];
./sound/pci/intel8x0.c:2323:	if (chip->device_type == DEVICE_INTEL_ICH4) {
./sound/pci/intel8x0.c:2324:		struct ac97_pcm *pcm = chip->ichd[ICHD_PCM2IN].pcm;
./sound/pci/intel8x0.c:2329:			tmp |= chip->ac97_sdin[0] << ICH_DI1L_SHIFT;
./sound/pci/intel8x0.c:2332:					tmp |= chip->ac97_sdin[pcm->r[0].codec[1]->num] << ICH_DI2L_SHIFT;
./sound/pci/intel8x0.c:2342:		chip->multi4 = 1;
./sound/pci/intel8x0.c:2344:			chip->multi6 = 1;
./sound/pci/intel8x0.c:2345:			if (chip->ac97[0]->flags & AC97_HAS_8CH)
./sound/pci/intel8x0.c:2346:				chip->multi8 = 1;
./sound/pci/intel8x0.c:2350:		chip->dra = 1;
./sound/pci/intel8x0.c:2352:	if (chip->device_type == DEVICE_INTEL_ICH4) {
./sound/pci/intel8x0.c:2354:			chip->smp20bit = 1;
./sound/pci/intel8x0.c:2356:	if (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {
./sound/pci/intel8x0.c:2358:		chip->ichd[chip->spdif_idx].pcm->rates = SNDRV_PCM_RATE_48000;
./sound/pci/intel8x0.c:2360:	if (chip->device_type == DEVICE_INTEL_ICH4 && !spdif_aclink) {
./sound/pci/intel8x0.c:2366:		snd_ac97_update_bits(chip->ac97[0], AC97_EXTENDED_STATUS, 0x03 << 4, 0x03 << 4);
./sound/pci/intel8x0.c:2368:	chip->in_ac97_init = 0;
./sound/pci/intel8x0.c:2373:	if (chip->device_type != DEVICE_ALI)
./sound/pci/intel8x0.c:2407:	if (snd_pci_quirk_lookup(chip->pci, ich_chip_reset_mode))
./sound/pci/intel8x0.c:2424:	(!snd_pci_quirk_lookup(chip->pci, ich_chip_reset_mode))
./sound/pci/intel8x0.c:2446:	dev_err(chip->card->dev, "AC'97 warm reset still in progress? [0x%x]\n",
./sound/pci/intel8x0.c:2461:	if (chip->device_type == DEVICE_NFORCE)
./sound/pci/intel8x0.c:2481:				chip->codec_isr_bits;
./sound/pci/intel8x0.c:2488:			dev_err(chip->card->dev,
./sound/pci/intel8x0.c:2496:		while (status != chip->codec_isr_bits &&
./sound/pci/intel8x0.c:2500:				chip->codec_isr_bits;
./sound/pci/intel8x0.c:2507:		for (i = 0; i < chip->ncodecs; i++)
./sound/pci/intel8x0.c:2508:			if (chip->ac97[i])
./sound/pci/intel8x0.c:2509:				status |= chip->codec_bit[chip->ac97_sdin[i]];
./sound/pci/intel8x0.c:2514:				chip->codec_isr_bits;
./sound/pci/intel8x0.c:2521:	if (chip->device_type == DEVICE_SIS) {
./sound/pci/intel8x0.c:2525:	if (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {
./sound/pci/intel8x0.c:2528:		pci_read_config_dword(chip->pci, 0x4c, &val);
./sound/pci/intel8x0.c:2530:		pci_write_config_dword(chip->pci, 0x4c, val);
./sound/pci/intel8x0.c:2553:	dev_err(chip->card->dev, "AC'97 reset failed.\n");
./sound/pci/intel8x0.c:2575:	if (chip->device_type != DEVICE_ALI) {
./sound/pci/intel8x0.c:2585:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0.c:2586:		iputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);
./sound/pci/intel8x0.c:2588:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0.c:2589:		iputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);
./sound/pci/intel8x0.c:2590:	for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0.c:2593:        		if ((igetbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset) & ICH_RESETREGS) == 0)
./sound/pci/intel8x0.c:2597:			dev_err(chip->card->dev, "reset of registers failed?\n");
./sound/pci/intel8x0.c:2600:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0.c:2601:		iputdword(chip, ICH_REG_OFF_BDBAR + chip->ichd[i].reg_offset,
./sound/pci/intel8x0.c:2602:			  chip->ichd[i].bdbar_addr);
./sound/pci/intel8x0.c:2610:	if (chip->irq < 0)
./sound/pci/intel8x0.c:2613:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0.c:2614:		iputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);
./sound/pci/intel8x0.c:2616:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0.c:2617:		iputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);
./sound/pci/intel8x0.c:2618:	if (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {
./sound/pci/intel8x0.c:2621:		pci_read_config_dword(chip->pci, 0x4c, &val);
./sound/pci/intel8x0.c:2623:		pci_write_config_dword(chip->pci, 0x4c, val);
./sound/pci/intel8x0.c:2628:	if (chip->irq >= 0)
./sound/pci/intel8x0.c:2629:		free_irq(chip->irq, chip);
./sound/pci/intel8x0.c:2630:	if (chip->bdbars.area) {
./sound/pci/intel8x0.c:2631:		if (chip->fix_nocache)
./sound/pci/intel8x0.c:2632:			fill_nocache(chip->bdbars.area, chip->bdbars.bytes, 0);
./sound/pci/intel8x0.c:2633:		snd_dma_free_pages(&chip->bdbars);
./sound/pci/intel8x0.c:2635:	if (chip->addr)
./sound/pci/intel8x0.c:2636:		pci_iounmap(chip->pci, chip->addr);
./sound/pci/intel8x0.c:2637:	if (chip->bmaddr)
./sound/pci/intel8x0.c:2638:		pci_iounmap(chip->pci, chip->bmaddr);
./sound/pci/intel8x0.c:2639:	pci_release_regions(chip->pci);
./sound/pci/intel8x0.c:2640:	pci_disable_device(chip->pci);
./sound/pci/intel8x0.c:2656:	for (i = 0; i < chip->pcm_devs; i++)
./sound/pci/intel8x0.c:2657:		snd_pcm_suspend_all(chip->pcm[i]);
./sound/pci/intel8x0.c:2659:	if (chip->fix_nocache) {
./sound/pci/intel8x0.c:2660:		for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0.c:2661:			struct ichdev *ichdev = &chip->ichd[i];
./sound/pci/intel8x0.c:2669:	for (i = 0; i < chip->ncodecs; i++)
./sound/pci/intel8x0.c:2670:		snd_ac97_suspend(chip->ac97[i]);
./sound/pci/intel8x0.c:2671:	if (chip->device_type == DEVICE_INTEL_ICH4)
./sound/pci/intel8x0.c:2672:		chip->sdm_saved = igetbyte(chip, ICHREG(SDM));
./sound/pci/intel8x0.c:2674:	if (chip->irq >= 0) {
./sound/pci/intel8x0.c:2675:		free_irq(chip->irq, chip);
./sound/pci/intel8x0.c:2676:		chip->irq = -1;
./sound/pci/intel8x0.c:2696:	chip->irq = pci->irq;
./sound/pci/intel8x0.c:2697:	synchronize_irq(chip->irq);
./sound/pci/intel8x0.c:2700:	if (chip->device_type == DEVICE_INTEL_ICH4 && !spdif_aclink) {
./sound/pci/intel8x0.c:2702:		iputbyte(chip, ICHREG(SDM), chip->sdm_saved);
./sound/pci/intel8x0.c:2710:	if (chip->fix_nocache)
./sound/pci/intel8x0.c:2711:		fill_nocache(chip->bdbars.area, chip->bdbars.bytes, 1);
./sound/pci/intel8x0.c:2713:	for (i = 0; i < chip->ncodecs; i++)
./sound/pci/intel8x0.c:2714:		snd_ac97_resume(chip->ac97[i]);
./sound/pci/intel8x0.c:2717:	if (chip->fix_nocache) {
./sound/pci/intel8x0.c:2718:		for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0.c:2719:			struct ichdev *ichdev = &chip->ichd[i];
./sound/pci/intel8x0.c:2729:	for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0.c:2730:		struct ichdev *ichdev = &chip->ichd[i];
./sound/pci/intel8x0.c:2763:	if (chip->ac97_bus->clock != 48000)
./sound/pci/intel8x0.c:2767:	subs = chip->pcm[0]->streams[0].substream;
./sound/pci/intel8x0.c:2769:		dev_warn(chip->card->dev,
./sound/pci/intel8x0.c:2773:	ichdev = &chip->ichd[ICHD_PCMOUT];
./sound/pci/intel8x0.c:2779:	if (snd_ac97_set_rate(chip->ac97[0], AC97_PCM_FRONT_DAC_RATE, 48000) < 0) {
./sound/pci/intel8x0.c:2780:		dev_err(chip->card->dev, "cannot set ac97 rate: clock = %d\n",
./sound/pci/intel8x0.c:2781:			chip->ac97_bus->clock);
./sound/pci/intel8x0.c:2786:	spin_lock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:2787:	chip->in_measurement = 1;
./sound/pci/intel8x0.c:2789:	if (chip->device_type != DEVICE_ALI)
./sound/pci/intel8x0.c:2796:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:2798:	spin_lock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:2818:	chip->in_measurement = 0;
./sound/pci/intel8x0.c:2821:	if (chip->device_type == DEVICE_ALI) {
./sound/pci/intel8x0.c:2832:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/intel8x0.c:2835:		dev_err(chip->card->dev,
./sound/pci/intel8x0.c:2848:	dev_info(chip->card->dev,
./sound/pci/intel8x0.c:2851:		dev_err(chip->card->dev, "?? calculation error..\n");
./sound/pci/intel8x0.c:2858:		dev_info(chip->card->dev, "measured clock %ld rejected\n", pos);
./sound/pci/intel8x0.c:2862:		chip->ac97_bus->clock = 41000;
./sound/pci/intel8x0.c:2865:		chip->ac97_bus->clock = 44100;
./sound/pci/intel8x0.c:2868:		chip->ac97_bus->clock = (chip->ac97_bus->clock * 48000) / pos;
./sound/pci/intel8x0.c:2870:	dev_info(chip->card->dev, "clocking to %d\n", chip->ac97_bus->clock);
./sound/pci/intel8x0.c:2871:	snd_ac97_update_power(chip->ac97[0], AC97_PCM_FRONT_DAC_RATE, 0);
./sound/pci/intel8x0.c:2886:	struct pci_dev *pci = chip->pci;
./sound/pci/intel8x0.c:2892:	dev_info(chip->card->dev, "white list rate for %04x:%04x is %i\n",
./sound/pci/intel8x0.c:2894:	chip->ac97_bus->clock = wl->value;
./sound/pci/intel8x0.c:2905:	if (chip->device_type == DEVICE_ALI)
./sound/pci/intel8x0.c:2910:	if (chip->device_type == DEVICE_INTEL_ICH4)
./sound/pci/intel8x0.c:2913:	if (tmp & chip->codec_isr_bits) {
./sound/pci/intel8x0.c:2918:		for (i = 0; i < chip->max_codecs; i++)
./sound/pci/intel8x0.c:2919:			if (tmp & chip->codec_bit[i])
./sound/pci/intel8x0.c:2924:	if (chip->device_type == DEVICE_INTEL_ICH4 ||
./sound/pci/intel8x0.c:2925:	    chip->device_type == DEVICE_SIS)
./sound/pci/intel8x0.c:2927:			chip->ac97_sdin[0],
./sound/pci/intel8x0.c:2928:			chip->ac97_sdin[1],
./sound/pci/intel8x0.c:2929:			chip->ac97_sdin[2]);
./sound/pci/intel8x0.c:2936:	if (! snd_card_proc_new(chip->card, "intel8x0", &entry))
./sound/pci/intel8x0.c:3044:	spin_lock_init(&chip->reg_lock);
./sound/pci/intel8x0.c:3045:	chip->device_type = device_type;
./sound/pci/intel8x0.c:3046:	chip->card = card;
./sound/pci/intel8x0.c:3047:	chip->pci = pci;
./sound/pci/intel8x0.c:3048:	chip->irq = -1;
./sound/pci/intel8x0.c:3051:	chip->buggy_irq = buggy_irq;
./sound/pci/intel8x0.c:3052:	chip->buggy_semaphore = buggy_semaphore;
./sound/pci/intel8x0.c:3054:		chip->xbox = 1;
./sound/pci/intel8x0.c:3056:	chip->inside_vm = snd_intel8x0_inside_vm(pci);
./sound/pci/intel8x0.c:3060:		chip->fix_nocache = 1; /* enable workaround */
./sound/pci/intel8x0.c:3070:		chip->bmaddr = pci_iomap(pci, 0, 0);
./sound/pci/intel8x0.c:3075:		chip->addr = pci_iomap(pci, 2, 0);
./sound/pci/intel8x0.c:3077:		chip->addr = pci_iomap(pci, 0, 0);
./sound/pci/intel8x0.c:3078:	if (!chip->addr) {
./sound/pci/intel8x0.c:3084:		chip->bmaddr = pci_iomap(pci, 3, 0);
./sound/pci/intel8x0.c:3086:		chip->bmaddr = pci_iomap(pci, 1, 0);
./sound/pci/intel8x0.c:3089:	if (!chip->bmaddr) {
./sound/pci/intel8x0.c:3094:	chip->bdbars_count = bdbars[device_type];
./sound/pci/intel8x0.c:3108:	for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0.c:3109:		ichdev = &chip->ichd[i];
./sound/pci/intel8x0.c:3130:				chip->bdbars_count * sizeof(u32) * ICH_MAX_FRAGS * 2,
./sound/pci/intel8x0.c:3131:				&chip->bdbars) < 0) {
./sound/pci/intel8x0.c:3139:	if (chip->fix_nocache)
./sound/pci/intel8x0.c:3140:		fill_nocache(chip->bdbars.area, chip->bdbars.bytes, 1);
./sound/pci/intel8x0.c:3142:	for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0.c:3143:		ichdev = &chip->ichd[i];
./sound/pci/intel8x0.c:3144:		ichdev->bdbar = ((u32 *)chip->bdbars.area) +
./sound/pci/intel8x0.c:3146:		ichdev->bdbar_addr = chip->bdbars.addr +
./sound/pci/intel8x0.c:3150:	chip->int_sta_reg = device_type == DEVICE_ALI ?
./sound/pci/intel8x0.c:3152:	chip->int_sta_mask = int_sta_masks;
./sound/pci/intel8x0.c:3156:	switch(chip->device_type) {
./sound/pci/intel8x0.c:3159:		chip->max_codecs = 3;
./sound/pci/intel8x0.c:3160:		chip->codec_bit = ich_codec_bits;
./sound/pci/intel8x0.c:3161:		chip->codec_ready_bits = ICH_PRI | ICH_SRI | ICH_TRI;
./sound/pci/intel8x0.c:3165:		chip->max_codecs = 3;
./sound/pci/intel8x0.c:3166:		chip->codec_bit = sis_codec_bits;
./sound/pci/intel8x0.c:3167:		chip->codec_ready_bits = ICH_PRI | ICH_SRI | ICH_SIS_TRI;
./sound/pci/intel8x0.c:3171:		chip->max_codecs = 2;
./sound/pci/intel8x0.c:3172:		chip->codec_bit = ich_codec_bits;
./sound/pci/intel8x0.c:3173:		chip->codec_ready_bits = ICH_PRI | ICH_SRI;
./sound/pci/intel8x0.c:3176:	for (i = 0; i < chip->max_codecs; i++)
./sound/pci/intel8x0.c:3177:		chip->codec_isr_bits |= chip->codec_bit[i];
./sound/pci/intel8x0.c:3191:	chip->irq = pci->irq;
./sound/pci/intel8x0.c:3320:		 snd_ac97_get_short_name(chip->ac97[0]), chip->irq);
./sound/pci/maestro3.c:932:	outw(value, chip->iobase + reg);
./sound/pci/maestro3.c:937:	return inw(chip->iobase + reg);
./sound/pci/maestro3.c:942:	outb(value, chip->iobase + reg);
./sound/pci/maestro3.c:947:	return inb(chip->iobase + reg);
./sound/pci/maestro3.c:970:	chip->reset_state = snd_m3_inb(chip, DSP_PORT_CONTROL_REG_B) & ~REGB_STOP_CLOCK;
./sound/pci/maestro3.c:972:	snd_m3_outb(chip, chip->reset_state & ~REGB_ENABLE_RESET, DSP_PORT_CONTROL_REG_B);
./sound/pci/maestro3.c:977:	snd_m3_outb(chip, chip->reset_state | REGB_ENABLE_RESET, DSP_PORT_CONTROL_REG_B);
./sound/pci/maestro3.c:1019:	chip->timer_users++;
./sound/pci/maestro3.c:1020:	if (chip->timer_users != 1) 
./sound/pci/maestro3.c:1038:	chip->timer_users--;
./sound/pci/maestro3.c:1039:	if (chip->timer_users > 0)  
./sound/pci/maestro3.c:1069:		chip->dacs_active++;
./sound/pci/maestro3.c:1074:				  chip->dacs_active);
./sound/pci/maestro3.c:1098:		chip->dacs_active--;
./sound/pci/maestro3.c:1101:				  chip->dacs_active);
./sound/pci/maestro3.c:1121:	spin_lock(&chip->reg_lock);
./sound/pci/maestro3.c:1142:	spin_unlock(&chip->reg_lock);
./sound/pci/maestro3.c:1441:	spin_lock_irq(&chip->reg_lock);
./sound/pci/maestro3.c:1452:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/maestro3.c:1495:	spin_lock(&chip->reg_lock);
./sound/pci/maestro3.c:1497:	spin_unlock(&chip->reg_lock);
./sound/pci/maestro3.c:1533:		spin_unlock(&chip->reg_lock);
./sound/pci/maestro3.c:1535:		spin_lock(&chip->reg_lock);
./sound/pci/maestro3.c:1551:	x = inb(chip->iobase + SHADOW_MIX_REG_VOICE) & 0xee;
./sound/pci/maestro3.c:1562:	outb(0x88, chip->iobase + SHADOW_MIX_REG_VOICE);
./sound/pci/maestro3.c:1563:	outb(0x88, chip->iobase + HW_VOL_COUNTER_VOICE);
./sound/pci/maestro3.c:1564:	outb(0x88, chip->iobase + SHADOW_MIX_REG_MASTER);
./sound/pci/maestro3.c:1565:	outb(0x88, chip->iobase + HW_VOL_COUNTER_MASTER);
./sound/pci/maestro3.c:1569:	if (chip->in_suspend)
./sound/pci/maestro3.c:1573:	if (!chip->master_switch || !chip->master_volume)
./sound/pci/maestro3.c:1576:	val = snd_ac97_read(chip->ac97, AC97_MASTER);
./sound/pci/maestro3.c:1599:	if (snd_ac97_update(chip->ac97, AC97_MASTER, val))
./sound/pci/maestro3.c:1600:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/pci/maestro3.c:1601:			       &chip->master_switch->id);
./sound/pci/maestro3.c:1603:	if (!chip->input_dev)
./sound/pci/maestro3.c:1625:		input_report_key(chip->input_dev, val, 1);
./sound/pci/maestro3.c:1626:		input_sync(chip->input_dev);
./sound/pci/maestro3.c:1627:		input_report_key(chip->input_dev, val, 0);
./sound/pci/maestro3.c:1628:		input_sync(chip->input_dev);
./sound/pci/maestro3.c:1639:	status = inb(chip->iobase + HOST_INT_STATUS);
./sound/pci/maestro3.c:1645:		schedule_work(&chip->hwvol_work);
./sound/pci/maestro3.c:1652:		u8 ctl = inb(chip->iobase + ASSP_CONTROL_B);
./sound/pci/maestro3.c:1654:			ctl = inb(chip->iobase + ASSP_HOST_INT_STATUS);
./sound/pci/maestro3.c:1656:				outb(DSP2HOST_REQ_TIMER, chip->iobase + ASSP_HOST_INT_STATUS);
./sound/pci/maestro3.c:1658:				spin_lock(&chip->reg_lock);
./sound/pci/maestro3.c:1659:				for (i = 0; i < chip->num_substreams; i++) {
./sound/pci/maestro3.c:1660:					struct m3_dma *s = &chip->substreams[i];
./sound/pci/maestro3.c:1664:				spin_unlock(&chip->reg_lock);
./sound/pci/maestro3.c:1670:	if ((status & MPU401_INT_PENDING) && chip->rmidi)
./sound/pci/maestro3.c:1671:		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
./sound/pci/maestro3.c:1675:	outb(status, chip->iobase + HOST_INT_STATUS);
./sound/pci/maestro3.c:1736:	spin_lock_irq(&chip->reg_lock);
./sound/pci/maestro3.c:1737:	for (i = 0; i < chip->num_substreams; i++) {
./sound/pci/maestro3.c:1738:		s = &chip->substreams[i];
./sound/pci/maestro3.c:1742:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/maestro3.c:1747:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/maestro3.c:1754:		s->index_list[0] = &chip->mixer_list;
./sound/pci/maestro3.c:1756:		s->index_list[0] = &chip->adc1_list;
./sound/pci/maestro3.c:1757:	s->index_list[1] = &chip->msrc_list;
./sound/pci/maestro3.c:1758:	s->index_list[2] = &chip->dma_list;
./sound/pci/maestro3.c:1771:	spin_lock_irq(&chip->reg_lock);
./sound/pci/maestro3.c:1782:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/maestro3.c:1865:	err = snd_pcm_new(chip->card, chip->card->driver, device,
./sound/pci/maestro3.c:1875:	strcpy(pcm->name, chip->card->driver);
./sound/pci/maestro3.c:1876:	chip->pcm = pcm;
./sound/pci/maestro3.c:1879:					      snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
./sound/pci/maestro3.c:1903:	dev_err(chip->card->dev, "ac97 serial bus busy\n");
./sound/pci/maestro3.c:1947:	int io = chip->iobase;
./sound/pci/maestro3.c:1954:	if (chip->pci->subsystem_vendor == 0x1028 &&
./sound/pci/maestro3.c:1955:	    chip->pci->subsystem_device == 0x00e5)
./sound/pci/maestro3.c:1988:	int io = chip->iobase;
./sound/pci/maestro3.c:1990:	if (chip->allegro_flag) {
./sound/pci/maestro3.c:2006:		if (!chip->irda_workaround)
./sound/pci/maestro3.c:2035:		dev_dbg(chip->card->dev,
./sound/pci/maestro3.c:2065:	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
./sound/pci/maestro3.c:2070:	if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97)) < 0)
./sound/pci/maestro3.c:2074:	snd_ac97_write(chip->ac97, AC97_PCM, 0x8000 | (15 << 8) | 15);
./sound/pci/maestro3.c:2076:	snd_ac97_write(chip->ac97, AC97_PCM, 0);
./sound/pci/maestro3.c:2082:	chip->master_switch = snd_ctl_find_id(chip->card, &elem_id);
./sound/pci/maestro3.c:2086:	chip->master_volume = snd_ctl_find_id(chip->card, &elem_id);
./sound/pci/maestro3.c:2124:	data = (const u16 *)chip->assp_kernel_image->data;
./sound/pci/maestro3.c:2125:	for (i = 0 ; i * 2 < chip->assp_kernel_image->size; i++) {
./sound/pci/maestro3.c:2137:	data = (const u16 *)chip->assp_minisrc_image->data;
./sound/pci/maestro3.c:2138:	for (i = 0; i * 2 < chip->assp_minisrc_image->size; i++) {
./sound/pci/maestro3.c:2179:	chip->mixer_list.curlen = 0;
./sound/pci/maestro3.c:2180:	chip->mixer_list.mem_addr = KDATA_MIXER_XFER0;
./sound/pci/maestro3.c:2181:	chip->mixer_list.max = MAX_VIRTUAL_MIXER_CHANNELS;
./sound/pci/maestro3.c:2182:	chip->adc1_list.curlen = 0;
./sound/pci/maestro3.c:2183:	chip->adc1_list.mem_addr = KDATA_ADC1_XFER0;
./sound/pci/maestro3.c:2184:	chip->adc1_list.max = MAX_VIRTUAL_ADC1_CHANNELS;
./sound/pci/maestro3.c:2185:	chip->dma_list.curlen = 0;
./sound/pci/maestro3.c:2186:	chip->dma_list.mem_addr = KDATA_DMA_XFER0;
./sound/pci/maestro3.c:2187:	chip->dma_list.max = MAX_VIRTUAL_DMA_CHANNELS;
./sound/pci/maestro3.c:2188:	chip->msrc_list.curlen = 0;
./sound/pci/maestro3.c:2189:	chip->msrc_list.mem_addr = KDATA_INSTANCE0_MINISRC;
./sound/pci/maestro3.c:2190:	chip->msrc_list.max = MAX_INSTANCE_MINISRC;
./sound/pci/maestro3.c:2215:		dev_err(chip->card->dev,
./sound/pci/maestro3.c:2243:	int io = chip->iobase;
./sound/pci/maestro3.c:2246:	if (! chip->external_amp)
./sound/pci/maestro3.c:2250:	polarity = polarity << chip->amp_gpio;
./sound/pci/maestro3.c:2251:	gpo = 1 << chip->amp_gpio;
./sound/pci/maestro3.c:2267:	unsigned long io = chip->iobase;
./sound/pci/maestro3.c:2270:	if (!chip->is_omnibook)
./sound/pci/maestro3.c:2290:	struct pci_dev *pcidev = chip->pci;
./sound/pci/maestro3.c:2291:	unsigned long io = chip->iobase;
./sound/pci/maestro3.c:2304:	n |= chip->hv_config;
./sound/pci/maestro3.c:2310:	outb(RESET_ASSP, chip->iobase + ASSP_CONTROL_B);
./sound/pci/maestro3.c:2313:	if (!chip->allegro_flag) {
./sound/pci/maestro3.c:2320:	if (chip->allegro_flag) {
./sound/pci/maestro3.c:2326:	t = inb(chip->iobase + ASSP_CONTROL_A);
./sound/pci/maestro3.c:2330:	outb(t, chip->iobase + ASSP_CONTROL_A);
./sound/pci/maestro3.c:2333:	outb(RUN_ASSP, chip->iobase + ASSP_CONTROL_B); 
./sound/pci/maestro3.c:2347:	unsigned long io = chip->iobase;
./sound/pci/maestro3.c:2352:	if (chip->hv_config & HV_CTRL_ENABLE)
./sound/pci/maestro3.c:2354:	outb(val, chip->iobase + HOST_INT_STATUS);
./sound/pci/maestro3.c:2369:	cancel_work_sync(&chip->hwvol_work);
./sound/pci/maestro3.c:2371:	if (chip->input_dev)
./sound/pci/maestro3.c:2372:		input_unregister_device(chip->input_dev);
./sound/pci/maestro3.c:2375:	if (chip->substreams) {
./sound/pci/maestro3.c:2376:		spin_lock_irq(&chip->reg_lock);
./sound/pci/maestro3.c:2377:		for (i = 0; i < chip->num_substreams; i++) {
./sound/pci/maestro3.c:2378:			s = &chip->substreams[i];
./sound/pci/maestro3.c:2383:		spin_unlock_irq(&chip->reg_lock);
./sound/pci/maestro3.c:2384:		kfree(chip->substreams);
./sound/pci/maestro3.c:2386:	if (chip->iobase) {
./sound/pci/maestro3.c:2387:		outw(0, chip->iobase + HOST_INT_CTRL); /* disable ints */
./sound/pci/maestro3.c:2391:	vfree(chip->suspend_mem);
./sound/pci/maestro3.c:2394:	if (chip->irq >= 0)
./sound/pci/maestro3.c:2395:		free_irq(chip->irq, chip);
./sound/pci/maestro3.c:2397:	if (chip->iobase)
./sound/pci/maestro3.c:2398:		pci_release_regions(chip->pci);
./sound/pci/maestro3.c:2400:	release_firmware(chip->assp_kernel_image);
./sound/pci/maestro3.c:2401:	release_firmware(chip->assp_minisrc_image);
./sound/pci/maestro3.c:2403:	pci_disable_device(chip->pci);
./sound/pci/maestro3.c:2419:	if (chip->suspend_mem == NULL)
./sound/pci/maestro3.c:2422:	chip->in_suspend = 1;
./sound/pci/maestro3.c:2423:	cancel_work_sync(&chip->hwvol_work);
./sound/pci/maestro3.c:2425:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/maestro3.c:2426:	snd_ac97_suspend(chip->ac97);
./sound/pci/maestro3.c:2435:		chip->suspend_mem[dsp_index++] =
./sound/pci/maestro3.c:2438:		chip->suspend_mem[dsp_index++] =
./sound/pci/maestro3.c:2449:	if (chip->suspend_mem == NULL)
./sound/pci/maestro3.c:2464:				  chip->suspend_mem[dsp_index++]);
./sound/pci/maestro3.c:2467:				  chip->suspend_mem[dsp_index++]);
./sound/pci/maestro3.c:2474:	snd_ac97_resume(chip->ac97);
./sound/pci/maestro3.c:2483:	chip->in_suspend = 0;
./sound/pci/maestro3.c:2503:	snprintf(chip->phys, sizeof(chip->phys), "pci-%s/input0",
./sound/pci/maestro3.c:2504:		 pci_name(chip->pci));
./sound/pci/maestro3.c:2506:	input_dev->name = chip->card->driver;
./sound/pci/maestro3.c:2507:	input_dev->phys = chip->phys;
./sound/pci/maestro3.c:2509:	input_dev->id.vendor  = chip->pci->vendor;
./sound/pci/maestro3.c:2510:	input_dev->id.product = chip->pci->device;
./sound/pci/maestro3.c:2511:	input_dev->dev.parent = &chip->pci->dev;
./sound/pci/maestro3.c:2524:	chip->input_dev = input_dev;
./sound/pci/maestro3.c:2571:	spin_lock_init(&chip->reg_lock);
./sound/pci/maestro3.c:2578:		chip->allegro_flag = 1;
./sound/pci/maestro3.c:2582:	chip->card = card;
./sound/pci/maestro3.c:2583:	chip->pci = pci;
./sound/pci/maestro3.c:2584:	chip->irq = -1;
./sound/pci/maestro3.c:2585:	INIT_WORK(&chip->hwvol_work, snd_m3_update_hw_volume);
./sound/pci/maestro3.c:2587:	chip->external_amp = enable_amp;
./sound/pci/maestro3.c:2589:		chip->amp_gpio = amp_gpio;
./sound/pci/maestro3.c:2595:			chip->amp_gpio = quirk->value;
./sound/pci/maestro3.c:2596:		} else if (chip->allegro_flag)
./sound/pci/maestro3.c:2597:			chip->amp_gpio = GPO_EXT_AMP_ALLEGRO;
./sound/pci/maestro3.c:2599:			chip->amp_gpio = GPO_EXT_AMP_M3;
./sound/pci/maestro3.c:2606:		chip->irda_workaround = 1;
./sound/pci/maestro3.c:2610:		chip->hv_config = quirk->value;
./sound/pci/maestro3.c:2612:		chip->is_omnibook = 1;
./sound/pci/maestro3.c:2614:	chip->num_substreams = NR_DSPS;
./sound/pci/maestro3.c:2615:	chip->substreams = kcalloc(chip->num_substreams, sizeof(struct m3_dma),
./sound/pci/maestro3.c:2617:	if (chip->substreams == NULL) {
./sound/pci/maestro3.c:2623:	err = request_firmware(&chip->assp_kernel_image,
./sound/pci/maestro3.c:2630:	err = request_firmware(&chip->assp_minisrc_image,
./sound/pci/maestro3.c:2641:	chip->iobase = pci_resource_start(pci, 0);
./sound/pci/maestro3.c:2661:	chip->irq = pci->irq;
./sound/pci/maestro3.c:2664:	chip->suspend_mem = vmalloc(sizeof(u16) * (REV_B_CODE_MEMORY_LENGTH + REV_B_DATA_MEMORY_LENGTH));
./sound/pci/maestro3.c:2665:	if (chip->suspend_mem == NULL)
./sound/pci/maestro3.c:2677:	for (i = 0; i < chip->num_substreams; i++) {
./sound/pci/maestro3.c:2678:		struct m3_dma *s = &chip->substreams[i];
./sound/pci/maestro3.c:2687:	if (chip->hv_config & HV_CTRL_ENABLE) {
./sound/pci/maestro3.c:2755:		card->shortname, chip->iobase, chip->irq);
./sound/pci/maestro3.c:2764:	err = snd_mpu401_uart_new(chip->card, 0, MPU401_HW_MPU401,
./sound/pci/maestro3.c:2765:				  chip->iobase + MPU401_DATA_PORT,
./sound/pci/maestro3.c:2767:				  -1, &chip->rmidi);
./sound/pci/aw2/aw2-alsa.c:226:	snd_aw2_saa7146_free(&chip->saa7146);
./sound/pci/aw2/aw2-alsa.c:229:	if (chip->irq >= 0)
./sound/pci/aw2/aw2-alsa.c:230:		free_irq(chip->irq, (void *)chip);
./sound/pci/aw2/aw2-alsa.c:232:	iounmap(chip->iobase_virt);
./sound/pci/aw2/aw2-alsa.c:233:	pci_release_regions(chip->pci);
./sound/pci/aw2/aw2-alsa.c:235:	pci_disable_device(chip->pci);
./sound/pci/aw2/aw2-alsa.c:242:/* chip-specific constructor */
./sound/pci/aw2/aw2-alsa.c:274:	chip->card = card;
./sound/pci/aw2/aw2-alsa.c:275:	chip->pci = pci;
./sound/pci/aw2/aw2-alsa.c:276:	chip->irq = -1;
./sound/pci/aw2/aw2-alsa.c:285:	chip->iobase_phys = pci_resource_start(pci, 0);
./sound/pci/aw2/aw2-alsa.c:286:	chip->iobase_virt =
./sound/pci/aw2/aw2-alsa.c:287:		ioremap_nocache(chip->iobase_phys,
./sound/pci/aw2/aw2-alsa.c:290:	if (chip->iobase_virt == NULL) {
./sound/pci/aw2/aw2-alsa.c:299:	snd_aw2_saa7146_setup(&chip->saa7146, chip->iobase_virt);
./sound/pci/aw2/aw2-alsa.c:305:		iounmap(chip->iobase_virt);
./sound/pci/aw2/aw2-alsa.c:306:		pci_release_regions(chip->pci);
./sound/pci/aw2/aw2-alsa.c:307:		pci_disable_device(chip->pci);
./sound/pci/aw2/aw2-alsa.c:311:	chip->irq = pci->irq;
./sound/pci/aw2/aw2-alsa.c:315:		free_irq(chip->irq, (void *)chip);
./sound/pci/aw2/aw2-alsa.c:316:		iounmap(chip->iobase_virt);
./sound/pci/aw2/aw2-alsa.c:317:		pci_release_regions(chip->pci);
./sound/pci/aw2/aw2-alsa.c:318:		pci_disable_device(chip->pci);
./sound/pci/aw2/aw2-alsa.c:361:	mutex_init(&chip->mtx);
./sound/pci/aw2/aw2-alsa.c:363:	spin_lock_init(&chip->reg_lock);
./sound/pci/aw2/aw2-alsa.c:369:		card->shortname, chip->irq);
./sound/pci/aw2/aw2-alsa.c:449:	mutex_lock(&chip->mtx);
./sound/pci/aw2/aw2-alsa.c:454:	snd_aw2_saa7146_pcm_init_playback(&chip->saa7146,
./sound/pci/aw2/aw2-alsa.c:465:	mutex_unlock(&chip->mtx);
./sound/pci/aw2/aw2-alsa.c:478:	mutex_lock(&chip->mtx);
./sound/pci/aw2/aw2-alsa.c:483:	snd_aw2_saa7146_pcm_init_capture(&chip->saa7146,
./sound/pci/aw2/aw2-alsa.c:494:	mutex_unlock(&chip->mtx);
./sound/pci/aw2/aw2-alsa.c:506:	spin_lock(&chip->reg_lock);
./sound/pci/aw2/aw2-alsa.c:509:		snd_aw2_saa7146_pcm_trigger_start_playback(&chip->saa7146,
./sound/pci/aw2/aw2-alsa.c:514:		snd_aw2_saa7146_pcm_trigger_stop_playback(&chip->saa7146,
./sound/pci/aw2/aw2-alsa.c:521:	spin_unlock(&chip->reg_lock);
./sound/pci/aw2/aw2-alsa.c:532:	spin_lock(&chip->reg_lock);
./sound/pci/aw2/aw2-alsa.c:535:		snd_aw2_saa7146_pcm_trigger_start_capture(&chip->saa7146,
./sound/pci/aw2/aw2-alsa.c:540:		snd_aw2_saa7146_pcm_trigger_stop_capture(&chip->saa7146,
./sound/pci/aw2/aw2-alsa.c:547:	spin_unlock(&chip->reg_lock);
./sound/pci/aw2/aw2-alsa.c:562:		snd_aw2_saa7146_get_hw_ptr_playback(&chip->saa7146,
./sound/pci/aw2/aw2-alsa.c:581:		snd_aw2_saa7146_get_hw_ptr_capture(&chip->saa7146,
./sound/pci/aw2/aw2-alsa.c:600:	err = snd_pcm_new(chip->card, "Audiowerk2 analog playback", 0, 1, 0,
./sound/pci/aw2/aw2-alsa.c:603:		dev_err(chip->card->dev, "snd_pcm_new error (0x%X)\n", err);
./sound/pci/aw2/aw2-alsa.c:608:	pcm_device = &chip->device_playback[NUM_STREAM_PLAYBACK_ANA];
./sound/pci/aw2/aw2-alsa.c:630:						    (chip->pci),
./sound/pci/aw2/aw2-alsa.c:633:		dev_err(chip->card->dev,
./sound/pci/aw2/aw2-alsa.c:637:	err = snd_pcm_new(chip->card, "Audiowerk2 digital playback", 1, 1, 0,
./sound/pci/aw2/aw2-alsa.c:641:		dev_err(chip->card->dev, "snd_pcm_new error (0x%X)\n", err);
./sound/pci/aw2/aw2-alsa.c:645:	pcm_device = &chip->device_playback[NUM_STREAM_PLAYBACK_DIG];
./sound/pci/aw2/aw2-alsa.c:667:						    (chip->pci),
./sound/pci/aw2/aw2-alsa.c:670:		dev_err(chip->card->dev,
./sound/pci/aw2/aw2-alsa.c:674:	err = snd_pcm_new(chip->card, "Audiowerk2 capture", 2, 0, 1,
./sound/pci/aw2/aw2-alsa.c:678:		dev_err(chip->card->dev, "snd_pcm_new error (0x%X)\n", err);
./sound/pci/aw2/aw2-alsa.c:683:	pcm_device = &chip->device_capture[NUM_STREAM_CAPTURE_ANA];
./sound/pci/aw2/aw2-alsa.c:705:						    (chip->pci),
./sound/pci/aw2/aw2-alsa.c:708:		dev_err(chip->card->dev,
./sound/pci/aw2/aw2-alsa.c:714:	err = snd_ctl_add(chip->card, snd_ctl_new1(&aw2_control, chip));
./sound/pci/aw2/aw2-alsa.c:716:		dev_err(chip->card->dev, "snd_ctl_add error (0x%X)\n", err);
./sound/pci/aw2/aw2-alsa.c:737:	if (snd_aw2_saa7146_is_using_digital_input(&chip->saa7146))
./sound/pci/aw2/aw2-alsa.c:751:	    snd_aw2_saa7146_is_using_digital_input(&chip->saa7146);
./sound/pci/aw2/aw2-alsa.c:757:		snd_aw2_saa7146_use_digital_input(&chip->saa7146, !is_disgital);
./sound/pci/aw2/aw2-saa7146.c:41:#define WRITEREG(value, addr) writel((value), chip->base_addr + (addr))
./sound/pci/aw2/aw2-saa7146.c:42:#define READREG(addr) readl(chip->base_addr + (addr))
./sound/pci/aw2/aw2-saa7146.c:51:/* chip-specific destructor */
./sound/pci/aw2/aw2-saa7146.c:61:	chip->base_addr = NULL;
./sound/pci/aw2/aw2-saa7146.c:94:	chip->base_addr = pci_base_addr;
./sound/pci/hda/hda_intel.c:407:		if (chip->driver_type == AZX_DRIVER_CMEDIA)
./sound/pci/hda/hda_intel.c:476:	if (!(chip->driver_caps & AZX_DCAPS_NO_TCSEL)) {
./sound/pci/hda/hda_intel.c:477:		dev_dbg(chip->card->dev, "Clearing TCSEL\n");
./sound/pci/hda/hda_intel.c:478:		update_pci_byte(chip->pci, AZX_PCIREG_TCSEL, 0x07, 0);
./sound/pci/hda/hda_intel.c:485:		dev_dbg(chip->card->dev, "Setting ATI snoop: %d\n",
./sound/pci/hda/hda_intel.c:487:		update_pci_byte(chip->pci,
./sound/pci/hda/hda_intel.c:494:		dev_dbg(chip->card->dev, "Setting Nvidia snoop: %d\n",
./sound/pci/hda/hda_intel.c:496:		update_pci_byte(chip->pci,
./sound/pci/hda/hda_intel.c:499:		update_pci_byte(chip->pci,
./sound/pci/hda/hda_intel.c:502:		update_pci_byte(chip->pci,
./sound/pci/hda/hda_intel.c:510:		pci_read_config_word(chip->pci, INTEL_SCH_HDA_DEVC, &snoop);
./sound/pci/hda/hda_intel.c:516:			pci_write_config_word(chip->pci, INTEL_SCH_HDA_DEVC, snoop);
./sound/pci/hda/hda_intel.c:517:			pci_read_config_word(chip->pci,
./sound/pci/hda/hda_intel.c:520:		dev_dbg(chip->card->dev, "SCH snoop: %s\n",
./sound/pci/hda/hda_intel.c:545:	struct pci_dev *pci = chip->pci;
./sound/pci/hda/hda_intel.c:548:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
./sound/pci/hda/hda_intel.c:561:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
./sound/pci/hda/hda_intel.c:590:		dev_info(chip->card->dev,
./sound/pci/hda/hda_intel.c:594:		chip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;
./sound/pci/hda/hda_intel.c:595:		chip->get_delay[stream] = NULL;
./sound/pci/hda/hda_intel.c:649:	if (chip->get_position[stream])
./sound/pci/hda/hda_intel.c:650:		pos = chip->get_position[stream](chip, azx_dev);
./sound/pci/hda/hda_intel.c:654:			dev_info(chip->card->dev,
./sound/pci/hda/hda_intel.c:656:			chip->get_position[stream] = azx_get_pos_lpib;
./sound/pci/hda/hda_intel.c:657:			if (chip->get_position[0] == azx_get_pos_lpib &&
./sound/pci/hda/hda_intel.c:658:			    chip->get_position[1] == azx_get_pos_lpib)
./sound/pci/hda/hda_intel.c:661:			chip->get_delay[stream] = NULL;
./sound/pci/hda/hda_intel.c:663:			chip->get_position[stream] = azx_get_pos_posbuf;
./sound/pci/hda/hda_intel.c:664:			if (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)
./sound/pci/hda/hda_intel.c:665:				chip->get_delay[stream] = azx_get_delay_from_lpib;
./sound/pci/hda/hda_intel.c:678:		return chip->bdl_pos_adj ? 0 : -1;
./sound/pci/hda/hda_intel.c:695:		dev_info(chip->card->dev,
./sound/pci/hda/hda_intel.c:697:			 chip->card->number);
./sound/pci/hda/hda_intel.c:746:	if (request_irq(chip->pci->irq, azx_interrupt,
./sound/pci/hda/hda_intel.c:747:			chip->msi ? 0 : IRQF_SHARED,
./sound/pci/hda/hda_intel.c:748:			chip->card->irq_descr, chip)) {
./sound/pci/hda/hda_intel.c:749:		dev_err(chip->card->dev,
./sound/pci/hda/hda_intel.c:751:			chip->pci->irq);
./sound/pci/hda/hda_intel.c:753:			snd_card_disconnect(chip->card);
./sound/pci/hda/hda_intel.c:756:	bus->irq = chip->pci->irq;
./sound/pci/hda/hda_intel.c:757:	pci_intx(chip->pci, !chip->msi);
./sound/pci/hda/hda_intel.c:852:		if (!hda->probe_continued || chip->disabled)
./sound/pci/hda/hda_intel.c:854:		snd_hda_set_power_save(&chip->bus, power_save * 1000);
./sound/pci/hda/hda_intel.c:880:	if (chip->disabled || hda->init_failed || !chip->running)
./sound/pci/hda/hda_intel.c:893:	if (chip->msi)
./sound/pci/hda/hda_intel.c:894:		pci_disable_msi(chip->pci);
./sound/pci/hda/hda_intel.c:895:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL
./sound/pci/hda/hda_intel.c:917:	if (chip->disabled || hda->init_failed || !chip->running)
./sound/pci/hda/hda_intel.c:920:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
./sound/pci/hda/hda_intel.c:926:	if (chip->msi)
./sound/pci/hda/hda_intel.c:928:			chip->msi = 0;
./sound/pci/hda/hda_intel.c:936:	if ((chip->driver_caps & AZX_DCAPS_I915_POWERWELL) &&
./sound/pci/hda/hda_intel.c:984:	if (chip->disabled || hda->init_failed)
./sound/pci/hda/hda_intel.c:997:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL
./sound/pci/hda/hda_intel.c:1020:	if (chip->disabled || hda->init_failed)
./sound/pci/hda/hda_intel.c:1026:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
./sound/pci/hda/hda_intel.c:1039:		list_for_each_codec(codec, &chip->bus)
./sound/pci/hda/hda_intel.c:1050:	if ((chip->driver_caps & AZX_DCAPS_I915_POWERWELL) &&
./sound/pci/hda/hda_intel.c:1069:	if (chip->disabled || hda->init_failed)
./sound/pci/hda/hda_intel.c:1073:	    azx_bus(chip)->codec_powered || !chip->running)
./sound/pci/hda/hda_intel.c:1112:	if (chip->disabled == disabled)
./sound/pci/hda/hda_intel.c:1116:		chip->disabled = disabled;
./sound/pci/hda/hda_intel.c:1118:			dev_info(chip->card->dev,
./sound/pci/hda/hda_intel.c:1121:				dev_err(chip->card->dev, "initialization error\n");
./sound/pci/hda/hda_intel.c:1126:		dev_info(chip->card->dev, "%s via vga_switcheroo\n",
./sound/pci/hda/hda_intel.c:1135:			chip->disabled = true;
./sound/pci/hda/hda_intel.c:1136:			if (snd_hda_lock_devices(&chip->bus))
./sound/pci/hda/hda_intel.c:1137:				dev_warn(chip->card->dev,
./sound/pci/hda/hda_intel.c:1140:			snd_hda_unlock_devices(&chip->bus);
./sound/pci/hda/hda_intel.c:1142:			chip->disabled = false;
./sound/pci/hda/hda_intel.c:1157:	if (chip->disabled || !hda->probe_continued)
./sound/pci/hda/hda_intel.c:1159:	if (snd_hda_lock_devices(&chip->bus))
./sound/pci/hda/hda_intel.c:1161:	snd_hda_unlock_devices(&chip->bus);
./sound/pci/hda/hda_intel.c:1168:	struct pci_dev *p = get_bound_vga(chip->pci);
./sound/pci/hda/hda_intel.c:1170:		dev_info(chip->card->dev,
./sound/pci/hda/hda_intel.c:1192:	err = vga_switcheroo_register_audio_client(chip->pci, &azx_vs_ops,
./sound/pci/hda/hda_intel.c:1199:	vga_switcheroo_init_domain_pm_optimus_hdmi_audio(chip->card->dev,
./sound/pci/hda/hda_intel.c:1214:	struct pci_dev *pci = chip->pci;
./sound/pci/hda/hda_intel.c:1218:	if (azx_has_pm_runtime(chip) && chip->running)
./sound/pci/hda/hda_intel.c:1227:		if (chip->disabled && hda->probe_continued)
./sound/pci/hda/hda_intel.c:1228:			snd_hda_unlock_devices(&chip->bus);
./sound/pci/hda/hda_intel.c:1230:			vga_switcheroo_unregister_client(chip->pci);
./sound/pci/hda/hda_intel.c:1231:			vga_switcheroo_fini_domain_pm_ops(chip->card->dev);
./sound/pci/hda/hda_intel.c:1243:	if (chip->msi)
./sound/pci/hda/hda_intel.c:1244:		pci_disable_msi(chip->pci);
./sound/pci/hda/hda_intel.c:1251:	if (chip->region_requested)
./sound/pci/hda/hda_intel.c:1252:		pci_release_regions(chip->pci);
./sound/pci/hda/hda_intel.c:1254:	pci_disable_device(chip->pci);
./sound/pci/hda/hda_intel.c:1256:	release_firmware(chip->fw);
./sound/pci/hda/hda_intel.c:1259:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
./sound/pci/hda/hda_intel.c:1273:	chip->bus.shutdown = 1;
./sound/pci/hda/hda_intel.c:1357:	q = snd_pci_quirk_lookup(chip->pci, position_fix_list);
./sound/pci/hda/hda_intel.c:1359:		dev_info(chip->card->dev,
./sound/pci/hda/hda_intel.c:1366:	if (chip->driver_type == AZX_DRIVER_VIA) {
./sound/pci/hda/hda_intel.c:1367:		dev_dbg(chip->card->dev, "Using VIACOMBO position fix\n");
./sound/pci/hda/hda_intel.c:1370:	if (chip->driver_caps & AZX_DCAPS_POSFIX_LPIB) {
./sound/pci/hda/hda_intel.c:1371:		dev_dbg(chip->card->dev, "Using LPIB position fix\n");
./sound/pci/hda/hda_intel.c:1387:	chip->get_position[0] = chip->get_position[1] = callbacks[fix];
./sound/pci/hda/hda_intel.c:1391:		chip->get_position[1] = NULL;
./sound/pci/hda/hda_intel.c:1394:	    (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)) {
./sound/pci/hda/hda_intel.c:1395:		chip->get_delay[0] = chip->get_delay[1] =
./sound/pci/hda/hda_intel.c:1429:	chip->codec_probe_mask = probe_mask[dev];
./sound/pci/hda/hda_intel.c:1430:	if (chip->codec_probe_mask == -1) {
./sound/pci/hda/hda_intel.c:1431:		q = snd_pci_quirk_lookup(chip->pci, probe_mask_list);
./sound/pci/hda/hda_intel.c:1433:			dev_info(chip->card->dev,
./sound/pci/hda/hda_intel.c:1436:			chip->codec_probe_mask = q->value;
./sound/pci/hda/hda_intel.c:1441:	if (chip->codec_probe_mask != -1 &&
./sound/pci/hda/hda_intel.c:1442:	    (chip->codec_probe_mask & AZX_FORCE_CODEC_MASK)) {
./sound/pci/hda/hda_intel.c:1443:		azx_bus(chip)->codec_mask = chip->codec_probe_mask & 0xff;
./sound/pci/hda/hda_intel.c:1444:		dev_info(chip->card->dev, "codec_mask forced to 0x%x\n",
./sound/pci/hda/hda_intel.c:1471:		chip->msi = !!enable_msi;
./sound/pci/hda/hda_intel.c:1474:	chip->msi = 1;	/* enable MSI as default */
./sound/pci/hda/hda_intel.c:1475:	q = snd_pci_quirk_lookup(chip->pci, msi_black_list);
./sound/pci/hda/hda_intel.c:1477:		dev_info(chip->card->dev,
./sound/pci/hda/hda_intel.c:1480:		chip->msi = q->value;
./sound/pci/hda/hda_intel.c:1485:	if (chip->driver_caps & AZX_DCAPS_NO_MSI) {
./sound/pci/hda/hda_intel.c:1486:		dev_info(chip->card->dev, "Disabling MSI\n");
./sound/pci/hda/hda_intel.c:1487:		chip->msi = 0;
./sound/pci/hda/hda_intel.c:1497:		dev_info(chip->card->dev, "Force to %s mode by module option\n",
./sound/pci/hda/hda_intel.c:1499:		chip->snoop = snoop;
./sound/pci/hda/hda_intel.c:1505:	    chip->driver_type == AZX_DRIVER_VIA) {
./sound/pci/hda/hda_intel.c:1510:		pci_read_config_byte(chip->pci, 0x42, &val);
./sound/pci/hda/hda_intel.c:1511:		if (!(val & 0x80) && chip->pci->revision == 0x30)
./sound/pci/hda/hda_intel.c:1515:	if (chip->driver_caps & AZX_DCAPS_SNOOP_OFF)
./sound/pci/hda/hda_intel.c:1518:	chip->snoop = snoop;
./sound/pci/hda/hda_intel.c:1520:		dev_info(chip->card->dev, "Force to non-snoop mode\n");
./sound/pci/hda/hda_intel.c:1532:	if (chip->pci->vendor == PCI_VENDOR_ID_INTEL) {
./sound/pci/hda/hda_intel.c:1533:		switch (chip->pci->device) {
./sound/pci/hda/hda_intel.c:1540:	switch (chip->driver_type) {
./sound/pci/hda/hda_intel.c:1580:	mutex_init(&chip->open_mutex);
./sound/pci/hda/hda_intel.c:1581:	chip->card = card;
./sound/pci/hda/hda_intel.c:1582:	chip->pci = pci;
./sound/pci/hda/hda_intel.c:1583:	chip->ops = &pci_hda_ops;
./sound/pci/hda/hda_intel.c:1584:	chip->driver_caps = driver_caps;
./sound/pci/hda/hda_intel.c:1585:	chip->driver_type = driver_caps & 0xff;
./sound/pci/hda/hda_intel.c:1587:	chip->dev_index = dev;
./sound/pci/hda/hda_intel.c:1588:	chip->jackpoll_ms = jackpoll_ms;
./sound/pci/hda/hda_intel.c:1589:	INIT_LIST_HEAD(&chip->pcm_list);
./sound/pci/hda/hda_intel.c:1599:	chip->single_cmd = single_cmd;
./sound/pci/hda/hda_intel.c:1603:		chip->bdl_pos_adj = default_bdl_pos_adj(chip);
./sound/pci/hda/hda_intel.c:1605:		chip->bdl_pos_adj = bdl_pos_adj[dev];
./sound/pci/hda/hda_intel.c:1614:	if (chip->driver_type == AZX_DRIVER_NVIDIA) {
./sound/pci/hda/hda_intel.c:1615:		dev_dbg(chip->card->dev, "Enable delay in RIRB handling\n");
./sound/pci/hda/hda_intel.c:1616:		chip->bus.needs_damn_long_delay = 1;
./sound/pci/hda/hda_intel.c:1636:	int dev = chip->dev_index;
./sound/pci/hda/hda_intel.c:1637:	struct pci_dev *pci = chip->pci;
./sound/pci/hda/hda_intel.c:1638:	struct snd_card *card = chip->card;
./sound/pci/hda/hda_intel.c:1646:	if (chip->driver_type == AZX_DRIVER_ULI) {
./sound/pci/hda/hda_intel.c:1657:	chip->region_requested = 1;
./sound/pci/hda/hda_intel.c:1666:	if (chip->msi) {
./sound/pci/hda/hda_intel.c:1667:		if (chip->driver_caps & AZX_DCAPS_NO_MSI64) {
./sound/pci/hda/hda_intel.c:1672:			chip->msi = 0;
./sound/pci/hda/hda_intel.c:1685:	if (chip->pci->vendor == PCI_VENDOR_ID_AMD)
./sound/pci/hda/hda_intel.c:1689:	if (chip->pci->vendor == PCI_VENDOR_ID_ATI) {
./sound/pci/hda/hda_intel.c:1703:	if (chip->driver_caps & AZX_DCAPS_NO_64BIT) {
./sound/pci/hda/hda_intel.c:1710:		chip->align_buffer_size = !!align_buffer_size;
./sound/pci/hda/hda_intel.c:1712:		if (chip->driver_caps & AZX_DCAPS_NO_ALIGN_BUFSIZE)
./sound/pci/hda/hda_intel.c:1713:			chip->align_buffer_size = 0;
./sound/pci/hda/hda_intel.c:1715:			chip->align_buffer_size = 1;
./sound/pci/hda/hda_intel.c:1731:	chip->capture_streams = (gcap >> 8) & 0x0f;
./sound/pci/hda/hda_intel.c:1732:	chip->playback_streams = (gcap >> 12) & 0x0f;
./sound/pci/hda/hda_intel.c:1733:	if (!chip->playback_streams && !chip->capture_streams) {
./sound/pci/hda/hda_intel.c:1736:		switch (chip->driver_type) {
./sound/pci/hda/hda_intel.c:1738:			chip->playback_streams = ULI_NUM_PLAYBACK;
./sound/pci/hda/hda_intel.c:1739:			chip->capture_streams = ULI_NUM_CAPTURE;
./sound/pci/hda/hda_intel.c:1743:			chip->playback_streams = ATIHDMI_NUM_PLAYBACK;
./sound/pci/hda/hda_intel.c:1744:			chip->capture_streams = ATIHDMI_NUM_CAPTURE;
./sound/pci/hda/hda_intel.c:1748:			chip->playback_streams = ICH6_NUM_PLAYBACK;
./sound/pci/hda/hda_intel.c:1749:			chip->capture_streams = ICH6_NUM_CAPTURE;
./sound/pci/hda/hda_intel.c:1753:	chip->capture_index_offset = 0;
./sound/pci/hda/hda_intel.c:1754:	chip->playback_index_offset = chip->capture_streams;
./sound/pci/hda/hda_intel.c:1755:	chip->num_streams = chip->playback_streams + chip->capture_streams;
./sound/pci/hda/hda_intel.c:1769:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
./sound/pci/hda/hda_intel.c:1781:	strlcpy(card->shortname, driver_short_names[chip->driver_type],
./sound/pci/hda/hda_intel.c:1796:	struct pci_dev *pci = chip->pci;
./sound/pci/hda/hda_intel.c:1803:	chip->fw = fw;
./sound/pci/hda/hda_intel.c:1804:	if (!chip->disabled) {
./sound/pci/hda/hda_intel.c:1859:	pci_disable_msi(chip->pci);
./sound/pci/hda/hda_intel.c:1860:	chip->msi = 0;
./sound/pci/hda/hda_intel.c:1923:	if (!azx_snoop(chip) && chip->driver_type != AZX_DRIVER_CMEDIA)
./sound/pci/hda/hda_intel.c:1989:		chip->disabled = true;
./sound/pci/hda/hda_intel.c:1992:	schedule_probe = !chip->disabled;
./sound/pci/hda/hda_intel.c:2016:	if (chip->disabled)
./sound/pci/hda/hda_intel.c:2035:	struct pci_dev *pci = chip->pci;
./sound/pci/hda/hda_intel.c:2036:	int dev = chip->dev_index;
./sound/pci/hda/hda_intel.c:2046:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
./sound/pci/hda/hda_intel.c:2059:				dev_err(chip->card->dev,
./sound/pci/hda/hda_intel.c:2068:			dev_err(chip->card->dev,
./sound/pci/hda/hda_intel.c:2080:	chip->beep_mode = beep_mode[dev];
./sound/pci/hda/hda_intel.c:2084:	err = azx_probe_codecs(chip, azx_max_codecs[chip->driver_type]);
./sound/pci/hda/hda_intel.c:2089:	if (chip->fw) {
./sound/pci/hda/hda_intel.c:2090:		err = snd_hda_load_patch(&chip->bus, chip->fw->size,
./sound/pci/hda/hda_intel.c:2091:					 chip->fw->data);
./sound/pci/hda/hda_intel.c:2095:		release_firmware(chip->fw); /* no longer needed */
./sound/pci/hda/hda_intel.c:2096:		chip->fw = NULL;
./sound/pci/hda/hda_intel.c:2106:	err = snd_card_register(chip->card);
./sound/pci/hda/hda_intel.c:2110:	chip->running = 1;
./sound/pci/hda/hda_intel.c:2112:	snd_hda_set_power_save(&chip->bus, power_save * 1000);
./sound/pci/hda/hda_intel.c:2117:	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL
./sound/pci/hda/hda_intel.c:2152:	if (chip && chip->running)
./sound/pci/hda/hda_controller.c:99:	mutex_lock(&chip->open_mutex);
./sound/pci/hda/hda_controller.c:104:	mutex_unlock(&chip->open_mutex);
./sound/pci/hda/hda_controller.c:127:	ret = chip->ops->substream_alloc_pages(chip, substream,
./sound/pci/hda/hda_controller.c:149:	err = chip->ops->substream_free_pages(chip, substream);
./sound/pci/hda/hda_controller.c:182:		dev_err(chip->card->dev,
./sound/pci/hda/hda_controller.c:197:	if ((chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND) &&
./sound/pci/hda/hda_controller.c:198:	    stream_tag > chip->capture_streams)
./sound/pci/hda/hda_controller.c:199:		stream_tag -= chip->capture_streams;
./sound/pci/hda/hda_controller.c:226:	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
./sound/pci/hda/hda_controller.c:306:	if (chip->get_position[stream])
./sound/pci/hda/hda_controller.c:307:		pos = chip->get_position[stream](chip, azx_dev);
./sound/pci/hda/hda_controller.c:318:		if (chip->get_delay[stream])
./sound/pci/hda/hda_controller.c:319:			delay += chip->get_delay[stream](chip, azx_dev, pos);
./sound/pci/hda/hda_controller.c:407:	mutex_lock(&chip->open_mutex);
./sound/pci/hda/hda_controller.c:428:	if (chip->align_buffer_size)
./sound/pci/hda/hda_controller.c:477:	mutex_unlock(&chip->open_mutex);
./sound/pci/hda/hda_controller.c:483:	mutex_unlock(&chip->open_mutex);
./sound/pci/hda/hda_controller.c:493:	if (chip->ops->pcm_mmap_prepare)
./sound/pci/hda/hda_controller.c:494:		chip->ops->pcm_mmap_prepare(substream, area);
./sound/pci/hda/hda_controller.c:535:	list_for_each_entry(apcm, &chip->pcm_list, list) {
./sound/pci/hda/hda_controller.c:537:			dev_err(chip->card->dev, "PCM %d already exists\n",
./sound/pci/hda/hda_controller.c:542:	err = snd_pcm_new(chip->card, cpcm->name, pcm_dev,
./sound/pci/hda/hda_controller.c:560:	list_add_tail(&apcm->list, &chip->pcm_list);
./sound/pci/hda/hda_controller.c:571:					      chip->card->dev,
./sound/pci/hda/hda_controller.c:593:	struct hda_bus *hbus = &chip->bus;
./sound/pci/hda/hda_controller.c:603:		if (chip->polling_mode || do_poll)
./sound/pci/hda/hda_controller.c:607:				chip->poll_count = 0;
./sound/pci/hda/hda_controller.c:627:	if (!chip->polling_mode && chip->poll_count < 2) {
./sound/pci/hda/hda_controller.c:628:		dev_dbg(chip->card->dev,
./sound/pci/hda/hda_controller.c:632:		chip->poll_count++;
./sound/pci/hda/hda_controller.c:637:	if (!chip->polling_mode) {
./sound/pci/hda/hda_controller.c:638:		dev_warn(chip->card->dev,
./sound/pci/hda/hda_controller.c:641:		chip->polling_mode = 1;
./sound/pci/hda/hda_controller.c:645:	if (chip->msi) {
./sound/pci/hda/hda_controller.c:646:		dev_warn(chip->card->dev,
./sound/pci/hda/hda_controller.c:649:		if (chip->ops->disable_msi_reset_irq &&
./sound/pci/hda/hda_controller.c:650:		    chip->ops->disable_msi_reset_irq(chip) < 0)
./sound/pci/hda/hda_controller.c:655:	if (chip->probing) {
./sound/pci/hda/hda_controller.c:671:	dev_err(chip->card->dev,
./sound/pci/hda/hda_controller.c:674:	chip->single_cmd = 1;
./sound/pci/hda/hda_controller.c:705:		dev_dbg(chip->card->dev, "get_response timeout: IRS=0x%x\n",
./sound/pci/hda/hda_controller.c:733:		dev_dbg(chip->card->dev,
./sound/pci/hda/hda_controller.c:752: * current setting of chip->single_cmd.
./sound/pci/hda/hda_controller.c:760:	if (chip->disabled)
./sound/pci/hda/hda_controller.c:762:	if (chip->single_cmd)
./sound/pci/hda/hda_controller.c:774:	if (chip->disabled)
./sound/pci/hda/hda_controller.c:776:	if (chip->single_cmd)
./sound/pci/hda/hda_controller.c:786:	if (chip->ops->link_power)
./sound/pci/hda/hda_controller.c:787:		return chip->ops->link_power(chip, enable);
./sound/pci/hda/hda_controller.c:811:		if (s->index == chip->playback_index_offset)
./sound/pci/hda/hda_controller.c:832:		chip->saved_azx_dev = *azx_dev;
./sound/pci/hda/hda_controller.c:841:			*azx_dev = chip->saved_azx_dev;
./sound/pci/hda/hda_controller.c:875:		*azx_dev = chip->saved_azx_dev;
./sound/pci/hda/hda_controller.c:889:		if (chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND)
./sound/pci/hda/hda_controller.c:920:	if (!chip->ops->position_check ||
./sound/pci/hda/hda_controller.c:921:	    chip->ops->position_check(chip, azx_dev)) {
./sound/pci/hda/hda_controller.c:938:		if (!pm_runtime_active(chip->card->dev))
./sound/pci/hda/hda_controller.c:944:	if (chip->disabled)
./sound/pci/hda/hda_controller.c:962:				if (chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND)
./sound/pci/hda/hda_controller.c:993:	chip->probing = 1;
./sound/pci/hda/hda_controller.c:996:	chip->probing = 0;
./sound/pci/hda/hda_controller.c:1000:	dev_dbg(chip->card->dev, "codec #%d probed OK\n", addr);
./sound/pci/hda/hda_controller.c:1021:	if (!chip->jackpoll_ms)
./sound/pci/hda/hda_controller.c:1024:	i = chip->jackpoll_ms[chip->dev_index];
./sound/pci/hda/hda_controller.c:1032:		dev_warn(chip->card->dev,
./sound/pci/hda/hda_controller.c:1041:	struct hda_bus *bus = &chip->bus;
./sound/pci/hda/hda_controller.c:1044:	err = snd_hdac_bus_init(&bus->core, chip->card->dev, &bus_core_ops,
./sound/pci/hda/hda_controller.c:1049:	bus->card = chip->card;
./sound/pci/hda/hda_controller.c:1051:	bus->pci = chip->pci;
./sound/pci/hda/hda_controller.c:1055:	if (chip->get_position[0] != azx_get_pos_lpib ||
./sound/pci/hda/hda_controller.c:1056:	    chip->get_position[1] != azx_get_pos_lpib)
./sound/pci/hda/hda_controller.c:1058:	bus->core.bdl_pos_adj = chip->bdl_pos_adj;
./sound/pci/hda/hda_controller.c:1059:	if (chip->driver_caps & AZX_DCAPS_CORBRP_SELF_CLEAR)
./sound/pci/hda/hda_controller.c:1062:	if (chip->driver_caps & AZX_DCAPS_4K_BDLE_BOUNDARY)
./sound/pci/hda/hda_controller.c:1069:	if (chip->driver_caps & AZX_DCAPS_SYNC_WRITE) {
./sound/pci/hda/hda_controller.c:1070:		dev_dbg(chip->card->dev, "Enable sync_write for stable communication\n");
./sound/pci/hda/hda_controller.c:1091:		if ((bus->codec_mask & (1 << c)) & chip->codec_probe_mask) {
./sound/pci/hda/hda_controller.c:1096:				dev_warn(chip->card->dev,
./sound/pci/hda/hda_controller.c:1114:		if ((bus->codec_mask & (1 << c)) & chip->codec_probe_mask) {
./sound/pci/hda/hda_controller.c:1116:			err = snd_hda_codec_new(&chip->bus, chip->card, c, &codec);
./sound/pci/hda/hda_controller.c:1120:			codec->beep_mode = chip->beep_mode;
./sound/pci/hda/hda_controller.c:1125:		dev_err(chip->card->dev, "no codecs initialized\n");
./sound/pci/hda/hda_controller.c:1136:	list_for_each_codec(codec, &chip->bus) {
./sound/pci/hda/hda_controller.c:1145:	if (index >= chip->capture_index_offset &&
./sound/pci/hda/hda_controller.c:1146:	    index < chip->capture_index_offset + chip->capture_streams)
./sound/pci/hda/hda_controller.c:1161:	for (i = 0; i < chip->num_streams; i++) {
./sound/pci/hda/hda_controller.c:1175:		if (chip->driver_caps & AZX_DCAPS_SEPARATE_STREAM_TAG)
./sound/pci/hda/hda_tegra.c:288:	chip->bus.shutdown = 1;
./sound/pci/hda/hda_tegra.c:359:	struct snd_card *card = chip->card;
./sound/pci/hda/hda_tegra.c:368:	err = devm_request_irq(chip->card->dev, irq_id, azx_interrupt,
./sound/pci/hda/hda_tegra.c:371:		dev_err(chip->card->dev,
./sound/pci/hda/hda_tegra.c:386:	chip->capture_streams = (gcap >> 8) & 0x0f;
./sound/pci/hda/hda_tegra.c:387:	chip->playback_streams = (gcap >> 12) & 0x0f;
./sound/pci/hda/hda_tegra.c:388:	if (!chip->playback_streams && !chip->capture_streams) {
./sound/pci/hda/hda_tegra.c:390:		chip->playback_streams = NUM_PLAYBACK_SD;
./sound/pci/hda/hda_tegra.c:391:		chip->capture_streams = NUM_CAPTURE_SD;
./sound/pci/hda/hda_tegra.c:393:	chip->capture_index_offset = 0;
./sound/pci/hda/hda_tegra.c:394:	chip->playback_index_offset = chip->capture_streams;
./sound/pci/hda/hda_tegra.c:395:	chip->num_streams = chip->playback_streams + chip->capture_streams;
./sound/pci/hda/hda_tegra.c:448:	mutex_init(&chip->open_mutex);
./sound/pci/hda/hda_tegra.c:449:	chip->card = card;
./sound/pci/hda/hda_tegra.c:450:	chip->ops = &hda_tegra_ops;
./sound/pci/hda/hda_tegra.c:451:	chip->driver_caps = driver_caps;
./sound/pci/hda/hda_tegra.c:452:	chip->driver_type = driver_caps & 0xff;
./sound/pci/hda/hda_tegra.c:453:	chip->dev_index = 0;
./sound/pci/hda/hda_tegra.c:454:	INIT_LIST_HEAD(&chip->pcm_list);
./sound/pci/hda/hda_tegra.c:456:	chip->codec_probe_mask = -1;
./sound/pci/hda/hda_tegra.c:458:	chip->single_cmd = false;
./sound/pci/hda/hda_tegra.c:459:	chip->snoop = true;
./sound/pci/hda/hda_tegra.c:467:	chip->bus.needs_damn_long_delay = 1;
./sound/pci/hda/hda_tegra.c:540:	err = snd_card_register(chip->card);
./sound/pci/hda/hda_tegra.c:544:	chip->running = 1;
./sound/pci/hda/hda_tegra.c:545:	snd_hda_set_power_save(&chip->bus, power_save * 1000);
./sound/pci/hda/hda_tegra.c:564:	if (chip && chip->running)
./sound/pci/fm801.c:76:#define fm801_writew(chip,reg,value)	outw((value), chip->port + FM801_##reg)
./sound/pci/fm801.c:77:#define fm801_readw(chip,reg)		inw(chip->port + FM801_##reg)
./sound/pci/fm801.c:79:#define fm801_writel(chip,reg,value)	outl((value), chip->port + FM801_##reg)
./sound/pci/fm801.c:221:	outw(value, chip->port + offset);
./sound/pci/fm801.c:226:	return inw(chip->port + offset);
./sound/pci/fm801.c:272:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/fm801.c:278:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/fm801.c:292:		dev_err(chip->card->dev, "AC'97 interface is busy (1)\n");
./sound/pci/fm801.c:303:		dev_err(chip->card->dev, "AC'97 interface #%d is busy (2)\n",
./sound/pci/fm801.c:315:		dev_err(chip->card->dev, "AC'97 interface is busy (1)\n");
./sound/pci/fm801.c:323:		dev_err(chip->card->dev, "AC'97 interface #%d is busy (2)\n",
./sound/pci/fm801.c:329:		dev_err(chip->card->dev,
./sound/pci/fm801.c:383:	spin_lock(&chip->reg_lock);
./sound/pci/fm801.c:386:		chip->ply_ctrl &= ~(FM801_BUF1_LAST |
./sound/pci/fm801.c:389:		chip->ply_ctrl |= FM801_START |
./sound/pci/fm801.c:393:		chip->ply_ctrl &= ~(FM801_START | FM801_PAUSE);
./sound/pci/fm801.c:397:		chip->ply_ctrl |= FM801_PAUSE;
./sound/pci/fm801.c:401:		chip->ply_ctrl &= ~FM801_PAUSE;
./sound/pci/fm801.c:404:		spin_unlock(&chip->reg_lock);
./sound/pci/fm801.c:408:	fm801_writew(chip, PLY_CTRL, chip->ply_ctrl);
./sound/pci/fm801.c:409:	spin_unlock(&chip->reg_lock);
./sound/pci/fm801.c:418:	spin_lock(&chip->reg_lock);
./sound/pci/fm801.c:421:		chip->cap_ctrl &= ~(FM801_BUF1_LAST |
./sound/pci/fm801.c:424:		chip->cap_ctrl |= FM801_START |
./sound/pci/fm801.c:428:		chip->cap_ctrl &= ~(FM801_START | FM801_PAUSE);
./sound/pci/fm801.c:432:		chip->cap_ctrl |= FM801_PAUSE;
./sound/pci/fm801.c:436:		chip->cap_ctrl &= ~FM801_PAUSE;
./sound/pci/fm801.c:439:		spin_unlock(&chip->reg_lock);
./sound/pci/fm801.c:443:	fm801_writew(chip, CAP_CTRL, chip->cap_ctrl);
./sound/pci/fm801.c:444:	spin_unlock(&chip->reg_lock);
./sound/pci/fm801.c:464:	chip->ply_size = snd_pcm_lib_buffer_bytes(substream);
./sound/pci/fm801.c:465:	chip->ply_count = snd_pcm_lib_period_bytes(substream);
./sound/pci/fm801.c:466:	spin_lock_irq(&chip->reg_lock);
./sound/pci/fm801.c:467:	chip->ply_ctrl &= ~(FM801_START | FM801_16BIT |
./sound/pci/fm801.c:471:		chip->ply_ctrl |= FM801_16BIT;
./sound/pci/fm801.c:473:		chip->ply_ctrl |= FM801_STEREO;
./sound/pci/fm801.c:475:			chip->ply_ctrl |= FM801_CHANNELS_4;
./sound/pci/fm801.c:477:			chip->ply_ctrl |= FM801_CHANNELS_6;
./sound/pci/fm801.c:479:	chip->ply_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;
./sound/pci/fm801.c:480:	chip->ply_buf = 0;
./sound/pci/fm801.c:481:	fm801_writew(chip, PLY_CTRL, chip->ply_ctrl);
./sound/pci/fm801.c:482:	fm801_writew(chip, PLY_COUNT, chip->ply_count - 1);
./sound/pci/fm801.c:483:	chip->ply_buffer = runtime->dma_addr;
./sound/pci/fm801.c:484:	chip->ply_pos = 0;
./sound/pci/fm801.c:485:	fm801_writel(chip, PLY_BUF1, chip->ply_buffer);
./sound/pci/fm801.c:487:		     chip->ply_buffer + (chip->ply_count % chip->ply_size));
./sound/pci/fm801.c:488:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/fm801.c:497:	chip->cap_size = snd_pcm_lib_buffer_bytes(substream);
./sound/pci/fm801.c:498:	chip->cap_count = snd_pcm_lib_period_bytes(substream);
./sound/pci/fm801.c:499:	spin_lock_irq(&chip->reg_lock);
./sound/pci/fm801.c:500:	chip->cap_ctrl &= ~(FM801_START | FM801_16BIT |
./sound/pci/fm801.c:503:		chip->cap_ctrl |= FM801_16BIT;
./sound/pci/fm801.c:505:		chip->cap_ctrl |= FM801_STEREO;
./sound/pci/fm801.c:506:	chip->cap_ctrl |= snd_fm801_rate_bits(runtime->rate) << FM801_RATE_SHIFT;
./sound/pci/fm801.c:507:	chip->cap_buf = 0;
./sound/pci/fm801.c:508:	fm801_writew(chip, CAP_CTRL, chip->cap_ctrl);
./sound/pci/fm801.c:509:	fm801_writew(chip, CAP_COUNT, chip->cap_count - 1);
./sound/pci/fm801.c:510:	chip->cap_buffer = runtime->dma_addr;
./sound/pci/fm801.c:511:	chip->cap_pos = 0;
./sound/pci/fm801.c:512:	fm801_writel(chip, CAP_BUF1, chip->cap_buffer);
./sound/pci/fm801.c:514:		     chip->cap_buffer + (chip->cap_count % chip->cap_size));
./sound/pci/fm801.c:515:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/fm801.c:524:	if (!(chip->ply_ctrl & FM801_START))
./sound/pci/fm801.c:526:	spin_lock(&chip->reg_lock);
./sound/pci/fm801.c:527:	ptr = chip->ply_pos + (chip->ply_count - 1) - fm801_readw(chip, PLY_COUNT);
./sound/pci/fm801.c:529:		ptr += chip->ply_count;
./sound/pci/fm801.c:530:		ptr %= chip->ply_size;
./sound/pci/fm801.c:532:	spin_unlock(&chip->reg_lock);
./sound/pci/fm801.c:541:	if (!(chip->cap_ctrl & FM801_START))
./sound/pci/fm801.c:543:	spin_lock(&chip->reg_lock);
./sound/pci/fm801.c:544:	ptr = chip->cap_pos + (chip->cap_count - 1) - fm801_readw(chip, CAP_COUNT);
./sound/pci/fm801.c:546:		ptr += chip->cap_count;
./sound/pci/fm801.c:547:		ptr %= chip->cap_size;
./sound/pci/fm801.c:549:	spin_unlock(&chip->reg_lock);
./sound/pci/fm801.c:565:	if (chip->pcm && (status & FM801_IRQ_PLAYBACK) && chip->playback_substream) {
./sound/pci/fm801.c:566:		spin_lock(&chip->reg_lock);
./sound/pci/fm801.c:567:		chip->ply_buf++;
./sound/pci/fm801.c:568:		chip->ply_pos += chip->ply_count;
./sound/pci/fm801.c:569:		chip->ply_pos %= chip->ply_size;
./sound/pci/fm801.c:570:		tmp = chip->ply_pos + chip->ply_count;
./sound/pci/fm801.c:571:		tmp %= chip->ply_size;
./sound/pci/fm801.c:572:		if (chip->ply_buf & 1)
./sound/pci/fm801.c:573:			fm801_writel(chip, PLY_BUF1, chip->ply_buffer + tmp);
./sound/pci/fm801.c:575:			fm801_writel(chip, PLY_BUF2, chip->ply_buffer + tmp);
./sound/pci/fm801.c:576:		spin_unlock(&chip->reg_lock);
./sound/pci/fm801.c:577:		snd_pcm_period_elapsed(chip->playback_substream);
./sound/pci/fm801.c:579:	if (chip->pcm && (status & FM801_IRQ_CAPTURE) && chip->capture_substream) {
./sound/pci/fm801.c:580:		spin_lock(&chip->reg_lock);
./sound/pci/fm801.c:581:		chip->cap_buf++;
./sound/pci/fm801.c:582:		chip->cap_pos += chip->cap_count;
./sound/pci/fm801.c:583:		chip->cap_pos %= chip->cap_size;
./sound/pci/fm801.c:584:		tmp = chip->cap_pos + chip->cap_count;
./sound/pci/fm801.c:585:		tmp %= chip->cap_size;
./sound/pci/fm801.c:586:		if (chip->cap_buf & 1)
./sound/pci/fm801.c:587:			fm801_writel(chip, CAP_BUF1, chip->cap_buffer + tmp);
./sound/pci/fm801.c:589:			fm801_writel(chip, CAP_BUF2, chip->cap_buffer + tmp);
./sound/pci/fm801.c:590:		spin_unlock(&chip->reg_lock);
./sound/pci/fm801.c:591:		snd_pcm_period_elapsed(chip->capture_substream);
./sound/pci/fm801.c:593:	if (chip->rmidi && (status & FM801_IRQ_MPU))
./sound/pci/fm801.c:594:		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
./sound/pci/fm801.c:648:	chip->playback_substream = substream;
./sound/pci/fm801.c:652:	if (chip->multichannel) {
./sound/pci/fm801.c:669:	chip->capture_substream = substream;
./sound/pci/fm801.c:682:	chip->playback_substream = NULL;
./sound/pci/fm801.c:690:	chip->capture_substream = NULL;
./sound/pci/fm801.c:718:	struct pci_dev *pdev = to_pci_dev(chip->dev);
./sound/pci/fm801.c:722:	if ((err = snd_pcm_new(chip->card, "FM801", device, 1, 1, &pcm)) < 0)
./sound/pci/fm801.c:731:	chip->pcm = pcm;
./sound/pci/fm801.c:735:					      chip->multichannel ? 128*1024 : 64*1024, 128*1024);
./sound/pci/fm801.c:739:				     chip->multichannel ? 6 : 2, 0,
./sound/pci/fm801.c:929:	spin_lock_irq(&chip->reg_lock);
./sound/pci/fm801.c:932:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/fm801.c:1033:	chip->ac97_bus = NULL;
./sound/pci/fm801.c:1040:		chip->ac97 = NULL;
./sound/pci/fm801.c:1042:		chip->ac97_sec = NULL;
./sound/pci/fm801.c:1056:	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)
./sound/pci/fm801.c:1058:	chip->ac97_bus->private_free = snd_fm801_mixer_free_ac97_bus;
./sound/pci/fm801.c:1063:	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
./sound/pci/fm801.c:1065:	if (chip->secondary) {
./sound/pci/fm801.c:1067:		ac97.addr = chip->secondary_addr;
./sound/pci/fm801.c:1068:		if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97_sec)) < 0)
./sound/pci/fm801.c:1072:		snd_ctl_add(chip->card, snd_ctl_new1(&snd_fm801_controls[i], chip));
./sound/pci/fm801.c:1073:	if (chip->multichannel) {
./sound/pci/fm801.c:1075:			snd_ctl_add(chip->card, snd_ctl_new1(&snd_fm801_controls_multi[i], chip));
./sound/pci/fm801.c:1116:	if (chip->multichannel) {
./sound/pci/fm801.c:1117:		if (chip->secondary_addr) {
./sound/pci/fm801.c:1118:			wait_for_codec(chip, chip->secondary_addr,
./sound/pci/fm801.c:1129:						chip->secondary = 1;
./sound/pci/fm801.c:1130:						chip->secondary_addr = i;
./sound/pci/fm801.c:1157:	if (chip->irq < 0)
./sound/pci/fm801.c:1172:	if (chip->irq < 0)
./sound/pci/fm801.c:1180:	devm_free_irq(chip->dev, chip->irq, chip);
./sound/pci/fm801.c:1184:	if (!(chip->tea575x_tuner & TUNER_DISABLED)) {
./sound/pci/fm801.c:1185:		snd_tea575x_exit(&chip->tea);
./sound/pci/fm801.c:1186:		v4l2_device_unregister(&chip->v4l2_dev);
./sound/pci/fm801.c:1216:	spin_lock_init(&chip->reg_lock);
./sound/pci/fm801.c:1217:	chip->card = card;
./sound/pci/fm801.c:1218:	chip->dev = &pci->dev;
./sound/pci/fm801.c:1219:	chip->irq = -1;
./sound/pci/fm801.c:1220:	chip->tea575x_tuner = tea575x_tuner;
./sound/pci/fm801.c:1223:	chip->port = pci_resource_start(pci, 0);
./sound/pci/fm801.c:1226:		chip->multichannel = 1;
./sound/pci/fm801.c:1228:	if (!(chip->tea575x_tuner & TUNER_ONLY)) {
./sound/pci/fm801.c:1230:			dev_info(chip->card->dev,
./sound/pci/fm801.c:1232:			chip->tea575x_tuner = 3 | TUNER_ONLY;
./sound/pci/fm801.c:1240:	if ((chip->tea575x_tuner & TUNER_ONLY) == 0) {
./sound/pci/fm801.c:1247:		chip->irq = pci->irq;
./sound/pci/fm801.c:1257:	err = v4l2_device_register(&pci->dev, &chip->v4l2_dev);
./sound/pci/fm801.c:1262:	chip->tea.v4l2_dev = &chip->v4l2_dev;
./sound/pci/fm801.c:1263:	chip->tea.radio_nr = radio_nr;
./sound/pci/fm801.c:1264:	chip->tea.private_data = chip;
./sound/pci/fm801.c:1265:	chip->tea.ops = &snd_fm801_tea_ops;
./sound/pci/fm801.c:1266:	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
./sound/pci/fm801.c:1267:	if ((chip->tea575x_tuner & TUNER_TYPE_MASK) > 0 &&
./sound/pci/fm801.c:1268:	    (chip->tea575x_tuner & TUNER_TYPE_MASK) < 4) {
./sound/pci/fm801.c:1269:		if (snd_tea575x_init(&chip->tea, THIS_MODULE)) {
./sound/pci/fm801.c:1274:	} else if ((chip->tea575x_tuner & TUNER_TYPE_MASK) == 0) {
./sound/pci/fm801.c:1275:		unsigned int tuner_only = chip->tea575x_tuner & TUNER_ONLY;
./sound/pci/fm801.c:1279:			chip->tea575x_tuner = tea575x_tuner;
./sound/pci/fm801.c:1280:			if (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {
./sound/pci/fm801.c:1289:			chip->tea575x_tuner = TUNER_DISABLED;
./sound/pci/fm801.c:1292:		chip->tea575x_tuner |= tuner_only;
./sound/pci/fm801.c:1294:	if (!(chip->tea575x_tuner & TUNER_DISABLED)) {
./sound/pci/fm801.c:1295:		strlcpy(chip->tea.card, get_tea575x_gpio(chip)->name,
./sound/pci/fm801.c:1296:			sizeof(chip->tea.card));
./sound/pci/fm801.c:1332:	strcat(card->shortname, chip->multichannel ? "AU" : "AS");
./sound/pci/fm801.c:1334:		card->shortname, chip->port, chip->irq);
./sound/pci/fm801.c:1336:	if (chip->tea575x_tuner & TUNER_ONLY)
./sound/pci/fm801.c:1348:				       chip->port + FM801_MPU401_DATA,
./sound/pci/fm801.c:1351:				       -1, &chip->rmidi)) < 0) {
./sound/pci/fm801.c:1355:	if ((err = snd_opl3_create(card, chip->port + FM801_OPL3_BANK0,
./sound/pci/fm801.c:1356:				   chip->port + FM801_OPL3_BANK1,
./sound/pci/fm801.c:1398:		chip->saved_regs[i] = fm801_ioread16(chip, saved_regs[i]);
./sound/pci/fm801.c:1400:	if (chip->tea575x_tuner & TUNER_ONLY) {
./sound/pci/fm801.c:1403:		snd_pcm_suspend_all(chip->pcm);
./sound/pci/fm801.c:1404:		snd_ac97_suspend(chip->ac97);
./sound/pci/fm801.c:1405:		snd_ac97_suspend(chip->ac97_sec);
./sound/pci/fm801.c:1417:	if (chip->tea575x_tuner & TUNER_ONLY) {
./sound/pci/fm801.c:1423:		snd_ac97_resume(chip->ac97);
./sound/pci/fm801.c:1424:		snd_ac97_resume(chip->ac97_sec);
./sound/pci/fm801.c:1428:		fm801_iowrite16(chip, saved_regs[i], chip->saved_regs[i]);
./sound/pci/fm801.c:1431:	if (!(chip->tea575x_tuner & TUNER_DISABLED))
./sound/pci/fm801.c:1432:		snd_tea575x_set_freq(&chip->tea);
./sound/pci/ad1889.c:112:	return readw(chip->iobase + reg);
./sound/pci/ad1889.c:118:	writew(val, chip->iobase + reg);
./sound/pci/ad1889.c:124:	return readl(chip->iobase + reg);
./sound/pci/ad1889.c:130:	writel(val, chip->iobase + reg);
./sound/pci/ad1889.c:203:		chip->wave.reg = reg;
./sound/pci/ad1889.c:224:		chip->ramc.reg = reg;
./sound/pci/ad1889.c:263:		dev_err(chip->card->dev, "[%s] Link is not ready.\n",
./sound/pci/ad1889.c:267:	dev_dbg(chip->card->dev, "[%s] ready after %d ms\n", __func__, 400 - retry);
./sound/pci/ad1889.c:326:	chip->psubs = ss;
./sound/pci/ad1889.c:338:	chip->csubs = ss;
./sound/pci/ad1889.c:348:	chip->psubs = NULL;
./sound/pci/ad1889.c:356:	chip->csubs = NULL;
./sound/pci/ad1889.c:383:	spin_lock_irq(&chip->lock);
./sound/pci/ad1889.c:385:	chip->wave.size = size;
./sound/pci/ad1889.c:386:	chip->wave.reg = reg;
./sound/pci/ad1889.c:387:	chip->wave.addr = rt->dma_addr;
./sound/pci/ad1889.c:389:	ad1889_writew(chip, AD_DS_WSMC, chip->wave.reg);
./sound/pci/ad1889.c:395:	ad1889_load_wave_buffer_address(chip, chip->wave.addr);
./sound/pci/ad1889.c:402:	spin_unlock_irq(&chip->lock);
./sound/pci/ad1889.c:404:	dev_dbg(chip->card->dev,
./sound/pci/ad1889.c:406:		chip->wave.addr, count, size, reg, rt->rate);
./sound/pci/ad1889.c:433:	spin_lock_irq(&chip->lock);
./sound/pci/ad1889.c:435:	chip->ramc.size = size;
./sound/pci/ad1889.c:436:	chip->ramc.reg = reg;
./sound/pci/ad1889.c:437:	chip->ramc.addr = rt->dma_addr;
./sound/pci/ad1889.c:439:	ad1889_writew(chip, AD_DS_RAMC, chip->ramc.reg);
./sound/pci/ad1889.c:442:	ad1889_load_adc_buffer_address(chip, chip->ramc.addr);
./sound/pci/ad1889.c:449:	spin_unlock_irq(&chip->lock);
./sound/pci/ad1889.c:451:	dev_dbg(chip->card->dev,
./sound/pci/ad1889.c:453:		chip->ramc.addr, count, size, reg, rt->rate);
./sound/pci/ad1889.c:487:	chip->wave.reg = wsmc;
./sound/pci/ad1889.c:525:	chip->ramc.reg = ramc;
./sound/pci/ad1889.c:543:	if (unlikely(!(chip->wave.reg & AD_DS_WSMC_WAEN)))
./sound/pci/ad1889.c:547:	ptr -= chip->wave.addr;
./sound/pci/ad1889.c:549:	if (snd_BUG_ON(ptr >= chip->wave.size))
./sound/pci/ad1889.c:562:	if (unlikely(!(chip->ramc.reg & AD_DS_RAMC_ADEN)))
./sound/pci/ad1889.c:566:	ptr -= chip->ramc.addr;
./sound/pci/ad1889.c:568:	if (snd_BUG_ON(ptr >= chip->ramc.size))
./sound/pci/ad1889.c:613:		dev_dbg(chip->card->dev,
./sound/pci/ad1889.c:616:	if ((st & AD_DMA_DISR_WAVI) && chip->psubs)
./sound/pci/ad1889.c:617:		snd_pcm_period_elapsed(chip->psubs);
./sound/pci/ad1889.c:618:	if ((st & AD_DMA_DISR_ADCI) && chip->csubs)
./sound/pci/ad1889.c:619:		snd_pcm_period_elapsed(chip->csubs);
./sound/pci/ad1889.c:630:	err = snd_pcm_new(chip->card, chip->card->driver, device, 1, 1, &pcm);
./sound/pci/ad1889.c:641:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/ad1889.c:643:	chip->pcm = pcm;
./sound/pci/ad1889.c:644:	chip->psubs = NULL;
./sound/pci/ad1889.c:645:	chip->csubs = NULL;
./sound/pci/ad1889.c:648:						snd_dma_pci_data(chip->pci),
./sound/pci/ad1889.c:653:		dev_err(chip->card->dev, "buffer allocation error: %d\n", err);
./sound/pci/ad1889.c:746:	if (!snd_card_proc_new(chip->card, chip->card->driver, &entry))
./sound/pci/ad1889.c:789:	chip->ac97_bus = NULL;
./sound/pci/ad1889.c:796:	chip->ac97 = NULL;
./sound/pci/ad1889.c:812:	err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus);
./sound/pci/ad1889.c:816:	chip->ac97_bus->private_free = snd_ad1889_ac97_bus_free;
./sound/pci/ad1889.c:821:	ac97.pci = chip->pci;
./sound/pci/ad1889.c:823:	err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97);
./sound/pci/ad1889.c:827:	snd_ac97_tune_hardware(chip->ac97, ac97_quirks, quirk_override);
./sound/pci/ad1889.c:835:	if (chip->irq < 0)
./sound/pci/ad1889.c:838:	spin_lock_irq(&chip->lock);
./sound/pci/ad1889.c:849:	spin_unlock_irq(&chip->lock);
./sound/pci/ad1889.c:851:	if (chip->irq >= 0)
./sound/pci/ad1889.c:852:		free_irq(chip->irq, chip);
./sound/pci/ad1889.c:855:	iounmap(chip->iobase);
./sound/pci/ad1889.c:856:	pci_release_regions(chip->pci);
./sound/pci/ad1889.c:857:	pci_disable_device(chip->pci);
./sound/pci/ad1889.c:914:	chip->card = card;
./sound/pci/ad1889.c:916:	chip->pci = pci;
./sound/pci/ad1889.c:917:	chip->irq = -1;
./sound/pci/ad1889.c:923:	chip->bar = pci_resource_start(pci, 0);
./sound/pci/ad1889.c:924:	chip->iobase = pci_ioremap_bar(pci, 0);
./sound/pci/ad1889.c:925:	if (chip->iobase == NULL) {
./sound/pci/ad1889.c:933:	spin_lock_init(&chip->lock);	/* only now can we call ad1889_free */
./sound/pci/ad1889.c:942:	chip->irq = pci->irq;
./sound/pci/ad1889.c:943:	synchronize_irq(chip->irq);
./sound/pci/ad1889.c:1001:		card->shortname, chip->bar, chip->irq);
./sound/pci/ali5451/ali5451.c:1571:	unsigned int modem_num = chip->num_of_codecs - 1;
./sound/pci/ali5451/ali5451.c:1572:	snd_ac97_write(chip->ac97[modem_num], AC97_LINE1_RATE,
./sound/pci/ali5451/ali5451.c:1574:	snd_ac97_write(chip->ac97[modem_num], AC97_LINE1_LEVEL, 0);
./sound/pci/ali5451/ali5451.c:1881:	im = chip->image;
./sound/pci/ali5451/ali5451.c:1886:	for (i = 0; i < chip->num_of_codecs; i++) {
./sound/pci/ali5451/ali5451.c:1887:		snd_pcm_suspend_all(chip->pcm[i]);
./sound/pci/ali5451/ali5451.c:1888:		snd_ac97_suspend(chip->ac97[i]);
./sound/pci/ali5451/ali5451.c:1891:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ali5451/ali5451.c:1915:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ali5451/ali5451.c:1926:	im = chip->image;
./sound/pci/ali5451/ali5451.c:1930:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ali5451/ali5451.c:1950:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ali5451/ali5451.c:1952:	for (i = 0 ; i < chip->num_of_codecs; i++)
./sound/pci/ali5451/ali5451.c:1953:		snd_ac97_resume(chip->ac97[i]);
./sound/pci/es1968.c:592:	outw(reg, chip->io_port + ESM_INDEX);
./sound/pci/es1968.c:593:	outw(data, chip->io_port + ESM_DATA);
./sound/pci/es1968.c:594:	chip->maestro_map[reg] = data;
./sound/pci/es1968.c:600:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:602:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:609:		outw(reg, chip->io_port + ESM_INDEX);
./sound/pci/es1968.c:610:		chip->maestro_map[reg] = inw(chip->io_port + ESM_DATA);
./sound/pci/es1968.c:612:	return chip->maestro_map[reg];
./sound/pci/es1968.c:619:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:621:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:631:		if (!(inb(chip->io_port + ESM_AC97_INDEX) & 1))
./sound/pci/es1968.c:635:	dev_dbg(chip->card->dev, "ac97 timeout\n");
./sound/pci/es1968.c:644:		if (!(inb(chip->io_port + ESM_AC97_INDEX) & 1))
./sound/pci/es1968.c:647:	dev_dbg(chip->card->dev, "ac97 timeout\n");
./sound/pci/es1968.c:658:	outw(val, chip->io_port + ESM_AC97_DATA);
./sound/pci/es1968.c:660:	outb(reg, chip->io_port + ESM_AC97_INDEX);
./sound/pci/es1968.c:671:	outb(reg | 0x80, chip->io_port + ESM_AC97_INDEX);
./sound/pci/es1968.c:675:		data = inw(chip->io_port + ESM_AC97_DATA);
./sound/pci/es1968.c:690:	dev_dbg(chip->card->dev, "APU register select failed. (Timeout)\n");
./sound/pci/es1968.c:702:	dev_dbg(chip->card->dev, "APU register set probably failed (Timeout)!\n");
./sound/pci/es1968.c:711:	chip->apu_map[channel][reg] = data;
./sound/pci/es1968.c:721:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:723:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:739:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:741:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:751:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:752:	outl(reg, chip->io_port + ASSP_INDEX);
./sound/pci/es1968.c:753:	outl(value, chip->io_port + ASSP_DATA);
./sound/pci/es1968.c:754:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:762:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:763:	outl(reg, chip->io_port + ASSP_INDEX);
./sound/pci/es1968.c:764:	value = inl(chip->io_port + ASSP_DATA);
./sound/pci/es1968.c:765:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:776:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:777:	outw(reg, chip->io_port + WC_INDEX);
./sound/pci/es1968.c:778:	outw(value, chip->io_port + WC_DATA);
./sound/pci/es1968.c:779:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:787:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:788:	outw(reg, chip->io_port + WC_INDEX);
./sound/pci/es1968.c:789:	value = inw(chip->io_port + WC_DATA);
./sound/pci/es1968.c:790:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:819:		if (chip->bob_freq > (ESS_SYSCLK >> (prescale + 9)))
./sound/pci/es1968.c:832:		if (chip->bob_freq >
./sound/pci/es1968.c:853:	chip->bobclient++;
./sound/pci/es1968.c:854:	if (chip->bobclient == 1) {
./sound/pci/es1968.c:855:		chip->bob_freq = freq;
./sound/pci/es1968.c:857:	} else if (chip->bob_freq < freq) {
./sound/pci/es1968.c:859:		chip->bob_freq = freq;
./sound/pci/es1968.c:867:	chip->bobclient--;
./sound/pci/es1968.c:868:	if (chip->bobclient <= 0)
./sound/pci/es1968.c:870:	else if (chip->bob_freq > ESM_BOB_FREQ) {
./sound/pci/es1968.c:874:		list_for_each_entry(es, &chip->substream_list, list) {
./sound/pci/es1968.c:878:		if (max_freq != chip->bob_freq) {
./sound/pci/es1968.c:880:			chip->bob_freq = max_freq;
./sound/pci/es1968.c:911:	u32 rate = (freq << 16) / chip->clock;
./sound/pci/es1968.c:951:	spin_lock(&chip->reg_lock);
./sound/pci/es1968.c:966:	spin_unlock(&chip->reg_lock);
./sound/pci/es1968.c:971:	spin_lock(&chip->reg_lock);
./sound/pci/es1968.c:978:	spin_unlock(&chip->reg_lock);
./sound/pci/es1968.c:1025:		pa -= chip->dma.addr;
./sound/pci/es1968.c:1080:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:1082:	outw(1, chip->io_port + 0x04);
./sound/pci/es1968.c:1084:	outw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);
./sound/pci/es1968.c:1085:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:1118:	pa -= chip->dma.addr;
./sound/pci/es1968.c:1208:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1968.c:1210:	outw(1, chip->io_port + 0x04);
./sound/pci/es1968.c:1212:	outw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);
./sound/pci/es1968.c:1213:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1968.c:1257:	spin_lock(&chip->substream_lock);
./sound/pci/es1968.c:1278:	spin_unlock(&chip->substream_lock);
./sound/pci/es1968.c:1347:	mutex_lock(&chip->memory_mutex);
./sound/pci/es1968.c:1348:	list_for_each_entry(buf, &chip->buf_list, list) {
./sound/pci/es1968.c:1352:	mutex_unlock(&chip->memory_mutex);
./sound/pci/es1968.c:1364:	mutex_lock(&chip->memory_mutex);
./sound/pci/es1968.c:1365:	list_for_each_entry(buf, &chip->buf_list, list) {
./sound/pci/es1968.c:1369:	mutex_unlock(&chip->memory_mutex);
./sound/pci/es1968.c:1376:			mutex_unlock(&chip->memory_mutex);
./sound/pci/es1968.c:1388:	mutex_unlock(&chip->memory_mutex);
./sound/pci/es1968.c:1397:	mutex_lock(&chip->memory_mutex);
./sound/pci/es1968.c:1399:	if (buf->list.prev != &chip->buf_list) {
./sound/pci/es1968.c:1408:	if (buf->list.next != &chip->buf_list) {
./sound/pci/es1968.c:1416:	mutex_unlock(&chip->memory_mutex);
./sound/pci/es1968.c:1423:	if (! chip->dma.area)
./sound/pci/es1968.c:1425:	snd_dma_free_pages(&chip->dma);
./sound/pci/es1968.c:1426:	while ((p = chip->buf_list.next) != &chip->buf_list) {
./sound/pci/es1968.c:1439:	chip->dma.dev.type = SNDRV_DMA_TYPE_DEV;
./sound/pci/es1968.c:1440:	chip->dma.dev.dev = snd_dma_pci_data(chip->pci);
./sound/pci/es1968.c:1442:					   snd_dma_pci_data(chip->pci),
./sound/pci/es1968.c:1443:					   chip->total_bufsize, &chip->dma);
./sound/pci/es1968.c:1444:	if (err < 0 || ! chip->dma.area) {
./sound/pci/es1968.c:1445:		dev_err(chip->card->dev,
./sound/pci/es1968.c:1447:			   chip->total_bufsize);
./sound/pci/es1968.c:1450:	if ((chip->dma.addr + chip->dma.bytes - 1) & ~((1 << 28) - 1)) {
./sound/pci/es1968.c:1451:		snd_dma_free_pages(&chip->dma);
./sound/pci/es1968.c:1452:		dev_err(chip->card->dev, "DMA buffer beyond 256MB.\n");
./sound/pci/es1968.c:1456:	INIT_LIST_HEAD(&chip->buf_list);
./sound/pci/es1968.c:1463:	memset(chip->dma.area, 0, ESM_MEM_ALIGN);
./sound/pci/es1968.c:1464:	chunk->buf = chip->dma;
./sound/pci/es1968.c:1469:	list_add(&chunk->list, &chip->buf_list);
./sound/pci/es1968.c:1493:		dev_dbg(chip->card->dev,
./sound/pci/es1968.c:1527:		if (chip->apu[apu] == ESM_APU_FREE &&
./sound/pci/es1968.c:1528:		    chip->apu[apu + 1] == ESM_APU_FREE) {
./sound/pci/es1968.c:1529:			chip->apu[apu] = chip->apu[apu + 1] = type;
./sound/pci/es1968.c:1541:	chip->apu[apu] = chip->apu[apu + 1] = ESM_APU_FREE;
./sound/pci/es1968.c:1580:	spin_lock_irq(&chip->substream_lock);
./sound/pci/es1968.c:1581:	list_add(&es->list, &chip->substream_list);
./sound/pci/es1968.c:1582:	spin_unlock_irq(&chip->substream_lock);
./sound/pci/es1968.c:1637:	spin_lock_irq(&chip->substream_lock);
./sound/pci/es1968.c:1638:	list_add(&es->list, &chip->substream_list);
./sound/pci/es1968.c:1639:	spin_unlock_irq(&chip->substream_lock);
./sound/pci/es1968.c:1652:	spin_lock_irq(&chip->substream_lock);
./sound/pci/es1968.c:1654:	spin_unlock_irq(&chip->substream_lock);
./sound/pci/es1968.c:1669:	spin_lock_irq(&chip->substream_lock);
./sound/pci/es1968.c:1671:	spin_unlock_irq(&chip->substream_lock);
./sound/pci/es1968.c:1716:	if (chip->clock == 0)
./sound/pci/es1968.c:1717:		chip->clock = 48000; /* default clock value */
./sound/pci/es1968.c:1721:		dev_err(chip->card->dev, "Hmm, cannot find empty APU pair!?\n");
./sound/pci/es1968.c:1725:		dev_warn(chip->card->dev,
./sound/pci/es1968.c:1727:			 chip->clock);
./sound/pci/es1968.c:1736:	pa = (unsigned int)((memory->buf.addr - chip->dma.addr) >> 1);
./sound/pci/es1968.c:1752:	spin_lock_irq(&chip->reg_lock);
./sound/pci/es1968.c:1753:	outw(1, chip->io_port + 0x04); /* clear WP interrupts */
./sound/pci/es1968.c:1754:	outw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ); /* enable WP ints */
./sound/pci/es1968.c:1755:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/es1968.c:1757:	snd_es1968_apu_set_freq(chip, apu, ((unsigned int)48000 << 16) / chip->clock); /* 48000 Hz */
./sound/pci/es1968.c:1759:	chip->in_measurement = 1;
./sound/pci/es1968.c:1760:	chip->measure_apu = apu;
./sound/pci/es1968.c:1761:	spin_lock_irq(&chip->reg_lock);
./sound/pci/es1968.c:1766:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/es1968.c:1768:	spin_lock_irq(&chip->reg_lock);
./sound/pci/es1968.c:1773:	chip->in_measurement = 0;
./sound/pci/es1968.c:1774:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/es1968.c:1779:	offset += chip->measure_count * (CLOCK_MEASURE_BUFSIZE/2);
./sound/pci/es1968.c:1784:		dev_err(chip->card->dev, "?? calculation error..\n");
./sound/pci/es1968.c:1790:				chip->clock = (chip->clock * offset) / 48000;
./sound/pci/es1968.c:1792:		dev_info(chip->card->dev, "clocking to %d\n", chip->clock);
./sound/pci/es1968.c:1820:	wave_set_register(chip, 0x01FC, chip->dma.addr >> 12);
./sound/pci/es1968.c:1821:	wave_set_register(chip, 0x01FD, chip->dma.addr >> 12);
./sound/pci/es1968.c:1822:	wave_set_register(chip, 0x01FE, chip->dma.addr >> 12);
./sound/pci/es1968.c:1823:	wave_set_register(chip, 0x01FF, chip->dma.addr >> 12);
./sound/pci/es1968.c:1825:	if ((err = snd_pcm_new(chip->card, "ESS Maestro", device,
./sound/pci/es1968.c:1826:			       chip->playback_streams,
./sound/pci/es1968.c:1827:			       chip->capture_streams, &pcm)) < 0)
./sound/pci/es1968.c:1840:	chip->pcm = pcm;
./sound/pci/es1968.c:1882:		spin_unlock(&chip->substream_lock);
./sound/pci/es1968.c:1884:		spin_lock(&chip->substream_lock);
./sound/pci/es1968.c:1901:	x = inb(chip->io_port + 0x1c) & 0xee;
./sound/pci/es1968.c:1903:	outb(0x88, chip->io_port + 0x1c);
./sound/pci/es1968.c:1904:	outb(0x88, chip->io_port + 0x1d);
./sound/pci/es1968.c:1905:	outb(0x88, chip->io_port + 0x1e);
./sound/pci/es1968.c:1906:	outb(0x88, chip->io_port + 0x1f);
./sound/pci/es1968.c:1908:	if (chip->in_suspend)
./sound/pci/es1968.c:1912:	if (! chip->master_switch || ! chip->master_volume)
./sound/pci/es1968.c:1915:	val = snd_ac97_read(chip->ac97, AC97_MASTER);
./sound/pci/es1968.c:1936:	if (snd_ac97_update(chip->ac97, AC97_MASTER, val))
./sound/pci/es1968.c:1937:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/pci/es1968.c:1938:			       &chip->master_volume->id);
./sound/pci/es1968.c:1940:	if (!chip->input_dev)
./sound/pci/es1968.c:1962:		input_report_key(chip->input_dev, val, 1);
./sound/pci/es1968.c:1963:		input_sync(chip->input_dev);
./sound/pci/es1968.c:1964:		input_report_key(chip->input_dev, val, 0);
./sound/pci/es1968.c:1965:		input_sync(chip->input_dev);
./sound/pci/es1968.c:1978:	if (!(event = inb(chip->io_port + 0x1A)))
./sound/pci/es1968.c:1981:	outw(inw(chip->io_port + 4) & 1, chip->io_port + 4);
./sound/pci/es1968.c:1984:		schedule_work(&chip->hwvol_work);
./sound/pci/es1968.c:1987:	outb(0xFF, chip->io_port + 0x1A);
./sound/pci/es1968.c:1989:	if ((event & ESM_MPU401_IRQ) && chip->rmidi) {
./sound/pci/es1968.c:1990:		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
./sound/pci/es1968.c:1995:		spin_lock(&chip->substream_lock);
./sound/pci/es1968.c:1996:		list_for_each_entry(es, &chip->substream_list, list) {
./sound/pci/es1968.c:2003:		spin_unlock(&chip->substream_lock);
./sound/pci/es1968.c:2004:		if (chip->in_measurement) {
./sound/pci/es1968.c:2005:			unsigned int curp = __apu_get_register(chip, chip->measure_apu, 5);
./sound/pci/es1968.c:2006:			if (curp < chip->measure_lastpos)
./sound/pci/es1968.c:2007:				chip->measure_count++;
./sound/pci/es1968.c:2008:			chip->measure_lastpos = curp;
./sound/pci/es1968.c:2033:	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
./sound/pci/es1968.c:2039:	if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97)) < 0)
./sound/pci/es1968.c:2047:	chip->master_switch = snd_ctl_find_id(chip->card, &elem_id);
./sound/pci/es1968.c:2051:	chip->master_volume = snd_ctl_find_id(chip->card, &elem_id);
./sound/pci/es1968.c:2063:	unsigned long ioaddr = chip->io_port;
./sound/pci/es1968.c:2081:	pci_read_config_word(chip->pci, 0x58, &w);	/* something magical with gpio and bus arb. */
./sound/pci/es1968.c:2082:	pci_read_config_dword(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);
./sound/pci/es1968.c:2112:	dev_info(chip->card->dev, "trying software reset\n");
./sound/pci/es1968.c:2170:	     chip->io_port + ESM_PORT_HOST_IRQ);
./sound/pci/es1968.c:2172:	outw(0x0000, chip->io_port + ESM_PORT_HOST_IRQ);
./sound/pci/es1968.c:2181:	struct pci_dev *pci = chip->pci;
./sound/pci/es1968.c:2183:	unsigned long iobase  = chip->io_port;
./sound/pci/es1968.c:2374:	if (chip->rmidi)
./sound/pci/es1968.c:2376:	outb(w, chip->io_port + 0x1A);
./sound/pci/es1968.c:2377:	outw(w, chip->io_port + ESM_PORT_HOST_IRQ);
./sound/pci/es1968.c:2389:	if (! chip->do_pm)
./sound/pci/es1968.c:2392:	chip->in_suspend = 1;
./sound/pci/es1968.c:2393:	cancel_work_sync(&chip->hwvol_work);
./sound/pci/es1968.c:2395:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/es1968.c:2396:	snd_ac97_suspend(chip->ac97);
./sound/pci/es1968.c:2407:	if (! chip->do_pm)
./sound/pci/es1968.c:2413:	if (chip->dma.addr) {
./sound/pci/es1968.c:2415:		wave_set_register(chip, 0x01FC, chip->dma.addr >> 12);
./sound/pci/es1968.c:2421:	snd_ac97_resume(chip->ac97);
./sound/pci/es1968.c:2423:	list_for_each_entry(es, &chip->substream_list, list) {
./sound/pci/es1968.c:2435:	if (chip->bobclient)
./sound/pci/es1968.c:2439:	chip->in_suspend = 0;
./sound/pci/es1968.c:2464:	chip->gameport = gp = gameport_allocate_port();
./sound/pci/es1968.c:2466:		dev_err(chip->card->dev,
./sound/pci/es1968.c:2472:	pci_read_config_word(chip->pci, ESM_LEGACY_AUDIO_CONTROL, &val);
./sound/pci/es1968.c:2473:	pci_write_config_word(chip->pci, ESM_LEGACY_AUDIO_CONTROL, val | 0x04);
./sound/pci/es1968.c:2476:	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
./sound/pci/es1968.c:2477:	gameport_set_dev_parent(gp, &chip->pci->dev);
./sound/pci/es1968.c:2488:	if (chip->gameport) {
./sound/pci/es1968.c:2489:		struct resource *r = gameport_get_port_data(chip->gameport);
./sound/pci/es1968.c:2491:		gameport_unregister_port(chip->gameport);
./sound/pci/es1968.c:2492:		chip->gameport = NULL;
./sound/pci/es1968.c:2512:	snprintf(chip->phys, sizeof(chip->phys), "pci-%s/input0",
./sound/pci/es1968.c:2513:		 pci_name(chip->pci));
./sound/pci/es1968.c:2515:	input_dev->name = chip->card->driver;
./sound/pci/es1968.c:2516:	input_dev->phys = chip->phys;
./sound/pci/es1968.c:2518:	input_dev->id.vendor  = chip->pci->vendor;
./sound/pci/es1968.c:2519:	input_dev->id.product = chip->pci->device;
./sound/pci/es1968.c:2520:	input_dev->dev.parent = &chip->pci->dev;
./sound/pci/es1968.c:2533:	chip->input_dev = input_dev;
./sound/pci/es1968.c:2570:	outw(val, chip->io_port + GPIO_DATA);
./sound/pci/es1968.c:2577:	u16 val = inw(chip->io_port + GPIO_DATA);
./sound/pci/es1968.c:2591:	unsigned long io = chip->io_port + GPIO_DATA;
./sound/pci/es1968.c:2617:	cancel_work_sync(&chip->hwvol_work);
./sound/pci/es1968.c:2619:	if (chip->input_dev)
./sound/pci/es1968.c:2620:		input_unregister_device(chip->input_dev);
./sound/pci/es1968.c:2623:	if (chip->io_port) {
./sound/pci/es1968.c:2624:		if (chip->irq >= 0)
./sound/pci/es1968.c:2625:			synchronize_irq(chip->irq);
./sound/pci/es1968.c:2626:		outw(1, chip->io_port + 0x04); /* clear WP interrupts */
./sound/pci/es1968.c:2627:		outw(0, chip->io_port + ESM_PORT_HOST_IRQ); /* disable IRQ */
./sound/pci/es1968.c:2631:	snd_tea575x_exit(&chip->tea);
./sound/pci/es1968.c:2632:	v4l2_device_unregister(&chip->v4l2_dev);
./sound/pci/es1968.c:2635:	if (chip->irq >= 0)
./sound/pci/es1968.c:2636:		free_irq(chip->irq, chip);
./sound/pci/es1968.c:2638:	pci_release_regions(chip->pci);
./sound/pci/es1968.c:2639:	pci_disable_device(chip->pci);
./sound/pci/es1968.c:2707:	chip->type = chip_type;
./sound/pci/es1968.c:2708:	spin_lock_init(&chip->reg_lock);
./sound/pci/es1968.c:2709:	spin_lock_init(&chip->substream_lock);
./sound/pci/es1968.c:2710:	INIT_LIST_HEAD(&chip->buf_list);
./sound/pci/es1968.c:2711:	INIT_LIST_HEAD(&chip->substream_list);
./sound/pci/es1968.c:2712:	mutex_init(&chip->memory_mutex);
./sound/pci/es1968.c:2713:	INIT_WORK(&chip->hwvol_work, es1968_update_hw_volume);
./sound/pci/es1968.c:2714:	chip->card = card;
./sound/pci/es1968.c:2715:	chip->pci = pci;
./sound/pci/es1968.c:2716:	chip->irq = -1;
./sound/pci/es1968.c:2717:	chip->total_bufsize = total_bufsize;	/* in bytes */
./sound/pci/es1968.c:2718:	chip->playback_streams = play_streams;
./sound/pci/es1968.c:2719:	chip->capture_streams = capt_streams;
./sound/pci/es1968.c:2726:	chip->io_port = pci_resource_start(pci, 0);
./sound/pci/es1968.c:2733:	chip->irq = pci->irq;
./sound/pci/es1968.c:2737:		chip->maestro_map[i] = 0;
./sound/pci/es1968.c:2741:		chip->apu[i] = ESM_APU_FREE;
./sound/pci/es1968.c:2749:		pci_read_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);
./sound/pci/es1968.c:2751:			if (chip->type == pm_whitelist[i].type &&
./sound/pci/es1968.c:2763:	chip->do_pm = do_pm;
./sound/pci/es1968.c:2774:	if (chip->pci->subsystem_vendor != 0x125d)
./sound/pci/es1968.c:2776:	err = v4l2_device_register(&pci->dev, &chip->v4l2_dev);
./sound/pci/es1968.c:2781:	chip->tea.v4l2_dev = &chip->v4l2_dev;
./sound/pci/es1968.c:2782:	chip->tea.private_data = chip;
./sound/pci/es1968.c:2783:	chip->tea.radio_nr = radio_nr;
./sound/pci/es1968.c:2784:	chip->tea.ops = &snd_es1968_tea_ops;
./sound/pci/es1968.c:2785:	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
./sound/pci/es1968.c:2787:		chip->tea575x_tuner = i;
./sound/pci/es1968.c:2788:		if (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {
./sound/pci/es1968.c:2791:			strlcpy(chip->tea.card, get_tea575x_gpio(chip)->name,
./sound/pci/es1968.c:2792:				sizeof(chip->tea.card));
./sound/pci/es1968.c:2845:	switch (chip->type) {
./sound/pci/es1968.c:2873:		pci_read_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);
./sound/pci/es1968.c:2875:			if (chip->type == mpu_blacklist[i].type &&
./sound/pci/es1968.c:2884:					       chip->io_port + ESM_MPU401_PORT,
./sound/pci/es1968.c:2887:					       -1, &chip->rmidi)) < 0) {
./sound/pci/es1968.c:2903:	chip->clock = clock[dev];
./sound/pci/es1968.c:2904:	if (! chip->clock)
./sound/pci/es1968.c:2908:		card->shortname, chip->io_port, chip->irq);
./sound/pci/riptide/riptide.c:1090:	struct cmdif *cif = chip->cif;
./sound/pci/riptide/riptide.c:1103:		substream[i] = chip->playback_substream[i];
./sound/pci/riptide/riptide.c:1104:	substream[i] = chip->capture_substream;
./sound/pci/riptide/riptide.c:1159:	chip->in_suspend = 1;
./sound/pci/riptide/riptide.c:1161:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/riptide/riptide.c:1162:	snd_ac97_suspend(chip->ac97);
./sound/pci/riptide/riptide.c:1172:	snd_ac97_resume(chip->ac97);
./sound/pci/riptide/riptide.c:1174:	chip->in_suspend = 0;
./sound/pci/riptide/riptide.c:1231:	if (!chip->fw_entry) {
./sound/pci/riptide/riptide.c:1232:		err = request_firmware(&chip->fw_entry, "riptide.hex",
./sound/pci/riptide/riptide.c:1233:				       &chip->pci->dev);
./sound/pci/riptide/riptide.c:1240:	err = loadfirmware(cif, chip->fw_entry->data, chip->fw_entry->size);
./sound/pci/riptide/riptide.c:1247:	chip->firmware = firmware;
./sound/pci/riptide/riptide.c:1363:	struct cmdif *cif = chip->cif;
./sound/pci/riptide/riptide.c:1396:	struct cmdif *cif = chip->cif;
./sound/pci/riptide/riptide.c:1399:	spin_lock(&chip->lock);
./sound/pci/riptide/riptide.c:1409:			chip->openstreams++;
./sound/pci/riptide/riptide.c:1421:		chip->openstreams--;
./sound/pci/riptide/riptide.c:1435:			chip->openstreams--;
./sound/pci/riptide/riptide.c:1442:			chip->openstreams++;
./sound/pci/riptide/riptide.c:1446:		spin_unlock(&chip->lock);
./sound/pci/riptide/riptide.c:1449:	spin_unlock(&chip->lock);
./sound/pci/riptide/riptide.c:1458:	struct cmdif *cif = chip->cif;
./sound/pci/riptide/riptide.c:1470:	spin_lock_irq(&chip->lock);
./sound/pci/riptide/riptide.c:1549:	spin_unlock_irq(&chip->lock);
./sound/pci/riptide/riptide.c:1568:				       snd_dma_pci_data(chip->pci),
./sound/pci/riptide/riptide.c:1584:	struct cmdif *cif = chip->cif;
./sound/pci/riptide/riptide.c:1609:	chip->playback_substream[sub_num] = substream;
./sound/pci/riptide/riptide.c:1632:	chip->capture_substream = substream;
./sound/pci/riptide/riptide.c:1656:	chip->playback_substream[sub_num] = NULL;
./sound/pci/riptide/riptide.c:1667:	chip->capture_substream = NULL;
./sound/pci/riptide/riptide.c:1701:	     snd_pcm_new(chip->card, "RIPTIDE", device, PLAYBACK_SUBSTREAMS, 1,
./sound/pci/riptide/riptide.c:1711:	chip->pcm = pcm;
./sound/pci/riptide/riptide.c:1713:					      snd_dma_pci_data(chip->pci),
./sound/pci/riptide/riptide.c:1722:	struct cmdif *cif = chip->cif;
./sound/pci/riptide/riptide.c:1725:		chip->received_irqs++;
./sound/pci/riptide/riptide.c:1728:			chip->handled_irqs++;
./sound/pci/riptide/riptide.c:1729:			tasklet_schedule(&chip->riptide_tq);
./sound/pci/riptide/riptide.c:1731:		if (chip->rmidi && IS_MPUIRQ(cif->hwport)) {
./sound/pci/riptide/riptide.c:1732:			chip->handled_irqs++;
./sound/pci/riptide/riptide.c:1734:						  chip->rmidi->private_data);
./sound/pci/riptide/riptide.c:1746:	struct cmdif *cif = chip->cif;
./sound/pci/riptide/riptide.c:1766:	struct cmdif *cif = chip->cif;
./sound/pci/riptide/riptide.c:1787:	cif = chip->cif;
./sound/pci/riptide/riptide.c:1791:		cif->hwport = (struct riptideport *)chip->port;
./sound/pci/riptide/riptide.c:1793:		chip->cif = cif;
./sound/pci/riptide/riptide.c:1798:	device_id = chip->device_id;
./sound/pci/riptide/riptide.c:1808:	if (chip->rmidi)
./sound/pci/riptide/riptide.c:1820:	if ((cif = chip->cif)) {
./sound/pci/riptide/riptide.c:1824:		kfree(chip->cif);
./sound/pci/riptide/riptide.c:1826:	if (chip->irq >= 0)
./sound/pci/riptide/riptide.c:1827:		free_irq(chip->irq, chip);
./sound/pci/riptide/riptide.c:1828:	release_firmware(chip->fw_entry);
./sound/pci/riptide/riptide.c:1829:	release_and_free_resource(chip->res_port);
./sound/pci/riptide/riptide.c:1858:	spin_lock_init(&chip->lock);
./sound/pci/riptide/riptide.c:1859:	chip->card = card;
./sound/pci/riptide/riptide.c:1860:	chip->pci = pci;
./sound/pci/riptide/riptide.c:1861:	chip->irq = -1;
./sound/pci/riptide/riptide.c:1862:	chip->openstreams = 0;
./sound/pci/riptide/riptide.c:1863:	chip->port = pci_resource_start(pci, 0);
./sound/pci/riptide/riptide.c:1864:	chip->received_irqs = 0;
./sound/pci/riptide/riptide.c:1865:	chip->handled_irqs = 0;
./sound/pci/riptide/riptide.c:1866:	chip->cif = NULL;
./sound/pci/riptide/riptide.c:1867:	tasklet_init(&chip->riptide_tq, riptide_handleirq, (unsigned long)chip);
./sound/pci/riptide/riptide.c:1869:	if ((chip->res_port =
./sound/pci/riptide/riptide.c:1870:	     request_region(chip->port, 64, "RIPTIDE")) == NULL) {
./sound/pci/riptide/riptide.c:1873:			   chip->port, chip->port + 64 - 1);
./sound/pci/riptide/riptide.c:1877:	hwport = (struct riptideport *)chip->port;
./sound/pci/riptide/riptide.c:1887:	chip->irq = pci->irq;
./sound/pci/riptide/riptide.c:1888:	chip->device_id = pci->device;
./sound/pci/riptide/riptide.c:1919:	snd_iprintf(buffer, "%s\n\n", chip->card->longname);
./sound/pci/riptide/riptide.c:1921:		    chip->device_id, chip->handled_irqs, chip->received_irqs);
./sound/pci/riptide/riptide.c:1924:			    (i % 16) ? ' ' : '\n', i, inl(chip->port + i));
./sound/pci/riptide/riptide.c:1925:	if ((cif = chip->cif)) {
./sound/pci/riptide/riptide.c:1928:			    chip->firmware.firmware.ASIC,
./sound/pci/riptide/riptide.c:1929:			    chip->firmware.firmware.CODEC,
./sound/pci/riptide/riptide.c:1930:			    chip->firmware.firmware.AUXDSP,
./sound/pci/riptide/riptide.c:1931:			    chip->firmware.firmware.PROG);
./sound/pci/riptide/riptide.c:1942:	snd_iprintf(buffer, "\nOpen streams %d:\n", chip->openstreams);
./sound/pci/riptide/riptide.c:1944:		if (chip->playback_substream[i]
./sound/pci/riptide/riptide.c:1945:		    && chip->playback_substream[i]->runtime
./sound/pci/riptide/riptide.c:1947:			chip->playback_substream[i]->runtime->private_data)) {
./sound/pci/riptide/riptide.c:1956:	if (chip->capture_substream
./sound/pci/riptide/riptide.c:1957:	    && chip->capture_substream->runtime
./sound/pci/riptide/riptide.c:1958:	    && (data = chip->capture_substream->runtime->private_data)) {
./sound/pci/riptide/riptide.c:1979:	if (!snd_card_proc_new(chip->card, "riptide", &entry))
./sound/pci/riptide/riptide.c:1997:	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus)) < 0)
./sound/pci/riptide/riptide.c:2000:	chip->ac97_bus = pbus;
./sound/pci/riptide/riptide.c:2001:	ac97.pci = chip->pci;
./sound/pci/riptide/riptide.c:2002:	if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97)) < 0)
./sound/pci/riptide/riptide.c:2103:	val |= (chip->irq << 4) & 0xf0;
./sound/pci/riptide/riptide.c:2104:	pci_write_config_word(chip->pci, PCI_EXT_Legacy_Mask, val);
./sound/pci/riptide/riptide.c:2107:		pci_write_config_word(chip->pci, PCI_EXT_MPU_Base, val);
./sound/pci/riptide/riptide.c:2110:					  &chip->rmidi);
./sound/pci/riptide/riptide.c:2116:			chip->mpuaddr = val;
./sound/pci/riptide/riptide.c:2120:		pci_write_config_word(chip->pci, PCI_EXT_FM_Base, val);
./sound/pci/riptide/riptide.c:2122:				      OPL3_HW_RIPTIDE, 0, &chip->opl3);
./sound/pci/riptide/riptide.c:2128:			chip->opladdr = val;
./sound/pci/riptide/riptide.c:2129:			err = snd_opl3_hwdep_new(chip->opl3, 0, 1, NULL);
./sound/pci/riptide/riptide.c:2138:		pci_write_config_word(chip->pci, PCI_EXT_Game_Base, val);
./sound/pci/riptide/riptide.c:2139:		chip->gameaddr = val;
./sound/pci/riptide/riptide.c:2148:		 card->shortname, chip->port, chip->irq, chip->mpuaddr,
./sound/pci/riptide/riptide.c:2149:		 chip->opladdr, chip->gameaddr);
./sound/pci/riptide/riptide.c:2153:		 card->shortname, chip->port, chip->irq, chip->mpuaddr,
./sound/pci/riptide/riptide.c:2154:		 chip->opladdr);
./sound/pci/intel8x0m.c:253:	return ioread8(chip->bmaddr + offset);
./sound/pci/intel8x0m.c:258:	return ioread16(chip->bmaddr + offset);
./sound/pci/intel8x0m.c:263:	return ioread32(chip->bmaddr + offset);
./sound/pci/intel8x0m.c:268:	iowrite8(val, chip->bmaddr + offset);
./sound/pci/intel8x0m.c:273:	iowrite16(val, chip->bmaddr + offset);
./sound/pci/intel8x0m.c:278:	iowrite32(val, chip->bmaddr + offset);
./sound/pci/intel8x0m.c:287:	return ioread16(chip->addr + offset);
./sound/pci/intel8x0m.c:292:	iowrite16(val, chip->addr + offset);
./sound/pci/intel8x0m.c:337:	dev_err(chip->card->dev,
./sound/pci/intel8x0m.c:352:		if (! chip->in_ac97_init)
./sound/pci/intel8x0m.c:353:			dev_err(chip->card->dev,
./sound/pci/intel8x0m.c:368:		if (! chip->in_ac97_init)
./sound/pci/intel8x0m.c:369:			dev_err(chip->card->dev,
./sound/pci/intel8x0m.c:379:			if (! chip->in_ac97_init)
./sound/pci/intel8x0m.c:380:				dev_err(chip->card->dev,
./sound/pci/intel8x0m.c:408:						     ichdev->fragsize1 >> chip->pcm_pos_shift);
./sound/pci/intel8x0m.c:411:						     ichdev->fragsize1 >> chip->pcm_pos_shift);
./sound/pci/intel8x0m.c:420:						     ichdev->fragsize >> chip->pcm_pos_shift);
./sound/pci/intel8x0m.c:422:			dev_dbg(chip->card->dev, "bdbar[%i] = 0x%x [0x%x]\n",
./sound/pci/intel8x0m.c:434:	dev_dbg(chip->card->dev,
./sound/pci/intel8x0m.c:480:		dev_dbg(chip->card->dev,
./sound/pci/intel8x0m.c:492:		spin_unlock(&chip->reg_lock);
./sound/pci/intel8x0m.c:494:		spin_lock(&chip->reg_lock);
./sound/pci/intel8x0m.c:506:	spin_lock(&chip->reg_lock);
./sound/pci/intel8x0m.c:507:	status = igetdword(chip, chip->int_sta_reg);
./sound/pci/intel8x0m.c:509:		spin_unlock(&chip->reg_lock);
./sound/pci/intel8x0m.c:512:	if ((status & chip->int_sta_mask) == 0) {
./sound/pci/intel8x0m.c:514:			iputdword(chip, chip->int_sta_reg, status);
./sound/pci/intel8x0m.c:515:		spin_unlock(&chip->reg_lock);
./sound/pci/intel8x0m.c:519:	for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0m.c:520:		ichdev = &chip->ichd[i];
./sound/pci/intel8x0m.c:526:	iputdword(chip, chip->int_sta_reg, status & chip->int_sta_mask);
./sound/pci/intel8x0m.c:527:	spin_unlock(&chip->reg_lock);
./sound/pci/intel8x0m.c:588:	ptr1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb) << chip->pcm_pos_shift;
./sound/pci/intel8x0m.c:661:	return snd_intel8x0m_pcm_open(substream, &chip->ichd[ICHD_MDMOUT]);
./sound/pci/intel8x0m.c:668:	chip->ichd[ICHD_MDMOUT].substream = NULL;
./sound/pci/intel8x0m.c:676:	return snd_intel8x0m_pcm_open(substream, &chip->ichd[ICHD_MDMIN]);
./sound/pci/intel8x0m.c:683:	chip->ichd[ICHD_MDMIN].substream = NULL;
./sound/pci/intel8x0m.c:731:	err = snd_pcm_new(chip->card, name, device,
./sound/pci/intel8x0m.c:746:		sprintf(pcm->name, "%s - %s", chip->card->shortname, rec->suffix);
./sound/pci/intel8x0m.c:748:		strcpy(pcm->name, chip->card->shortname);
./sound/pci/intel8x0m.c:749:	chip->pcm[device] = pcm;
./sound/pci/intel8x0m.c:752:					      snd_dma_pci_data(chip->pci),
./sound/pci/intel8x0m.c:778:	switch (chip->device_type) {
./sound/pci/intel8x0m.c:798:			if (! chip->ichd[rec->ac97_idx].ac97)
./sound/pci/intel8x0m.c:807:	chip->pcm_devs = device;
./sound/pci/intel8x0m.c:819:	chip->ac97_bus = NULL;
./sound/pci/intel8x0m.c:825:	chip->ac97 = NULL;
./sound/pci/intel8x0m.c:841:	chip->in_ac97_init = 1;
./sound/pci/intel8x0m.c:850:	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus)) < 0)
./sound/pci/intel8x0m.c:855:	chip->ac97_bus = pbus;
./sound/pci/intel8x0m.c:857:	ac97.pci = chip->pci;
./sound/pci/intel8x0m.c:860:		dev_err(chip->card->dev,
./sound/pci/intel8x0m.c:866:	chip->ac97 = x97;
./sound/pci/intel8x0m.c:867:	if(ac97_is_modem(x97) && !chip->ichd[ICHD_MDMIN].ac97) {
./sound/pci/intel8x0m.c:868:		chip->ichd[ICHD_MDMIN].ac97 = x97;
./sound/pci/intel8x0m.c:869:		chip->ichd[ICHD_MDMOUT].ac97 = x97;
./sound/pci/intel8x0m.c:872:	chip->in_ac97_init = 0;
./sound/pci/intel8x0m.c:877:	if (chip->device_type != DEVICE_ALI)
./sound/pci/intel8x0m.c:912:	dev_err(chip->card->dev, "AC'97 warm reset still in progress? [0x%x]\n",
./sound/pci/intel8x0m.c:932:			dev_err(chip->card->dev,
./sound/pci/intel8x0m.c:951:		if (chip->ac97)
./sound/pci/intel8x0m.c:952:			status |= get_ich_codec_bit(chip, chip->ac97->num);
./sound/pci/intel8x0m.c:964:	if (chip->device_type == DEVICE_SIS) {
./sound/pci/intel8x0m.c:982:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0m.c:983:		iputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);
./sound/pci/intel8x0m.c:985:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0m.c:986:		iputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);
./sound/pci/intel8x0m.c:988:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0m.c:989:		iputdword(chip, ICH_REG_OFF_BDBAR + chip->ichd[i].reg_offset, chip->ichd[i].bdbar_addr);
./sound/pci/intel8x0m.c:997:	if (chip->irq < 0)
./sound/pci/intel8x0m.c:1000:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0m.c:1001:		iputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);
./sound/pci/intel8x0m.c:1003:	for (i = 0; i < chip->bdbars_count; i++)
./sound/pci/intel8x0m.c:1004:		iputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);
./sound/pci/intel8x0m.c:1006:	if (chip->irq >= 0)
./sound/pci/intel8x0m.c:1007:		free_irq(chip->irq, chip);
./sound/pci/intel8x0m.c:1008:	if (chip->bdbars.area)
./sound/pci/intel8x0m.c:1009:		snd_dma_free_pages(&chip->bdbars);
./sound/pci/intel8x0m.c:1010:	if (chip->addr)
./sound/pci/intel8x0m.c:1011:		pci_iounmap(chip->pci, chip->addr);
./sound/pci/intel8x0m.c:1012:	if (chip->bmaddr)
./sound/pci/intel8x0m.c:1013:		pci_iounmap(chip->pci, chip->bmaddr);
./sound/pci/intel8x0m.c:1014:	pci_release_regions(chip->pci);
./sound/pci/intel8x0m.c:1015:	pci_disable_device(chip->pci);
./sound/pci/intel8x0m.c:1031:	for (i = 0; i < chip->pcm_devs; i++)
./sound/pci/intel8x0m.c:1032:		snd_pcm_suspend_all(chip->pcm[i]);
./sound/pci/intel8x0m.c:1033:	snd_ac97_suspend(chip->ac97);
./sound/pci/intel8x0m.c:1034:	if (chip->irq >= 0) {
./sound/pci/intel8x0m.c:1035:		free_irq(chip->irq, chip);
./sound/pci/intel8x0m.c:1036:		chip->irq = -1;
./sound/pci/intel8x0m.c:1054:	chip->irq = pci->irq;
./sound/pci/intel8x0m.c:1056:	snd_ac97_resume(chip->ac97);
./sound/pci/intel8x0m.c:1075:	if (chip->device_type == DEVICE_ALI)
./sound/pci/intel8x0m.c:1092:	if (! snd_card_proc_new(chip->card, "intel8x0m", &entry))
./sound/pci/intel8x0m.c:1136:	spin_lock_init(&chip->reg_lock);
./sound/pci/intel8x0m.c:1137:	chip->device_type = device_type;
./sound/pci/intel8x0m.c:1138:	chip->card = card;
./sound/pci/intel8x0m.c:1139:	chip->pci = pci;
./sound/pci/intel8x0m.c:1140:	chip->irq = -1;
./sound/pci/intel8x0m.c:1150:		chip->bmaddr = pci_iomap(pci, 0, 0);
./sound/pci/intel8x0m.c:1155:		chip->addr = pci_iomap(pci, 2, 0);
./sound/pci/intel8x0m.c:1157:		chip->addr = pci_iomap(pci, 0, 0);
./sound/pci/intel8x0m.c:1158:	if (!chip->addr) {
./sound/pci/intel8x0m.c:1164:		chip->bmaddr = pci_iomap(pci, 3, 0);
./sound/pci/intel8x0m.c:1166:		chip->bmaddr = pci_iomap(pci, 1, 0);
./sound/pci/intel8x0m.c:1167:	if (!chip->bmaddr) {
./sound/pci/intel8x0m.c:1180:	chip->irq = pci->irq;
./sound/pci/intel8x0m.c:1182:	synchronize_irq(chip->irq);
./sound/pci/intel8x0m.c:1185:	chip->bdbars_count = 2;
./sound/pci/intel8x0m.c:1188:	for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0m.c:1189:		ichdev = &chip->ichd[i];
./sound/pci/intel8x0m.c:1205:	chip->pcm_pos_shift = (device_type == DEVICE_SIS) ? 0 : 1;
./sound/pci/intel8x0m.c:1210:				chip->bdbars_count * sizeof(u32) * ICH_MAX_FRAGS * 2,
./sound/pci/intel8x0m.c:1211:				&chip->bdbars) < 0) {
./sound/pci/intel8x0m.c:1218:	for (i = 0; i < chip->bdbars_count; i++) {
./sound/pci/intel8x0m.c:1219:		ichdev = &chip->ichd[i];
./sound/pci/intel8x0m.c:1220:		ichdev->bdbar = ((u32 *)chip->bdbars.area) + (i * ICH_MAX_FRAGS * 2);
./sound/pci/intel8x0m.c:1221:		ichdev->bdbar_addr = chip->bdbars.addr + (i * sizeof(u32) * ICH_MAX_FRAGS * 2);
./sound/pci/intel8x0m.c:1224:	chip->int_sta_reg = ICH_REG_GLOB_STA;
./sound/pci/intel8x0m.c:1225:	chip->int_sta_mask = int_sta_masks;
./sound/pci/intel8x0m.c:1307:		card->shortname, chip->irq);
./sound/pci/echoaudio/echoaudio_gml.c:49:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_gml.c:51:		chip->asic_loaded = false;
./sound/pci/echoaudio/echoaudio_gml.c:55:	chip->asic_loaded = (asic_status == ASIC_ALREADY_LOADED);
./sound/pci/echoaudio/echoaudio_gml.c:56:	return chip->asic_loaded ? 0 : -EIO;
./sound/pci/echoaudio/echoaudio_gml.c:67:	if (chip->digital_in_automute)
./sound/pci/echoaudio/echoaudio_gml.c:72:	dev_dbg(chip->card->dev, "write_control_reg: 0x%x\n", value);
./sound/pci/echoaudio/echoaudio_gml.c:76:	if (value != chip->comm_page->control_register || force) {
./sound/pci/echoaudio/echoaudio_gml.c:79:		chip->comm_page->control_register = value;
./sound/pci/echoaudio/echoaudio_gml.c:95:	dev_dbg(chip->card->dev, "set_input_auto_mute %d\n", automute);
./sound/pci/echoaudio/echoaudio_gml.c:97:	chip->digital_in_automute = automute;
./sound/pci/echoaudio/echoaudio_gml.c:101:	return set_input_clock(chip, chip->input_clock);
./sound/pci/echoaudio/echoaudio_gml.c:112:	if (chip->bad_board)
./sound/pci/echoaudio/echoaudio_gml.c:116:	if (snd_BUG_ON(chip->pipe_alloc_mask))
./sound/pci/echoaudio/echoaudio_gml.c:119:	if (snd_BUG_ON(!(chip->digital_modes & (1 << mode))))
./sound/pci/echoaudio/echoaudio_gml.c:122:	previous_mode = chip->digital_mode;
./sound/pci/echoaudio/echoaudio_gml.c:130:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio_gml.c:134:						 chip->monitor_gain[o][i]);
./sound/pci/echoaudio/echoaudio_gml.c:138:			set_input_gain(chip, i, chip->input_gain[i]);
./sound/pci/echoaudio/echoaudio_gml.c:143:			set_output_gain(chip, o, chip->output_gain[o]);
./sound/pci/echoaudio/echoaudio_gml.c:145:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio_gml.c:160:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/echoaudio_gml.c:170:		switch (chip->sample_rate) {
./sound/pci/echoaudio/echoaudio_gml.c:184:		switch (chip->sample_rate) {
./sound/pci/echoaudio/echoaudio_gml.c:197:	chip->professional_spdif = prof;
./sound/pci/echoaudio/echoaudio_gml.c:198:	dev_dbg(chip->card->dev, "set_professional_spdif to %s\n",
./sound/pci/echoaudio/midi.c:39:	dev_dbg(chip->card->dev, "enable_midi_input(%d)\n", enable);
./sound/pci/echoaudio/midi.c:45:		chip->mtc_state = MIDI_IN_STATE_NORMAL;
./sound/pci/echoaudio/midi.c:46:		chip->comm_page->flags |=
./sound/pci/echoaudio/midi.c:49:		chip->comm_page->flags &=
./sound/pci/echoaudio/midi.c:72:	chip->comm_page->midi_output[0] = bytes;
./sound/pci/echoaudio/midi.c:73:	memcpy(&chip->comm_page->midi_output[1], data, bytes);
./sound/pci/echoaudio/midi.c:74:	chip->comm_page->midi_out_free_count = 0;
./sound/pci/echoaudio/midi.c:77:	dev_dbg(chip->card->dev, "write_midi: %d\n", bytes);
./sound/pci/echoaudio/midi.c:92:	switch (chip->mtc_state) {
./sound/pci/echoaudio/midi.c:95:			chip->mtc_state = MIDI_IN_STATE_TS_HIGH;
./sound/pci/echoaudio/midi.c:98:		chip->mtc_state = MIDI_IN_STATE_TS_LOW;
./sound/pci/echoaudio/midi.c:102:		chip->mtc_state = MIDI_IN_STATE_F1_DATA;
./sound/pci/echoaudio/midi.c:106:		chip->mtc_state = MIDI_IN_STATE_NORMAL;
./sound/pci/echoaudio/midi.c:121:	count = le16_to_cpu(chip->comm_page->midi_input[0]);
./sound/pci/echoaudio/midi.c:131:		midi_byte = le16_to_cpu(chip->comm_page->midi_input[i]);
./sound/pci/echoaudio/midi.c:142:		chip->midi_buffer[received++] = (u8)midi_byte;
./sound/pci/echoaudio/midi.c:159:	chip->midi_in = substream;
./sound/pci/echoaudio/midi.c:170:	if (up != chip->midi_input_enabled) {
./sound/pci/echoaudio/midi.c:171:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/midi.c:173:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/midi.c:174:		chip->midi_input_enabled = up;
./sound/pci/echoaudio/midi.c:184:	chip->midi_in = NULL;
./sound/pci/echoaudio/midi.c:194:	chip->tinuse = 0;
./sound/pci/echoaudio/midi.c:195:	chip->midi_full = 0;
./sound/pci/echoaudio/midi.c:196:	chip->midi_out = substream;
./sound/pci/echoaudio/midi.c:212:	spin_lock_irqsave(&chip->lock, flags);
./sound/pci/echoaudio/midi.c:213:	chip->midi_full = 0;
./sound/pci/echoaudio/midi.c:214:	if (!snd_rawmidi_transmit_empty(chip->midi_out)) {
./sound/pci/echoaudio/midi.c:215:		bytes = snd_rawmidi_transmit_peek(chip->midi_out, buf,
./sound/pci/echoaudio/midi.c:217:		dev_dbg(chip->card->dev, "Try to send %d bytes...\n", bytes);
./sound/pci/echoaudio/midi.c:220:			dev_err(chip->card->dev,
./sound/pci/echoaudio/midi.c:224:			chip->midi_full = 1;
./sound/pci/echoaudio/midi.c:226:			dev_dbg(chip->card->dev, "%d bytes sent\n", sent);
./sound/pci/echoaudio/midi.c:227:			snd_rawmidi_transmit_ack(chip->midi_out, sent);
./sound/pci/echoaudio/midi.c:231:			dev_dbg(chip->card->dev, "Full\n");
./sound/pci/echoaudio/midi.c:233:			chip->midi_full = 1;
./sound/pci/echoaudio/midi.c:238:	if (!snd_rawmidi_transmit_empty(chip->midi_out) && chip->tinuse) {
./sound/pci/echoaudio/midi.c:242:		mod_timer(&chip->timer, jiffies + (time * HZ + 999) / 1000);
./sound/pci/echoaudio/midi.c:243:		dev_dbg(chip->card->dev,
./sound/pci/echoaudio/midi.c:246:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/pci/echoaudio/midi.c:256:	dev_dbg(chip->card->dev, "snd_echo_midi_output_trigger(%d)\n", up);
./sound/pci/echoaudio/midi.c:257:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/midi.c:259:		if (!chip->tinuse) {
./sound/pci/echoaudio/midi.c:260:			setup_timer(&chip->timer, snd_echo_midi_output_write,
./sound/pci/echoaudio/midi.c:262:			chip->tinuse = 1;
./sound/pci/echoaudio/midi.c:265:		if (chip->tinuse) {
./sound/pci/echoaudio/midi.c:266:			chip->tinuse = 0;
./sound/pci/echoaudio/midi.c:267:			spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/midi.c:268:			del_timer_sync(&chip->timer);
./sound/pci/echoaudio/midi.c:269:			dev_dbg(chip->card->dev, "Timer removed\n");
./sound/pci/echoaudio/midi.c:273:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/midi.c:275:	if (up && !chip->midi_full)
./sound/pci/echoaudio/midi.c:285:	chip->midi_out = NULL;
./sound/pci/echoaudio/midi.c:312:				   &chip->rmidi)) < 0)
./sound/pci/echoaudio/midi.c:315:	strcpy(chip->rmidi->name, card->shortname);
./sound/pci/echoaudio/midi.c:316:	chip->rmidi->private_data = chip;
./sound/pci/echoaudio/midi.c:318:	snd_rawmidi_set_ops(chip->rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
./sound/pci/echoaudio/midi.c:320:	snd_rawmidi_set_ops(chip->rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
./sound/pci/echoaudio/midi.c:323:	chip->rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
./sound/pci/echoaudio/echoaudio_dsp.c:50:		if (chip->comm_page->handshake) {
./sound/pci/echoaudio/echoaudio_dsp.c:56:	dev_err(chip->card->dev, "wait_handshake(): Timeout waiting for DSP\n");
./sound/pci/echoaudio/echoaudio_dsp.c:83:	dev_err(chip->card->dev, "timeout on send_vector\n");
./sound/pci/echoaudio/echoaudio_dsp.c:106:	chip->bad_board = true;		/* Set true until DSP re-loaded */
./sound/pci/echoaudio/echoaudio_dsp.c:107:	dev_dbg(chip->card->dev, "write_dsp: Set bad_board to true\n");
./sound/pci/echoaudio/echoaudio_dsp.c:129:	chip->bad_board = true;		/* Set true until DSP re-loaded */
./sound/pci/echoaudio/echoaudio_dsp.c:130:	dev_err(chip->card->dev, "read_dsp: Set bad_board to true\n");
./sound/pci/echoaudio/echoaudio_dsp.c:152:			dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:157:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:169:	chip->asic_loaded = true;
./sound/pci/echoaudio/echoaudio_dsp.c:189:		dev_warn(chip->card->dev, "Firmware not found !\n");
./sound/pci/echoaudio/echoaudio_dsp.c:213:	dev_err(chip->card->dev, "failed on write_dsp\n");
./sound/pci/echoaudio/echoaudio_dsp.c:237:	if (chip->device_id != DEVICE_ID_56361)
./sound/pci/echoaudio/echoaudio_dsp.c:244:		dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:252:		dev_warn(chip->card->dev, "Firmware not found !\n");
./sound/pci/echoaudio/echoaudio_dsp.c:287:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:293:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:303:			dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:319:		dev_err(chip->card->dev, "Resident loader failed to set HF5\n");
./sound/pci/echoaudio/echoaudio_dsp.c:323:	dev_dbg(chip->card->dev, "Resident loader successfully installed\n");
./sound/pci/echoaudio/echoaudio_dsp.c:340:	if (chip->dsp_code == code) {
./sound/pci/echoaudio/echoaudio_dsp.c:341:		dev_warn(chip->card->dev, "DSP is already loaded!\n");
./sound/pci/echoaudio/echoaudio_dsp.c:344:	chip->bad_board = true;		/* Set true until DSP loaded */
./sound/pci/echoaudio/echoaudio_dsp.c:345:	chip->dsp_code = NULL;		/* Current DSP code not loaded */
./sound/pci/echoaudio/echoaudio_dsp.c:346:	chip->asic_loaded = false;	/* Loading the DSP code will reset the ASIC */
./sound/pci/echoaudio/echoaudio_dsp.c:348:	dev_dbg(chip->card->dev, "load_dsp: Set bad_board to true\n");
./sound/pci/echoaudio/echoaudio_dsp.c:358:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:374:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:412:			dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:417:			dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:422:			dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:430:				dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:438:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:452:				dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:457:			if (write_dsp(chip, chip->comm_page_phys) < 0) {
./sound/pci/echoaudio/echoaudio_dsp.c:458:				dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:468:				dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:473:			chip->dsp_code = code;		/* Show which DSP code loaded */
./sound/pci/echoaudio/echoaudio_dsp.c:474:			chip->bad_board = false;	/* DSP OK */
./sound/pci/echoaudio/echoaudio_dsp.c:480:	dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:493:	if (snd_BUG_ON(!chip->comm_page))
./sound/pci/echoaudio/echoaudio_dsp.c:497:	if (chip->dsp_code) {
./sound/pci/echoaudio/echoaudio_dsp.c:501:		chip->dsp_code = NULL;
./sound/pci/echoaudio/echoaudio_dsp.c:504:	err = get_firmware(&fw, chip, chip->dsp_code_to_load);
./sound/pci/echoaudio/echoaudio_dsp.c:537:	chip->nominal_level[index] = consumer;
./sound/pci/echoaudio/echoaudio_dsp.c:540:		chip->comm_page->nominal_level_mask |= cpu_to_le32(1 << index);
./sound/pci/echoaudio/echoaudio_dsp.c:542:		chip->comm_page->nominal_level_mask &= ~cpu_to_le32(1 << index);
./sound/pci/echoaudio/echoaudio_dsp.c:561:	chip->output_gain[channel] = gain;
./sound/pci/echoaudio/echoaudio_dsp.c:562:	chip->comm_page->line_out_level[channel] = gain;
./sound/pci/echoaudio/echoaudio_dsp.c:580:	chip->monitor_gain[output][input] = gain;
./sound/pci/echoaudio/echoaudio_dsp.c:581:	chip->comm_page->monitors[monitor_index(chip, output, input)] = gain;
./sound/pci/echoaudio/echoaudio_dsp.c:613:	if (on && !chip->meters_enabled) {
./sound/pci/echoaudio/echoaudio_dsp.c:615:		chip->meters_enabled = 1;
./sound/pci/echoaudio/echoaudio_dsp.c:616:	} else if (!on && chip->meters_enabled) {
./sound/pci/echoaudio/echoaudio_dsp.c:618:		chip->meters_enabled = 0;
./sound/pci/echoaudio/echoaudio_dsp.c:619:		memset((s8 *)chip->comm_page->vu_meter, ECHOGAIN_MUTED,
./sound/pci/echoaudio/echoaudio_dsp.c:621:		memset((s8 *)chip->comm_page->peak_meter, ECHOGAIN_MUTED,
./sound/pci/echoaudio/echoaudio_dsp.c:643:		meters[n++] = chip->comm_page->vu_meter[m];
./sound/pci/echoaudio/echoaudio_dsp.c:644:		meters[n++] = chip->comm_page->peak_meter[m];
./sound/pci/echoaudio/echoaudio_dsp.c:654:		meters[n++] = chip->comm_page->vu_meter[m];
./sound/pci/echoaudio/echoaudio_dsp.c:655:		meters[n++] = chip->comm_page->peak_meter[m];
./sound/pci/echoaudio/echoaudio_dsp.c:662:		meters[n++] = chip->comm_page->vu_meter[m];
./sound/pci/echoaudio/echoaudio_dsp.c:663:		meters[n++] = chip->comm_page->peak_meter[m];
./sound/pci/echoaudio/echoaudio_dsp.c:680:	chip->comm_page->gd_clock_state = GD_CLOCK_UNDEF;
./sound/pci/echoaudio/echoaudio_dsp.c:681:	chip->comm_page->gd_spdif_status = GD_SPDIF_STATUS_UNDEF;
./sound/pci/echoaudio/echoaudio_dsp.c:682:	chip->comm_page->handshake = 0xffffffff;
./sound/pci/echoaudio/echoaudio_dsp.c:686:		err = set_output_gain(chip, i, chip->output_gain[i]);
./sound/pci/echoaudio/echoaudio_dsp.c:695:						chip->vmixer_gain[o][i]);
./sound/pci/echoaudio/echoaudio_dsp.c:707:						chip->monitor_gain[o][i]);
./sound/pci/echoaudio/echoaudio_dsp.c:715:		err = set_input_gain(chip, i, chip->input_gain[i]);
./sound/pci/echoaudio/echoaudio_dsp.c:729:	err = set_sample_rate(chip, chip->sample_rate);
./sound/pci/echoaudio/echoaudio_dsp.c:733:	if (chip->meters_enabled) {
./sound/pci/echoaudio/echoaudio_dsp.c:740:	if (set_digital_mode(chip, chip->digital_mode) < 0)
./sound/pci/echoaudio/echoaudio_dsp.c:745:	if (set_professional_spdif(chip, chip->professional_spdif) < 0)
./sound/pci/echoaudio/echoaudio_dsp.c:750:	if (set_phantom_power(chip, chip->phantom_power) < 0)
./sound/pci/echoaudio/echoaudio_dsp.c:756:	if (set_input_clock(chip, chip->input_clock) < 0)
./sound/pci/echoaudio/echoaudio_dsp.c:761:	if (set_output_clock(chip, chip->output_clock) < 0)
./sound/pci/echoaudio/echoaudio_dsp.c:850:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:852:	chip->comm_page->audio_format[pipe_index] = cpu_to_le16(dsp_format);
./sound/pci/echoaudio/echoaudio_dsp.c:868:	chip->comm_page->cmd_start |= cpu_to_le32(channel_mask);
./sound/pci/echoaudio/echoaudio_dsp.c:870:	if (chip->comm_page->cmd_start) {
./sound/pci/echoaudio/echoaudio_dsp.c:876:		chip->active_mask |= channel_mask;
./sound/pci/echoaudio/echoaudio_dsp.c:877:		chip->comm_page->cmd_start = 0;
./sound/pci/echoaudio/echoaudio_dsp.c:881:	dev_err(chip->card->dev, "start_transport: No pipes to start!\n");
./sound/pci/echoaudio/echoaudio_dsp.c:893:	chip->comm_page->cmd_stop |= cpu_to_le32(channel_mask);
./sound/pci/echoaudio/echoaudio_dsp.c:894:	chip->comm_page->cmd_reset = 0;
./sound/pci/echoaudio/echoaudio_dsp.c:895:	if (chip->comm_page->cmd_stop) {
./sound/pci/echoaudio/echoaudio_dsp.c:901:		chip->active_mask &= ~channel_mask;
./sound/pci/echoaudio/echoaudio_dsp.c:902:		chip->comm_page->cmd_stop = 0;
./sound/pci/echoaudio/echoaudio_dsp.c:903:		chip->comm_page->cmd_reset = 0;
./sound/pci/echoaudio/echoaudio_dsp.c:907:	dev_warn(chip->card->dev, "pause_transport: No pipes to stop!\n");
./sound/pci/echoaudio/echoaudio_dsp.c:919:	chip->comm_page->cmd_stop |= cpu_to_le32(channel_mask);
./sound/pci/echoaudio/echoaudio_dsp.c:920:	chip->comm_page->cmd_reset |= cpu_to_le32(channel_mask);
./sound/pci/echoaudio/echoaudio_dsp.c:921:	if (chip->comm_page->cmd_reset) {
./sound/pci/echoaudio/echoaudio_dsp.c:927:		chip->active_mask &= ~channel_mask;
./sound/pci/echoaudio/echoaudio_dsp.c:928:		chip->comm_page->cmd_stop = 0;
./sound/pci/echoaudio/echoaudio_dsp.c:929:		chip->comm_page->cmd_reset = 0;
./sound/pci/echoaudio/echoaudio_dsp.c:933:	dev_warn(chip->card->dev, "stop_transport: No pipes to stop!\n");
./sound/pci/echoaudio/echoaudio_dsp.c:941:	return (chip->pipe_alloc_mask & (1 << pipe_index));
./sound/pci/echoaudio/echoaudio_dsp.c:952:	stop_transport(chip, chip->active_mask);
./sound/pci/echoaudio/echoaudio_dsp.c:961:	if (chip->dsp_code) {
./sound/pci/echoaudio/echoaudio_dsp.c:963:		chip->dsp_code = NULL;
./sound/pci/echoaudio/echoaudio_dsp.c:977:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:983:	chip->card_name = ECHOCARD_NAME;
./sound/pci/echoaudio/echoaudio_dsp.c:984:	chip->bad_board = true;	/* Set true until DSP loaded */
./sound/pci/echoaudio/echoaudio_dsp.c:985:	chip->dsp_code = NULL;	/* Current DSP code not loaded */
./sound/pci/echoaudio/echoaudio_dsp.c:986:	chip->asic_loaded = false;
./sound/pci/echoaudio/echoaudio_dsp.c:987:	memset(chip->comm_page, 0, sizeof(struct comm_page));
./sound/pci/echoaudio/echoaudio_dsp.c:990:	chip->comm_page->comm_size =
./sound/pci/echoaudio/echoaudio_dsp.c:992:	chip->comm_page->handshake = 0xffffffff;
./sound/pci/echoaudio/echoaudio_dsp.c:993:	chip->comm_page->midi_out_free_count =
./sound/pci/echoaudio/echoaudio_dsp.c:995:	chip->comm_page->sample_rate = cpu_to_le32(44100);
./sound/pci/echoaudio/echoaudio_dsp.c:998:	memset(chip->comm_page->monitors, ECHOGAIN_MUTED, MONITOR_ARRAY_SIZE);
./sound/pci/echoaudio/echoaudio_dsp.c:999:	memset(chip->comm_page->vmixer, ECHOGAIN_MUTED, VMIXER_ARRAY_SIZE);
./sound/pci/echoaudio/echoaudio_dsp.c:1012:	memset(chip->output_gain, ECHOGAIN_MUTED, sizeof(chip->output_gain));
./sound/pci/echoaudio/echoaudio_dsp.c:1013:	memset(chip->input_gain, ECHOGAIN_MUTED, sizeof(chip->input_gain));
./sound/pci/echoaudio/echoaudio_dsp.c:1014:	memset(chip->monitor_gain, ECHOGAIN_MUTED, sizeof(chip->monitor_gain));
./sound/pci/echoaudio/echoaudio_dsp.c:1015:	memset(chip->vmixer_gain, ECHOGAIN_MUTED, sizeof(chip->vmixer_gain));
./sound/pci/echoaudio/echoaudio_dsp.c:1016:	chip->input_clock = ECHO_CLOCK_INTERNAL;
./sound/pci/echoaudio/echoaudio_dsp.c:1017:	chip->output_clock = ECHO_CLOCK_WORD;
./sound/pci/echoaudio/echoaudio_dsp.c:1018:	chip->sample_rate = 44100;
./sound/pci/echoaudio/echoaudio_dsp.c:1036:		if (chip->comm_page->midi_input[0])	/* The count is at index 0 */
./sound/pci/echoaudio/echoaudio_dsp.c:1040:		chip->comm_page->midi_input[0] = 0;
./sound/pci/echoaudio/echoaudio_dsp.c:1063:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:1066:	if (chip->bad_board)
./sound/pci/echoaudio/echoaudio_dsp.c:1073:	if (chip->pipe_alloc_mask & channel_mask) {
./sound/pci/echoaudio/echoaudio_dsp.c:1074:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_dsp.c:1079:	chip->comm_page->position[pipe_index] = 0;
./sound/pci/echoaudio/echoaudio_dsp.c:1080:	chip->pipe_alloc_mask |= channel_mask;
./sound/pci/echoaudio/echoaudio_dsp.c:1082:		chip->pipe_cyclic_mask |= channel_mask;
./sound/pci/echoaudio/echoaudio_dsp.c:1090:	pipe->dma_counter = &chip->comm_page->position[pipe_index];
./sound/pci/echoaudio/echoaudio_dsp.c:1110:	chip->pipe_alloc_mask &= ~channel_mask;
./sound/pci/echoaudio/echoaudio_dsp.c:1111:	chip->pipe_cyclic_mask &= ~channel_mask;
./sound/pci/echoaudio/echoaudio_dsp.c:1125:	chip->comm_page->sglist_addr[pipe->index].addr =
./sound/pci/echoaudio/echoaudio_dsp.c:1143:		dev_err(chip->card->dev, "SGlist: too many fragments\n");
./sound/pci/echoaudio/layla24_dsp.c:47:		dev_err(chip->card->dev,
./sound/pci/echoaudio/layla24_dsp.c:52:	chip->device_id = device_id;
./sound/pci/echoaudio/layla24_dsp.c:53:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/layla24_dsp.c:54:	chip->bad_board = true;
./sound/pci/echoaudio/layla24_dsp.c:55:	chip->has_midi = true;
./sound/pci/echoaudio/layla24_dsp.c:56:	chip->dsp_code_to_load = FW_LAYLA24_DSP;
./sound/pci/echoaudio/layla24_dsp.c:57:	chip->input_clock_types =
./sound/pci/echoaudio/layla24_dsp.c:60:	chip->digital_modes =
./sound/pci/echoaudio/layla24_dsp.c:67:	chip->bad_board = false;
./sound/pci/echoaudio/layla24_dsp.c:79:	chip->digital_mode = DIGITAL_MODE_SPDIF_RCA;
./sound/pci/echoaudio/layla24_dsp.c:80:	chip->professional_spdif = false;
./sound/pci/echoaudio/layla24_dsp.c:81:	chip->digital_in_automute = true;
./sound/pci/echoaudio/layla24_dsp.c:92:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/layla24_dsp.c:116:	if (chip->asic_loaded)
./sound/pci/echoaudio/layla24_dsp.c:129:	chip->asic_code = FW_LAYLA24_2S_ASIC;
./sound/pci/echoaudio/layla24_dsp.c:162:		       chip->digital_mode == DIGITAL_MODE_ADAT))
./sound/pci/echoaudio/layla24_dsp.c:166:	if (chip->input_clock != ECHO_CLOCK_INTERNAL) {
./sound/pci/echoaudio/layla24_dsp.c:167:		dev_warn(chip->card->dev,
./sound/pci/echoaudio/layla24_dsp.c:170:		chip->comm_page->sample_rate = cpu_to_le32(rate);
./sound/pci/echoaudio/layla24_dsp.c:171:		chip->sample_rate = rate;
./sound/pci/echoaudio/layla24_dsp.c:176:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/layla24_dsp.c:230:		chip->comm_page->sample_rate =
./sound/pci/echoaudio/layla24_dsp.c:239:	chip->comm_page->sample_rate = cpu_to_le32(rate);	/* ignored by the DSP ? */
./sound/pci/echoaudio/layla24_dsp.c:240:	chip->sample_rate = rate;
./sound/pci/echoaudio/layla24_dsp.c:241:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/layla24_dsp.c:254:	control_reg = le32_to_cpu(chip->comm_page->control_register) &
./sound/pci/echoaudio/layla24_dsp.c:256:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/layla24_dsp.c:261:		chip->input_clock = ECHO_CLOCK_INTERNAL;
./sound/pci/echoaudio/layla24_dsp.c:262:		return set_sample_rate(chip, chip->sample_rate);
./sound/pci/echoaudio/layla24_dsp.c:264:		if (chip->digital_mode == DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/layla24_dsp.c:278:		if (chip->digital_mode != DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/layla24_dsp.c:284:		dev_err(chip->card->dev,
./sound/pci/echoaudio/layla24_dsp.c:289:	chip->input_clock = clock;
./sound/pci/echoaudio/layla24_dsp.c:303:	if (asic != chip->asic_code) {
./sound/pci/echoaudio/layla24_dsp.c:304:		monitors = kmemdup(chip->comm_page->monitors,
./sound/pci/echoaudio/layla24_dsp.c:309:		memset(chip->comm_page->monitors, ECHOGAIN_MUTED,
./sound/pci/echoaudio/layla24_dsp.c:315:			memcpy(chip->comm_page->monitors, monitors,
./sound/pci/echoaudio/layla24_dsp.c:320:		chip->asic_code = asic;
./sound/pci/echoaudio/layla24_dsp.c:321:		memcpy(chip->comm_page->monitors, monitors, MONITOR_ARRAY_SIZE);
./sound/pci/echoaudio/layla24_dsp.c:341:		if (chip->input_clock == ECHO_CLOCK_ADAT)
./sound/pci/echoaudio/layla24_dsp.c:346:		if (chip->input_clock == ECHO_CLOCK_SPDIF)
./sound/pci/echoaudio/layla24_dsp.c:351:		dev_err(chip->card->dev,
./sound/pci/echoaudio/layla24_dsp.c:357:		chip->sample_rate = 48000;
./sound/pci/echoaudio/layla24_dsp.c:358:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/layla24_dsp.c:360:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/layla24_dsp.c:367:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/layla24_dsp.c:370:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/layla24_dsp.c:387:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/layla24_dsp.c:390:	chip->digital_mode = mode;
./sound/pci/echoaudio/layla24_dsp.c:392:	dev_dbg(chip->card->dev, "set_digital_mode to %d\n", mode);
./sound/pci/echoaudio/darla24_dsp.c:40:		dev_err(chip->card->dev,
./sound/pci/echoaudio/darla24_dsp.c:45:	chip->device_id = device_id;
./sound/pci/echoaudio/darla24_dsp.c:46:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/darla24_dsp.c:47:	chip->bad_board = true;
./sound/pci/echoaudio/darla24_dsp.c:48:	chip->dsp_code_to_load = FW_DARLA24_DSP;
./sound/pci/echoaudio/darla24_dsp.c:51:	chip->asic_loaded = true;
./sound/pci/echoaudio/darla24_dsp.c:52:	chip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL |
./sound/pci/echoaudio/darla24_dsp.c:57:	chip->bad_board = false;
./sound/pci/echoaudio/darla24_dsp.c:77:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/darla24_dsp.c:130:		dev_err(chip->card->dev,
./sound/pci/echoaudio/darla24_dsp.c:139:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/darla24_dsp.c:141:	chip->sample_rate = rate;
./sound/pci/echoaudio/darla24_dsp.c:144:	if (chip->input_clock == ECHO_CLOCK_ESYNC)
./sound/pci/echoaudio/darla24_dsp.c:147:	chip->comm_page->sample_rate = cpu_to_le32(rate);	/* ignored by the DSP ? */
./sound/pci/echoaudio/darla24_dsp.c:148:	chip->comm_page->gd_clock_state = clock;
./sound/pci/echoaudio/darla24_dsp.c:160:	chip->input_clock = clock;
./sound/pci/echoaudio/darla24_dsp.c:161:	return set_sample_rate(chip, chip->sample_rate);
./sound/pci/echoaudio/gina24_dsp.c:48:		dev_err(chip->card->dev,
./sound/pci/echoaudio/gina24_dsp.c:53:	chip->device_id = device_id;
./sound/pci/echoaudio/gina24_dsp.c:54:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/gina24_dsp.c:55:	chip->bad_board = true;
./sound/pci/echoaudio/gina24_dsp.c:56:	chip->input_clock_types =
./sound/pci/echoaudio/gina24_dsp.c:62:	if (chip->device_id == DEVICE_ID_56361) {
./sound/pci/echoaudio/gina24_dsp.c:63:		chip->dsp_code_to_load = FW_GINA24_361_DSP;
./sound/pci/echoaudio/gina24_dsp.c:64:		chip->digital_modes =
./sound/pci/echoaudio/gina24_dsp.c:69:		chip->dsp_code_to_load = FW_GINA24_301_DSP;
./sound/pci/echoaudio/gina24_dsp.c:70:		chip->digital_modes =
./sound/pci/echoaudio/gina24_dsp.c:79:	chip->bad_board = false;
./sound/pci/echoaudio/gina24_dsp.c:88:	chip->digital_mode = DIGITAL_MODE_SPDIF_RCA;
./sound/pci/echoaudio/gina24_dsp.c:89:	chip->professional_spdif = false;
./sound/pci/echoaudio/gina24_dsp.c:90:	chip->digital_in_automute = true;
./sound/pci/echoaudio/gina24_dsp.c:102:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/gina24_dsp.c:128:	if (chip->asic_loaded)
./sound/pci/echoaudio/gina24_dsp.c:135:	if (chip->device_id == DEVICE_ID_56361)
./sound/pci/echoaudio/gina24_dsp.c:144:	chip->asic_code = asic;
./sound/pci/echoaudio/gina24_dsp.c:167:		       chip->digital_mode == DIGITAL_MODE_ADAT))
./sound/pci/echoaudio/gina24_dsp.c:171:	if (chip->input_clock != ECHO_CLOCK_INTERNAL) {
./sound/pci/echoaudio/gina24_dsp.c:172:		dev_warn(chip->card->dev,
./sound/pci/echoaudio/gina24_dsp.c:175:		chip->comm_page->sample_rate = cpu_to_le32(rate);
./sound/pci/echoaudio/gina24_dsp.c:176:		chip->sample_rate = rate;
./sound/pci/echoaudio/gina24_dsp.c:182:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/gina24_dsp.c:218:		dev_err(chip->card->dev,
./sound/pci/echoaudio/gina24_dsp.c:225:	chip->comm_page->sample_rate = cpu_to_le32(rate);	/* ignored by the DSP */
./sound/pci/echoaudio/gina24_dsp.c:226:	chip->sample_rate = rate;
./sound/pci/echoaudio/gina24_dsp.c:227:	dev_dbg(chip->card->dev, "set_sample_rate: %d clock %d\n", rate, clock);
./sound/pci/echoaudio/gina24_dsp.c:240:	control_reg = le32_to_cpu(chip->comm_page->control_register) &
./sound/pci/echoaudio/gina24_dsp.c:242:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/gina24_dsp.c:246:		chip->input_clock = ECHO_CLOCK_INTERNAL;
./sound/pci/echoaudio/gina24_dsp.c:247:		return set_sample_rate(chip, chip->sample_rate);
./sound/pci/echoaudio/gina24_dsp.c:249:		if (chip->digital_mode == DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/gina24_dsp.c:258:		if (chip->digital_mode != DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/gina24_dsp.c:271:		dev_err(chip->card->dev,
./sound/pci/echoaudio/gina24_dsp.c:276:	chip->input_clock = clock;
./sound/pci/echoaudio/gina24_dsp.c:293:		if (chip->input_clock == ECHO_CLOCK_ADAT)
./sound/pci/echoaudio/gina24_dsp.c:297:		if (chip->input_clock == ECHO_CLOCK_SPDIF)
./sound/pci/echoaudio/gina24_dsp.c:301:		dev_err(chip->card->dev,
./sound/pci/echoaudio/gina24_dsp.c:306:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/gina24_dsp.c:309:		chip->sample_rate = 48000;
./sound/pci/echoaudio/gina24_dsp.c:314:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/gina24_dsp.c:324:		if (chip->device_id == DEVICE_ID_56301)
./sound/pci/echoaudio/gina24_dsp.c:337:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/gina24_dsp.c:340:	chip->digital_mode = mode;
./sound/pci/echoaudio/gina24_dsp.c:342:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/gina24_dsp.c:343:		"set_digital_mode to %d\n", chip->digital_mode);
./sound/pci/echoaudio/darla20_dsp.c:40:		dev_err(chip->card->dev,
./sound/pci/echoaudio/darla20_dsp.c:45:	chip->device_id = device_id;
./sound/pci/echoaudio/darla20_dsp.c:46:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/darla20_dsp.c:47:	chip->bad_board = true;
./sound/pci/echoaudio/darla20_dsp.c:48:	chip->dsp_code_to_load = FW_DARLA20_DSP;
./sound/pci/echoaudio/darla20_dsp.c:49:	chip->spdif_status = GD_SPDIF_STATUS_UNDEF;
./sound/pci/echoaudio/darla20_dsp.c:50:	chip->clock_state = GD_CLOCK_UNDEF;
./sound/pci/echoaudio/darla20_dsp.c:53:	chip->asic_loaded = true;
./sound/pci/echoaudio/darla20_dsp.c:54:	chip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL;
./sound/pci/echoaudio/darla20_dsp.c:58:	chip->bad_board = false;
./sound/pci/echoaudio/darla20_dsp.c:110:	if (chip->clock_state == clock_state)
./sound/pci/echoaudio/darla20_dsp.c:112:	if (spdif_status == chip->spdif_status)
./sound/pci/echoaudio/darla20_dsp.c:115:	chip->comm_page->sample_rate = cpu_to_le32(rate);
./sound/pci/echoaudio/darla20_dsp.c:116:	chip->comm_page->gd_clock_state = clock_state;
./sound/pci/echoaudio/darla20_dsp.c:117:	chip->comm_page->gd_spdif_status = spdif_status;
./sound/pci/echoaudio/darla20_dsp.c:118:	chip->comm_page->gd_resampler_state = 3;	/* magic number - should always be 3 */
./sound/pci/echoaudio/darla20_dsp.c:122:		chip->clock_state = clock_state;
./sound/pci/echoaudio/darla20_dsp.c:124:		chip->spdif_status = spdif_status;
./sound/pci/echoaudio/darla20_dsp.c:125:	chip->sample_rate = rate;
./sound/pci/echoaudio/mona_dsp.c:48:		dev_err(chip->card->dev,
./sound/pci/echoaudio/mona_dsp.c:53:	chip->device_id = device_id;
./sound/pci/echoaudio/mona_dsp.c:54:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/mona_dsp.c:55:	chip->bad_board = true;
./sound/pci/echoaudio/mona_dsp.c:56:	chip->input_clock_types =
./sound/pci/echoaudio/mona_dsp.c:59:	chip->digital_modes =
./sound/pci/echoaudio/mona_dsp.c:65:	if (chip->device_id == DEVICE_ID_56361)
./sound/pci/echoaudio/mona_dsp.c:66:		chip->dsp_code_to_load = FW_MONA_361_DSP;
./sound/pci/echoaudio/mona_dsp.c:68:		chip->dsp_code_to_load = FW_MONA_301_DSP;
./sound/pci/echoaudio/mona_dsp.c:72:	chip->bad_board = false;
./sound/pci/echoaudio/mona_dsp.c:81:	chip->digital_mode = DIGITAL_MODE_SPDIF_RCA;
./sound/pci/echoaudio/mona_dsp.c:82:	chip->professional_spdif = false;
./sound/pci/echoaudio/mona_dsp.c:83:	chip->digital_in_automute = true;
./sound/pci/echoaudio/mona_dsp.c:95:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/mona_dsp.c:121:	if (chip->asic_loaded)
./sound/pci/echoaudio/mona_dsp.c:126:	if (chip->device_id == DEVICE_ID_56361)
./sound/pci/echoaudio/mona_dsp.c:135:	chip->asic_code = asic;
./sound/pci/echoaudio/mona_dsp.c:170:	if (chip->device_id == DEVICE_ID_56361) {
./sound/pci/echoaudio/mona_dsp.c:182:	if (asic != chip->asic_code) {
./sound/pci/echoaudio/mona_dsp.c:188:		chip->asic_code = asic;
./sound/pci/echoaudio/mona_dsp.c:203:	if (chip->input_clock != ECHO_CLOCK_INTERNAL) {
./sound/pci/echoaudio/mona_dsp.c:204:		dev_dbg(chip->card->dev,
./sound/pci/echoaudio/mona_dsp.c:207:		chip->comm_page->sample_rate = cpu_to_le32(rate);
./sound/pci/echoaudio/mona_dsp.c:208:		chip->sample_rate = rate;
./sound/pci/echoaudio/mona_dsp.c:214:		if (chip->digital_mode == DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/mona_dsp.c:216:		if (chip->device_id == DEVICE_ID_56361)
./sound/pci/echoaudio/mona_dsp.c:221:		if (chip->device_id == DEVICE_ID_56361)
./sound/pci/echoaudio/mona_dsp.c:228:	if (asic != chip->asic_code) {
./sound/pci/echoaudio/mona_dsp.c:231:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/mona_dsp.c:234:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/mona_dsp.c:238:		chip->asic_code = asic;
./sound/pci/echoaudio/mona_dsp.c:244:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/mona_dsp.c:281:		dev_err(chip->card->dev,
./sound/pci/echoaudio/mona_dsp.c:288:	chip->comm_page->sample_rate = cpu_to_le32(rate);	/* ignored by the DSP */
./sound/pci/echoaudio/mona_dsp.c:289:	chip->sample_rate = rate;
./sound/pci/echoaudio/mona_dsp.c:290:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/mona_dsp.c:305:	if (atomic_read(&chip->opencount))
./sound/pci/echoaudio/mona_dsp.c:309:	control_reg = le32_to_cpu(chip->comm_page->control_register) &
./sound/pci/echoaudio/mona_dsp.c:311:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/mona_dsp.c:315:		chip->input_clock = ECHO_CLOCK_INTERNAL;
./sound/pci/echoaudio/mona_dsp.c:316:		return set_sample_rate(chip, chip->sample_rate);
./sound/pci/echoaudio/mona_dsp.c:318:		if (chip->digital_mode == DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/mona_dsp.c:320:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/mona_dsp.c:323:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/mona_dsp.c:333:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/mona_dsp.c:336:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/mona_dsp.c:346:		dev_dbg(chip->card->dev, "Set Mona clock to ADAT\n");
./sound/pci/echoaudio/mona_dsp.c:347:		if (chip->digital_mode != DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/mona_dsp.c:353:		dev_err(chip->card->dev,
./sound/pci/echoaudio/mona_dsp.c:358:	chip->input_clock = clock;
./sound/pci/echoaudio/mona_dsp.c:374:		if (chip->input_clock == ECHO_CLOCK_ADAT)
./sound/pci/echoaudio/mona_dsp.c:378:		if (chip->input_clock == ECHO_CLOCK_SPDIF)
./sound/pci/echoaudio/mona_dsp.c:382:		dev_err(chip->card->dev,
./sound/pci/echoaudio/mona_dsp.c:387:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/mona_dsp.c:390:		chip->sample_rate = 48000;
./sound/pci/echoaudio/mona_dsp.c:395:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/mona_dsp.c:409:		if (chip->asic_code == FW_MONA_361_1_ASIC96 ||
./sound/pci/echoaudio/mona_dsp.c:410:		    chip->asic_code == FW_MONA_301_1_ASIC96) {
./sound/pci/echoaudio/mona_dsp.c:419:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/mona_dsp.c:422:	chip->digital_mode = mode;
./sound/pci/echoaudio/mona_dsp.c:424:	dev_dbg(chip->card->dev, "set_digital_mode to %d\n", mode);
./sound/pci/echoaudio/indigoiox_dsp.c:43:		dev_err(chip->card->dev,
./sound/pci/echoaudio/indigoiox_dsp.c:48:	chip->device_id = device_id;
./sound/pci/echoaudio/indigoiox_dsp.c:49:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/indigoiox_dsp.c:50:	chip->bad_board = true;
./sound/pci/echoaudio/indigoiox_dsp.c:51:	chip->dsp_code_to_load = FW_INDIGO_IOX_DSP;
./sound/pci/echoaudio/indigoiox_dsp.c:54:	chip->asic_loaded = true;
./sound/pci/echoaudio/indigoiox_dsp.c:55:	chip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL;
./sound/pci/echoaudio/indigoiox_dsp.c:60:	chip->bad_board = false;
./sound/pci/echoaudio/indigo_express_dsp.c:36:	old_control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/indigo_express_dsp.c:64:		dev_dbg(chip->card->dev,
./sound/pci/echoaudio/indigo_express_dsp.c:66:		chip->comm_page->control_register = cpu_to_le32(control_reg);
./sound/pci/echoaudio/indigo_express_dsp.c:67:		chip->sample_rate = rate;
./sound/pci/echoaudio/indigo_express_dsp.c:89:	chip->vmixer_gain[output][pipe] = gain;
./sound/pci/echoaudio/indigo_express_dsp.c:91:	chip->comm_page->vmixer[index] = gain;
./sound/pci/echoaudio/indigo_express_dsp.c:93:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echo3g_dsp.c:53:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echo3g_dsp.c:58:	chip->comm_page->e3g_frq_register =
./sound/pci/echoaudio/echo3g_dsp.c:60:	chip->device_id = device_id;
./sound/pci/echoaudio/echo3g_dsp.c:61:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/echo3g_dsp.c:62:	chip->bad_board = true;
./sound/pci/echoaudio/echo3g_dsp.c:63:	chip->has_midi = true;
./sound/pci/echoaudio/echo3g_dsp.c:64:	chip->dsp_code_to_load = FW_ECHO3G_DSP;
./sound/pci/echoaudio/echo3g_dsp.c:73:		chip->input_clock_types =	ECHO_CLOCK_BIT_INTERNAL |
./sound/pci/echoaudio/echo3g_dsp.c:76:		chip->card_name = "Gina3G";
./sound/pci/echoaudio/echo3g_dsp.c:77:		chip->px_digital_out = chip->bx_digital_out = 6;
./sound/pci/echoaudio/echo3g_dsp.c:78:		chip->px_analog_in = chip->bx_analog_in = 14;
./sound/pci/echoaudio/echo3g_dsp.c:79:		chip->px_digital_in = chip->bx_digital_in = 16;
./sound/pci/echoaudio/echo3g_dsp.c:80:		chip->px_num = chip->bx_num = 24;
./sound/pci/echoaudio/echo3g_dsp.c:81:		chip->has_phantom_power = true;
./sound/pci/echoaudio/echo3g_dsp.c:82:		chip->hasnt_input_nominal_level = true;
./sound/pci/echoaudio/echo3g_dsp.c:84:		chip->input_clock_types =	ECHO_CLOCK_BIT_INTERNAL |
./sound/pci/echoaudio/echo3g_dsp.c:88:		chip->card_name = "Layla3G";
./sound/pci/echoaudio/echo3g_dsp.c:89:		chip->px_digital_out = chip->bx_digital_out = 8;
./sound/pci/echoaudio/echo3g_dsp.c:90:		chip->px_analog_in = chip->bx_analog_in = 16;
./sound/pci/echoaudio/echo3g_dsp.c:91:		chip->px_digital_in = chip->bx_digital_in = 24;
./sound/pci/echoaudio/echo3g_dsp.c:92:		chip->px_num = chip->bx_num = 32;
./sound/pci/echoaudio/echo3g_dsp.c:97:	chip->digital_modes =	ECHOCAPS_HAS_DIGITAL_MODE_SPDIF_RCA |
./sound/pci/echoaudio/echo3g_dsp.c:108:	chip->digital_mode = DIGITAL_MODE_SPDIF_RCA;
./sound/pci/echoaudio/echo3g_dsp.c:109:	chip->professional_spdif = false;
./sound/pci/echoaudio/echo3g_dsp.c:110:	chip->non_audio_spdif = false;
./sound/pci/echoaudio/echo3g_dsp.c:111:	chip->bad_board = false;
./sound/pci/echoaudio/echo3g_dsp.c:112:	chip->phantom_power = false;
./sound/pci/echoaudio/echo3g_dsp.c:120:	u32 control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/echo3g_dsp.c:127:	chip->phantom_power = on;
./sound/pci/echoaudio/echo3g_dsp.c:129:				 le32_to_cpu(chip->comm_page->e3g_frq_register),
./sound/pci/echoaudio/mia_dsp.c:48:		dev_err(chip->card->dev,
./sound/pci/echoaudio/mia_dsp.c:53:	chip->device_id = device_id;
./sound/pci/echoaudio/mia_dsp.c:54:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/mia_dsp.c:55:	chip->bad_board = true;
./sound/pci/echoaudio/mia_dsp.c:56:	chip->dsp_code_to_load = FW_MIA_DSP;
./sound/pci/echoaudio/mia_dsp.c:59:	chip->asic_loaded = true;
./sound/pci/echoaudio/mia_dsp.c:61:		chip->has_midi = true;
./sound/pci/echoaudio/mia_dsp.c:62:	chip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL |
./sound/pci/echoaudio/mia_dsp.c:67:	chip->bad_board = false;
./sound/pci/echoaudio/mia_dsp.c:87:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/mia_dsp.c:128:		dev_err(chip->card->dev,
./sound/pci/echoaudio/mia_dsp.c:134:	if (chip->input_clock == ECHO_CLOCK_SPDIF)
./sound/pci/echoaudio/mia_dsp.c:138:	if (control_reg != le32_to_cpu(chip->comm_page->control_register)) {
./sound/pci/echoaudio/mia_dsp.c:142:		chip->comm_page->sample_rate = cpu_to_le32(rate);	/* ignored by the DSP */
./sound/pci/echoaudio/mia_dsp.c:143:		chip->comm_page->control_register = cpu_to_le32(control_reg);
./sound/pci/echoaudio/mia_dsp.c:144:		chip->sample_rate = rate;
./sound/pci/echoaudio/mia_dsp.c:156:	dev_dbg(chip->card->dev, "set_input_clock(%d)\n", clock);
./sound/pci/echoaudio/mia_dsp.c:161:	chip->input_clock = clock;
./sound/pci/echoaudio/mia_dsp.c:162:	return set_sample_rate(chip, chip->sample_rate);
./sound/pci/echoaudio/mia_dsp.c:180:	chip->vmixer_gain[output][pipe] = gain;
./sound/pci/echoaudio/mia_dsp.c:182:	chip->comm_page->vmixer[index] = gain;
./sound/pci/echoaudio/mia_dsp.c:184:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/mia_dsp.c:215:	dev_dbg(chip->card->dev, "set_professional_spdif %d\n", prof);
./sound/pci/echoaudio/mia_dsp.c:217:		chip->comm_page->flags |=
./sound/pci/echoaudio/mia_dsp.c:220:		chip->comm_page->flags &=
./sound/pci/echoaudio/mia_dsp.c:222:	chip->professional_spdif = prof;
./sound/pci/echoaudio/indigodjx_dsp.c:43:		dev_err(chip->card->dev,
./sound/pci/echoaudio/indigodjx_dsp.c:48:	chip->device_id = device_id;
./sound/pci/echoaudio/indigodjx_dsp.c:49:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/indigodjx_dsp.c:50:	chip->bad_board = true;
./sound/pci/echoaudio/indigodjx_dsp.c:51:	chip->dsp_code_to_load = FW_INDIGO_DJX_DSP;
./sound/pci/echoaudio/indigodjx_dsp.c:54:	chip->asic_loaded = true;
./sound/pci/echoaudio/indigodjx_dsp.c:55:	chip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL;
./sound/pci/echoaudio/indigodjx_dsp.c:60:	chip->bad_board = false;
./sound/pci/echoaudio/indigo_dsp.c:45:		dev_err(chip->card->dev,
./sound/pci/echoaudio/indigo_dsp.c:50:	chip->device_id = device_id;
./sound/pci/echoaudio/indigo_dsp.c:51:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/indigo_dsp.c:52:	chip->bad_board = true;
./sound/pci/echoaudio/indigo_dsp.c:53:	chip->dsp_code_to_load = FW_INDIGO_DSP;
./sound/pci/echoaudio/indigo_dsp.c:56:	chip->asic_loaded = true;
./sound/pci/echoaudio/indigo_dsp.c:57:	chip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL;
./sound/pci/echoaudio/indigo_dsp.c:61:	chip->bad_board = false;
./sound/pci/echoaudio/indigo_dsp.c:111:		dev_err(chip->card->dev,
./sound/pci/echoaudio/indigo_dsp.c:117:	if (control_reg != le32_to_cpu(chip->comm_page->control_register)) {
./sound/pci/echoaudio/indigo_dsp.c:121:		chip->comm_page->sample_rate = cpu_to_le32(rate);	/* ignored by the DSP */
./sound/pci/echoaudio/indigo_dsp.c:122:		chip->comm_page->control_register = cpu_to_le32(control_reg);
./sound/pci/echoaudio/indigo_dsp.c:123:		chip->sample_rate = rate;
./sound/pci/echoaudio/indigo_dsp.c:146:	chip->vmixer_gain[output][pipe] = gain;
./sound/pci/echoaudio/indigo_dsp.c:148:	chip->comm_page->vmixer[index] = gain;
./sound/pci/echoaudio/indigo_dsp.c:150:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/indigodj_dsp.c:45:		dev_err(chip->card->dev,
./sound/pci/echoaudio/indigodj_dsp.c:50:	chip->device_id = device_id;
./sound/pci/echoaudio/indigodj_dsp.c:51:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/indigodj_dsp.c:52:	chip->bad_board = true;
./sound/pci/echoaudio/indigodj_dsp.c:53:	chip->dsp_code_to_load = FW_INDIGO_DJ_DSP;
./sound/pci/echoaudio/indigodj_dsp.c:56:	chip->asic_loaded = true;
./sound/pci/echoaudio/indigodj_dsp.c:57:	chip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL;
./sound/pci/echoaudio/indigodj_dsp.c:61:	chip->bad_board = false;
./sound/pci/echoaudio/indigodj_dsp.c:111:		dev_err(chip->card->dev,
./sound/pci/echoaudio/indigodj_dsp.c:117:	if (control_reg != le32_to_cpu(chip->comm_page->control_register)) {
./sound/pci/echoaudio/indigodj_dsp.c:121:		chip->comm_page->sample_rate = cpu_to_le32(rate);	/* ignored by the DSP */
./sound/pci/echoaudio/indigodj_dsp.c:122:		chip->comm_page->control_register = cpu_to_le32(control_reg);
./sound/pci/echoaudio/indigodj_dsp.c:123:		chip->sample_rate = rate;
./sound/pci/echoaudio/indigodj_dsp.c:146:	chip->vmixer_gain[output][pipe] = gain;
./sound/pci/echoaudio/indigodj_dsp.c:148:	chip->comm_page->vmixer[index] = gain;
./sound/pci/echoaudio/indigodj_dsp.c:150:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio.c:50:	if (chip->fw_cache[fw_index]) {
./sound/pci/echoaudio/echoaudio.c:51:		dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio.c:54:		*fw_entry = chip->fw_cache[fw_index];
./sound/pci/echoaudio/echoaudio.c:59:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio.c:64:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio.c:68:		chip->fw_cache[fw_index] = *fw_entry;
./sound/pci/echoaudio/echoaudio.c:79:	dev_dbg(chip->card->dev, "firmware not released (kept in cache)\n");
./sound/pci/echoaudio/echoaudio.c:93:		if (chip->fw_cache[i]) {
./sound/pci/echoaudio/echoaudio.c:94:			release_firmware(chip->fw_cache[i]);
./sound/pci/echoaudio/echoaudio.c:95:			dev_dbg(chip->card->dev, "release_firmware(%d)\n", i);
./sound/pci/echoaudio/echoaudio.c:261:	if (!chip->can_set_rate) {
./sound/pci/echoaudio/echoaudio.c:263:		fixed.min = fixed.max = chip->sample_rate;
./sound/pci/echoaudio/echoaudio.c:291:	dev_dbg(chip->card->dev, "max_channels=%d\n", max_channels);
./sound/pci/echoaudio/echoaudio.c:298:	if (chip->digital_mode == DIGITAL_MODE_ADAT) {
./sound/pci/echoaudio/echoaudio.c:339:				       snd_dma_pci_data(chip->pci),
./sound/pci/echoaudio/echoaudio.c:341:		dev_err(chip->card->dev, "s-g list allocation failed\n");
./sound/pci/echoaudio/echoaudio.c:368:	atomic_inc(&chip->opencount);
./sound/pci/echoaudio/echoaudio.c:369:	if (atomic_read(&chip->opencount) > 1 && chip->rate_set)
./sound/pci/echoaudio/echoaudio.c:370:		chip->can_set_rate=0;
./sound/pci/echoaudio/echoaudio.c:371:	dev_dbg(chip->card->dev, "pcm_analog_in_open  cs=%d  oc=%d  r=%d\n",
./sound/pci/echoaudio/echoaudio.c:372:		chip->can_set_rate, atomic_read(&chip->opencount),
./sound/pci/echoaudio/echoaudio.c:373:		chip->sample_rate);
./sound/pci/echoaudio/echoaudio.c:403:	atomic_inc(&chip->opencount);
./sound/pci/echoaudio/echoaudio.c:404:	if (atomic_read(&chip->opencount) > 1 && chip->rate_set)
./sound/pci/echoaudio/echoaudio.c:405:		chip->can_set_rate=0;
./sound/pci/echoaudio/echoaudio.c:406:	dev_dbg(chip->card->dev, "pcm_analog_out_open  cs=%d  oc=%d  r=%d\n",
./sound/pci/echoaudio/echoaudio.c:407:		chip->can_set_rate, atomic_read(&chip->opencount),
./sound/pci/echoaudio/echoaudio.c:408:		chip->sample_rate);
./sound/pci/echoaudio/echoaudio.c:422:	mutex_lock(&chip->mode_mutex);
./sound/pci/echoaudio/echoaudio.c:423:	if (chip->digital_mode == DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/echoaudio.c:444:	atomic_inc(&chip->opencount);
./sound/pci/echoaudio/echoaudio.c:445:	if (atomic_read(&chip->opencount) > 1 && chip->rate_set)
./sound/pci/echoaudio/echoaudio.c:446:		chip->can_set_rate=0;
./sound/pci/echoaudio/echoaudio.c:449:	mutex_unlock(&chip->mode_mutex);
./sound/pci/echoaudio/echoaudio.c:463:	mutex_lock(&chip->mode_mutex);
./sound/pci/echoaudio/echoaudio.c:464:	if (chip->digital_mode == DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/echoaudio.c:486:	atomic_inc(&chip->opencount);
./sound/pci/echoaudio/echoaudio.c:487:	if (atomic_read(&chip->opencount) > 1 && chip->rate_set)
./sound/pci/echoaudio/echoaudio.c:488:		chip->can_set_rate=0;
./sound/pci/echoaudio/echoaudio.c:490:	mutex_unlock(&chip->mode_mutex);
./sound/pci/echoaudio/echoaudio.c:509:	atomic_dec(&chip->opencount);
./sound/pci/echoaudio/echoaudio.c:510:	oc = atomic_read(&chip->opencount);
./sound/pci/echoaudio/echoaudio.c:511:	dev_dbg(chip->card->dev, "pcm_close  oc=%d  cs=%d  rs=%d\n", oc,
./sound/pci/echoaudio/echoaudio.c:512:		chip->can_set_rate, chip->rate_set);
./sound/pci/echoaudio/echoaudio.c:514:		chip->can_set_rate = 1;
./sound/pci/echoaudio/echoaudio.c:516:		chip->rate_set = 0;
./sound/pci/echoaudio/echoaudio.c:517:	dev_dbg(chip->card->dev, "pcm_close2 oc=%d  cs=%d  rs=%d\n", oc,
./sound/pci/echoaudio/echoaudio.c:518:		chip->can_set_rate, chip->rate_set);
./sound/pci/echoaudio/echoaudio.c:540:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:542:		dev_dbg(chip->card->dev, "hwp_ie free(%d)\n", pipe->index);
./sound/pci/echoaudio/echoaudio.c:545:		chip->substream[pipe->index] = NULL;
./sound/pci/echoaudio/echoaudio.c:550:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:551:		dev_err(chip->card->dev, "allocate_pipes(%d) err=%d\n",
./sound/pci/echoaudio/echoaudio.c:555:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:556:	dev_dbg(chip->card->dev, "allocate_pipes()=%d\n", pipe_index);
./sound/pci/echoaudio/echoaudio.c:558:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio.c:565:		dev_err(chip->card->dev, "malloc_pages err=%d\n", err);
./sound/pci/echoaudio/echoaudio.c:566:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:568:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:605:	 * initialized before chip->substream
./sound/pci/echoaudio/echoaudio.c:607:	chip->last_period[pipe_index] = 0;
./sound/pci/echoaudio/echoaudio.c:611:	chip->substream[pipe_index] = substream;
./sound/pci/echoaudio/echoaudio.c:612:	chip->rate_set = 1;
./sound/pci/echoaudio/echoaudio.c:613:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:615:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:677:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:679:		dev_dbg(chip->card->dev, "pcm_hw_free(%d)\n", pipe->index);
./sound/pci/echoaudio/echoaudio.c:681:		chip->substream[pipe->index] = NULL;
./sound/pci/echoaudio/echoaudio.c:684:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:699:	dev_dbg(chip->card->dev, "Prepare rate=%d format=%d channels=%d\n",
./sound/pci/echoaudio/echoaudio.c:720:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio.c:747:			if (s == chip->substream[i]) {
./sound/pci/echoaudio/echoaudio.c:754:	spin_lock(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:761:				pipe = chip->substream[i]->runtime->private_data;
./sound/pci/echoaudio/echoaudio.c:764:					chip->last_period[i] = 0;
./sound/pci/echoaudio/echoaudio.c:777:				      chip->pipe_cyclic_mask);
./sound/pci/echoaudio/echoaudio.c:783:				pipe = chip->substream[i]->runtime->private_data;
./sound/pci/echoaudio/echoaudio.c:792:				pipe = chip->substream[i]->runtime->private_data;
./sound/pci/echoaudio/echoaudio.c:801:	spin_unlock(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:916:	if ((err = snd_pcm_new(chip->card, "PCM", 0, num_pipes_out(chip),
./sound/pci/echoaudio/echoaudio.c:920:	chip->analog_pcm = pcm;
./sound/pci/echoaudio/echoaudio.c:921:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/echoaudio/echoaudio.c:924:	if ((err = snd_echo_preallocate_pages(pcm, snd_dma_pci_data(chip->pci))) < 0)
./sound/pci/echoaudio/echoaudio.c:929:	if ((err = snd_pcm_new(chip->card, "Digital PCM", 1, 0,
./sound/pci/echoaudio/echoaudio.c:933:	chip->digital_pcm = pcm;
./sound/pci/echoaudio/echoaudio.c:934:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/echoaudio/echoaudio.c:936:	if ((err = snd_echo_preallocate_pages(pcm, snd_dma_pci_data(chip->pci))) < 0)
./sound/pci/echoaudio/echoaudio.c:948:	if ((err = snd_pcm_new(chip->card, "Analog PCM", 0,
./sound/pci/echoaudio/echoaudio.c:953:	chip->analog_pcm = pcm;
./sound/pci/echoaudio/echoaudio.c:954:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/echoaudio/echoaudio.c:957:	if ((err = snd_echo_preallocate_pages(pcm, snd_dma_pci_data(chip->pci))) < 0)
./sound/pci/echoaudio/echoaudio.c:962:	if ((err = snd_pcm_new(chip->card, "Digital PCM", 1,
./sound/pci/echoaudio/echoaudio.c:967:	chip->digital_pcm = pcm;
./sound/pci/echoaudio/echoaudio.c:968:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/echoaudio/echoaudio.c:971:	if ((err = snd_echo_preallocate_pages(pcm, snd_dma_pci_data(chip->pci))) < 0)
./sound/pci/echoaudio/echoaudio.c:1011:		ucontrol->value.integer.value[c] = chip->output_gain[c];
./sound/pci/echoaudio/echoaudio.c:1023:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1029:		if (chip->output_gain[c] != gain) {
./sound/pci/echoaudio/echoaudio.c:1036:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1092:		ucontrol->value.integer.value[c] = chip->input_gain[c];
./sound/pci/echoaudio/echoaudio.c:1104:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1110:		if (chip->input_gain[c] != gain) {
./sound/pci/echoaudio/echoaudio.c:1117:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1161:		ucontrol->value.integer.value[c] = chip->nominal_level[c];
./sound/pci/echoaudio/echoaudio.c:1173:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1175:		if (chip->nominal_level[c] != ucontrol->value.integer.value[c]) {
./sound/pci/echoaudio/echoaudio.c:1183:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1224:			chip->nominal_level[bx_analog_in(chip) + c];
./sound/pci/echoaudio/echoaudio.c:1236:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1238:		if (chip->nominal_level[bx_analog_in(chip) + c] !=
./sound/pci/echoaudio/echoaudio.c:1249:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1293:	ucontrol->value.integer.value[0] = chip->monitor_gain[out][in];
./sound/pci/echoaudio/echoaudio.c:1313:	if (chip->monitor_gain[out][in] != gain) {
./sound/pci/echoaudio/echoaudio.c:1314:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1317:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1362:		chip->vmixer_gain[ucontrol->id.index / num_pipes_out(chip)]
./sound/pci/echoaudio/echoaudio.c:1381:	if (chip->vmixer_gain[out][vch] != ucontrol->value.integer.value[0]) {
./sound/pci/echoaudio/echoaudio.c:1382:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1385:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1418:	return snd_ctl_enum_info(uinfo, 1, chip->num_digital_modes, names);
./sound/pci/echoaudio/echoaudio.c:1428:	mode = chip->digital_mode;
./sound/pci/echoaudio/echoaudio.c:1429:	for (i = chip->num_digital_modes - 1; i >= 0; i--)
./sound/pci/echoaudio/echoaudio.c:1430:		if (mode == chip->digital_mode_list[i]) {
./sound/pci/echoaudio/echoaudio.c:1448:	if (emode >= chip->num_digital_modes)
./sound/pci/echoaudio/echoaudio.c:1450:	dmode = chip->digital_mode_list[emode];
./sound/pci/echoaudio/echoaudio.c:1452:	if (dmode != chip->digital_mode) {
./sound/pci/echoaudio/echoaudio.c:1455:		mutex_lock(&chip->mode_mutex);
./sound/pci/echoaudio/echoaudio.c:1460:		if (atomic_read(&chip->opencount)) {
./sound/pci/echoaudio/echoaudio.c:1465:			if (changed > 0 && chip->clock_src_ctl) {
./sound/pci/echoaudio/echoaudio.c:1466:				snd_ctl_notify(chip->card,
./sound/pci/echoaudio/echoaudio.c:1468:					       &chip->clock_src_ctl->id);
./sound/pci/echoaudio/echoaudio.c:1469:				dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio.c:1475:		mutex_unlock(&chip->mode_mutex);
./sound/pci/echoaudio/echoaudio.c:1509:	ucontrol->value.enumerated.item[0] = !!chip->professional_spdif;
./sound/pci/echoaudio/echoaudio.c:1521:	if (mode != chip->professional_spdif) {
./sound/pci/echoaudio/echoaudio.c:1522:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1524:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1555:	return snd_ctl_enum_info(uinfo, 1, chip->num_clock_sources, names);
./sound/pci/echoaudio/echoaudio.c:1565:	clock = chip->input_clock;
./sound/pci/echoaudio/echoaudio.c:1567:	for (i = 0; i < chip->num_clock_sources; i++)
./sound/pci/echoaudio/echoaudio.c:1568:		if (clock == chip->clock_source_list[i])
./sound/pci/echoaudio/echoaudio.c:1584:	if (eclock >= chip->input_clock_types)
./sound/pci/echoaudio/echoaudio.c:1586:	dclock = chip->clock_source_list[eclock];
./sound/pci/echoaudio/echoaudio.c:1587:	if (chip->input_clock != dclock) {
./sound/pci/echoaudio/echoaudio.c:1588:		mutex_lock(&chip->mode_mutex);
./sound/pci/echoaudio/echoaudio.c:1589:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1592:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1593:		mutex_unlock(&chip->mode_mutex);
./sound/pci/echoaudio/echoaudio.c:1597:		dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio.c:1625:	ucontrol->value.integer.value[0] = chip->phantom_power;
./sound/pci/echoaudio/echoaudio.c:1636:	if (chip->phantom_power != power) {
./sound/pci/echoaudio/echoaudio.c:1637:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1639:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1668:	ucontrol->value.integer.value[0] = chip->digital_in_automute;
./sound/pci/echoaudio/echoaudio.c:1679:	if (chip->digital_in_automute != automute) {
./sound/pci/echoaudio/echoaudio.c:1680:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1682:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1710:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1712:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1794:	src = chip->num_clock_sources - 1;
./sound/pci/echoaudio/echoaudio.c:1798:				if (bit == chip->clock_source_list[src]) {
./sound/pci/echoaudio/echoaudio.c:1828:	spin_lock(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1831:		spin_unlock(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1837:		substream = chip->substream[ss];
./sound/pci/echoaudio/echoaudio.c:1842:			if (period != chip->last_period[ss]) {
./sound/pci/echoaudio/echoaudio.c:1843:				chip->last_period[ss] = period;
./sound/pci/echoaudio/echoaudio.c:1844:				spin_unlock(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1846:				spin_lock(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1850:	spin_unlock(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1853:	if (st > 0 && chip->midi_in) {
./sound/pci/echoaudio/echoaudio.c:1854:		snd_rawmidi_receive(chip->midi_in, chip->midi_buffer, st);
./sound/pci/echoaudio/echoaudio.c:1855:		dev_dbg(chip->card->dev, "rawmidi_iread=%d\n", st);
./sound/pci/echoaudio/echoaudio.c:1870:	if (chip->comm_page)
./sound/pci/echoaudio/echoaudio.c:1873:	if (chip->irq >= 0)
./sound/pci/echoaudio/echoaudio.c:1874:		free_irq(chip->irq, chip);
./sound/pci/echoaudio/echoaudio.c:1876:	if (chip->comm_page)
./sound/pci/echoaudio/echoaudio.c:1877:		snd_dma_free_pages(&chip->commpage_dma_buf);
./sound/pci/echoaudio/echoaudio.c:1879:	iounmap(chip->dsp_registers);
./sound/pci/echoaudio/echoaudio.c:1880:	release_and_free_resource(chip->iores);
./sound/pci/echoaudio/echoaudio.c:1881:	pci_disable_device(chip->pci);
./sound/pci/echoaudio/echoaudio.c:1928:		spin_lock_init(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:1929:		chip->card = card;
./sound/pci/echoaudio/echoaudio.c:1930:		chip->pci = pci;
./sound/pci/echoaudio/echoaudio.c:1931:		chip->irq = -1;
./sound/pci/echoaudio/echoaudio.c:1932:		atomic_set(&chip->opencount, 0);
./sound/pci/echoaudio/echoaudio.c:1933:		mutex_init(&chip->mode_mutex);
./sound/pci/echoaudio/echoaudio.c:1934:		chip->can_set_rate = 1;
./sound/pci/echoaudio/echoaudio.c:1943:	chip->dsp_registers_phys = pci_resource_start(pci, 0);
./sound/pci/echoaudio/echoaudio.c:1948:	if ((chip->iores = request_mem_region(chip->dsp_registers_phys, sz,
./sound/pci/echoaudio/echoaudio.c:1950:		dev_err(chip->card->dev, "cannot get memory region\n");
./sound/pci/echoaudio/echoaudio.c:1954:	chip->dsp_registers = (volatile u32 __iomem *)
./sound/pci/echoaudio/echoaudio.c:1955:		ioremap_nocache(chip->dsp_registers_phys, sz);
./sound/pci/echoaudio/echoaudio.c:1959:		dev_err(chip->card->dev, "cannot grab irq\n");
./sound/pci/echoaudio/echoaudio.c:1963:	chip->irq = pci->irq;
./sound/pci/echoaudio/echoaudio.c:1965:		chip->pci, chip->irq, chip->pci->subsystem_device);
./sound/pci/echoaudio/echoaudio.c:1969:	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/echoaudio/echoaudio.c:1971:				&chip->commpage_dma_buf) < 0) {
./sound/pci/echoaudio/echoaudio.c:1972:		dev_err(chip->card->dev, "cannot allocate the comm page\n");
./sound/pci/echoaudio/echoaudio.c:1976:	chip->comm_page_phys = chip->commpage_dma_buf.addr;
./sound/pci/echoaudio/echoaudio.c:1977:	chip->comm_page = (struct comm_page *)chip->commpage_dma_buf.area;
./sound/pci/echoaudio/echoaudio.c:1979:	err = init_hw(chip, chip->pci->device, chip->pci->subsystem_device);
./sound/pci/echoaudio/echoaudio.c:2029:	strcpy(card->shortname, chip->card_name);
./sound/pci/echoaudio/echoaudio.c:2037:		chip->dsp_registers_phys, chip->irq);
./sound/pci/echoaudio/echoaudio.c:2040:		dev_err(chip->card->dev, "new pcm error %d\n", err);
./sound/pci/echoaudio/echoaudio.c:2046:	if (chip->has_midi) {	/* Some Mia's do not have midi */
./sound/pci/echoaudio/echoaudio.c:2048:			dev_err(chip->card->dev, "new midi error %d\n", err);
./sound/pci/echoaudio/echoaudio.c:2057:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_vmixer, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2060:	err = snd_ctl_add(chip->card,
./sound/pci/echoaudio/echoaudio.c:2066:	err = snd_ctl_add(chip->card,
./sound/pci/echoaudio/echoaudio.c:2073:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_line_input_gain, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2078:	if (!chip->hasnt_input_nominal_level)
./sound/pci/echoaudio/echoaudio.c:2079:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_intput_nominal_level, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2084:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_output_nominal_level, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2088:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_vumeters_switch, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2091:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_vumeters, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2096:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_monitor_mixer, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2101:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_automute_switch, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2105:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_channels_info, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2110:	chip->num_digital_modes = 0;
./sound/pci/echoaudio/echoaudio.c:2112:		if (chip->digital_modes & (1 << i))
./sound/pci/echoaudio/echoaudio.c:2113:			chip->digital_mode_list[chip->num_digital_modes++] = i;
./sound/pci/echoaudio/echoaudio.c:2115:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_digital_mode_switch, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2121:	chip->num_clock_sources = 0;
./sound/pci/echoaudio/echoaudio.c:2123:		if (chip->input_clock_types & (1 << i))
./sound/pci/echoaudio/echoaudio.c:2124:			chip->clock_source_list[chip->num_clock_sources++] = i;
./sound/pci/echoaudio/echoaudio.c:2126:	if (chip->num_clock_sources > 1) {
./sound/pci/echoaudio/echoaudio.c:2127:		chip->clock_src_ctl = snd_ctl_new1(&snd_echo_clock_source_switch, chip);
./sound/pci/echoaudio/echoaudio.c:2128:		if ((err = snd_ctl_add(chip->card, chip->clock_src_ctl)) < 0)
./sound/pci/echoaudio/echoaudio.c:2134:	if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_spdif_mode_switch, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2139:	if (chip->has_phantom_power)
./sound/pci/echoaudio/echoaudio.c:2140:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_echo_phantom_power_switch, chip))) < 0)
./sound/pci/echoaudio/echoaudio.c:2167:	snd_pcm_suspend_all(chip->analog_pcm);
./sound/pci/echoaudio/echoaudio.c:2168:	snd_pcm_suspend_all(chip->digital_pcm);
./sound/pci/echoaudio/echoaudio.c:2172:	if (chip->midi_out)
./sound/pci/echoaudio/echoaudio.c:2173:		snd_echo_midi_output_trigger(chip->midi_out, 0);
./sound/pci/echoaudio/echoaudio.c:2175:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:2177:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:2182:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:2185:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio.c:2187:	chip->dsp_code = NULL;
./sound/pci/echoaudio/echoaudio.c:2188:	free_irq(chip->irq, chip);
./sound/pci/echoaudio/echoaudio.c:2189:	chip->irq = -1;
./sound/pci/echoaudio/echoaudio.c:2206:	commpage = chip->comm_page;
./sound/pci/echoaudio/echoaudio.c:2209:	err = init_hw(chip, chip->pci->device, chip->pci->subsystem_device);
./sound/pci/echoaudio/echoaudio.c:2217:	/* Temporarily set chip->pipe_alloc_mask=0 otherwise
./sound/pci/echoaudio/echoaudio.c:2220:	pipe_alloc_mask = chip->pipe_alloc_mask;
./sound/pci/echoaudio/echoaudio.c:2221:	chip->pipe_alloc_mask = 0;
./sound/pci/echoaudio/echoaudio.c:2223:	chip->pipe_alloc_mask = pipe_alloc_mask;
./sound/pci/echoaudio/echoaudio.c:2239:		dev_err(chip->card->dev, "cannot grab irq\n");
./sound/pci/echoaudio/echoaudio.c:2243:	chip->irq = pci->irq;
./sound/pci/echoaudio/echoaudio.c:2244:	dev_dbg(dev, "resume irq=%d\n", chip->irq);
./sound/pci/echoaudio/echoaudio.c:2247:	if (chip->midi_input_enabled)
./sound/pci/echoaudio/echoaudio.c:2249:	if (chip->midi_out)
./sound/pci/echoaudio/echoaudio.c:2250:		snd_echo_midi_output_trigger(chip->midi_out, 1);
./sound/pci/echoaudio/echoaudio.c:2269:		snd_card_free(chip->card);
./sound/pci/echoaudio/echo3g.c:37:#define PX_DIGITAL_OUT	chip->px_digital_out
./sound/pci/echoaudio/echo3g.c:38:#define PX_ANALOG_IN	chip->px_analog_in
./sound/pci/echoaudio/echo3g.c:39:#define PX_DIGITAL_IN	chip->px_digital_in
./sound/pci/echoaudio/echo3g.c:40:#define PX_NUM		chip->px_num
./sound/pci/echoaudio/echo3g.c:44:#define BX_DIGITAL_OUT	chip->bx_digital_out
./sound/pci/echoaudio/echo3g.c:45:#define BX_ANALOG_IN	chip->bx_analog_in
./sound/pci/echoaudio/echo3g.c:46:#define BX_DIGITAL_IN	chip->bx_digital_in
./sound/pci/echoaudio/echo3g.c:47:#define BX_NUM		chip->bx_num
./sound/pci/echoaudio/echoaudio_3g.c:43:	chip->comm_page->ext_box_status = cpu_to_le32(E3G_ASIC_NOT_LOADED);
./sound/pci/echoaudio/echoaudio_3g.c:44:	chip->asic_loaded = false;
./sound/pci/echoaudio/echoaudio_3g.c:49:		chip->dsp_code = NULL;
./sound/pci/echoaudio/echoaudio_3g.c:53:	box_status = le32_to_cpu(chip->comm_page->ext_box_status);
./sound/pci/echoaudio/echoaudio_3g.c:54:	dev_dbg(chip->card->dev, "box_status=%x\n", box_status);
./sound/pci/echoaudio/echoaudio_3g.c:58:	chip->asic_loaded = true;
./sound/pci/echoaudio/echoaudio_3g.c:66:	return le32_to_cpu(chip->comm_page->e3g_frq_register);
./sound/pci/echoaudio/echoaudio_3g.c:79:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio_3g.c:85:	if (ctl != chip->comm_page->control_register ||
./sound/pci/echoaudio/echoaudio_3g.c:86:	    frq != chip->comm_page->e3g_frq_register || force) {
./sound/pci/echoaudio/echoaudio_3g.c:87:		chip->comm_page->e3g_frq_register = frq;
./sound/pci/echoaudio/echoaudio_3g.c:88:		chip->comm_page->control_register = ctl;
./sound/pci/echoaudio/echoaudio_3g.c:93:	dev_dbg(chip->card->dev, "WriteControlReg: not written, no change\n");
./sound/pci/echoaudio/echoaudio_3g.c:106:	if (snd_BUG_ON(chip->pipe_alloc_mask))
./sound/pci/echoaudio/echoaudio_3g.c:109:	if (snd_BUG_ON(!(chip->digital_modes & (1 << mode))))
./sound/pci/echoaudio/echoaudio_3g.c:112:	previous_mode = chip->digital_mode;
./sound/pci/echoaudio/echoaudio_3g.c:120:		spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio_3g.c:124:						 chip->monitor_gain[o][i]);
./sound/pci/echoaudio/echoaudio_3g.c:128:			set_input_gain(chip, i, chip->input_gain[i]);
./sound/pci/echoaudio/echoaudio_3g.c:133:			set_output_gain(chip, o, chip->output_gain[o]);
./sound/pci/echoaudio/echoaudio_3g.c:135:		spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio_3g.c:152:		if (chip->professional_spdif)
./sound/pci/echoaudio/echoaudio_3g.c:160:	if (chip->professional_spdif)
./sound/pci/echoaudio/echoaudio_3g.c:163:	if (chip->non_audio_spdif)
./sound/pci/echoaudio/echoaudio_3g.c:179:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/echoaudio_3g.c:180:	chip->professional_spdif = prof;
./sound/pci/echoaudio/echoaudio_3g.c:181:	control_reg = set_spdif_bits(chip, control_reg, chip->sample_rate);
./sound/pci/echoaudio/echoaudio_3g.c:197:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/echoaudio_3g.c:204:	switch(chip->digital_mode) {
./sound/pci/echoaudio/echoaudio_3g.c:225:	if (chip->asic_loaded)
./sound/pci/echoaudio/echoaudio_3g.c:235:	chip->asic_code = FW_3G_ASIC;
./sound/pci/echoaudio/echoaudio_3g.c:261:	if (chip->input_clock != ECHO_CLOCK_INTERNAL) {
./sound/pci/echoaudio/echoaudio_3g.c:262:		dev_warn(chip->card->dev,
./sound/pci/echoaudio/echoaudio_3g.c:265:		chip->comm_page->sample_rate = cpu_to_le32(rate);
./sound/pci/echoaudio/echoaudio_3g.c:266:		chip->sample_rate = rate;
./sound/pci/echoaudio/echoaudio_3g.c:267:		set_input_clock(chip, chip->input_clock);
./sound/pci/echoaudio/echoaudio_3g.c:272:		       chip->digital_mode == DIGITAL_MODE_ADAT))
./sound/pci/echoaudio/echoaudio_3g.c:276:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/echoaudio_3g.c:315:	chip->comm_page->sample_rate = cpu_to_le32(rate);	/* ignored by the DSP */
./sound/pci/echoaudio/echoaudio_3g.c:316:	chip->sample_rate = rate;
./sound/pci/echoaudio/echoaudio_3g.c:317:	dev_dbg(chip->card->dev,
./sound/pci/echoaudio/echoaudio_3g.c:333:	control_reg = le32_to_cpu(chip->comm_page->control_register) &
./sound/pci/echoaudio/echoaudio_3g.c:335:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/echoaudio_3g.c:339:		chip->input_clock = ECHO_CLOCK_INTERNAL;
./sound/pci/echoaudio/echoaudio_3g.c:340:		return set_sample_rate(chip, chip->sample_rate);
./sound/pci/echoaudio/echoaudio_3g.c:342:		if (chip->digital_mode == DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/echoaudio_3g.c:351:		if (chip->digital_mode != DIGITAL_MODE_ADAT)
./sound/pci/echoaudio/echoaudio_3g.c:364:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_3g.c:369:	chip->input_clock = clock;
./sound/pci/echoaudio/echoaudio_3g.c:385:		if (chip->input_clock == ECHO_CLOCK_ADAT)
./sound/pci/echoaudio/echoaudio_3g.c:389:		if (chip->input_clock == ECHO_CLOCK_SPDIF)
./sound/pci/echoaudio/echoaudio_3g.c:393:		dev_err(chip->card->dev,
./sound/pci/echoaudio/echoaudio_3g.c:398:	spin_lock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio_3g.c:401:		chip->sample_rate = 48000;
./sound/pci/echoaudio/echoaudio_3g.c:406:	control_reg = le32_to_cpu(chip->comm_page->control_register);
./sound/pci/echoaudio/echoaudio_3g.c:424:	spin_unlock_irq(&chip->lock);
./sound/pci/echoaudio/echoaudio_3g.c:427:	chip->digital_mode = mode;
./sound/pci/echoaudio/echoaudio_3g.c:429:	dev_dbg(chip->card->dev, "set_digital_mode(%d)\n", chip->digital_mode);
./sound/pci/echoaudio/layla20_dsp.c:47:		dev_err(chip->card->dev,
./sound/pci/echoaudio/layla20_dsp.c:52:	chip->device_id = device_id;
./sound/pci/echoaudio/layla20_dsp.c:53:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/layla20_dsp.c:54:	chip->bad_board = true;
./sound/pci/echoaudio/layla20_dsp.c:55:	chip->has_midi = true;
./sound/pci/echoaudio/layla20_dsp.c:56:	chip->dsp_code_to_load = FW_LAYLA20_DSP;
./sound/pci/echoaudio/layla20_dsp.c:57:	chip->input_clock_types =
./sound/pci/echoaudio/layla20_dsp.c:60:	chip->output_clock_types =
./sound/pci/echoaudio/layla20_dsp.c:65:	chip->bad_board = false;
./sound/pci/echoaudio/layla20_dsp.c:74:	chip->professional_spdif = false;
./sound/pci/echoaudio/layla20_dsp.c:85:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/layla20_dsp.c:116:	chip->asic_loaded = false;
./sound/pci/echoaudio/layla20_dsp.c:123:			dev_err(chip->card->dev,
./sound/pci/echoaudio/layla20_dsp.c:130:				chip->asic_loaded = true;
./sound/pci/echoaudio/layla20_dsp.c:145:	if (chip->asic_loaded)
./sound/pci/echoaudio/layla20_dsp.c:166:	if (chip->input_clock != ECHO_CLOCK_INTERNAL) {
./sound/pci/echoaudio/layla20_dsp.c:167:		dev_warn(chip->card->dev,
./sound/pci/echoaudio/layla20_dsp.c:169:		chip->comm_page->sample_rate = cpu_to_le32(rate);
./sound/pci/echoaudio/layla20_dsp.c:170:		chip->sample_rate = rate;
./sound/pci/echoaudio/layla20_dsp.c:177:	dev_dbg(chip->card->dev, "set_sample_rate(%d)\n", rate);
./sound/pci/echoaudio/layla20_dsp.c:178:	chip->sample_rate = rate;
./sound/pci/echoaudio/layla20_dsp.c:179:	chip->comm_page->sample_rate = cpu_to_le32(rate);
./sound/pci/echoaudio/layla20_dsp.c:194:		rate = chip->sample_rate;
./sound/pci/echoaudio/layla20_dsp.c:207:		dev_err(chip->card->dev,
./sound/pci/echoaudio/layla20_dsp.c:212:	chip->input_clock = clock_source;
./sound/pci/echoaudio/layla20_dsp.c:214:	chip->comm_page->input_clock = cpu_to_le16(clock);
./sound/pci/echoaudio/layla20_dsp.c:236:		dev_err(chip->card->dev, "set_output_clock wrong clock\n");
./sound/pci/echoaudio/layla20_dsp.c:243:	chip->comm_page->output_clock = cpu_to_le16(clock);
./sound/pci/echoaudio/layla20_dsp.c:244:	chip->output_clock = clock;
./sound/pci/echoaudio/layla20_dsp.c:260:	chip->input_gain[input] = gain;
./sound/pci/echoaudio/layla20_dsp.c:262:	chip->comm_page->line_in_level[input] = gain;
./sound/pci/echoaudio/layla20_dsp.c:282:		chip->comm_page->flags |=
./sound/pci/echoaudio/layla20_dsp.c:285:		chip->comm_page->flags &=
./sound/pci/echoaudio/layla20_dsp.c:287:	chip->professional_spdif = prof;
./sound/pci/echoaudio/gina20_dsp.c:44:		dev_err(chip->card->dev,
./sound/pci/echoaudio/gina20_dsp.c:49:	chip->device_id = device_id;
./sound/pci/echoaudio/gina20_dsp.c:50:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/gina20_dsp.c:51:	chip->bad_board = true;
./sound/pci/echoaudio/gina20_dsp.c:52:	chip->dsp_code_to_load = FW_GINA20_DSP;
./sound/pci/echoaudio/gina20_dsp.c:53:	chip->spdif_status = GD_SPDIF_STATUS_UNDEF;
./sound/pci/echoaudio/gina20_dsp.c:54:	chip->clock_state = GD_CLOCK_UNDEF;
./sound/pci/echoaudio/gina20_dsp.c:57:	chip->asic_loaded = true;
./sound/pci/echoaudio/gina20_dsp.c:58:	chip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL |
./sound/pci/echoaudio/gina20_dsp.c:63:	chip->bad_board = false;
./sound/pci/echoaudio/gina20_dsp.c:72:	chip->professional_spdif = false;
./sound/pci/echoaudio/gina20_dsp.c:84:	clocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);
./sound/pci/echoaudio/gina20_dsp.c:126:	if (chip->clock_state == clock_state)
./sound/pci/echoaudio/gina20_dsp.c:128:	if (spdif_status == chip->spdif_status)
./sound/pci/echoaudio/gina20_dsp.c:131:	chip->comm_page->sample_rate = cpu_to_le32(rate);
./sound/pci/echoaudio/gina20_dsp.c:132:	chip->comm_page->gd_clock_state = clock_state;
./sound/pci/echoaudio/gina20_dsp.c:133:	chip->comm_page->gd_spdif_status = spdif_status;
./sound/pci/echoaudio/gina20_dsp.c:134:	chip->comm_page->gd_resampler_state = 3;	/* magic number - should always be 3 */
./sound/pci/echoaudio/gina20_dsp.c:138:		chip->clock_state = clock_state;
./sound/pci/echoaudio/gina20_dsp.c:140:		chip->spdif_status = spdif_status;
./sound/pci/echoaudio/gina20_dsp.c:141:	chip->sample_rate = rate;
./sound/pci/echoaudio/gina20_dsp.c:155:		chip->clock_state = GD_CLOCK_UNDEF;
./sound/pci/echoaudio/gina20_dsp.c:156:		chip->spdif_status = GD_SPDIF_STATUS_UNDEF;
./sound/pci/echoaudio/gina20_dsp.c:157:		set_sample_rate(chip, chip->sample_rate);
./sound/pci/echoaudio/gina20_dsp.c:158:		chip->input_clock = clock;
./sound/pci/echoaudio/gina20_dsp.c:161:		chip->comm_page->gd_clock_state = GD_CLOCK_SPDIFIN;
./sound/pci/echoaudio/gina20_dsp.c:162:		chip->comm_page->gd_spdif_status = GD_SPDIF_STATUS_NOCHANGE;
./sound/pci/echoaudio/gina20_dsp.c:165:		chip->clock_state = GD_CLOCK_SPDIFIN;
./sound/pci/echoaudio/gina20_dsp.c:166:		chip->input_clock = clock;
./sound/pci/echoaudio/gina20_dsp.c:186:	chip->input_gain[input] = gain;
./sound/pci/echoaudio/gina20_dsp.c:188:	chip->comm_page->line_in_level[input] = gain;
./sound/pci/echoaudio/gina20_dsp.c:208:		chip->comm_page->flags |=
./sound/pci/echoaudio/gina20_dsp.c:211:		chip->comm_page->flags &=
./sound/pci/echoaudio/gina20_dsp.c:213:	chip->professional_spdif = prof;
./sound/pci/echoaudio/indigoio_dsp.c:45:		dev_err(chip->card->dev,
./sound/pci/echoaudio/indigoio_dsp.c:50:	chip->device_id = device_id;
./sound/pci/echoaudio/indigoio_dsp.c:51:	chip->subdevice_id = subdevice_id;
./sound/pci/echoaudio/indigoio_dsp.c:52:	chip->bad_board = true;
./sound/pci/echoaudio/indigoio_dsp.c:53:	chip->dsp_code_to_load = FW_INDIGO_IO_DSP;
./sound/pci/echoaudio/indigoio_dsp.c:56:	chip->asic_loaded = true;
./sound/pci/echoaudio/indigoio_dsp.c:57:	chip->input_clock_types = ECHO_CLOCK_BIT_INTERNAL;
./sound/pci/echoaudio/indigoio_dsp.c:61:	chip->bad_board = false;
./sound/pci/echoaudio/indigoio_dsp.c:95:	chip->sample_rate = rate;
./sound/pci/echoaudio/indigoio_dsp.c:96:	chip->comm_page->sample_rate = cpu_to_le32(rate);
./sound/pci/echoaudio/indigoio_dsp.c:116:	chip->vmixer_gain[output][pipe] = gain;
./sound/pci/echoaudio/indigoio_dsp.c:118:	chip->comm_page->vmixer[index] = gain;
./sound/pci/echoaudio/indigoio_dsp.c:120:	dev_dbg(chip->card->dev,
./sound/pci/nm256/nm256.c:194:	u32 buf;	/* offset from chip->buffer */
./sound/pci/nm256/nm256.c:282:	return readb(chip->cport + offset);
./sound/pci/nm256/nm256.c:288:	return readw(chip->cport + offset);
./sound/pci/nm256/nm256.c:294:	return readl(chip->cport + offset);
./sound/pci/nm256/nm256.c:300:	writeb(val, chip->cport + offset);
./sound/pci/nm256/nm256.c:306:	writew(val, chip->cport + offset);
./sound/pci/nm256/nm256.c:312:	writel(val, chip->cport + offset);
./sound/pci/nm256/nm256.c:318:	offset -= chip->buffer_start;
./sound/pci/nm256/nm256.c:320:	if (offset < 0 || offset >= chip->buffer_size) {
./sound/pci/nm256/nm256.c:321:		dev_err(chip->card->dev,
./sound/pci/nm256/nm256.c:327:	memcpy_toio(chip->buffer + offset, src, size);
./sound/pci/nm256/nm256.c:346:	u32 coeff_buf = chip->coeff_buf[stream];
./sound/pci/nm256/nm256.c:370:		dev_dbg(chip->card->dev,
./sound/pci/nm256/nm256.c:380:	if (! chip->use_cache) {
./sound/pci/nm256/nm256.c:384:	if (! chip->coeffs_current) {
./sound/pci/nm256/nm256.c:385:		snd_nm256_write_buffer(chip, coefficients, chip->all_coeff_buf,
./sound/pci/nm256/nm256.c:387:		chip->coeffs_current = 1;
./sound/pci/nm256/nm256.c:389:		u32 base = chip->all_coeff_buf;
./sound/pci/nm256/nm256.c:467:	mutex_lock(&chip->irq_mutex);
./sound/pci/nm256/nm256.c:468:	if (chip->irq < 0) {
./sound/pci/nm256/nm256.c:469:		if (request_irq(chip->pci->irq, chip->interrupt, IRQF_SHARED,
./sound/pci/nm256/nm256.c:471:			dev_err(chip->card->dev,
./sound/pci/nm256/nm256.c:472:				"unable to grab IRQ %d\n", chip->pci->irq);
./sound/pci/nm256/nm256.c:473:			mutex_unlock(&chip->irq_mutex);
./sound/pci/nm256/nm256.c:476:		chip->irq = chip->pci->irq;
./sound/pci/nm256/nm256.c:478:	chip->irq_acks++;
./sound/pci/nm256/nm256.c:479:	mutex_unlock(&chip->irq_mutex);
./sound/pci/nm256/nm256.c:486:	mutex_lock(&chip->irq_mutex);
./sound/pci/nm256/nm256.c:487:	if (chip->irq_acks > 0)
./sound/pci/nm256/nm256.c:488:		chip->irq_acks--;
./sound/pci/nm256/nm256.c:489:	if (chip->irq_acks == 0 && chip->irq >= 0) {
./sound/pci/nm256/nm256.c:490:		free_irq(chip->irq, chip);
./sound/pci/nm256/nm256.c:491:		chip->irq = -1;
./sound/pci/nm256/nm256.c:493:	mutex_unlock(&chip->irq_mutex);
./sound/pci/nm256/nm256.c:571:	spin_lock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:595:	spin_unlock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:609:	spin_lock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:629:	spin_unlock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:650:	spin_lock_irq(&chip->reg_lock);
./sound/pci/nm256/nm256.c:653:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/nm256/nm256.c:758:	s = &chip->streams[SNDRV_PCM_STREAM_PLAYBACK];
./sound/pci/nm256/nm256.c:760:		spin_unlock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:762:		spin_lock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:773:	s = &chip->streams[SNDRV_PCM_STREAM_CAPTURE];
./sound/pci/nm256/nm256.c:775:		spin_unlock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:777:		spin_lock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:863:	snd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_PLAYBACK],
./sound/pci/nm256/nm256.c:875:	snd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_CAPTURE],
./sound/pci/nm256/nm256.c:941:		struct nm256_stream *s = &chip->streams[i];
./sound/pci/nm256/nm256.c:942:		s->bufptr = chip->buffer + (s->buf - chip->buffer_start);
./sound/pci/nm256/nm256.c:943:		s->bufptr_addr = chip->buffer_addr + (s->buf - chip->buffer_start);
./sound/pci/nm256/nm256.c:946:	err = snd_pcm_new(chip->card, chip->card->driver, device,
./sound/pci/nm256/nm256.c:956:	chip->pcm = pcm;
./sound/pci/nm256/nm256.c:980:	if (chip->badintrcount++ > 1000) {
./sound/pci/nm256/nm256.c:993:		if (chip->streams[SNDRV_PCM_STREAM_PLAYBACK].running)
./sound/pci/nm256/nm256.c:995:		if (chip->streams[SNDRV_PCM_STREAM_CAPTURE].running)
./sound/pci/nm256/nm256.c:997:		chip->badintrcount = 0;
./sound/pci/nm256/nm256.c:1025:	chip->badintrcount = 0;
./sound/pci/nm256/nm256.c:1029:	spin_lock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:1045:		dev_dbg(chip->card->dev, "NM256: Got misc interrupt #1\n");
./sound/pci/nm256/nm256.c:1054:		dev_dbg(chip->card->dev, "NM256: Got misc interrupt #2\n");
./sound/pci/nm256/nm256.c:1061:		dev_dbg(chip->card->dev,
./sound/pci/nm256/nm256.c:1068:	spin_unlock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:1091:	chip->badintrcount = 0;
./sound/pci/nm256/nm256.c:1095:	spin_lock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:1111:		dev_dbg(chip->card->dev, "NM256: Got misc interrupt #1\n");
./sound/pci/nm256/nm256.c:1119:		dev_dbg(chip->card->dev, "NM256: Got misc interrupt #2\n");
./sound/pci/nm256/nm256.c:1126:		dev_dbg(chip->card->dev,
./sound/pci/nm256/nm256.c:1133:	spin_unlock(&chip->reg_lock);
./sound/pci/nm256/nm256.c:1152:	testaddr = chip->mixer_status_offset;
./sound/pci/nm256/nm256.c:1153:	testb = chip->mixer_status_mask;
./sound/pci/nm256/nm256.c:1222:	return chip->ac97_regs[idx];
./sound/pci/nm256/nm256.c:1239:	base = chip->mixer_base;
./sound/pci/nm256/nm256.c:1249:			chip->ac97_regs[idx] = val;
./sound/pci/nm256/nm256.c:1253:	dev_dbg(chip->card->dev, "nm256: ac97 codec not ready..\n");
./sound/pci/nm256/nm256.c:1281:	if (! chip->reset_workaround) {
./sound/pci/nm256/nm256.c:1285:	if (! chip->reset_workaround_2) {
./sound/pci/nm256/nm256.c:1290:	if (! chip->in_resume) {
./sound/pci/nm256/nm256.c:1315:	chip->ac97_regs = kcalloc(ARRAY_SIZE(nm256_ac97_init_val),
./sound/pci/nm256/nm256.c:1317:	if (! chip->ac97_regs)
./sound/pci/nm256/nm256.c:1320:	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
./sound/pci/nm256/nm256.c:1328:	err = snd_ac97_mixer(pbus, &ac97, &chip->ac97);
./sound/pci/nm256/nm256.c:1331:	if (! (chip->ac97->id & (0xf0000000))) {
./sound/pci/nm256/nm256.c:1333:		sprintf(chip->card->mixername, "%s AC97", chip->card->driver);
./sound/pci/nm256/nm256.c:1350:	unsigned long pointer_found = chip->buffer_end - 0x1400;
./sound/pci/nm256/nm256.c:1353:	temp = ioremap_nocache(chip->buffer_addr + chip->buffer_end - 0x400, 16);
./sound/pci/nm256/nm256.c:1355:		dev_err(chip->card->dev,
./sound/pci/nm256/nm256.c:1368:		    pointer < chip->buffer_size ||
./sound/pci/nm256/nm256.c:1369:		    pointer > chip->buffer_end) {
./sound/pci/nm256/nm256.c:1370:			dev_err(chip->card->dev,
./sound/pci/nm256/nm256.c:1376:			dev_info(chip->card->dev,
./sound/pci/nm256/nm256.c:1383:	chip->buffer_end = pointer_found;
./sound/pci/nm256/nm256.c:1399:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/nm256/nm256.c:1400:	snd_ac97_suspend(chip->ac97);
./sound/pci/nm256/nm256.c:1401:	chip->coeffs_current = 0;
./sound/pci/nm256/nm256.c:1412:	chip->in_resume = 1;
./sound/pci/nm256/nm256.c:1417:	snd_ac97_resume(chip->ac97);
./sound/pci/nm256/nm256.c:1420:		struct nm256_stream *s = &chip->streams[i];
./sound/pci/nm256/nm256.c:1422:			spin_lock_irq(&chip->reg_lock);
./sound/pci/nm256/nm256.c:1424:			spin_unlock_irq(&chip->reg_lock);
./sound/pci/nm256/nm256.c:1429:	chip->in_resume = 0;
./sound/pci/nm256/nm256.c:1441:	if (chip->streams[SNDRV_PCM_STREAM_PLAYBACK].running)
./sound/pci/nm256/nm256.c:1443:	if (chip->streams[SNDRV_PCM_STREAM_CAPTURE].running)
./sound/pci/nm256/nm256.c:1446:	if (chip->irq >= 0)
./sound/pci/nm256/nm256.c:1447:		free_irq(chip->irq, chip);
./sound/pci/nm256/nm256.c:1449:	iounmap(chip->cport);
./sound/pci/nm256/nm256.c:1450:	iounmap(chip->buffer);
./sound/pci/nm256/nm256.c:1451:	release_and_free_resource(chip->res_cport);
./sound/pci/nm256/nm256.c:1452:	release_and_free_resource(chip->res_buffer);
./sound/pci/nm256/nm256.c:1454:	pci_disable_device(chip->pci);
./sound/pci/nm256/nm256.c:1455:	kfree(chip->ac97_regs);
./sound/pci/nm256/nm256.c:1488:	chip->card = card;
./sound/pci/nm256/nm256.c:1489:	chip->pci = pci;
./sound/pci/nm256/nm256.c:1490:	chip->use_cache = use_cache;
./sound/pci/nm256/nm256.c:1491:	spin_lock_init(&chip->reg_lock);
./sound/pci/nm256/nm256.c:1492:	chip->irq = -1;
./sound/pci/nm256/nm256.c:1493:	mutex_init(&chip->irq_mutex);
./sound/pci/nm256/nm256.c:1496:	chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize = playback_bufsize * 1024;
./sound/pci/nm256/nm256.c:1497:	chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize = capture_bufsize * 1024;
./sound/pci/nm256/nm256.c:1506:	chip->buffer_addr = pci_resource_start(pci, 0);
./sound/pci/nm256/nm256.c:1507:	chip->cport_addr = pci_resource_start(pci, 1);
./sound/pci/nm256/nm256.c:1511:	chip->res_cport = request_mem_region(chip->cport_addr, NM_PORT2_SIZE,
./sound/pci/nm256/nm256.c:1513:	if (chip->res_cport == NULL) {
./sound/pci/nm256/nm256.c:1515:			   chip->cport_addr, NM_PORT2_SIZE);
./sound/pci/nm256/nm256.c:1519:	chip->cport = ioremap_nocache(chip->cport_addr, NM_PORT2_SIZE);
./sound/pci/nm256/nm256.c:1520:	if (chip->cport == NULL) {
./sound/pci/nm256/nm256.c:1522:			chip->cport_addr);
./sound/pci/nm256/nm256.c:1544:		chip->buffer_end = 2560 * 1024;
./sound/pci/nm256/nm256.c:1545:		chip->interrupt = snd_nm256_interrupt;
./sound/pci/nm256/nm256.c:1546:		chip->mixer_status_offset = NM_MIXER_STATUS_OFFSET;
./sound/pci/nm256/nm256.c:1547:		chip->mixer_status_mask = NM_MIXER_READY_MASK;
./sound/pci/nm256/nm256.c:1551:			chip->buffer_end = 6144 * 1024;
./sound/pci/nm256/nm256.c:1553:			chip->buffer_end = 4096 * 1024;
./sound/pci/nm256/nm256.c:1555:		chip->interrupt = snd_nm256_interrupt_zx;
./sound/pci/nm256/nm256.c:1556:		chip->mixer_status_offset = NM2_MIXER_STATUS_OFFSET;
./sound/pci/nm256/nm256.c:1557:		chip->mixer_status_mask = NM2_MIXER_READY_MASK;
./sound/pci/nm256/nm256.c:1560:	chip->buffer_size = chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize +
./sound/pci/nm256/nm256.c:1561:		chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;
./sound/pci/nm256/nm256.c:1562:	if (chip->use_cache)
./sound/pci/nm256/nm256.c:1563:		chip->buffer_size += NM_TOTAL_COEFF_COUNT * 4;
./sound/pci/nm256/nm256.c:1565:		chip->buffer_size += NM_MAX_PLAYBACK_COEF_SIZE + NM_MAX_RECORD_COEF_SIZE;
./sound/pci/nm256/nm256.c:1567:	if (buffer_top >= chip->buffer_size && buffer_top < chip->buffer_end)
./sound/pci/nm256/nm256.c:1568:		chip->buffer_end = buffer_top;
./sound/pci/nm256/nm256.c:1575:	chip->buffer_start = chip->buffer_end - chip->buffer_size;
./sound/pci/nm256/nm256.c:1576:	chip->buffer_addr += chip->buffer_start;
./sound/pci/nm256/nm256.c:1579:	       chip->buffer_start, chip->buffer_end);
./sound/pci/nm256/nm256.c:1581:	chip->res_buffer = request_mem_region(chip->buffer_addr,
./sound/pci/nm256/nm256.c:1582:					      chip->buffer_size,
./sound/pci/nm256/nm256.c:1584:	if (chip->res_buffer == NULL) {
./sound/pci/nm256/nm256.c:1586:			   chip->buffer_addr, chip->buffer_size);
./sound/pci/nm256/nm256.c:1590:	chip->buffer = ioremap_nocache(chip->buffer_addr, chip->buffer_size);
./sound/pci/nm256/nm256.c:1591:	if (chip->buffer == NULL) {
./sound/pci/nm256/nm256.c:1594:			chip->buffer_addr);
./sound/pci/nm256/nm256.c:1599:	addr = chip->buffer_start;
./sound/pci/nm256/nm256.c:1600:	chip->streams[SNDRV_PCM_STREAM_PLAYBACK].buf = addr;
./sound/pci/nm256/nm256.c:1601:	addr += chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize;
./sound/pci/nm256/nm256.c:1602:	chip->streams[SNDRV_PCM_STREAM_CAPTURE].buf = addr;
./sound/pci/nm256/nm256.c:1603:	addr += chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;
./sound/pci/nm256/nm256.c:1604:	if (chip->use_cache) {
./sound/pci/nm256/nm256.c:1605:		chip->all_coeff_buf = addr;
./sound/pci/nm256/nm256.c:1607:		chip->coeff_buf[SNDRV_PCM_STREAM_PLAYBACK] = addr;
./sound/pci/nm256/nm256.c:1609:		chip->coeff_buf[SNDRV_PCM_STREAM_CAPTURE] = addr;
./sound/pci/nm256/nm256.c:1613:	chip->mixer_base = NM_MIXER_OFFSET;
./sound/pci/nm256/nm256.c:1615:	chip->coeffs_current = 0;
./sound/pci/nm256/nm256.c:1711:		chip->reset_workaround = 1;
./sound/pci/nm256/nm256.c:1716:		chip->reset_workaround_2 = 1;
./sound/pci/nm256/nm256.c:1728:		chip->buffer_addr, chip->cport_addr, chip->irq);
./sound/pci/vx222/vx222.c:121:	if (chip->irq >= 0)
./sound/pci/vx222/vx222.c:122:		free_irq(chip->irq, (void*)chip);
./sound/pci/vx222/vx222.c:178:	chip->irq = pci->irq;
./sound/pci/vx222/vx222_ops.c:90:	return chip->port[vx2_reg_index[reg]] + vx2_reg_offset[reg];
./sound/pci/vx222/vx222_ops.c:113:	dev_dbg(chip->card->dev, "outb: %x -> %x\n", val, vx2_reg_addr(chip, offset));
./sound/pci/vx222/vx222_ops.c:136:	dev_dbg(chip->card->dev, "outl: %x -> %x\n", val, vx2_reg_addr(chip, offset));
./sound/pci/vx222/vx222_ops.c:165:	vx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_DSP_RESET_MASK);
./sound/pci/vx222/vx222_ops.c:169:	chip->regCDSP |= VX_CDSP_DSP_RESET_MASK;
./sound/pci/vx222/vx222_ops.c:171:	vx_outl(chip, CDSP, chip->regCDSP);
./sound/pci/vx222/vx222_ops.c:180:	dev_dbg(_chip->card->dev, "testing xilinx...\n");
./sound/pci/vx222/vx222_ops.c:186:	vx_outl(chip, CDSP, chip->regCDSP | VX_CDSP_TEST0_MASK);
./sound/pci/vx222/vx222_ops.c:190:		dev_dbg(_chip->card->dev, "bad!\n");
./sound/pci/vx222/vx222_ops.c:195:	vx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_TEST0_MASK);
./sound/pci/vx222/vx222_ops.c:199:		dev_dbg(_chip->card->dev, "bad! #2\n");
./sound/pci/vx222/vx222_ops.c:203:	if (_chip->type == VX_TYPE_BOARD) {
./sound/pci/vx222/vx222_ops.c:206:		vx_outl(chip, CDSP, chip->regCDSP | VX_CDSP_TEST1_MASK);
./sound/pci/vx222/vx222_ops.c:210:			dev_dbg(_chip->card->dev, "bad! #3\n");
./sound/pci/vx222/vx222_ops.c:215:		vx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_TEST1_MASK);
./sound/pci/vx222/vx222_ops.c:219:			dev_dbg(_chip->card->dev, "bad! #4\n");
./sound/pci/vx222/vx222_ops.c:223:	dev_dbg(_chip->card->dev, "ok, xilinx fine.\n");
./sound/pci/vx222/vx222_ops.c:383:	if (chip->type == VX_TYPE_BOARD)
./sound/pci/vx222/vx222_ops.c:400:	if (chip->type != VX_TYPE_BOARD) {
./sound/pci/vx222/vx222_ops.c:405:		dev_err(chip->card->dev,
./sound/pci/vx222/vx222_ops.c:452:	if (! (chip->chip_status & VX_STAT_XILINX_LOADED))
./sound/pci/vx222/vx222_ops.c:488:		chip->regCDSP |= VX_CDSP_VALID_IRQ_MASK;
./sound/pci/vx222/vx222_ops.c:492:		chip->regCDSP &= ~VX_CDSP_VALID_IRQ_MASK;
./sound/pci/vx222/vx222_ops.c:494:	vx_outl(chip, CDSP, chip->regCDSP);
./sound/pci/vx222/vx222_ops.c:736:	vx_outl(chip, CDSP, chip->regCDSP &~ VX_CDSP_CODEC_RESET_MASK);
./sound/pci/vx222/vx222_ops.c:740:	chip->regCDSP |= VX_CDSP_CODEC_RESET_MASK;
./sound/pci/vx222/vx222_ops.c:741:	vx_outl(chip, CDSP, chip->regCDSP);
./sound/pci/vx222/vx222_ops.c:743:	if (_chip->type == VX_TYPE_BOARD) {
./sound/pci/vx222/vx222_ops.c:756:	if (_chip->type == VX_TYPE_MIC) {
./sound/pci/vx222/vx222_ops.c:758:		chip->regSELMIC =  MICRO_SELECT_INPUT_NORM |
./sound/pci/vx222/vx222_ops.c:763:		chip->regSELMIC &= ~MICRO_SELECT_PHANTOM_ALIM;
./sound/pci/vx222/vx222_ops.c:765:		vx_outl(_chip, SELMIC, chip->regSELMIC);
./sound/pci/vx222/vx222_ops.c:779:		chip->regCFG |= VX_CFG_DATAIN_SEL_MASK;
./sound/pci/vx222/vx222_ops.c:782:		chip->regCFG &= ~VX_CFG_DATAIN_SEL_MASK;
./sound/pci/vx222/vx222_ops.c:785:	vx_outl(chip, CFG, chip->regCFG);
./sound/pci/vx222/vx222_ops.c:797:		chip->regCFG &= ~VX_CFG_CLOCKIN_SEL_MASK;
./sound/pci/vx222/vx222_ops.c:799:		chip->regCFG |= VX_CFG_CLOCKIN_SEL_MASK;
./sound/pci/vx222/vx222_ops.c:800:	vx_outl(chip, CFG, chip->regCFG);
./sound/pci/vx222/vx222_ops.c:811:	chip->regCDSP = VX_CDSP_CODEC_RESET_MASK | VX_CDSP_DSP_RESET_MASK ;
./sound/pci/vx222/vx222_ops.c:812:	chip->regCFG = 0;
./sound/pci/vx222/vx222_ops.c:832:	miclevel = chip->mic_level;
./sound/pci/vx222/vx222_ops.c:843:	chip->regSELMIC &= ~MICRO_SELECT_PREAMPLI_MASK;
./sound/pci/vx222/vx222_ops.c:844:	chip->regSELMIC |= (preamp << MICRO_SELECT_PREAMPLI_OFFSET) & MICRO_SELECT_PREAMPLI_MASK;
./sound/pci/vx222/vx222_ops.c:845:	vx_outl(chip, SELMIC, chip->regSELMIC);
./sound/pci/vx222/vx222_ops.c:848:		(unsigned int)chip->input_level[1] << 8 |
./sound/pci/vx222/vx222_ops.c:849:		(unsigned int)chip->input_level[0];
./sound/pci/vx222/vx222_ops.c:882:	mutex_lock(&_chip->mixer_mutex);
./sound/pci/vx222/vx222_ops.c:883:	ucontrol->value.integer.value[0] = chip->input_level[0];
./sound/pci/vx222/vx222_ops.c:884:	ucontrol->value.integer.value[1] = chip->input_level[1];
./sound/pci/vx222/vx222_ops.c:885:	mutex_unlock(&_chip->mixer_mutex);
./sound/pci/vx222/vx222_ops.c:899:	mutex_lock(&_chip->mixer_mutex);
./sound/pci/vx222/vx222_ops.c:900:	if (chip->input_level[0] != ucontrol->value.integer.value[0] ||
./sound/pci/vx222/vx222_ops.c:901:	    chip->input_level[1] != ucontrol->value.integer.value[1]) {
./sound/pci/vx222/vx222_ops.c:902:		chip->input_level[0] = ucontrol->value.integer.value[0];
./sound/pci/vx222/vx222_ops.c:903:		chip->input_level[1] = ucontrol->value.integer.value[1];
./sound/pci/vx222/vx222_ops.c:905:		mutex_unlock(&_chip->mixer_mutex);
./sound/pci/vx222/vx222_ops.c:908:	mutex_unlock(&_chip->mixer_mutex);
./sound/pci/vx222/vx222_ops.c:926:	ucontrol->value.integer.value[0] = chip->mic_level;
./sound/pci/vx222/vx222_ops.c:937:	mutex_lock(&_chip->mixer_mutex);
./sound/pci/vx222/vx222_ops.c:938:	if (chip->mic_level != ucontrol->value.integer.value[0]) {
./sound/pci/vx222/vx222_ops.c:939:		chip->mic_level = ucontrol->value.integer.value[0];
./sound/pci/vx222/vx222_ops.c:941:		mutex_unlock(&_chip->mixer_mutex);
./sound/pci/vx222/vx222_ops.c:944:	mutex_unlock(&_chip->mixer_mutex);
./sound/pci/vx222/vx222_ops.c:979:	if (_chip->type != VX_TYPE_MIC)
./sound/pci/vx222/vx222_ops.c:983:	chip->input_level[0] = chip->input_level[1] = 0;
./sound/pci/vx222/vx222_ops.c:984:	chip->mic_level = 0;
./sound/pci/vx222/vx222_ops.c:988:	if ((err = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_input_level, chip))) < 0)
./sound/pci/vx222/vx222_ops.c:990:	if ((err = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_mic_level, chip))) < 0)
./sound/pci/ymfpci/ymfpci.c:92:	if (chip->pci->device >= 0x0010) { /* YMF 744/754 */
./sound/pci/ymfpci/ymfpci.c:96:			if (!(io_port = pci_resource_start(chip->pci, 2)))
./sound/pci/ymfpci/ymfpci.c:109:				dev_err(chip->card->dev,
./sound/pci/ymfpci/ymfpci.c:120:			dev_err(chip->card->dev,
./sound/pci/ymfpci/ymfpci.c:127:		dev_err(chip->card->dev,
./sound/pci/ymfpci/ymfpci.c:132:	chip->gameport = gp = gameport_allocate_port();
./sound/pci/ymfpci/ymfpci.c:134:		dev_err(chip->card->dev,
./sound/pci/ymfpci/ymfpci.c:142:	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
./sound/pci/ymfpci/ymfpci.c:143:	gameport_set_dev_parent(gp, &chip->pci->dev);
./sound/pci/ymfpci/ymfpci.c:147:	if (chip->pci->device >= 0x0010) /* YMF 744/754 */
./sound/pci/ymfpci/ymfpci.c:148:		pci_write_config_word(chip->pci, PCIR_DSXG_JOYBASE, io_port);
./sound/pci/ymfpci/ymfpci.c:150:	pci_write_config_word(chip->pci, PCIR_DSXG_LEGACY, legacy_ctrl | YMFPCI_LEGACY_JPEN);
./sound/pci/ymfpci/ymfpci.c:151:	pci_write_config_word(chip->pci, PCIR_DSXG_ELEGACY, legacy_ctrl2);
./sound/pci/ymfpci/ymfpci.c:153:	gameport_register_port(chip->gameport);
./sound/pci/ymfpci/ymfpci.c:160:	if (chip->gameport) {
./sound/pci/ymfpci/ymfpci.c:161:		struct resource *r = gameport_get_port_data(chip->gameport);
./sound/pci/ymfpci/ymfpci.c:163:		gameport_unregister_port(chip->gameport);
./sound/pci/ymfpci/ymfpci.c:164:		chip->gameport = NULL;
./sound/pci/ymfpci/ymfpci.c:276:	chip->fm_res = fm_res;
./sound/pci/ymfpci/ymfpci.c:277:	chip->mpu_res = mpu_res;
./sound/pci/ymfpci/ymfpci.c:284:		chip->reg_area_phys,
./sound/pci/ymfpci/ymfpci.c:285:		chip->irq);
./sound/pci/ymfpci/ymfpci.c:299:	if (chip->ac97->ext_id & AC97_EI_SDAC) {
./sound/pci/ymfpci/ymfpci.c:315:	if (chip->mpu_res) {
./sound/pci/ymfpci/ymfpci.c:320:					       -1, &chip->rawmidi)) < 0) {
./sound/pci/ymfpci/ymfpci.c:328:	if (chip->fm_res) {
./sound/pci/ymfpci/ymfpci_main.c:50:	return readb(chip->reg_area_virt + offset);
./sound/pci/ymfpci/ymfpci_main.c:55:	writeb(val, chip->reg_area_virt + offset);
./sound/pci/ymfpci/ymfpci_main.c:60:	return readw(chip->reg_area_virt + offset);
./sound/pci/ymfpci/ymfpci_main.c:65:	writew(val, chip->reg_area_virt + offset);
./sound/pci/ymfpci/ymfpci_main.c:70:	return readl(chip->reg_area_virt + offset);
./sound/pci/ymfpci/ymfpci_main.c:75:	writel(val, chip->reg_area_virt + offset);
./sound/pci/ymfpci/ymfpci_main.c:89:	dev_err(chip->card->dev,
./sound/pci/ymfpci/ymfpci_main.c:114:	if (chip->device_id == PCI_DEVICE_ID_YAMAHA_744 && chip->rev < 2) {
./sound/pci/ymfpci/ymfpci_main.c:183:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:184:	if (chip->start_count++ > 0)
./sound/pci/ymfpci/ymfpci_main.c:188:	chip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT) & 1;
./sound/pci/ymfpci/ymfpci_main.c:190:      	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:198:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:199:	if (--chip->start_count > 0)
./sound/pci/ymfpci/ymfpci_main.c:207:	if (atomic_read(&chip->interrupt_sleep_count)) {
./sound/pci/ymfpci/ymfpci_main.c:208:		atomic_set(&chip->interrupt_sleep_count, 0);
./sound/pci/ymfpci/ymfpci_main.c:209:		wake_up(&chip->interrupt_sleep);
./sound/pci/ymfpci/ymfpci_main.c:212:      	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:228:		voice = &chip->voices[idx];
./sound/pci/ymfpci/ymfpci_main.c:229:		voice2 = pair ? &chip->voices[idx+1] : NULL;
./sound/pci/ymfpci/ymfpci_main.c:269:	spin_lock_irqsave(&chip->voice_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:277:	spin_unlock_irqrestore(&chip->voice_lock, flags);	
./sound/pci/ymfpci/ymfpci_main.c:288:	spin_lock_irqsave(&chip->voice_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:289:	if (pvoice->number == chip->src441_used) {
./sound/pci/ymfpci/ymfpci_main.c:290:		chip->src441_used = -1;
./sound/pci/ymfpci/ymfpci_main.c:296:	spin_unlock_irqrestore(&chip->voice_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:313:	spin_lock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:315:		pos = le32_to_cpu(voice->bank[chip->active_bank].start);
./sound/pci/ymfpci/ymfpci_main.c:324:			dev_dbg(chip->card->dev,
./sound/pci/ymfpci/ymfpci_main.c:326:			       chip->active_bank,
./sound/pci/ymfpci/ymfpci_main.c:327:			       voice->bank[chip->active_bank].start);
./sound/pci/ymfpci/ymfpci_main.c:330:			spin_unlock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:332:			spin_lock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:337:			unsigned int next_bank = 1 - chip->active_bank;
./sound/pci/ymfpci/ymfpci_main.c:342:			volume = cpu_to_le32(chip->pcm_mixer[subs].left << 15);
./sound/pci/ymfpci/ymfpci_main.c:348:			volume = cpu_to_le32(chip->pcm_mixer[subs].right << 15);
./sound/pci/ymfpci/ymfpci_main.c:355:	spin_unlock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:365:	spin_lock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:367:		pos = le32_to_cpu(chip->bank_capture[ypcm->capture_bank_number][chip->active_bank]->start) >> ypcm->shift;
./sound/pci/ymfpci/ymfpci_main.c:377:			dev_dbg(chip->card->dev,
./sound/pci/ymfpci/ymfpci_main.c:379:			       chip->active_bank,
./sound/pci/ymfpci/ymfpci_main.c:380:			       voice->bank[chip->active_bank].start);
./sound/pci/ymfpci/ymfpci_main.c:382:			spin_unlock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:384:			spin_lock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:387:	spin_unlock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:398:	spin_lock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:407:		chip->ctrl_playback[ypcm->voices[0]->number + 1] = cpu_to_le32(ypcm->voices[0]->bank_addr);
./sound/pci/ymfpci/ymfpci_main.c:409:			chip->ctrl_playback[ypcm->voices[1]->number + 1] = cpu_to_le32(ypcm->voices[1]->bank_addr);
./sound/pci/ymfpci/ymfpci_main.c:413:		if (substream->pcm == chip->pcm && !ypcm->use_441_slot) {
./sound/pci/ymfpci/ymfpci_main.c:414:			kctl = chip->pcm_mixer[substream->number].ctl;
./sound/pci/ymfpci/ymfpci_main.c:420:		chip->ctrl_playback[ypcm->voices[0]->number + 1] = 0;
./sound/pci/ymfpci/ymfpci_main.c:422:			chip->ctrl_playback[ypcm->voices[1]->number + 1] = 0;
./sound/pci/ymfpci/ymfpci_main.c:430:	spin_unlock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:432:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &kctl->id);
./sound/pci/ymfpci/ymfpci_main.c:443:	spin_lock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:463:	spin_unlock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:491:		ypcm->voices[1] = &ypcm->chip->voices[ypcm->voices[0]->number + 1];
./sound/pci/ymfpci/ymfpci_main.c:522:		vol_left = cpu_to_le32(ypcm->chip->pcm_mixer
./sound/pci/ymfpci/ymfpci_main.c:524:		vol_right = cpu_to_le32(ypcm->chip->pcm_mixer
./sound/pci/ymfpci/ymfpci_main.c:530:	spin_lock_irqsave(&ypcm->chip->voice_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:534:	else if (ypcm->chip->device_id == PCI_DEVICE_ID_YAMAHA_754 &&
./sound/pci/ymfpci/ymfpci_main.c:536:		 voiceidx == 0 && (ypcm->chip->src441_used == -1 ||
./sound/pci/ymfpci/ymfpci_main.c:537:				   ypcm->chip->src441_used == voice->number)) {
./sound/pci/ymfpci/ymfpci_main.c:538:		ypcm->chip->src441_used = voice->number;
./sound/pci/ymfpci/ymfpci_main.c:542:	if (ypcm->chip->src441_used == voice->number &&
./sound/pci/ymfpci/ymfpci_main.c:544:		ypcm->chip->src441_used = -1;
./sound/pci/ymfpci/ymfpci_main.c:549:	spin_unlock_irqrestore(&ypcm->chip->voice_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:604:	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/ymfpci/ymfpci_main.c:605:				4096, &chip->ac3_tmp_base) < 0)
./sound/pci/ymfpci/ymfpci_main.c:608:	chip->bank_effect[3][0]->base =
./sound/pci/ymfpci/ymfpci_main.c:609:	chip->bank_effect[3][1]->base = cpu_to_le32(chip->ac3_tmp_base.addr);
./sound/pci/ymfpci/ymfpci_main.c:610:	chip->bank_effect[3][0]->loop_end =
./sound/pci/ymfpci/ymfpci_main.c:611:	chip->bank_effect[3][1]->loop_end = cpu_to_le32(1024);
./sound/pci/ymfpci/ymfpci_main.c:612:	chip->bank_effect[4][0]->base =
./sound/pci/ymfpci/ymfpci_main.c:613:	chip->bank_effect[4][1]->base = cpu_to_le32(chip->ac3_tmp_base.addr + 2048);
./sound/pci/ymfpci/ymfpci_main.c:614:	chip->bank_effect[4][0]->loop_end =
./sound/pci/ymfpci/ymfpci_main.c:615:	chip->bank_effect[4][1]->loop_end = cpu_to_le32(1024);
./sound/pci/ymfpci/ymfpci_main.c:617:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:620:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:626:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:629:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:631:	if (chip->ac3_tmp_base.area) {
./sound/pci/ymfpci/ymfpci_main.c:632:		snd_dma_free_pages(&chip->ac3_tmp_base);
./sound/pci/ymfpci/ymfpci_main.c:633:		chip->ac3_tmp_base.area = NULL;
./sound/pci/ymfpci/ymfpci_main.c:690:					  substream->pcm == chip->pcm);
./sound/pci/ymfpci/ymfpci_main.c:692:	if (substream->pcm == chip->pcm && !ypcm->use_441_slot) {
./sound/pci/ymfpci/ymfpci_main.c:693:		kctl = chip->pcm_mixer[substream->number].ctl;
./sound/pci/ymfpci/ymfpci_main.c:695:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &kctl->id);
./sound/pci/ymfpci/ymfpci_main.c:750:		bank = chip->bank_capture[ypcm->capture_bank_number][nbank];
./sound/pci/ymfpci/ymfpci_main.c:768:	return le32_to_cpu(voice->bank[chip->active_bank].start);
./sound/pci/ymfpci/ymfpci_main.c:779:	return le32_to_cpu(chip->bank_capture[ypcm->capture_bank_number][chip->active_bank]->start) >> ypcm->shift;
./sound/pci/ymfpci/ymfpci_main.c:791:		add_wait_queue(&chip->interrupt_sleep, &wait);
./sound/pci/ymfpci/ymfpci_main.c:792:		atomic_inc(&chip->interrupt_sleep_count);
./sound/pci/ymfpci/ymfpci_main.c:794:		remove_wait_queue(&chip->interrupt_sleep, &wait);
./sound/pci/ymfpci/ymfpci_main.c:806:		chip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT) & 1;
./sound/pci/ymfpci/ymfpci_main.c:807:		spin_lock(&chip->voice_lock);
./sound/pci/ymfpci/ymfpci_main.c:809:			voice = &chip->voices[nvoice];
./sound/pci/ymfpci/ymfpci_main.c:814:			if (chip->capture_substream[nvoice])
./sound/pci/ymfpci/ymfpci_main.c:815:				snd_ymfpci_pcm_capture_interrupt(chip->capture_substream[nvoice]);
./sound/pci/ymfpci/ymfpci_main.c:819:			if (chip->effect_substream[nvoice])
./sound/pci/ymfpci/ymfpci_main.c:820:				snd_ymfpci_pcm_effect_interrupt(chip->effect_substream[nvoice]);
./sound/pci/ymfpci/ymfpci_main.c:823:		spin_unlock(&chip->voice_lock);
./sound/pci/ymfpci/ymfpci_main.c:824:		spin_lock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:828:		spin_unlock(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:830:		if (atomic_read(&chip->interrupt_sleep_count)) {
./sound/pci/ymfpci/ymfpci_main.c:831:			atomic_set(&chip->interrupt_sleep_count, 0);
./sound/pci/ymfpci/ymfpci_main.c:832:			wake_up(&chip->interrupt_sleep);
./sound/pci/ymfpci/ymfpci_main.c:838:		if (chip->timer)
./sound/pci/ymfpci/ymfpci_main.c:839:			snd_timer_interrupt(chip->timer, chip->timer_ticks);
./sound/pci/ymfpci/ymfpci_main.c:843:	if (chip->rawmidi)
./sound/pci/ymfpci/ymfpci_main.c:844:		snd_mpu401_uart_interrupt(irq, chip->rawmidi->private_data);
./sound/pci/ymfpci/ymfpci_main.c:929:	if (! chip->rear_opened) {
./sound/pci/ymfpci/ymfpci_main.c:930:		if (! chip->spdif_opened) /* set AC3 */
./sound/pci/ymfpci/ymfpci_main.c:942:	if (! chip->rear_opened) {
./sound/pci/ymfpci/ymfpci_main.c:943:		if (! chip->spdif_opened)
./sound/pci/ymfpci/ymfpci_main.c:962:	ypcm->output_rear = chip->mode_dup4ch ? 1 : 0;
./sound/pci/ymfpci/ymfpci_main.c:964:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:967:		chip->rear_opened++;
./sound/pci/ymfpci/ymfpci_main.c:969:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:986:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:990:	chip->spdif_pcm_bits = chip->spdif_bits;
./sound/pci/ymfpci/ymfpci_main.c:991:	snd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_pcm_bits);
./sound/pci/ymfpci/ymfpci_main.c:992:	chip->spdif_opened++;
./sound/pci/ymfpci/ymfpci_main.c:993:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:995:	chip->spdif_pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
./sound/pci/ymfpci/ymfpci_main.c:996:	snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |
./sound/pci/ymfpci/ymfpci_main.c:997:		       SNDRV_CTL_EVENT_MASK_INFO, &chip->spdif_pcm_ctl->id);
./sound/pci/ymfpci/ymfpci_main.c:1014:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1016:	chip->rear_opened++;
./sound/pci/ymfpci/ymfpci_main.c:1017:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1047:	chip->capture_substream[capture_bank_number] = substream;
./sound/pci/ymfpci/ymfpci_main.c:1074:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1075:	if (ypcm->output_rear && chip->rear_opened > 0) {
./sound/pci/ymfpci/ymfpci_main.c:1076:		chip->rear_opened--;
./sound/pci/ymfpci/ymfpci_main.c:1079:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1087:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1088:	chip->spdif_opened = 0;
./sound/pci/ymfpci/ymfpci_main.c:1092:	snd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);
./sound/pci/ymfpci/ymfpci_main.c:1093:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1094:	chip->spdif_pcm_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
./sound/pci/ymfpci/ymfpci_main.c:1095:	snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |
./sound/pci/ymfpci/ymfpci_main.c:1096:		       SNDRV_CTL_EVENT_MASK_INFO, &chip->spdif_pcm_ctl->id);
./sound/pci/ymfpci/ymfpci_main.c:1104:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1105:	if (chip->rear_opened > 0) {
./sound/pci/ymfpci/ymfpci_main.c:1106:		chip->rear_opened--;
./sound/pci/ymfpci/ymfpci_main.c:1109:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1120:		chip->capture_substream[ypcm->capture_bank_number] = NULL;
./sound/pci/ymfpci/ymfpci_main.c:1153:	if ((err = snd_pcm_new(chip->card, "YMFPCI", device, 32, 1, &pcm)) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1163:	chip->pcm = pcm;
./sound/pci/ymfpci/ymfpci_main.c:1166:					      snd_dma_pci_data(chip->pci), 64*1024, 256*1024);
./sound/pci/ymfpci/ymfpci_main.c:1188:	if ((err = snd_pcm_new(chip->card, "YMFPCI - PCM2", device, 0, 1, &pcm)) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1197:		chip->device_id == PCI_DEVICE_ID_YAMAHA_754 ? "Direct Recording" : "AC'97");
./sound/pci/ymfpci/ymfpci_main.c:1198:	chip->pcm2 = pcm;
./sound/pci/ymfpci/ymfpci_main.c:1201:					      snd_dma_pci_data(chip->pci), 64*1024, 256*1024);
./sound/pci/ymfpci/ymfpci_main.c:1222:	if ((err = snd_pcm_new(chip->card, "YMFPCI - IEC958", device, 1, 0, &pcm)) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1231:	chip->pcm_spdif = pcm;
./sound/pci/ymfpci/ymfpci_main.c:1234:					      snd_dma_pci_data(chip->pci), 64*1024, 256*1024);
./sound/pci/ymfpci/ymfpci_main.c:1263:	if ((err = snd_pcm_new(chip->card, "YMFPCI - Rear", device, 1, 0, &pcm)) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1272:	chip->pcm_4ch = pcm;
./sound/pci/ymfpci/ymfpci_main.c:1275:					      snd_dma_pci_data(chip->pci), 64*1024, 256*1024);
./sound/pci/ymfpci/ymfpci_main.c:1293:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1294:	ucontrol->value.iec958.status[0] = (chip->spdif_bits >> 0) & 0xff;
./sound/pci/ymfpci/ymfpci_main.c:1295:	ucontrol->value.iec958.status[1] = (chip->spdif_bits >> 8) & 0xff;
./sound/pci/ymfpci/ymfpci_main.c:1297:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1310:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1311:	change = chip->spdif_bits != val;
./sound/pci/ymfpci/ymfpci_main.c:1312:	chip->spdif_bits = val;
./sound/pci/ymfpci/ymfpci_main.c:1313:	if ((snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) & 1) && chip->pcm_spdif == NULL)
./sound/pci/ymfpci/ymfpci_main.c:1314:		snd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);
./sound/pci/ymfpci/ymfpci_main.c:1315:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1340:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1343:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1368:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1369:	ucontrol->value.iec958.status[0] = (chip->spdif_pcm_bits >> 0) & 0xff;
./sound/pci/ymfpci/ymfpci_main.c:1370:	ucontrol->value.iec958.status[1] = (chip->spdif_pcm_bits >> 8) & 0xff;
./sound/pci/ymfpci/ymfpci_main.c:1372:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1385:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1386:	change = chip->spdif_pcm_bits != val;
./sound/pci/ymfpci/ymfpci_main.c:1387:	chip->spdif_pcm_bits = val;
./sound/pci/ymfpci/ymfpci_main.c:1389:		snd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_pcm_bits);
./sound/pci/ymfpci/ymfpci_main.c:1390:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1416:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1418:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1431:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1438:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1498:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1503:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1539:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1541:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1561:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1566:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1581:	spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1586:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:1598:	ucontrol->value.integer.value[0] = chip->mode_dup4ch;
./sound/pci/ymfpci/ymfpci_main.c:1606:	change = (ucontrol->value.integer.value[0] != chip->mode_dup4ch);
./sound/pci/ymfpci/ymfpci_main.c:1608:		chip->mode_dup4ch = !!ucontrol->value.integer.value[0];
./sound/pci/ymfpci/ymfpci_main.c:1660:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1671:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1680:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1687:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1744:	ucontrol->value.integer.value[0] = chip->pcm_mixer[subs].left;
./sound/pci/ymfpci/ymfpci_main.c:1745:	ucontrol->value.integer.value[1] = chip->pcm_mixer[subs].right;
./sound/pci/ymfpci/ymfpci_main.c:1757:	if (ucontrol->value.integer.value[0] != chip->pcm_mixer[subs].left ||
./sound/pci/ymfpci/ymfpci_main.c:1758:	    ucontrol->value.integer.value[1] != chip->pcm_mixer[subs].right) {
./sound/pci/ymfpci/ymfpci_main.c:1759:		chip->pcm_mixer[subs].left = ucontrol->value.integer.value[0];
./sound/pci/ymfpci/ymfpci_main.c:1760:		chip->pcm_mixer[subs].right = ucontrol->value.integer.value[1];
./sound/pci/ymfpci/ymfpci_main.c:1761:		if (chip->pcm_mixer[subs].left > 0x8000)
./sound/pci/ymfpci/ymfpci_main.c:1762:			chip->pcm_mixer[subs].left = 0x8000;
./sound/pci/ymfpci/ymfpci_main.c:1763:		if (chip->pcm_mixer[subs].right > 0x8000)
./sound/pci/ymfpci/ymfpci_main.c:1764:			chip->pcm_mixer[subs].right = 0x8000;
./sound/pci/ymfpci/ymfpci_main.c:1767:		spin_lock_irqsave(&chip->voice_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1773:		spin_unlock_irqrestore(&chip->voice_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1797:	chip->ac97_bus = NULL;
./sound/pci/ymfpci/ymfpci_main.c:1803:	chip->ac97 = NULL;
./sound/pci/ymfpci/ymfpci_main.c:1818:	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1820:	chip->ac97_bus->private_free = snd_ymfpci_mixer_free_ac97_bus;
./sound/pci/ymfpci/ymfpci_main.c:1821:	chip->ac97_bus->no_vra = 1; /* YMFPCI doesn't need VRA */
./sound/pci/ymfpci/ymfpci_main.c:1826:	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1830:	snd_ac97_update_bits(chip->ac97, AC97_EXTENDED_STATUS,
./sound/pci/ymfpci/ymfpci_main.c:1834:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_ymfpci_controls[idx], chip))) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1837:	if (chip->ac97->ext_id & AC97_EI_SDAC) {
./sound/pci/ymfpci/ymfpci_main.c:1839:		err = snd_ctl_add(chip->card, kctl);
./sound/pci/ymfpci/ymfpci_main.c:1845:	if (snd_BUG_ON(!chip->pcm_spdif))
./sound/pci/ymfpci/ymfpci_main.c:1847:	if ((err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_ymfpci_spdif_default, chip))) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1849:	kctl->id.device = chip->pcm_spdif->device;
./sound/pci/ymfpci/ymfpci_main.c:1850:	if ((err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_ymfpci_spdif_mask, chip))) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1852:	kctl->id.device = chip->pcm_spdif->device;
./sound/pci/ymfpci/ymfpci_main.c:1853:	if ((err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_ymfpci_spdif_stream, chip))) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1855:	kctl->id.device = chip->pcm_spdif->device;
./sound/pci/ymfpci/ymfpci_main.c:1856:	chip->spdif_pcm_ctl = kctl;
./sound/pci/ymfpci/ymfpci_main.c:1859:	if (chip->device_id == PCI_DEVICE_ID_YAMAHA_754 &&
./sound/pci/ymfpci/ymfpci_main.c:1860:	    (err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_ymfpci_drec_source, chip))) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1867:		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_ymfpci_rear_shared, chip))) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1872:	substream = chip->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
./sound/pci/ymfpci/ymfpci_main.c:1877:		kctl->id.device = chip->pcm->device;
./sound/pci/ymfpci/ymfpci_main.c:1880:		if ((err = snd_ctl_add(chip->card, kctl)) < 0)
./sound/pci/ymfpci/ymfpci_main.c:1882:		chip->pcm_mixer[idx].left = 0x8000;
./sound/pci/ymfpci/ymfpci_main.c:1883:		chip->pcm_mixer[idx].right = 0x8000;
./sound/pci/ymfpci/ymfpci_main.c:1884:		chip->pcm_mixer[idx].ctl = kctl;
./sound/pci/ymfpci/ymfpci_main.c:1903:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1905:		chip->timer_ticks = timer->sticks;
./sound/pci/ymfpci/ymfpci_main.c:1912:		chip->timer_ticks = 2;
./sound/pci/ymfpci/ymfpci_main.c:1917:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1927:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1929:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/ymfpci/ymfpci_main.c:1958:	tid.card = chip->card->number;
./sound/pci/ymfpci/ymfpci_main.c:1961:	if ((err = snd_timer_new(chip->card, "YMFPCI", &tid, &timer)) >= 0) {
./sound/pci/ymfpci/ymfpci_main.c:1966:	chip->timer = timer;
./sound/pci/ymfpci/ymfpci_main.c:2042:	err = request_firmware(&chip->dsp_microcode, "yamaha/ds1_dsp.fw",
./sound/pci/ymfpci/ymfpci_main.c:2043:			       &chip->pci->dev);
./sound/pci/ymfpci/ymfpci_main.c:2045:		if (chip->dsp_microcode->size != YDSXG_DSPLENGTH) {
./sound/pci/ymfpci/ymfpci_main.c:2046:			dev_err(chip->card->dev,
./sound/pci/ymfpci/ymfpci_main.c:2053:	is_1e = chip->device_id == PCI_DEVICE_ID_YAMAHA_724F ||
./sound/pci/ymfpci/ymfpci_main.c:2054:		chip->device_id == PCI_DEVICE_ID_YAMAHA_740C ||
./sound/pci/ymfpci/ymfpci_main.c:2055:		chip->device_id == PCI_DEVICE_ID_YAMAHA_744 ||
./sound/pci/ymfpci/ymfpci_main.c:2056:		chip->device_id == PCI_DEVICE_ID_YAMAHA_754;
./sound/pci/ymfpci/ymfpci_main.c:2058:	err = request_firmware(&chip->controller_microcode, name,
./sound/pci/ymfpci/ymfpci_main.c:2059:			       &chip->pci->dev);
./sound/pci/ymfpci/ymfpci_main.c:2061:		if (chip->controller_microcode->size != YDSXG_CTRLLENGTH) {
./sound/pci/ymfpci/ymfpci_main.c:2062:			dev_err(chip->card->dev,
./sound/pci/ymfpci/ymfpci_main.c:2095:	inst = (const __le32 *)chip->dsp_microcode->data;
./sound/pci/ymfpci/ymfpci_main.c:2101:	inst = (const __le32 *)chip->controller_microcode->data;
./sound/pci/ymfpci/ymfpci_main.c:2117:	chip->bank_size_playback = snd_ymfpci_readl(chip, YDSXGR_PLAYCTRLSIZE) << 2;
./sound/pci/ymfpci/ymfpci_main.c:2118:	chip->bank_size_capture = snd_ymfpci_readl(chip, YDSXGR_RECCTRLSIZE) << 2;
./sound/pci/ymfpci/ymfpci_main.c:2119:	chip->bank_size_effect = snd_ymfpci_readl(chip, YDSXGR_EFFCTRLSIZE) << 2;
./sound/pci/ymfpci/ymfpci_main.c:2120:	chip->work_size = YDSXG_DEFAULT_WORK_SIZE;
./sound/pci/ymfpci/ymfpci_main.c:2123:	       ALIGN(chip->bank_size_playback * 2 * YDSXG_PLAYBACK_VOICES, 0x100) +
./sound/pci/ymfpci/ymfpci_main.c:2124:	       ALIGN(chip->bank_size_capture * 2 * YDSXG_CAPTURE_VOICES, 0x100) +
./sound/pci/ymfpci/ymfpci_main.c:2125:	       ALIGN(chip->bank_size_effect * 2 * YDSXG_EFFECT_VOICES, 0x100) +
./sound/pci/ymfpci/ymfpci_main.c:2126:	       chip->work_size;
./sound/pci/ymfpci/ymfpci_main.c:2129:	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/ymfpci/ymfpci_main.c:2130:				size, &chip->work_ptr) < 0) 
./sound/pci/ymfpci/ymfpci_main.c:2132:	ptr = chip->work_ptr.area;
./sound/pci/ymfpci/ymfpci_main.c:2133:	ptr_addr = chip->work_ptr.addr;
./sound/pci/ymfpci/ymfpci_main.c:2136:	chip->bank_base_playback = ptr;
./sound/pci/ymfpci/ymfpci_main.c:2137:	chip->bank_base_playback_addr = ptr_addr;
./sound/pci/ymfpci/ymfpci_main.c:2138:	chip->ctrl_playback = (u32 *)ptr;
./sound/pci/ymfpci/ymfpci_main.c:2139:	chip->ctrl_playback[0] = cpu_to_le32(YDSXG_PLAYBACK_VOICES);
./sound/pci/ymfpci/ymfpci_main.c:2143:		chip->voices[voice].number = voice;
./sound/pci/ymfpci/ymfpci_main.c:2144:		chip->voices[voice].bank = (struct snd_ymfpci_playback_bank *)ptr;
./sound/pci/ymfpci/ymfpci_main.c:2145:		chip->voices[voice].bank_addr = ptr_addr;
./sound/pci/ymfpci/ymfpci_main.c:2147:			chip->bank_playback[voice][bank] = (struct snd_ymfpci_playback_bank *)ptr;
./sound/pci/ymfpci/ymfpci_main.c:2148:			ptr += chip->bank_size_playback;
./sound/pci/ymfpci/ymfpci_main.c:2149:			ptr_addr += chip->bank_size_playback;
./sound/pci/ymfpci/ymfpci_main.c:2154:	chip->bank_base_capture = ptr;
./sound/pci/ymfpci/ymfpci_main.c:2155:	chip->bank_base_capture_addr = ptr_addr;
./sound/pci/ymfpci/ymfpci_main.c:2158:			chip->bank_capture[voice][bank] = (struct snd_ymfpci_capture_bank *)ptr;
./sound/pci/ymfpci/ymfpci_main.c:2159:			ptr += chip->bank_size_capture;
./sound/pci/ymfpci/ymfpci_main.c:2160:			ptr_addr += chip->bank_size_capture;
./sound/pci/ymfpci/ymfpci_main.c:2164:	chip->bank_base_effect = ptr;
./sound/pci/ymfpci/ymfpci_main.c:2165:	chip->bank_base_effect_addr = ptr_addr;
./sound/pci/ymfpci/ymfpci_main.c:2168:			chip->bank_effect[voice][bank] = (struct snd_ymfpci_effect_bank *)ptr;
./sound/pci/ymfpci/ymfpci_main.c:2169:			ptr += chip->bank_size_effect;
./sound/pci/ymfpci/ymfpci_main.c:2170:			ptr_addr += chip->bank_size_effect;
./sound/pci/ymfpci/ymfpci_main.c:2174:	chip->work_base = ptr;
./sound/pci/ymfpci/ymfpci_main.c:2175:	chip->work_base_addr = ptr_addr;
./sound/pci/ymfpci/ymfpci_main.c:2177:	snd_BUG_ON(ptr + chip->work_size !=
./sound/pci/ymfpci/ymfpci_main.c:2178:		   chip->work_ptr.area + chip->work_ptr.bytes);
./sound/pci/ymfpci/ymfpci_main.c:2180:	snd_ymfpci_writel(chip, YDSXGR_PLAYCTRLBASE, chip->bank_base_playback_addr);
./sound/pci/ymfpci/ymfpci_main.c:2181:	snd_ymfpci_writel(chip, YDSXGR_RECCTRLBASE, chip->bank_base_capture_addr);
./sound/pci/ymfpci/ymfpci_main.c:2182:	snd_ymfpci_writel(chip, YDSXGR_EFFCTRLBASE, chip->bank_base_effect_addr);
./sound/pci/ymfpci/ymfpci_main.c:2183:	snd_ymfpci_writel(chip, YDSXGR_WORKBASE, chip->work_base_addr);
./sound/pci/ymfpci/ymfpci_main.c:2184:	snd_ymfpci_writel(chip, YDSXGR_WORKSIZE, chip->work_size >> 2);
./sound/pci/ymfpci/ymfpci_main.c:2187:	chip->spdif_bits = chip->spdif_pcm_bits = SNDRV_PCM_DEFAULT_CON_SPDIF & 0xffff;
./sound/pci/ymfpci/ymfpci_main.c:2189:	snd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);
./sound/pci/ymfpci/ymfpci_main.c:2216:	if (chip->res_reg_area) {	/* don't touch busy hardware */
./sound/pci/ymfpci/ymfpci_main.c:2238:	pci_set_power_state(chip->pci, PCI_D3hot);
./sound/pci/ymfpci/ymfpci_main.c:2242:	kfree(chip->saved_regs);
./sound/pci/ymfpci/ymfpci_main.c:2244:	if (chip->irq >= 0)
./sound/pci/ymfpci/ymfpci_main.c:2245:		free_irq(chip->irq, chip);
./sound/pci/ymfpci/ymfpci_main.c:2246:	release_and_free_resource(chip->mpu_res);
./sound/pci/ymfpci/ymfpci_main.c:2247:	release_and_free_resource(chip->fm_res);
./sound/pci/ymfpci/ymfpci_main.c:2249:	iounmap(chip->reg_area_virt);
./sound/pci/ymfpci/ymfpci_main.c:2250:	if (chip->work_ptr.area)
./sound/pci/ymfpci/ymfpci_main.c:2251:		snd_dma_free_pages(&chip->work_ptr);
./sound/pci/ymfpci/ymfpci_main.c:2253:	release_and_free_resource(chip->res_reg_area);
./sound/pci/ymfpci/ymfpci_main.c:2255:	pci_write_config_word(chip->pci, 0x40, chip->old_legacy_ctrl);
./sound/pci/ymfpci/ymfpci_main.c:2257:	pci_disable_device(chip->pci);
./sound/pci/ymfpci/ymfpci_main.c:2258:	release_firmware(chip->dsp_microcode);
./sound/pci/ymfpci/ymfpci_main.c:2259:	release_firmware(chip->controller_microcode);
./sound/pci/ymfpci/ymfpci_main.c:2307:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/ymfpci/ymfpci_main.c:2308:	snd_pcm_suspend_all(chip->pcm2);
./sound/pci/ymfpci/ymfpci_main.c:2309:	snd_pcm_suspend_all(chip->pcm_spdif);
./sound/pci/ymfpci/ymfpci_main.c:2310:	snd_pcm_suspend_all(chip->pcm_4ch);
./sound/pci/ymfpci/ymfpci_main.c:2311:	snd_ac97_suspend(chip->ac97);
./sound/pci/ymfpci/ymfpci_main.c:2313:		chip->saved_regs[i] = snd_ymfpci_readl(chip, saved_regs_index[i]);
./sound/pci/ymfpci/ymfpci_main.c:2314:	chip->saved_ydsxgr_mode = snd_ymfpci_readl(chip, YDSXGR_MODE);
./sound/pci/ymfpci/ymfpci_main.c:2315:	pci_read_config_word(chip->pci, PCIR_DSXG_LEGACY,
./sound/pci/ymfpci/ymfpci_main.c:2316:			     &chip->saved_dsxg_legacy);
./sound/pci/ymfpci/ymfpci_main.c:2317:	pci_read_config_word(chip->pci, PCIR_DSXG_ELEGACY,
./sound/pci/ymfpci/ymfpci_main.c:2318:			     &chip->saved_dsxg_elegacy);
./sound/pci/ymfpci/ymfpci_main.c:2338:		snd_ymfpci_writel(chip, saved_regs_index[i], chip->saved_regs[i]);
./sound/pci/ymfpci/ymfpci_main.c:2340:	snd_ac97_resume(chip->ac97);
./sound/pci/ymfpci/ymfpci_main.c:2342:	pci_write_config_word(chip->pci, PCIR_DSXG_LEGACY,
./sound/pci/ymfpci/ymfpci_main.c:2343:			      chip->saved_dsxg_legacy);
./sound/pci/ymfpci/ymfpci_main.c:2344:	pci_write_config_word(chip->pci, PCIR_DSXG_ELEGACY,
./sound/pci/ymfpci/ymfpci_main.c:2345:			      chip->saved_dsxg_elegacy);
./sound/pci/ymfpci/ymfpci_main.c:2348:	if (chip->start_count > 0) {
./sound/pci/ymfpci/ymfpci_main.c:2349:		spin_lock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:2350:		snd_ymfpci_writel(chip, YDSXGR_MODE, chip->saved_ydsxgr_mode);
./sound/pci/ymfpci/ymfpci_main.c:2351:		chip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT);
./sound/pci/ymfpci/ymfpci_main.c:2352:		spin_unlock_irq(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:2383:	chip->old_legacy_ctrl = old_legacy_ctrl;
./sound/pci/ymfpci/ymfpci_main.c:2384:	spin_lock_init(&chip->reg_lock);
./sound/pci/ymfpci/ymfpci_main.c:2385:	spin_lock_init(&chip->voice_lock);
./sound/pci/ymfpci/ymfpci_main.c:2386:	init_waitqueue_head(&chip->interrupt_sleep);
./sound/pci/ymfpci/ymfpci_main.c:2387:	atomic_set(&chip->interrupt_sleep_count, 0);
./sound/pci/ymfpci/ymfpci_main.c:2388:	chip->card = card;
./sound/pci/ymfpci/ymfpci_main.c:2389:	chip->pci = pci;
./sound/pci/ymfpci/ymfpci_main.c:2390:	chip->irq = -1;
./sound/pci/ymfpci/ymfpci_main.c:2391:	chip->device_id = pci->device;
./sound/pci/ymfpci/ymfpci_main.c:2392:	chip->rev = pci->revision;
./sound/pci/ymfpci/ymfpci_main.c:2393:	chip->reg_area_phys = pci_resource_start(pci, 0);
./sound/pci/ymfpci/ymfpci_main.c:2394:	chip->reg_area_virt = ioremap_nocache(chip->reg_area_phys, 0x8000);
./sound/pci/ymfpci/ymfpci_main.c:2396:	chip->src441_used = -1;
./sound/pci/ymfpci/ymfpci_main.c:2398:	if ((chip->res_reg_area = request_mem_region(chip->reg_area_phys, 0x8000, "YMFPCI")) == NULL) {
./sound/pci/ymfpci/ymfpci_main.c:2399:		dev_err(chip->card->dev,
./sound/pci/ymfpci/ymfpci_main.c:2401:			chip->reg_area_phys, chip->reg_area_phys + 0x8000 - 1);
./sound/pci/ymfpci/ymfpci_main.c:2407:		dev_err(chip->card->dev, "unable to grab IRQ %d\n", pci->irq);
./sound/pci/ymfpci/ymfpci_main.c:2411:	chip->irq = pci->irq;
./sound/pci/ymfpci/ymfpci_main.c:2421:		dev_err(chip->card->dev, "firmware request failed: %d\n", err);
./sound/pci/ymfpci/ymfpci_main.c:2440:	chip->saved_regs = kmalloc(YDSXGR_NUM_SAVED_REGS * sizeof(u32),
./sound/pci/ymfpci/ymfpci_main.c:2442:	if (chip->saved_regs == NULL) {
./sound/pci/au88x0/au88x0_pcm.c:230:		dev_err(chip->card->dev, "Vortex: pcm page alloc failed!\n");
./sound/pci/au88x0/au88x0_pcm.c:237:	spin_lock_irq(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:254:			spin_unlock_irq(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:257:		stream = substream->runtime->private_data = &chip->dma_adb[dma];
./sound/pci/au88x0/au88x0_pcm.c:264:			chip->pcm_vol[substream->number].active = 1;
./sound/pci/au88x0/au88x0_pcm.c:265:			vortex_notify_pcm_vol_change(chip->card,
./sound/pci/au88x0/au88x0_pcm.c:266:				chip->pcm_vol[substream->number].kctl, 1);
./sound/pci/au88x0/au88x0_pcm.c:276:		    &chip->dma_wt[substream->number];
./sound/pci/au88x0/au88x0_pcm.c:284:	spin_unlock_irq(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:294:	spin_lock_irq(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:299:				chip->pcm_vol[substream->number].active = 0;
./sound/pci/au88x0/au88x0_pcm.c:300:				vortex_notify_pcm_vol_change(chip->card,
./sound/pci/au88x0/au88x0_pcm.c:301:					chip->pcm_vol[substream->number].kctl,
./sound/pci/au88x0/au88x0_pcm.c:317:	spin_unlock_irq(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:336:	spin_lock_irq(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:351:	spin_unlock_irq(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:362:	spin_lock(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:374:			dev_info(chip->card->dev, "wt start %d\n", dma);
./sound/pci/au88x0/au88x0_pcm.c:387:			dev_info(chip->card->dev, "wt stop %d\n", dma);
./sound/pci/au88x0/au88x0_pcm.c:411:		spin_unlock(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:414:	spin_unlock(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:426:	spin_lock(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:434:	spin_unlock(&chip->lock);
./sound/pci/au88x0/au88x0_pcm.c:633:	err = snd_pcm_new(chip->card, vortex_pcm_prettyname[idx], idx, nr,
./sound/pci/au88x0/au88x0_pcm.c:639:	chip->pcm[idx] = pcm;
./sound/pci/au88x0/au88x0_pcm.c:653:					      snd_dma_pci_data(chip->pci_dev),
./sound/pci/au88x0/au88x0_pcm.c:684:			if ((err = snd_ctl_add(chip->card, kctl)) < 0)
./sound/pci/au88x0/au88x0_pcm.c:690:			chip->pcm_vol[i].active = 0;
./sound/pci/au88x0/au88x0_pcm.c:691:			chip->pcm_vol[i].dma = -1;
./sound/pci/au88x0/au88x0_pcm.c:695:			chip->pcm_vol[i].kctl = kctl;
./sound/pci/au88x0/au88x0_pcm.c:698:			err = snd_ctl_add(chip->card, kctl);
./sound/pci/au88x0/au88x0.c:137:// chip-specific constructor
./sound/pci/au88x0/au88x0.c:166:	chip->card = card;
./sound/pci/au88x0/au88x0.c:169:	chip->pci_dev = pci;
./sound/pci/au88x0/au88x0.c:170:	chip->io = pci_resource_start(pci, 0);
./sound/pci/au88x0/au88x0.c:171:	chip->vendor = pci->vendor;
./sound/pci/au88x0/au88x0.c:172:	chip->device = pci->device;
./sound/pci/au88x0/au88x0.c:173:	chip->card = card;
./sound/pci/au88x0/au88x0.c:174:	chip->irq = -1;
./sound/pci/au88x0/au88x0.c:182:	chip->mmio = pci_ioremap_bar(pci, 0);
./sound/pci/au88x0/au88x0.c:183:	if (!chip->mmio) {
./sound/pci/au88x0/au88x0.c:203:	chip->irq = pci->irq;
./sound/pci/au88x0/au88x0.c:218:	free_irq(chip->irq, chip);
./sound/pci/au88x0/au88x0.c:222:	iounmap(chip->mmio);
./sound/pci/au88x0/au88x0.c:224:	pci_release_regions(chip->pci_dev);
./sound/pci/au88x0/au88x0.c:226:	pci_disable_device(chip->pci_dev);
./sound/pci/au88x0/au88x0.c:266:		card->shortname, chip->io, chip->irq);
./sound/pci/au88x0/au88x0.c:332:				  &(chip->device))) < 0) {
./sound/pci/au88x0/au88x0.c:337:				  &(chip->vendor))) < 0) {
./sound/pci/au88x0/au88x0.c:341:	chip->rev = pci->revision;
./sound/pci/au88x0/au88x0.c:343:	if ((chip->rev) != 0xfe && (chip->rev) != 0xfa) {
./sound/pci/au88x0/au88x0.c:346:		       chip->rev);
./sound/pci/cs5530.c:79:	pci_release_regions(chip->pci);
./sound/pci/cs5530.c:80:	pci_disable_device(chip->pci);
./sound/pci/cs5530.c:131:	chip->card = card;
./sound/pci/cs5530.c:132:	chip->pci = pci;
./sound/pci/cs5530.c:140:	chip->pci_base = pci_resource_start(pci, 0);
./sound/pci/cs5530.c:219:						dma16, SB_HW_CS5530, &chip->sb);
./sound/pci/cs5530.c:226:	err = snd_sb16dsp_pcm(chip->sb, 0);
./sound/pci/cs5530.c:233:	err = snd_sbmixer_new(chip->sb);
./sound/pci/cs5530.c:279:	sprintf(card->longname, "%s at 0x%lx", card->shortname, chip->pci_base);
./sound/pci/bt87x.c:219:	return readl(chip->mmio + reg);
./sound/pci/bt87x.c:224:	writel(value, chip->mmio + reg);
./sound/pci/bt87x.c:233:	if (chip->dma_risc.area == NULL) {
./sound/pci/bt87x.c:234:		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/bt87x.c:235:					PAGE_ALIGN(MAX_RISC_SIZE), &chip->dma_risc) < 0)
./sound/pci/bt87x.c:238:	risc = (u32 *)chip->dma_risc.area;
./sound/pci/bt87x.c:272:	*risc++ = cpu_to_le32(chip->dma_risc.addr);
./sound/pci/bt87x.c:273:	chip->line_bytes = period_bytes;
./sound/pci/bt87x.c:274:	chip->lines = periods;
./sound/pci/bt87x.c:280:	if (chip->dma_risc.area) {
./sound/pci/bt87x.c:281:		snd_dma_free_pages(&chip->dma_risc);
./sound/pci/bt87x.c:282:		chip->dma_risc.area = NULL;
./sound/pci/bt87x.c:290:	pci_read_config_word(chip->pci, PCI_STATUS, &pci_status);
./sound/pci/bt87x.c:294:	pci_write_config_word(chip->pci, PCI_STATUS, pci_status);
./sound/pci/bt87x.c:296:		dev_err(chip->card->dev,
./sound/pci/bt87x.c:300:		dev_err(chip->card->dev,
./sound/pci/bt87x.c:303:		chip->pci_parity_errors++;
./sound/pci/bt87x.c:304:		if (chip->pci_parity_errors > 20) {
./sound/pci/bt87x.c:305:			dev_err(chip->card->dev,
./sound/pci/bt87x.c:307:			dev_err(chip->card->dev,
./sound/pci/bt87x.c:309:			dev_err(chip->card->dev,
./sound/pci/bt87x.c:311:			dev_err(chip->card->dev,
./sound/pci/bt87x.c:313:			chip->interrupt_mask &= ~(INT_PPERR | INT_RIPERR);
./sound/pci/bt87x.c:314:			snd_bt87x_writel(chip, REG_INT_MASK, chip->interrupt_mask);
./sound/pci/bt87x.c:325:	irq_status = status & chip->interrupt_mask;
./sound/pci/bt87x.c:332:			dev_warn(chip->card->dev,
./sound/pci/bt87x.c:335:			dev_err(chip->card->dev,
./sound/pci/bt87x.c:340:	if ((irq_status & INT_RISCI) && (chip->reg_control & CTL_ACAP_EN)) {
./sound/pci/bt87x.c:344:		chip->current_line = (chip->current_line + 1) % chip->lines;
./sound/pci/bt87x.c:346:		current_block = chip->current_line * 16 / chip->lines;
./sound/pci/bt87x.c:349:			chip->current_line = (irq_block * chip->lines + 15) / 16;
./sound/pci/bt87x.c:351:		snd_pcm_period_elapsed(chip->substream);
./sound/pci/bt87x.c:394:	chip->reg_control |= CTL_DA_IOM_DA | CTL_A_PWRDN;
./sound/pci/bt87x.c:396:	runtime->hw.rates = snd_pcm_rate_to_rate_bit(chip->board.dig_rate);
./sound/pci/bt87x.c:397:	runtime->hw.rate_min = chip->board.dig_rate;
./sound/pci/bt87x.c:398:	runtime->hw.rate_max = chip->board.dig_rate;
./sound/pci/bt87x.c:415:	chip->reg_control &= ~(CTL_DA_IOM_DA | CTL_A_PWRDN);
./sound/pci/bt87x.c:427:	if (test_and_set_bit(0, &chip->opened))
./sound/pci/bt87x.c:441:	chip->substream = substream;
./sound/pci/bt87x.c:445:	clear_bit(0, &chip->opened);
./sound/pci/bt87x.c:454:	spin_lock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:455:	chip->reg_control |= CTL_A_PWRDN;
./sound/pci/bt87x.c:456:	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
./sound/pci/bt87x.c:457:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:459:	chip->substream = NULL;
./sound/pci/bt87x.c:460:	clear_bit(0, &chip->opened);
./sound/pci/bt87x.c:495:	spin_lock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:496:	chip->reg_control &= ~(CTL_DA_SDR_MASK | CTL_DA_SBR);
./sound/pci/bt87x.c:498:	chip->reg_control |= decimation << CTL_DA_SDR_SHIFT;
./sound/pci/bt87x.c:500:		chip->reg_control |= CTL_DA_SBR;
./sound/pci/bt87x.c:501:	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
./sound/pci/bt87x.c:502:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:508:	spin_lock(&chip->reg_lock);
./sound/pci/bt87x.c:509:	chip->current_line = 0;
./sound/pci/bt87x.c:510:	chip->reg_control |= CTL_FIFO_ENABLE | CTL_RISC_ENABLE | CTL_ACAP_EN;
./sound/pci/bt87x.c:511:	snd_bt87x_writel(chip, REG_RISC_STRT_ADD, chip->dma_risc.addr);
./sound/pci/bt87x.c:513:			 chip->line_bytes | (chip->lines << 16));
./sound/pci/bt87x.c:514:	snd_bt87x_writel(chip, REG_INT_MASK, chip->interrupt_mask);
./sound/pci/bt87x.c:515:	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
./sound/pci/bt87x.c:516:	spin_unlock(&chip->reg_lock);
./sound/pci/bt87x.c:522:	spin_lock(&chip->reg_lock);
./sound/pci/bt87x.c:523:	chip->reg_control &= ~(CTL_FIFO_ENABLE | CTL_RISC_ENABLE | CTL_ACAP_EN);
./sound/pci/bt87x.c:524:	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
./sound/pci/bt87x.c:527:	spin_unlock(&chip->reg_lock);
./sound/pci/bt87x.c:550:	return (snd_pcm_uframes_t)bytes_to_frames(runtime, chip->current_line * chip->line_bytes);
./sound/pci/bt87x.c:580:	value->value.integer.value[0] = (chip->reg_control & CTL_A_GAIN_MASK) >> CTL_A_GAIN_SHIFT;
./sound/pci/bt87x.c:591:	spin_lock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:592:	old_control = chip->reg_control;
./sound/pci/bt87x.c:593:	chip->reg_control = (chip->reg_control & ~CTL_A_GAIN_MASK)
./sound/pci/bt87x.c:595:	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
./sound/pci/bt87x.c:596:	changed = old_control != chip->reg_control;
./sound/pci/bt87x.c:597:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:616:	value->value.integer.value[0] = !! (chip->reg_control & CTL_A_G2X);
./sound/pci/bt87x.c:627:	spin_lock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:628:	old_control = chip->reg_control;
./sound/pci/bt87x.c:629:	chip->reg_control = (chip->reg_control & ~CTL_A_G2X)
./sound/pci/bt87x.c:631:	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
./sound/pci/bt87x.c:632:	changed = chip->reg_control != old_control;
./sound/pci/bt87x.c:633:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:658:	value->value.enumerated.item[0] = (chip->reg_control & CTL_A_SEL_MASK) >> CTL_A_SEL_SHIFT;
./sound/pci/bt87x.c:669:	spin_lock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:670:	old_control = chip->reg_control;
./sound/pci/bt87x.c:671:	chip->reg_control = (chip->reg_control & ~CTL_A_SEL_MASK)
./sound/pci/bt87x.c:673:	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
./sound/pci/bt87x.c:674:	changed = chip->reg_control != old_control;
./sound/pci/bt87x.c:675:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/bt87x.c:689:	if (chip->mmio)
./sound/pci/bt87x.c:691:	if (chip->irq >= 0)
./sound/pci/bt87x.c:692:		free_irq(chip->irq, chip);
./sound/pci/bt87x.c:693:	iounmap(chip->mmio);
./sound/pci/bt87x.c:694:	pci_release_regions(chip->pci);
./sound/pci/bt87x.c:695:	pci_disable_device(chip->pci);
./sound/pci/bt87x.c:711:	err = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);
./sound/pci/bt87x.c:719:						     snd_dma_pci_data(chip->pci),
./sound/pci/bt87x.c:745:	chip->card = card;
./sound/pci/bt87x.c:746:	chip->pci = pci;
./sound/pci/bt87x.c:747:	chip->irq = -1;
./sound/pci/bt87x.c:748:	spin_lock_init(&chip->reg_lock);
./sound/pci/bt87x.c:755:	chip->mmio = pci_ioremap_bar(pci, 0);
./sound/pci/bt87x.c:756:	if (!chip->mmio) {
./sound/pci/bt87x.c:762:	chip->reg_control = CTL_A_PWRDN | CTL_DA_ES2 |
./sound/pci/bt87x.c:764:	chip->interrupt_mask = MY_INTERRUPTS;
./sound/pci/bt87x.c:765:	snd_bt87x_writel(chip, REG_GPIO_DMA_CTL, chip->reg_control);
./sound/pci/bt87x.c:775:	chip->irq = pci->irq;
./sound/pci/bt87x.c:777:	synchronize_irq(chip->irq);
./sound/pci/bt87x.c:907:	memcpy(&chip->board, &snd_bt87x_boards[boardid], sizeof(chip->board));
./sound/pci/bt87x.c:909:	if (!chip->board.no_digital) {
./sound/pci/bt87x.c:911:			chip->board.dig_rate = digital_rate[dev];
./sound/pci/bt87x.c:913:		chip->reg_control |= chip->board.digital_fmt;
./sound/pci/bt87x.c:919:	if (!chip->board.no_analog) {
./sound/pci/bt87x.c:938:		   chip->board.no_analog ? "no " : "",
./sound/pci/bt87x.c:939:		   chip->board.no_digital ? "no " : "", chip->board.dig_rate);
./sound/pci/bt87x.c:945:		chip->irq);
./sound/pci/via82xx.c:436:		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/via82xx.c:532:	dev_err(chip->card->dev, "codec_ready: codec %i is not ready [0x%x]\n",
./sound/pci/via82xx.c:591:			dev_err(chip->card->dev,
./sound/pci/via82xx.c:635:	if (! (status & chip->intr_mask)) {
./sound/pci/via82xx.c:636:		if (chip->rmidi)
./sound/pci/via82xx.c:638:			return snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
./sound/pci/via82xx.c:643:	spin_lock(&chip->reg_lock);
./sound/pci/via82xx.c:644:	for (i = 0; i < chip->num_devs; i++) {
./sound/pci/via82xx.c:645:		struct viadev *viadev = &chip->devs[i];
./sound/pci/via82xx.c:660:			spin_unlock(&chip->reg_lock);
./sound/pci/via82xx.c:662:			spin_lock(&chip->reg_lock);
./sound/pci/via82xx.c:667:	spin_unlock(&chip->reg_lock);
./sound/pci/via82xx.c:682:	spin_lock(&chip->reg_lock);
./sound/pci/via82xx.c:685:	for (i = 0; i < chip->num_devs; i++) {
./sound/pci/via82xx.c:686:		struct viadev *viadev = &chip->devs[i];
./sound/pci/via82xx.c:711:			spin_unlock(&chip->reg_lock);
./sound/pci/via82xx.c:715:			spin_lock(&chip->reg_lock);
./sound/pci/via82xx.c:721:	spin_unlock(&chip->reg_lock);
./sound/pci/via82xx.c:738:	if (chip->chip_type != TYPE_VIA686)
./sound/pci/via82xx.c:797:		dev_dbg(chip->card->dev,
./sound/pci/via82xx.c:815:			dev_dbg(chip->card->dev,
./sound/pci/via82xx.c:825:				dev_dbg(chip->card->dev,
./sound/pci/via82xx.c:848:	spin_lock(&chip->reg_lock);
./sound/pci/via82xx.c:860:	spin_unlock(&chip->reg_lock);
./sound/pci/via82xx.c:878:	spin_lock(&chip->reg_lock);
./sound/pci/via82xx.c:886:	if (chip->revision == VIA_REV_8251 && (status & VIA_REG_STAT_EOL))
./sound/pci/via82xx.c:897:			dev_dbg(chip->card->dev,
./sound/pci/via82xx.c:919:	spin_unlock(&chip->reg_lock);
./sound/pci/via82xx.c:939:	err = build_via_table(viadev, substream, chip->pci,
./sound/pci/via82xx.c:957:	clean_via_table(viadev, substream, chip->pci);
./sound/pci/via82xx.c:997:	snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);
./sound/pci/via82xx.c:998:	snd_ac97_set_rate(chip->ac97, AC97_SPDIF, runtime->rate);
./sound/pci/via82xx.c:1009:	snd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);
./sound/pci/via82xx.c:1042:	int ac97_rate = chip->dxs_src ? 48000 : runtime->rate;
./sound/pci/via82xx.c:1046:	if ((rate_changed = via_lock_rate(&chip->rates[0], ac97_rate)) < 0)
./sound/pci/via82xx.c:1049:		snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE,
./sound/pci/via82xx.c:1050:				  chip->no_vra ? 48000 : runtime->rate);
./sound/pci/via82xx.c:1051:	if (chip->spdif_on && viadev->reg_offset == 0x30)
./sound/pci/via82xx.c:1052:		snd_ac97_set_rate(chip->ac97, AC97_SPDIF, runtime->rate);
./sound/pci/via82xx.c:1062:	outb(chip->playback_volume[viadev->reg_offset / 0x10][0],
./sound/pci/via82xx.c:1064:	outb(chip->playback_volume[viadev->reg_offset / 0x10][1],
./sound/pci/via82xx.c:1087:	if (via_lock_rate(&chip->rates[0], runtime->rate) < 0)
./sound/pci/via82xx.c:1089:	snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE, runtime->rate);
./sound/pci/via82xx.c:1090:	snd_ac97_set_rate(chip->ac97, AC97_PCM_SURR_DAC_RATE, runtime->rate);
./sound/pci/via82xx.c:1091:	snd_ac97_set_rate(chip->ac97, AC97_PCM_LFE_DAC_RATE, runtime->rate);
./sound/pci/via82xx.c:1092:	snd_ac97_set_rate(chip->ac97, AC97_SPDIF, runtime->rate);
./sound/pci/via82xx.c:1101:	if (chip->revision == VIA_REV_8233A)
./sound/pci/via82xx.c:1134:	if (via_lock_rate(&chip->rates[1], runtime->rate) < 0)
./sound/pci/via82xx.c:1136:	snd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE, runtime->rate);
./sound/pci/via82xx.c:1189:	ratep = &chip->rates[viadev->direction];
./sound/pci/via82xx.c:1192:	if (chip->spdif_on && viadev->reg_offset == 0x30) {
./sound/pci/via82xx.c:1194:		runtime->hw.rates = chip->ac97->rates[AC97_RATES_SPDIF];
./sound/pci/via82xx.c:1196:	} else if (chip->dxs_fixed && viadev->reg_offset < 0x40) {
./sound/pci/via82xx.c:1200:	} else if (chip->dxs_src && viadev->reg_offset < 0x40) {
./sound/pci/via82xx.c:1209:		runtime->hw.rates = chip->ac97->rates[idx];
./sound/pci/via82xx.c:1242:	struct viadev *viadev = &chip->devs[chip->playback_devno + substream->number];
./sound/pci/via82xx.c:1260:	viadev = &chip->devs[chip->playback_devno + substream->number];
./sound/pci/via82xx.c:1264:	if (chip->dxs_controls[stream]) {
./sound/pci/via82xx.c:1265:		chip->playback_volume[stream][0] =
./sound/pci/via82xx.c:1267:		chip->playback_volume[stream][1] =
./sound/pci/via82xx.c:1269:		chip->dxs_controls[stream]->vd[0].access &=
./sound/pci/via82xx.c:1271:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |
./sound/pci/via82xx.c:1273:			       &chip->dxs_controls[stream]->id);
./sound/pci/via82xx.c:1284:	struct viadev *viadev = &chip->devs[chip->multi_devno];
./sound/pci/via82xx.c:1301:	if (chip->revision == VIA_REV_8233A)
./sound/pci/via82xx.c:1314:	struct viadev *viadev = &chip->devs[chip->capture_devno + substream->pcm->device];
./sound/pci/via82xx.c:1329:	ratep = &chip->rates[viadev->direction];
./sound/pci/via82xx.c:1337:			snd_ac97_update_power(chip->ac97,
./sound/pci/via82xx.c:1339:			snd_ac97_update_power(chip->ac97,
./sound/pci/via82xx.c:1341:			snd_ac97_update_power(chip->ac97,
./sound/pci/via82xx.c:1344:			snd_ac97_update_power(chip->ac97,
./sound/pci/via82xx.c:1358:	if (chip->dxs_controls[stream]) {
./sound/pci/via82xx.c:1359:		chip->dxs_controls[stream]->vd[0].access |=
./sound/pci/via82xx.c:1361:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO,
./sound/pci/via82xx.c:1362:			       &chip->dxs_controls[stream]->id);
./sound/pci/via82xx.c:1437:	chip->devs[idx].reg_offset = reg_offset;
./sound/pci/via82xx.c:1438:	chip->devs[idx].shadow_shift = shadow_pos * 4;
./sound/pci/via82xx.c:1439:	chip->devs[idx].direction = direction;
./sound/pci/via82xx.c:1440:	chip->devs[idx].port = chip->port + reg_offset;
./sound/pci/via82xx.c:1452:	chip->playback_devno = 0;	/* x 4 */
./sound/pci/via82xx.c:1453:	chip->multi_devno = 4;		/* x 1 */
./sound/pci/via82xx.c:1454:	chip->capture_devno = 5;	/* x 2 */
./sound/pci/via82xx.c:1455:	chip->num_devs = 7;
./sound/pci/via82xx.c:1456:	chip->intr_mask = 0x33033333; /* FLAG|EOL for rec0-1, mc, sdx0-3 */
./sound/pci/via82xx.c:1459:	err = snd_pcm_new(chip->card, chip->card->shortname, 0, 4, 1, &pcm);
./sound/pci/via82xx.c:1465:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:1466:	chip->pcms[0] = pcm;
./sound/pci/via82xx.c:1471:	init_viadev(chip, chip->capture_devno, VIA_REG_CAPTURE_8233_STATUS, 6, 1);
./sound/pci/via82xx.c:1474:					      snd_dma_pci_data(chip->pci),
./sound/pci/via82xx.c:1484:	err = snd_pcm_new(chip->card, chip->card->shortname, 1, 1, 1, &pcm);
./sound/pci/via82xx.c:1490:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:1491:	chip->pcms[1] = pcm;
./sound/pci/via82xx.c:1493:	init_viadev(chip, chip->multi_devno, VIA_REG_MULTPLAY_STATUS, 4, 0);
./sound/pci/via82xx.c:1495:	init_viadev(chip, chip->capture_devno + 1, VIA_REG_CAPTURE_8233_STATUS + 0x10, 7, 1);
./sound/pci/via82xx.c:1498:					      snd_dma_pci_data(chip->pci),
./sound/pci/via82xx.c:1506:	chip->ac97->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;
./sound/pci/via82xx.c:1520:	chip->multi_devno = 0;
./sound/pci/via82xx.c:1521:	chip->playback_devno = 1;
./sound/pci/via82xx.c:1522:	chip->capture_devno = 2;
./sound/pci/via82xx.c:1523:	chip->num_devs = 3;
./sound/pci/via82xx.c:1524:	chip->intr_mask = 0x03033000; /* FLAG|EOL for rec0, mc, sdx3 */
./sound/pci/via82xx.c:1527:	err = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);
./sound/pci/via82xx.c:1533:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:1534:	chip->pcms[0] = pcm;
./sound/pci/via82xx.c:1536:	init_viadev(chip, chip->multi_devno, VIA_REG_MULTPLAY_STATUS, 4, 0);
./sound/pci/via82xx.c:1538:	init_viadev(chip, chip->capture_devno, VIA_REG_CAPTURE_8233_STATUS, 6, 1);
./sound/pci/via82xx.c:1541:					      snd_dma_pci_data(chip->pci),
./sound/pci/via82xx.c:1549:	chip->ac97->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;
./sound/pci/via82xx.c:1552:	if (! ac97_can_spdif(chip->ac97))
./sound/pci/via82xx.c:1556:	err = snd_pcm_new(chip->card, chip->card->shortname, 1, 1, 0, &pcm);
./sound/pci/via82xx.c:1561:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:1562:	chip->pcms[1] = pcm;
./sound/pci/via82xx.c:1564:	init_viadev(chip, chip->playback_devno, 0x30, 3, 0);
./sound/pci/via82xx.c:1567:					      snd_dma_pci_data(chip->pci),
./sound/pci/via82xx.c:1580:	chip->playback_devno = 0;
./sound/pci/via82xx.c:1581:	chip->capture_devno = 1;
./sound/pci/via82xx.c:1582:	chip->num_devs = 2;
./sound/pci/via82xx.c:1583:	chip->intr_mask = 0x77; /* FLAG | EOL for PB, CP, FM */
./sound/pci/via82xx.c:1585:	err = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);
./sound/pci/via82xx.c:1591:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:1592:	chip->pcms[0] = pcm;
./sound/pci/via82xx.c:1597:					      snd_dma_pci_data(chip->pci),
./sound/pci/via82xx.c:1623:	unsigned long port = chip->port + (kcontrol->id.index ? (VIA_REG_CAPTURE_CHANNEL + 0x10) : VIA_REG_CAPTURE_CHANNEL);
./sound/pci/via82xx.c:1632:	unsigned long port = chip->port + (kcontrol->id.index ? (VIA_REG_CAPTURE_CHANNEL + 0x10) : VIA_REG_CAPTURE_CHANNEL);
./sound/pci/via82xx.c:1635:	spin_lock_irq(&chip->reg_lock);
./sound/pci/via82xx.c:1642:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/via82xx.c:1662:	pci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &val);
./sound/pci/via82xx.c:1673:	pci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &oval);
./sound/pci/via82xx.c:1678:	chip->spdif_on = ucontrol->value.integer.value[0] ? 1 : 0;
./sound/pci/via82xx.c:1680:		pci_write_config_byte(chip->pci, VIA8233_SPDIF_CTRL, val);
./sound/pci/via82xx.c:1710:	ucontrol->value.integer.value[0] = VIA_DXS_MAX_VOLUME - chip->playback_volume[idx][0];
./sound/pci/via82xx.c:1711:	ucontrol->value.integer.value[1] = VIA_DXS_MAX_VOLUME - chip->playback_volume[idx][1];
./sound/pci/via82xx.c:1719:	ucontrol->value.integer.value[0] = VIA_DXS_MAX_VOLUME - chip->playback_volume_c[0];
./sound/pci/via82xx.c:1720:	ucontrol->value.integer.value[1] = VIA_DXS_MAX_VOLUME - chip->playback_volume_c[1];
./sound/pci/via82xx.c:1729:	unsigned long port = chip->port + 0x10 * idx;
./sound/pci/via82xx.c:1738:		change |= val != chip->playback_volume[idx][i];
./sound/pci/via82xx.c:1740:			chip->playback_volume[idx][i] = val;
./sound/pci/via82xx.c:1760:		if (val != chip->playback_volume_c[i]) {
./sound/pci/via82xx.c:1762:			chip->playback_volume_c[i] = val;
./sound/pci/via82xx.c:1764:				unsigned long port = chip->port + 0x10 * idx;
./sound/pci/via82xx.c:1765:				chip->playback_volume[idx][i] = val;
./sound/pci/via82xx.c:1806:	chip->ac97_bus = NULL;
./sound/pci/via82xx.c:1812:	chip->ac97 = NULL;
./sound/pci/via82xx.c:1908:	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)
./sound/pci/via82xx.c:1910:	chip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;
./sound/pci/via82xx.c:1911:	chip->ac97_bus->clock = chip->ac97_clock;
./sound/pci/via82xx.c:1916:	ac97.pci = chip->pci;
./sound/pci/via82xx.c:1918:	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
./sound/pci/via82xx.c:1921:	snd_ac97_tune_hardware(chip->ac97, ac97_quirks, quirk_override);
./sound/pci/via82xx.c:1923:	if (chip->chip_type != TYPE_VIA686) {
./sound/pci/via82xx.c:1925:		snd_ac97_update_bits(chip->ac97, AC97_EXTENDED_STATUS, 0x03 << 4, 0x03 << 4);
./sound/pci/via82xx.c:1943:		dev_warn(chip->card->dev, "cannot reserve joystick port %#x\n",
./sound/pci/via82xx.c:1948:	chip->gameport = gp = gameport_allocate_port();
./sound/pci/via82xx.c:1950:		dev_err(chip->card->dev,
./sound/pci/via82xx.c:1957:	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
./sound/pci/via82xx.c:1958:	gameport_set_dev_parent(gp, &chip->pci->dev);
./sound/pci/via82xx.c:1964:	pci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, *legacy);
./sound/pci/via82xx.c:1966:	gameport_register_port(chip->gameport);
./sound/pci/via82xx.c:1973:	if (chip->gameport) {
./sound/pci/via82xx.c:1974:		struct resource *r = gameport_get_port_data(chip->gameport);
./sound/pci/via82xx.c:1976:		gameport_unregister_port(chip->gameport);
./sound/pci/via82xx.c:1977:		chip->gameport = NULL;
./sound/pci/via82xx.c:1999:	caps = chip->chip_type == TYPE_VIA8233A ? 1 : 2;
./sound/pci/via82xx.c:2002:		err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_via8233_capture_source, chip));
./sound/pci/via82xx.c:2006:	if (ac97_can_spdif(chip->ac97)) {
./sound/pci/via82xx.c:2007:		err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_via8233_dxs3_spdif_control, chip));
./sound/pci/via82xx.c:2011:	if (chip->chip_type != TYPE_VIA8233A) {
./sound/pci/via82xx.c:2019:		if (! snd_ctl_find_id(chip->card, &sid)) {
./sound/pci/via82xx.c:2020:			dev_info(chip->card->dev,
./sound/pci/via82xx.c:2022:			err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_via8233_pcmdxs_volume_control, chip));
./sound/pci/via82xx.c:2036:				err = snd_ctl_add(chip->card, kctl);
./sound/pci/via82xx.c:2039:				chip->dxs_controls[i] = kctl;
./sound/pci/via82xx.c:2044:	pci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &val);
./sound/pci/via82xx.c:2047:	pci_write_config_byte(chip->pci, VIA8233_SPDIF_CTRL, val);
./sound/pci/via82xx.c:2057:	legacy = chip->old_legacy;
./sound/pci/via82xx.c:2058:	legacy_cfg = chip->old_legacy_cfg;
./sound/pci/via82xx.c:2061:	if (chip->revision >= VIA_REV_686_H) {
./sound/pci/via82xx.c:2065:			pci_write_config_dword(chip->pci, 0x18, mpu_port | 0x01);
./sound/pci/via82xx.c:2067:			chip->mpu_port_saved = mpu_port;
./sound/pci/via82xx.c:2070:			mpu_port = pci_resource_start(chip->pci, 2);
./sound/pci/via82xx.c:2088:	    (chip->mpu_res = request_region(mpu_port, 2, "VIA82xx MPU401"))
./sound/pci/via82xx.c:2100:	pci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, legacy);
./sound/pci/via82xx.c:2101:	pci_write_config_byte(chip->pci, VIA_PNP_CONTROL, legacy_cfg);
./sound/pci/via82xx.c:2102:	if (chip->mpu_res) {
./sound/pci/via82xx.c:2103:		if (snd_mpu401_uart_new(chip->card, 0, MPU401_HW_VIA686A,
./sound/pci/via82xx.c:2106:					&chip->rmidi) < 0) {
./sound/pci/via82xx.c:2107:			dev_warn(chip->card->dev,
./sound/pci/via82xx.c:2114:		pci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, legacy);
./sound/pci/via82xx.c:2120:	chip->legacy_saved = legacy;
./sound/pci/via82xx.c:2121:	chip->legacy_cfg_saved = legacy_cfg;
./sound/pci/via82xx.c:2137:	snd_iprintf(buffer, "%s\n\n", chip->card->longname);
./sound/pci/via82xx.c:2139:		snd_iprintf(buffer, "%02x: %08x\n", i, inl(chip->port + i));
./sound/pci/via82xx.c:2147:	if (! snd_card_proc_new(chip->card, "via82xx", &entry))
./sound/pci/via82xx.c:2162:	if (chip->chip_type == TYPE_VIA686)
./sound/pci/via82xx.c:2164:		pci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, 0);
./sound/pci/via82xx.c:2166:	pci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);
./sound/pci/via82xx.c:2169:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,
./sound/pci/via82xx.c:2175:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, 0x00);
./sound/pci/via82xx.c:2179:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,
./sound/pci/via82xx.c:2185:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);
./sound/pci/via82xx.c:2191:	pci_read_config_byte(chip->pci, VIA_ACLINK_CTRL, &pval);
./sound/pci/via82xx.c:2195:		pci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);
./sound/pci/via82xx.c:2202:		pci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);
./sound/pci/via82xx.c:2209:		dev_err(chip->card->dev,
./sound/pci/via82xx.c:2222:			chip->ac97_secondary = 1;
./sound/pci/via82xx.c:2232:	if (chip->chip_type == TYPE_VIA686) {
./sound/pci/via82xx.c:2234:		pci_write_config_byte(chip->pci, VIA_FM_NMI_CTRL, 0);
./sound/pci/via82xx.c:2239:	if (chip->chip_type != TYPE_VIA686) {
./sound/pci/via82xx.c:2253:	if (chip->chip_type != TYPE_VIA8233A) {
./sound/pci/via82xx.c:2256:			unsigned long port = chip->port + 0x10 * idx;
./sound/pci/via82xx.c:2258:				chip->playback_volume[idx][i]=chip->playback_volume_c[i];
./sound/pci/via82xx.c:2259:				outb(chip->playback_volume_c[i],
./sound/pci/via82xx.c:2280:		snd_pcm_suspend_all(chip->pcms[i]);
./sound/pci/via82xx.c:2281:	for (i = 0; i < chip->num_devs; i++)
./sound/pci/via82xx.c:2282:		snd_via82xx_channel_reset(chip, &chip->devs[i]);
./sound/pci/via82xx.c:2283:	synchronize_irq(chip->irq);
./sound/pci/via82xx.c:2284:	snd_ac97_suspend(chip->ac97);
./sound/pci/via82xx.c:2287:	if (chip->chip_type != TYPE_VIA686) {
./sound/pci/via82xx.c:2288:		pci_read_config_byte(chip->pci, VIA8233_SPDIF_CTRL, &chip->spdif_ctrl_saved);
./sound/pci/via82xx.c:2289:		chip->capture_src_saved[0] = inb(chip->port + VIA_REG_CAPTURE_CHANNEL);
./sound/pci/via82xx.c:2290:		chip->capture_src_saved[1] = inb(chip->port + VIA_REG_CAPTURE_CHANNEL + 0x10);
./sound/pci/via82xx.c:2304:	if (chip->chip_type == TYPE_VIA686) {
./sound/pci/via82xx.c:2305:		if (chip->mpu_port_saved)
./sound/pci/via82xx.c:2306:			pci_write_config_dword(chip->pci, 0x18, chip->mpu_port_saved | 0x01);
./sound/pci/via82xx.c:2307:		pci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, chip->legacy_saved);
./sound/pci/via82xx.c:2308:		pci_write_config_byte(chip->pci, VIA_PNP_CONTROL, chip->legacy_cfg_saved);
./sound/pci/via82xx.c:2310:		pci_write_config_byte(chip->pci, VIA8233_SPDIF_CTRL, chip->spdif_ctrl_saved);
./sound/pci/via82xx.c:2311:		outb(chip->capture_src_saved[0], chip->port + VIA_REG_CAPTURE_CHANNEL);
./sound/pci/via82xx.c:2312:		outb(chip->capture_src_saved[1], chip->port + VIA_REG_CAPTURE_CHANNEL + 0x10);
./sound/pci/via82xx.c:2315:	snd_ac97_resume(chip->ac97);
./sound/pci/via82xx.c:2317:	for (i = 0; i < chip->num_devs; i++)
./sound/pci/via82xx.c:2318:		snd_via82xx_channel_reset(chip, &chip->devs[i]);
./sound/pci/via82xx.c:2334:	if (chip->irq < 0)
./sound/pci/via82xx.c:2337:	for (i = 0; i < chip->num_devs; i++)
./sound/pci/via82xx.c:2338:		snd_via82xx_channel_reset(chip, &chip->devs[i]);
./sound/pci/via82xx.c:2340:	if (chip->irq >= 0)
./sound/pci/via82xx.c:2341:		free_irq(chip->irq, chip);
./sound/pci/via82xx.c:2343:	release_and_free_resource(chip->mpu_res);
./sound/pci/via82xx.c:2344:	pci_release_regions(chip->pci);
./sound/pci/via82xx.c:2346:	if (chip->chip_type == TYPE_VIA686) {
./sound/pci/via82xx.c:2348:		pci_write_config_byte(chip->pci, VIA_FUNC_ENABLE, chip->old_legacy);
./sound/pci/via82xx.c:2349:		pci_write_config_byte(chip->pci, VIA_PNP_CONTROL, chip->old_legacy_cfg);
./sound/pci/via82xx.c:2351:	pci_disable_device(chip->pci);
./sound/pci/via82xx.c:2383:	chip->chip_type = chip_type;
./sound/pci/via82xx.c:2384:	chip->revision = revision;
./sound/pci/via82xx.c:2386:	spin_lock_init(&chip->reg_lock);
./sound/pci/via82xx.c:2387:	spin_lock_init(&chip->rates[0].lock);
./sound/pci/via82xx.c:2388:	spin_lock_init(&chip->rates[1].lock);
./sound/pci/via82xx.c:2389:	chip->card = card;
./sound/pci/via82xx.c:2390:	chip->pci = pci;
./sound/pci/via82xx.c:2391:	chip->irq = -1;
./sound/pci/via82xx.c:2393:	pci_read_config_byte(pci, VIA_FUNC_ENABLE, &chip->old_legacy);
./sound/pci/via82xx.c:2394:	pci_read_config_byte(pci, VIA_PNP_CONTROL, &chip->old_legacy_cfg);
./sound/pci/via82xx.c:2395:	pci_write_config_byte(chip->pci, VIA_FUNC_ENABLE,
./sound/pci/via82xx.c:2396:			      chip->old_legacy & ~(VIA_FUNC_ENABLE_SB|VIA_FUNC_ENABLE_FM));
./sound/pci/via82xx.c:2403:	chip->port = pci_resource_start(pci, 0);
./sound/pci/via82xx.c:2413:	chip->irq = pci->irq;
./sound/pci/via82xx.c:2415:		chip->ac97_clock = ac97_clock;
./sound/pci/via82xx.c:2416:	synchronize_irq(chip->irq);
./sound/pci/via82xx.c:2594:			// chip->dxs_fixed = 1; /* FIXME: use 48k for DXS #3? */
./sound/pci/via82xx.c:2599:				chip->dxs_fixed = 1;
./sound/pci/via82xx.c:2601:				chip->no_vra = 1;
./sound/pci/via82xx.c:2603:				chip->no_vra = 1;
./sound/pci/via82xx.c:2604:				chip->dxs_src = 1;
./sound/pci/via82xx.c:2612:	for (i = 0; i < chip->num_devs; i++)
./sound/pci/via82xx.c:2613:		snd_via82xx_channel_reset(chip, &chip->devs[i]);
./sound/pci/via82xx.c:2617:		 snd_ac97_get_short_name(chip->ac97), chip->port, chip->irq);
./sound/pci/trident/trident_main.c:3185:	chip->gameport = gp = gameport_allocate_port();
./sound/pci/trident/trident_main.c:3187:		dev_err(chip->card->dev,
./sound/pci/trident/trident_main.c:3193:	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
./sound/pci/trident/trident_main.c:3194:	gameport_set_dev_parent(gp, &chip->pci->dev);
./sound/pci/trident/trident_main.c:3210:	if (chip->gameport) {
./sound/pci/trident/trident_main.c:3211:		gameport_unregister_port(chip->gameport);
./sound/pci/trident/trident_main.c:3212:		chip->gameport = NULL;
./sound/pci/atiixp.c:316:	void __iomem *addr = chip->remap_addr + reg;
./sound/pci/atiixp.c:331:	writel(value, chip->remap_addr + ATI_REG_##reg)
./sound/pci/atiixp.c:333:	readl(chip->remap_addr + ATI_REG_##reg)
./sound/pci/atiixp.c:370:					snd_dma_pci_data(chip->pci),
./sound/pci/atiixp.c:381:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/atiixp.c:382:	writel(0, chip->remap_addr + dma->ops->llp_offset);
./sound/pci/atiixp.c:385:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/atiixp.c:405:	       chip->remap_addr + dma->ops->llp_offset);
./sound/pci/atiixp.c:420:		writel(0, chip->remap_addr + dma->ops->llp_offset);
./sound/pci/atiixp.c:435:			dev_warn(chip->card->dev, "codec acquire timeout\n");
./sound/pci/atiixp.c:466:		dev_warn(chip->card->dev, "codec read timeout (reg %x)\n", reg);
./sound/pci/atiixp.c:526:			dev_err(chip->card->dev, "codec reset timeout\n");
./sound/pci/atiixp.c:582:	chip->codec_not_ready_bits = 0;
./sound/pci/atiixp.c:584:		ac97_codec = ac97_probing_bugs(chip->pci);
./sound/pci/atiixp.c:586:		chip->codec_not_ready_bits |= 
./sound/pci/atiixp.c:596:		if (chip->codec_not_ready_bits)
./sound/pci/atiixp.c:601:	if ((chip->codec_not_ready_bits & ALL_CODEC_NOT_READY) == ALL_CODEC_NOT_READY) {
./sound/pci/atiixp.c:602:		dev_err(chip->card->dev, "no codec detected!\n");
./sound/pci/atiixp.c:670:		curptr = readl(chip->remap_addr + dma->ops->dt_cur);
./sound/pci/atiixp.c:678:	dev_dbg(chip->card->dev, "invalid DMA pointer read 0x%x (buf=%x)\n",
./sound/pci/atiixp.c:679:		   readl(chip->remap_addr + dma->ops->dt_cur), dma->buf_addr);
./sound/pci/atiixp.c:690:	dev_dbg(chip->card->dev, "XRUN detected (DMA %d)\n", dma->ops->type);
./sound/pci/atiixp.c:731:	spin_lock(&chip->reg_lock);
./sound/pci/atiixp.c:758:	spin_unlock(&chip->reg_lock);
./sound/pci/atiixp.c:766: * every callback is supposed to be called in chip->reg_lock spinlock
./sound/pci/atiixp.c:872:	spin_lock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:873:	if (chip->spdif_over_aclink) {
./sound/pci/atiixp.c:890:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:900:	spin_lock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:935:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:944:	spin_lock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:948:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:975:		struct ac97_pcm *pcm = chip->pcms[dma->ac97_pcm_type];
./sound/pci/atiixp.c:999:		struct ac97_pcm *pcm = chip->pcms[dma->ac97_pcm_type];
./sound/pci/atiixp.c:1048:		runtime->hw.rates = chip->pcms[pcm_type]->rates;
./sound/pci/atiixp.c:1059:	spin_lock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:1061:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:1074:	spin_lock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:1076:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/atiixp.c:1089:	mutex_lock(&chip->open_mutex);
./sound/pci/atiixp.c:1090:	err = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_PLAYBACK], 0);
./sound/pci/atiixp.c:1091:	mutex_unlock(&chip->open_mutex);
./sound/pci/atiixp.c:1094:	substream->runtime->hw.channels_max = chip->max_channels;
./sound/pci/atiixp.c:1095:	if (chip->max_channels > 2)
./sound/pci/atiixp.c:1106:	mutex_lock(&chip->open_mutex);
./sound/pci/atiixp.c:1107:	err = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_PLAYBACK]);
./sound/pci/atiixp.c:1108:	mutex_unlock(&chip->open_mutex);
./sound/pci/atiixp.c:1115:	return snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_CAPTURE], 1);
./sound/pci/atiixp.c:1121:	return snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_CAPTURE]);
./sound/pci/atiixp.c:1128:	mutex_lock(&chip->open_mutex);
./sound/pci/atiixp.c:1129:	if (chip->spdif_over_aclink) /* share DMA_PLAYBACK */
./sound/pci/atiixp.c:1130:		err = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_PLAYBACK], 2);
./sound/pci/atiixp.c:1132:		err = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_SPDIF], -1);
./sound/pci/atiixp.c:1133:	mutex_unlock(&chip->open_mutex);
./sound/pci/atiixp.c:1141:	mutex_lock(&chip->open_mutex);
./sound/pci/atiixp.c:1142:	if (chip->spdif_over_aclink)
./sound/pci/atiixp.c:1143:		err = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_PLAYBACK]);
./sound/pci/atiixp.c:1145:		err = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_SPDIF]);
./sound/pci/atiixp.c:1146:	mutex_unlock(&chip->open_mutex);
./sound/pci/atiixp.c:1254:	struct snd_ac97_bus *pbus = chip->ac97_bus;
./sound/pci/atiixp.c:1258:	chip->dmas[ATI_DMA_PLAYBACK].ops = &snd_atiixp_playback_dma_ops;
./sound/pci/atiixp.c:1259:	chip->dmas[ATI_DMA_CAPTURE].ops = &snd_atiixp_capture_dma_ops;
./sound/pci/atiixp.c:1260:	if (! chip->spdif_over_aclink)
./sound/pci/atiixp.c:1261:		chip->dmas[ATI_DMA_SPDIF].ops = &snd_atiixp_spdif_dma_ops;
./sound/pci/atiixp.c:1264:	if (chip->spdif_over_aclink)
./sound/pci/atiixp.c:1272:		chip->pcms[i] = &pbus->pcms[i];
./sound/pci/atiixp.c:1274:	chip->max_channels = 2;
./sound/pci/atiixp.c:1277:			chip->max_channels = 6;
./sound/pci/atiixp.c:1279:			chip->max_channels = 4;
./sound/pci/atiixp.c:1283:	err = snd_pcm_new(chip->card, "ATI IXP AC97",
./sound/pci/atiixp.c:1291:	chip->pcmdevs[ATI_PCMDEV_ANALOG] = pcm;
./sound/pci/atiixp.c:1294:					      snd_dma_pci_data(chip->pci),
./sound/pci/atiixp.c:1298:				     snd_pcm_alt_chmaps, chip->max_channels, 0,
./sound/pci/atiixp.c:1303:	chip->ac97[0]->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;
./sound/pci/atiixp.c:1306:	if (chip->pcms[ATI_PCM_SPDIF] && ! chip->pcms[ATI_PCM_SPDIF]->rates)
./sound/pci/atiixp.c:1310:	if (chip->pcms[ATI_PCM_SPDIF])
./sound/pci/atiixp.c:1311:		chip->pcms[ATI_PCM_SPDIF]->rates = SNDRV_PCM_RATE_48000;
./sound/pci/atiixp.c:1314:	err = snd_pcm_new(chip->card, "ATI IXP IEC958",
./sound/pci/atiixp.c:1320:	if (chip->spdif_over_aclink)
./sound/pci/atiixp.c:1324:	chip->pcmdevs[ATI_PCMDEV_DIGITAL] = pcm;
./sound/pci/atiixp.c:1327:					      snd_dma_pci_data(chip->pci),
./sound/pci/atiixp.c:1332:		if (chip->ac97[i])
./sound/pci/atiixp.c:1333:			snd_ac97_update_bits(chip->ac97[i],
./sound/pci/atiixp.c:1358:		snd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_PLAYBACK]);
./sound/pci/atiixp.c:1360:		snd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_PLAYBACK]);
./sound/pci/atiixp.c:1362:		snd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_CAPTURE]);
./sound/pci/atiixp.c:1364:		snd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_CAPTURE]);
./sound/pci/atiixp.c:1365:	if (! chip->spdif_over_aclink) {
./sound/pci/atiixp.c:1367:			snd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_SPDIF]);
./sound/pci/atiixp.c:1369:			snd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_SPDIF]);
./sound/pci/atiixp.c:1376:		spin_lock(&chip->reg_lock);
./sound/pci/atiixp.c:1377:		chip->codec_not_ready_bits |= detected;
./sound/pci/atiixp.c:1379:		spin_unlock(&chip->reg_lock);
./sound/pci/atiixp.c:1435:	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus)) < 0)
./sound/pci/atiixp.c:1438:	chip->ac97_bus = pbus;
./sound/pci/atiixp.c:1442:		if (chip->codec_not_ready_bits & codec_skip[i])
./sound/pci/atiixp.c:1446:		ac97.pci = chip->pci;
./sound/pci/atiixp.c:1449:		if (! chip->spdif_over_aclink)
./sound/pci/atiixp.c:1451:		if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97[i])) < 0) {
./sound/pci/atiixp.c:1452:			chip->ac97[i] = NULL; /* to be sure */
./sound/pci/atiixp.c:1453:			dev_dbg(chip->card->dev,
./sound/pci/atiixp.c:1461:		dev_err(chip->card->dev, "no codec available\n");
./sound/pci/atiixp.c:1465:	snd_ac97_tune_hardware(chip->ac97[0], ac97_quirks, quirk_override);
./sound/pci/atiixp.c:1483:		if (chip->pcmdevs[i]) {
./sound/pci/atiixp.c:1484:			struct atiixp_dma *dma = &chip->dmas[i];
./sound/pci/atiixp.c:1486:				dma->saved_curptr = readl(chip->remap_addr +
./sound/pci/atiixp.c:1488:			snd_pcm_suspend_all(chip->pcmdevs[i]);
./sound/pci/atiixp.c:1491:		snd_ac97_suspend(chip->ac97[i]);
./sound/pci/atiixp.c:1507:		snd_ac97_resume(chip->ac97[i]);
./sound/pci/atiixp.c:1510:		if (chip->pcmdevs[i]) {
./sound/pci/atiixp.c:1511:			struct atiixp_dma *dma = &chip->dmas[i];
./sound/pci/atiixp.c:1516:				       chip->remap_addr + dma->ops->llp_offset);
./sound/pci/atiixp.c:1517:				writel(dma->saved_curptr, chip->remap_addr +
./sound/pci/atiixp.c:1544:		snd_iprintf(buffer, "%02x: %08x\n", i, readl(chip->remap_addr + i));
./sound/pci/atiixp.c:1551:	if (! snd_card_proc_new(chip->card, "atiixp", &entry))
./sound/pci/atiixp.c:1562:	if (chip->irq < 0)
./sound/pci/atiixp.c:1567:	if (chip->irq >= 0)
./sound/pci/atiixp.c:1568:		free_irq(chip->irq, chip);
./sound/pci/atiixp.c:1569:	iounmap(chip->remap_addr);
./sound/pci/atiixp.c:1570:	pci_release_regions(chip->pci);
./sound/pci/atiixp.c:1571:	pci_disable_device(chip->pci);
./sound/pci/atiixp.c:1604:	spin_lock_init(&chip->reg_lock);
./sound/pci/atiixp.c:1605:	mutex_init(&chip->open_mutex);
./sound/pci/atiixp.c:1606:	chip->card = card;
./sound/pci/atiixp.c:1607:	chip->pci = pci;
./sound/pci/atiixp.c:1608:	chip->irq = -1;
./sound/pci/atiixp.c:1614:	chip->addr = pci_resource_start(pci, 0);
./sound/pci/atiixp.c:1615:	chip->remap_addr = pci_ioremap_bar(pci, 0);
./sound/pci/atiixp.c:1616:	if (chip->remap_addr == NULL) {
./sound/pci/atiixp.c:1628:	chip->irq = pci->irq;
./sound/pci/atiixp.c:1630:	synchronize_irq(chip->irq);
./sound/pci/atiixp.c:1662:	chip->spdif_over_aclink = spdif_aclink;
./sound/pci/atiixp.c:1677:		 chip->ac97[0] ? snd_ac97_get_short_name(chip->ac97[0]) : "?",
./sound/pci/atiixp.c:1678:		 chip->addr, chip->irq);
./sound/pci/lola/lola_mixer.c:40:		dev_err(chip->card->dev, "Can't read wcaps for 0x%x\n", nid);
./sound/pci/lola/lola_mixer.c:51:		dev_err(chip->card->dev, "Invalid wcaps 0x%x for 0x%x\n", val, nid);
./sound/pci/lola/lola_mixer.c:65:		dev_err(chip->card->dev, "Can't read AMP-caps for 0x%x\n", nid);
./sound/pci/lola/lola_mixer.c:82:		dev_err(chip->card->dev, "Can't get MAX_LEVEL 0x%x\n", nid);
./sound/pci/lola/lola_mixer.c:98:	for (i = 0; i < chip->pin[dir].num_pins; i++, nid++) {
./sound/pci/lola/lola_mixer.c:99:		err = lola_init_pin(chip, &chip->pin[dir].pins[i], dir, nid);
./sound/pci/lola/lola_mixer.c:102:		if (chip->pin[dir].pins[i].is_analog)
./sound/pci/lola/lola_mixer.c:103:			chip->pin[dir].num_analog_pins++;
./sound/pci/lola/lola_mixer.c:111:	vfree(chip->mixer.array_saved);
./sound/pci/lola/lola_mixer.c:121:		dev_err(chip->card->dev, "Can't read wcaps for 0x%x\n", nid);
./sound/pci/lola/lola_mixer.c:126:		dev_dbg(chip->card->dev, "No valid mixer widget\n");
./sound/pci/lola/lola_mixer.c:130:	chip->mixer.nid = nid;
./sound/pci/lola/lola_mixer.c:131:	chip->mixer.caps = val;
./sound/pci/lola/lola_mixer.c:132:	chip->mixer.array = (struct lola_mixer_array __iomem *)
./sound/pci/lola/lola_mixer.c:133:		(chip->bar[BAR1].remap_addr + LOLA_BAR1_SOURCE_GAIN_ENABLE);
./sound/pci/lola/lola_mixer.c:136:	chip->mixer.array_saved = vmalloc(sizeof(struct lola_mixer_array));
./sound/pci/lola/lola_mixer.c:139:	chip->mixer.src_stream_outs = chip->pcm[PLAY].num_streams;
./sound/pci/lola/lola_mixer.c:140:	chip->mixer.src_phys_ins = chip->pin[CAPT].num_pins;
./sound/pci/lola/lola_mixer.c:143:	chip->mixer.dest_stream_ins = chip->pcm[CAPT].num_streams;
./sound/pci/lola/lola_mixer.c:144:	chip->mixer.dest_phys_outs = chip->pin[PLAY].num_pins;
./sound/pci/lola/lola_mixer.c:149:	chip->mixer.src_stream_out_ofs = chip->mixer.src_phys_ins +
./sound/pci/lola/lola_mixer.c:151:	chip->mixer.dest_phys_out_ofs = chip->mixer.dest_stream_ins +
./sound/pci/lola/lola_mixer.c:202:	if (chip->mixer.src_stream_out_ofs > MAX_AUDIO_INOUT_COUNT ||
./sound/pci/lola/lola_mixer.c:203:	    chip->mixer.dest_phys_out_ofs > MAX_STREAM_IN_COUNT) {
./sound/pci/lola/lola_mixer.c:204:		dev_err(chip->card->dev, "Invalid mixer widget size\n");
./sound/pci/lola/lola_mixer.c:208:	chip->mixer.src_mask = ((1U << chip->mixer.src_phys_ins) - 1) |
./sound/pci/lola/lola_mixer.c:209:		(((1U << chip->mixer.src_stream_outs) - 1)
./sound/pci/lola/lola_mixer.c:210:		 << chip->mixer.src_stream_out_ofs);
./sound/pci/lola/lola_mixer.c:211:	chip->mixer.dest_mask = ((1U << chip->mixer.dest_stream_ins) - 1) |
./sound/pci/lola/lola_mixer.c:212:		(((1U << chip->mixer.dest_phys_outs) - 1)
./sound/pci/lola/lola_mixer.c:213:		 << chip->mixer.dest_phys_out_ofs);
./sound/pci/lola/lola_mixer.c:215:	dev_dbg(chip->card->dev, "Mixer src_mask=%x, dest_mask=%x\n",
./sound/pci/lola/lola_mixer.c:216:		    chip->mixer.src_mask, chip->mixer.dest_mask);
./sound/pci/lola/lola_mixer.c:226:	if (!(chip->mixer.src_mask & (1 << id)))
./sound/pci/lola/lola_mixer.c:228:	oldval = val = readl(&chip->mixer.array->src_gain_enable);
./sound/pci/lola/lola_mixer.c:235:	    (gain == readw(&chip->mixer.array->src_gain[id])))
./sound/pci/lola/lola_mixer.c:238:	dev_dbg(chip->card->dev,
./sound/pci/lola/lola_mixer.c:241:	writew(gain, &chip->mixer.array->src_gain[id]);
./sound/pci/lola/lola_mixer.c:242:	writel(val, &chip->mixer.array->src_gain_enable);
./sound/pci/lola/lola_mixer.c:245:	return lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:255:	if ((chip->mixer.src_mask & mask) != mask)
./sound/pci/lola/lola_mixer.c:259:			writew(*gains, &chip->mixer.array->src_gain[i]);
./sound/pci/lola/lola_mixer.c:263:	writel(mask, &chip->mixer.array->src_gain_enable);
./sound/pci/lola/lola_mixer.c:265:	if (chip->mixer.caps & LOLA_PEAK_METER_CAN_AGC_MASK) {
./sound/pci/lola/lola_mixer.c:267:		return lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:273:			lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:287:	if (!(chip->mixer.src_mask & (1 << src)) ||
./sound/pci/lola/lola_mixer.c:288:	    !(chip->mixer.dest_mask & (1 << dest)))
./sound/pci/lola/lola_mixer.c:291:		writew(gain, &chip->mixer.array->dest_mix_gain[dest][src]);
./sound/pci/lola/lola_mixer.c:292:	val = readl(&chip->mixer.array->dest_mix_gain_enable[dest]);
./sound/pci/lola/lola_mixer.c:297:	writel(val, &chip->mixer.array->dest_mix_gain_enable[dest]);
./sound/pci/lola/lola_mixer.c:299:	return lola_codec_write(chip, chip->mixer.nid, LOLA_VERB_SET_MIX_GAIN,
./sound/pci/lola/lola_mixer.c:309:	if (!(chip->mixer.dest_mask & (1 << id)) ||
./sound/pci/lola/lola_mixer.c:310:	    (chip->mixer.src_mask & mask) != mask)
./sound/pci/lola/lola_mixer.c:314:			writew(*gains, &chip->mixer.array->dest_mix_gain[id][i]);
./sound/pci/lola/lola_mixer.c:318:	writel(mask, &chip->mixer.array->dest_mix_gain_enable[id]);
./sound/pci/lola/lola_mixer.c:321:	return lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:338:	pin = chip->pin[dir].pins;
./sound/pci/lola/lola_mixer.c:339:	max_idx = chip->pin[dir].num_pins;
./sound/pci/lola/lola_mixer.c:353:	if (chip->mixer.array_saved) {
./sound/pci/lola/lola_mixer.c:355:		memcpy_fromio(chip->mixer.array_saved, chip->mixer.array,
./sound/pci/lola/lola_mixer.c:356:			      sizeof(*chip->mixer.array));
./sound/pci/lola/lola_mixer.c:366:	if (chip->mixer.array_saved) {
./sound/pci/lola/lola_mixer.c:368:		memcpy_toio(chip->mixer.array, chip->mixer.array_saved,
./sound/pci/lola/lola_mixer.c:369:			    sizeof(*chip->mixer.array));
./sound/pci/lola/lola_mixer.c:373:		for (i = 0; i < chip->mixer.src_phys_ins; i++)
./sound/pci/lola/lola_mixer.c:374:			lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:377:		for (i = 0; i < chip->mixer.src_stream_outs; i++)
./sound/pci/lola/lola_mixer.c:378:			lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:380:					 chip->mixer.src_stream_out_ofs + i, 0);
./sound/pci/lola/lola_mixer.c:381:		for (i = 0; i < chip->mixer.dest_stream_ins; i++)
./sound/pci/lola/lola_mixer.c:382:			lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:385:		for (i = 0; i < chip->mixer.dest_phys_outs; i++)
./sound/pci/lola/lola_mixer.c:386:			lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:388:					 chip->mixer.dest_phys_out_ofs + i, 0);
./sound/pci/lola/lola_mixer.c:403:	if (idx >= chip->pin[dir].num_pins)
./sound/pci/lola/lola_mixer.c:405:	pin = &chip->pin[dir].pins[idx];
./sound/pci/lola/lola_mixer.c:412:	dev_dbg(chip->card->dev,
./sound/pci/lola/lola_mixer.c:431:	if ((chip->input_src_caps_mask & src_mask) != src_mask)
./sound/pci/lola/lola_mixer.c:434:	for (n = 0; n < chip->pin[CAPT].num_pins; n += 2) {
./sound/pci/lola/lola_mixer.c:437:		if (!(chip->input_src_caps_mask & mask))
./sound/pci/lola/lola_mixer.c:442:			src_state = (chip->input_src_mask & mask) != 0;
./sound/pci/lola/lola_mixer.c:446:		err = lola_codec_write(chip, chip->pcm[CAPT].streams[n].nid,
./sound/pci/lola/lola_mixer.c:456:		chip->input_src_mask = src_mask;
./sound/pci/lola/lola_mixer.c:467:	lola_set_src_config(chip, (1 << chip->pin[CAPT].num_pins) - 1, false);
./sound/pci/lola/lola_mixer.c:470:	memset_io(chip->mixer.array, 0, sizeof(*chip->mixer.array));
./sound/pci/lola/lola_mixer.c:472:	for (i = 0; i < chip->mixer.dest_stream_ins; i++)
./sound/pci/lola/lola_mixer.c:473:		lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:477:	for (i = 0; i < chip->mixer.dest_phys_outs; i++)
./sound/pci/lola/lola_mixer.c:478:		lola_codec_write(chip, chip->mixer.nid,
./sound/pci/lola/lola_mixer.c:480:				 chip->mixer.dest_phys_out_ofs + i, 0);
./sound/pci/lola/lola_mixer.c:483:	for (i = 0; i < chip->mixer.src_phys_ins; i++)
./sound/pci/lola/lola_mixer.c:487:	for (i = 0; i < chip->mixer.src_stream_outs; i++)
./sound/pci/lola/lola_mixer.c:489:					i + chip->mixer.src_stream_out_ofs,
./sound/pci/lola/lola_mixer.c:492:	for (i = 0; i < chip->mixer.dest_stream_ins; i++) {
./sound/pci/lola/lola_mixer.c:493:		int src = i % chip->mixer.src_phys_ins;
./sound/pci/lola/lola_mixer.c:500:	for (i = 0; i < chip->mixer.src_stream_outs; i++) {
./sound/pci/lola/lola_mixer.c:501:		int src = chip->mixer.src_stream_out_ofs + i;
./sound/pci/lola/lola_mixer.c:502:		int dst = chip->mixer.dest_phys_out_ofs +
./sound/pci/lola/lola_mixer.c:503:			i % chip->mixer.dest_phys_outs;
./sound/pci/lola/lola_mixer.c:519:	uinfo->count = chip->pin[dir].num_pins;
./sound/pci/lola/lola_mixer.c:521:	uinfo->value.integer.max = chip->pin[dir].pins[0].amp_num_steps;
./sound/pci/lola/lola_mixer.c:532:	for (i = 0; i < chip->pin[dir].num_pins; i++)
./sound/pci/lola/lola_mixer.c:534:			chip->pin[dir].pins[i].cur_gain_step;
./sound/pci/lola/lola_mixer.c:545:	for (i = 0; i < chip->pin[dir].num_pins; i++) {
./sound/pci/lola/lola_mixer.c:565:	pin = &chip->pin[dir].pins[0];
./sound/pci/lola/lola_mixer.c:596:	if (!chip->pin[dir].num_pins)
./sound/pci/lola/lola_mixer.c:599:	if (chip->pin[dir].num_pins != chip->pin[dir].num_analog_pins)
./sound/pci/lola/lola_mixer.c:603:	return snd_ctl_add(chip->card,
./sound/pci/lola/lola_mixer.c:616:	uinfo->count = chip->pin[CAPT].num_pins;
./sound/pci/lola/lola_mixer.c:628:	for (i = 0; i < chip->pin[CAPT].num_pins; i++)
./sound/pci/lola/lola_mixer.c:630:			!!(chip->input_src_mask & (1 << i));
./sound/pci/lola/lola_mixer.c:642:	for (i = 0; i < chip->pin[CAPT].num_pins; i++)
./sound/pci/lola/lola_mixer.c:662:	if (!chip->input_src_caps_mask)
./sound/pci/lola/lola_mixer.c:665:	return snd_ctl_add(chip->card,
./sound/pci/lola/lola_mixer.c:692:	mask = readl(&chip->mixer.array->src_gain_enable);
./sound/pci/lola/lola_mixer.c:696:		if (!(chip->mixer.src_mask & (1 << idx)))
./sound/pci/lola/lola_mixer.c:699:			val = readw(&chip->mixer.array->src_gain[idx]) + 1;
./sound/pci/lola/lola_mixer.c:745:	return snd_ctl_add(chip->card,
./sound/pci/lola/lola_mixer.c:775:	mask = readl(&chip->mixer.array->dest_mix_gain_enable[dst]);
./sound/pci/lola/lola_mixer.c:779:		if (!(chip->mixer.src_mask & (1 << src)))
./sound/pci/lola/lola_mixer.c:782:			val = readw(&chip->mixer.array->dest_mix_gain[dst][src]) + 1;
./sound/pci/lola/lola_mixer.c:835:	return snd_ctl_add(chip->card,
./sound/pci/lola/lola_mixer.c:855:	err = create_src_gain_mixer(chip, chip->mixer.src_phys_ins, 0,
./sound/pci/lola/lola_mixer.c:859:	err = create_src_gain_mixer(chip, chip->mixer.src_stream_outs,
./sound/pci/lola/lola_mixer.c:860:				    chip->mixer.src_stream_out_ofs,
./sound/pci/lola/lola_mixer.c:867:				     chip->mixer.src_phys_ins, 0,
./sound/pci/lola/lola_mixer.c:868:				     chip->mixer.dest_stream_ins, 0,
./sound/pci/lola/lola_mixer.c:873:				     chip->mixer.src_stream_outs,
./sound/pci/lola/lola_mixer.c:874:				     chip->mixer.src_stream_out_ofs,
./sound/pci/lola/lola_mixer.c:875:				     chip->mixer.dest_stream_ins, 0,
./sound/pci/lola/lola_mixer.c:880:				     chip->mixer.src_phys_ins, 0,
./sound/pci/lola/lola_mixer.c:881:				     chip->mixer.dest_phys_outs,
./sound/pci/lola/lola_mixer.c:882:				     chip->mixer.dest_phys_out_ofs,
./sound/pci/lola/lola_mixer.c:887:				     chip->mixer.src_stream_outs,
./sound/pci/lola/lola_mixer.c:888:				     chip->mixer.src_stream_out_ofs,
./sound/pci/lola/lola_mixer.c:889:				     chip->mixer.dest_phys_outs,
./sound/pci/lola/lola_mixer.c:890:				     chip->mixer.dest_phys_out_ofs,
./sound/pci/lola/lola_clock.c:72:	if (!chip->granularity)
./sound/pci/lola/lola_clock.c:94:		if (val == chip->granularity)
./sound/pci/lola/lola_clock.c:98:		if (chip->audio_in_alloc_mask || chip->audio_out_alloc_mask)
./sound/pci/lola/lola_clock.c:102:						    chip->clock.cur_freq))
./sound/pci/lola/lola_clock.c:106:	chip->granularity = val;
./sound/pci/lola/lola_clock.c:131:		dev_err(chip->card->dev, "Can't read wcaps for 0x%x\n", nid);
./sound/pci/lola/lola_clock.c:136:		dev_dbg(chip->card->dev, "No valid clock widget\n");
./sound/pci/lola/lola_clock.c:140:	chip->clock.nid = nid;
./sound/pci/lola/lola_clock.c:141:	chip->clock.items = val & 0xff;
./sound/pci/lola/lola_clock.c:142:	dev_dbg(chip->card->dev, "clock_list nid=%x, entries=%d\n", nid,
./sound/pci/lola/lola_clock.c:143:		    chip->clock.items);
./sound/pci/lola/lola_clock.c:144:	if (chip->clock.items > MAX_SAMPLE_CLOCK_COUNT) {
./sound/pci/lola/lola_clock.c:145:		dev_err(chip->card->dev, "CLOCK_LIST too big: %d\n",
./sound/pci/lola/lola_clock.c:146:		       chip->clock.items);
./sound/pci/lola/lola_clock.c:150:	nitems = chip->clock.items;
./sound/pci/lola/lola_clock.c:161:			dev_err(chip->card->dev, "Can't read CLOCK_LIST\n");
./sound/pci/lola/lola_clock.c:177:				if (freq < chip->sample_rate_min)
./sound/pci/lola/lola_clock.c:180:					chip->clock.cur_index = idx_list;
./sound/pci/lola/lola_clock.c:181:					chip->clock.cur_freq = 48000;
./sound/pci/lola/lola_clock.c:182:					chip->clock.cur_valid = true;
./sound/pci/lola/lola_clock.c:186:				if (freq < chip->sample_rate_min)
./sound/pci/lola/lola_clock.c:196:				sc = &chip->clock.sample_clock[idx_list];
./sound/pci/lola/lola_clock.c:201:				chip->clock.idx_lookup[idx_list] = idx;
./sound/pci/lola/lola_clock.c:204:				chip->clock.items--;
./sound/pci/lola/lola_clock.c:219:	err = lola_codec_read(chip, chip->clock.nid,
./sound/pci/lola/lola_clock.c:226:		dev_warn(chip->card->dev, "error in enable_clock_events %d\n",
./sound/pci/lola/lola_clock.c:238:	err = lola_codec_read(chip, chip->clock.nid,
./sound/pci/lola/lola_clock.c:240:			      chip->clock.idx_lookup[idx],
./sound/pci/lola/lola_clock.c:245:		dev_warn(chip->card->dev, "error in set_clock %d\n", res);
./sound/pci/lola/lola_clock.c:265:	if (chip->clock.sample_clock[chip->clock.cur_index].type !=
./sound/pci/lola/lola_clock.c:267:		chip->clock.cur_freq = lola_sample_rate_convert(val & 0x7f);
./sound/pci/lola/lola_clock.c:268:		chip->clock.cur_valid = (val & 0x100) != 0;
./sound/pci/lola/lola_clock.c:278:	if (idx == chip->clock.cur_index) {
./sound/pci/lola/lola_clock.c:280:		freq = chip->clock.cur_freq;
./sound/pci/lola/lola_clock.c:281:		valid = chip->clock.cur_valid;
./sound/pci/lola/lola_clock.c:282:	} else if (chip->clock.sample_clock[idx].type ==
./sound/pci/lola/lola_clock.c:285:		freq = chip->clock.sample_clock[idx].freq;
./sound/pci/lola/lola_clock.c:292:	if (!check_gran_clock_compatibility(chip, chip->granularity, freq))
./sound/pci/lola/lola_clock.c:295:	if (idx != chip->clock.cur_index) {
./sound/pci/lola/lola_clock.c:300:		chip->clock.cur_index = idx;
./sound/pci/lola/lola_clock.c:301:		chip->clock.cur_freq = freq;
./sound/pci/lola/lola_clock.c:302:		chip->clock.cur_valid = true;
./sound/pci/lola/lola_clock.c:311:	if (chip->clock.cur_freq == rate && chip->clock.cur_valid)
./sound/pci/lola/lola_clock.c:314:	for (i = 0; i < chip->clock.items; i++) {
./sound/pci/lola/lola_clock.c:315:		if (chip->clock.sample_clock[i].type == LOLA_CLOCK_TYPE_INTERNAL &&
./sound/pci/lola/lola_clock.c:316:		    chip->clock.sample_clock[i].freq == rate)
./sound/pci/lola/lola_clock.c:319:	if (i >= chip->clock.items)
./sound/pci/lola/lola_pcm.c:37:	return &chip->pcm[substream->stream];
./sound/pci/lola/lola_pcm.c:55:	if (chip->granularity) {
./sound/pci/lola/lola_pcm.c:57:		tstamp += (wait_banks + 1) * chip->granularity - 1;
./sound/pci/lola/lola_pcm.c:58:		tstamp -= tstamp % chip->granularity;
./sound/pci/lola/lola_pcm.c:106:	dev_warn(chip->card->dev, "SRST not clear (stream %d)\n", str->dsd);
./sound/pci/lola/lola_pcm.c:121:	dev_warn(chip->card->dev, "FIFO not ready (stream %d)\n", str->dsd);
./sound/pci/lola/lola_pcm.c:159:	dev_warn(chip->card->dev, "FIFO not ready (pending %d)\n", pending - 1);
./sound/pci/lola/lola_pcm.c:230:	mutex_lock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:232:		mutex_unlock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:240:	if (chip->sample_rate) {
./sound/pci/lola/lola_pcm.c:242:		runtime->hw.rate_min = chip->sample_rate;
./sound/pci/lola/lola_pcm.c:243:		runtime->hw.rate_max = chip->sample_rate;
./sound/pci/lola/lola_pcm.c:245:		runtime->hw.rate_min = chip->sample_rate_min;
./sound/pci/lola/lola_pcm.c:246:		runtime->hw.rate_max = chip->sample_rate_max;
./sound/pci/lola/lola_pcm.c:248:	chip->ref_count_rate++;
./sound/pci/lola/lola_pcm.c:250:	/* period size = multiple of chip->granularity (8, 16 or 32 frames)*/
./sound/pci/lola/lola_pcm.c:252:				   chip->granularity);
./sound/pci/lola/lola_pcm.c:254:				   chip->granularity);
./sound/pci/lola/lola_pcm.c:255:	mutex_unlock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:277:	mutex_lock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:282:	if (--chip->ref_count_rate == 0) {
./sound/pci/lola/lola_pcm.c:284:		chip->sample_rate = 0;
./sound/pci/lola/lola_pcm.c:286:	mutex_unlock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:308:	mutex_lock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:311:	mutex_unlock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:376:	dev_err(chip->card->dev, "Too many BDL entries: buffer=%d, period=%d\n",
./sound/pci/lola/lola_pcm.c:418:		dev_err(chip->card->dev, "Cannot set stream format 0x%x\n",
./sound/pci/lola/lola_pcm.c:430:			dev_err(chip->card->dev,
./sound/pci/lola/lola_pcm.c:474:	mutex_lock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:478:		mutex_unlock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:485:	mutex_unlock(&chip->open_mutex);
./sound/pci/lola/lola_pcm.c:502:	chip->sample_rate = runtime->rate;	/* sample rate gets locked */
./sound/pci/lola/lola_pcm.c:547:	spin_lock(&chip->reg_lock);
./sound/pci/lola/lola_pcm.c:560:	spin_unlock(&chip->reg_lock);
./sound/pci/lola/lola_pcm.c:608:					  snd_dma_pci_data(chip->pci),
./sound/pci/lola/lola_pcm.c:609:					  PAGE_SIZE, &chip->pcm[i].bdl);
./sound/pci/lola/lola_pcm.c:614:	err = snd_pcm_new(chip->card, "Digigram Lola", 0,
./sound/pci/lola/lola_pcm.c:615:			  chip->pcm[SNDRV_PCM_STREAM_PLAYBACK].num_streams,
./sound/pci/lola/lola_pcm.c:616:			  chip->pcm[SNDRV_PCM_STREAM_CAPTURE].num_streams,
./sound/pci/lola/lola_pcm.c:623:		if (chip->pcm[i].num_streams)
./sound/pci/lola/lola_pcm.c:628:					      snd_dma_pci_data(chip->pci),
./sound/pci/lola/lola_pcm.c:635:	snd_dma_free_pages(&chip->pcm[0].bdl);
./sound/pci/lola/lola_pcm.c:636:	snd_dma_free_pages(&chip->pcm[1].bdl);
./sound/pci/lola/lola_pcm.c:655:		dev_err(chip->card->dev, "Can't read wcaps for 0x%x\n", nid);
./sound/pci/lola/lola_pcm.c:661:			dev_err(chip->card->dev,
./sound/pci/lola/lola_pcm.c:671:			dev_err(chip->card->dev,
./sound/pci/lola/lola_pcm.c:678:			chip->input_src_caps_mask |= (1 << idx);
./sound/pci/lola/lola_pcm.c:683:		dev_err(chip->card->dev, "Can't read FORMATS 0x%x\n", nid);
./sound/pci/lola/lola_pcm.c:690:		dev_err(chip->card->dev,
./sound/pci/lola/lola_pcm.c:699:	struct lola_pcm *pcm = &chip->pcm[dir];
./sound/pci/lola/lola.c:94:	chip->last_cmd_nid = nid;
./sound/pci/lola/lola.c:95:	chip->last_verb = verb;
./sound/pci/lola/lola.c:96:	chip->last_data = data;
./sound/pci/lola/lola.c:97:	chip->last_extdata = extdata;
./sound/pci/lola/lola.c:100:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/lola/lola.c:101:	if (chip->rirb.cmds < LOLA_CORB_ENTRIES - 1) {
./sound/pci/lola/lola.c:102:		unsigned int wp = chip->corb.wp + 1;
./sound/pci/lola/lola.c:104:		chip->corb.wp = wp;
./sound/pci/lola/lola.c:105:		chip->corb.buf[wp * 2] = cpu_to_le32(data);
./sound/pci/lola/lola.c:106:		chip->corb.buf[wp * 2 + 1] = cpu_to_le32(extdata);
./sound/pci/lola/lola.c:108:		chip->rirb.cmds++;
./sound/pci/lola/lola.c:112:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/lola/lola.c:129:	if (wp == chip->rirb.wp)
./sound/pci/lola/lola.c:131:	chip->rirb.wp = wp;
./sound/pci/lola/lola.c:133:	while (chip->rirb.rp != wp) {
./sound/pci/lola/lola.c:134:		chip->rirb.rp++;
./sound/pci/lola/lola.c:135:		chip->rirb.rp %= LOLA_CORB_ENTRIES;
./sound/pci/lola/lola.c:137:		rp = chip->rirb.rp << 1; /* an RIRB entry is 8-bytes */
./sound/pci/lola/lola.c:138:		res_ex = le32_to_cpu(chip->rirb.buf[rp + 1]);
./sound/pci/lola/lola.c:139:		res = le32_to_cpu(chip->rirb.buf[rp]);
./sound/pci/lola/lola.c:142:		else if (chip->rirb.cmds) {
./sound/pci/lola/lola.c:143:			chip->res = res;
./sound/pci/lola/lola.c:144:			chip->res_ex = res_ex;
./sound/pci/lola/lola.c:146:			chip->rirb.cmds--;
./sound/pci/lola/lola.c:159:		if (chip->polling_mode) {
./sound/pci/lola/lola.c:160:			spin_lock_irq(&chip->reg_lock);
./sound/pci/lola/lola.c:162:			spin_unlock_irq(&chip->reg_lock);
./sound/pci/lola/lola.c:164:		if (!chip->rirb.cmds) {
./sound/pci/lola/lola.c:165:			*val = chip->res;
./sound/pci/lola/lola.c:167:				*extval = chip->res_ex;
./sound/pci/lola/lola.c:169:				      chip->res, chip->res_ex);
./sound/pci/lola/lola.c:170:			if (chip->res_ex & LOLA_RIRB_EX_ERROR) {
./sound/pci/lola/lola.c:171:				dev_warn(chip->card->dev, "RIRB ERROR: "
./sound/pci/lola/lola.c:173:				       chip->last_cmd_nid,
./sound/pci/lola/lola.c:174:				       chip->last_verb, chip->last_data,
./sound/pci/lola/lola.c:175:				       chip->last_extdata);
./sound/pci/lola/lola.c:185:	dev_warn(chip->card->dev, "RIRB response error\n");
./sound/pci/lola/lola.c:186:	if (!chip->polling_mode) {
./sound/pci/lola/lola.c:187:		dev_warn(chip->card->dev, "switching to polling mode\n");
./sound/pci/lola/lola.c:188:		chip->polling_mode = 1;
./sound/pci/lola/lola.c:237:	spin_lock(&chip->reg_lock);
./sound/pci/lola/lola.c:250:		for (i = 0; in_sts && i < chip->pcm[CAPT].num_streams; i++) {
./sound/pci/lola/lola.c:264:		for (i = 0; out_sts && i < chip->pcm[PLAY].num_streams; i++) {
./sound/pci/lola/lola.c:297:	spin_unlock(&chip->reg_lock);
./sound/pci/lola/lola.c:299:	lola_pcm_update(chip, &chip->pcm[CAPT], notify_ins);
./sound/pci/lola/lola.c:300:	lola_pcm_update(chip, &chip->pcm[PLAY], notify_outs);
./sound/pci/lola/lola.c:320:	chip->cold_reset = 1;
./sound/pci/lola/lola.c:330:		dev_err(chip->card->dev, "cannot reset controller\n");
./sound/pci/lola/lola.c:341:	val = (1 << chip->pcm[PLAY].num_streams) - 1;
./sound/pci/lola/lola.c:343:	val = (1 << chip->pcm[CAPT].num_streams) - 1;
./sound/pci/lola/lola.c:366:				  snd_dma_pci_data(chip->pci),
./sound/pci/lola/lola.c:367:				  PAGE_SIZE, &chip->rb);
./sound/pci/lola/lola.c:371:	chip->corb.addr = chip->rb.addr;
./sound/pci/lola/lola.c:372:	chip->corb.buf = (u32 *)chip->rb.area;
./sound/pci/lola/lola.c:373:	chip->rirb.addr = chip->rb.addr + 2048;
./sound/pci/lola/lola.c:374:	chip->rirb.buf = (u32 *)(chip->rb.area + 2048);
./sound/pci/lola/lola.c:389:	lola_writel(chip, BAR0, CORBLBASE, (u32)chip->corb.addr);
./sound/pci/lola/lola.c:390:	lola_writel(chip, BAR0, CORBUBASE, upper_32_bits(chip->corb.addr));
./sound/pci/lola/lola.c:403:	chip->corb.wp = 0;
./sound/pci/lola/lola.c:406:	lola_writel(chip, BAR0, RIRBLBASE, (u32)chip->rirb.addr);
./sound/pci/lola/lola.c:407:	lola_writel(chip, BAR0, RIRBUBASE, upper_32_bits(chip->rirb.addr));
./sound/pci/lola/lola.c:420:	chip->rirb.rp = chip->rirb.cmds = 0;
./sound/pci/lola/lola.c:435:	lola_set_granularity(chip, chip->granularity, true);
./sound/pci/lola/lola.c:437:	lola_set_clock_index(chip, chip->clock.cur_index);
./sound/pci/lola/lola.c:443:	lola_set_src_config(chip, chip->input_src_mask, false);
./sound/pci/lola/lola.c:455:		dev_err(chip->card->dev, "Can't read VENDOR_ID\n");
./sound/pci/lola/lola.c:460:		dev_err(chip->card->dev, "Unknown codec vendor 0x%x\n", val);
./sound/pci/lola/lola.c:466:		dev_err(chip->card->dev, "Can't read FUNCTION_TYPE\n");
./sound/pci/lola/lola.c:470:		dev_err(chip->card->dev, "Unknown function type %d\n", val);
./sound/pci/lola/lola.c:476:		dev_err(chip->card->dev, "Can't read SPECCAPS\n");
./sound/pci/lola/lola.c:479:	chip->lola_caps = val;
./sound/pci/lola/lola.c:480:	chip->pin[CAPT].num_pins = LOLA_AFG_INPUT_PIN_COUNT(chip->lola_caps);
./sound/pci/lola/lola.c:481:	chip->pin[PLAY].num_pins = LOLA_AFG_OUTPUT_PIN_COUNT(chip->lola_caps);
./sound/pci/lola/lola.c:482:	dev_dbg(chip->card->dev, "speccaps=0x%x, pins in=%d, out=%d\n",
./sound/pci/lola/lola.c:483:		    chip->lola_caps,
./sound/pci/lola/lola.c:484:		    chip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);
./sound/pci/lola/lola.c:486:	if (chip->pin[CAPT].num_pins > MAX_AUDIO_INOUT_COUNT ||
./sound/pci/lola/lola.c:487:	    chip->pin[PLAY].num_pins > MAX_AUDIO_INOUT_COUNT) {
./sound/pci/lola/lola.c:488:		dev_err(chip->card->dev, "Invalid Lola-spec caps 0x%x\n", val);
./sound/pci/lola/lola.c:507:	if (LOLA_AFG_CLOCK_WIDGET_PRESENT(chip->lola_caps)) {
./sound/pci/lola/lola.c:513:	if (LOLA_AFG_MIXER_WIDGET_PRESENT(chip->lola_caps)) {
./sound/pci/lola/lola.c:528:	if (!chip->cold_reset) {
./sound/pci/lola/lola.c:530:		chip->cold_reset = 1;
./sound/pci/lola/lola.c:533:		if (chip->granularity != LOLA_GRANULARITY_MIN)
./sound/pci/lola/lola.c:534:			lola_set_granularity(chip, chip->granularity, true);
./sound/pci/lola/lola.c:548:	if (chip->initialized)
./sound/pci/lola/lola.c:552:	if (chip->irq >= 0)
./sound/pci/lola/lola.c:553:		free_irq(chip->irq, (void *)chip);
./sound/pci/lola/lola.c:554:	iounmap(chip->bar[0].remap_addr);
./sound/pci/lola/lola.c:555:	iounmap(chip->bar[1].remap_addr);
./sound/pci/lola/lola.c:556:	if (chip->rb.area)
./sound/pci/lola/lola.c:557:		snd_dma_free_pages(&chip->rb);
./sound/pci/lola/lola.c:558:	pci_release_regions(chip->pci);
./sound/pci/lola/lola.c:559:	pci_disable_device(chip->pci);
./sound/pci/lola/lola.c:591:	spin_lock_init(&chip->reg_lock);
./sound/pci/lola/lola.c:592:	mutex_init(&chip->open_mutex);
./sound/pci/lola/lola.c:593:	chip->card = card;
./sound/pci/lola/lola.c:594:	chip->pci = pci;
./sound/pci/lola/lola.c:595:	chip->irq = -1;
./sound/pci/lola/lola.c:597:	chip->granularity = granularity[dev];
./sound/pci/lola/lola.c:598:	switch (chip->granularity) {
./sound/pci/lola/lola.c:600:		chip->sample_rate_max = 48000;
./sound/pci/lola/lola.c:603:		chip->sample_rate_max = 96000;
./sound/pci/lola/lola.c:606:		chip->sample_rate_max = 192000;
./sound/pci/lola/lola.c:609:		dev_warn(chip->card->dev,
./sound/pci/lola/lola.c:611:			   chip->granularity, LOLA_GRANULARITY_MAX);
./sound/pci/lola/lola.c:612:		chip->granularity = LOLA_GRANULARITY_MAX;
./sound/pci/lola/lola.c:613:		chip->sample_rate_max = 192000;
./sound/pci/lola/lola.c:616:	chip->sample_rate_min = sample_rate_min[dev];
./sound/pci/lola/lola.c:617:	if (chip->sample_rate_min > chip->sample_rate_max) {
./sound/pci/lola/lola.c:618:		dev_warn(chip->card->dev,
./sound/pci/lola/lola.c:620:			   chip->sample_rate_min);
./sound/pci/lola/lola.c:621:		chip->sample_rate_min = 16000;
./sound/pci/lola/lola.c:631:	chip->bar[0].addr = pci_resource_start(pci, 0);
./sound/pci/lola/lola.c:632:	chip->bar[0].remap_addr = pci_ioremap_bar(pci, 0);
./sound/pci/lola/lola.c:633:	chip->bar[1].addr = pci_resource_start(pci, 2);
./sound/pci/lola/lola.c:634:	chip->bar[1].remap_addr = pci_ioremap_bar(pci, 2);
./sound/pci/lola/lola.c:635:	if (!chip->bar[0].remap_addr || !chip->bar[1].remap_addr) {
./sound/pci/lola/lola.c:636:		dev_err(chip->card->dev, "ioremap error\n");
./sound/pci/lola/lola.c:649:		dev_err(chip->card->dev, "unable to grab IRQ %d\n", pci->irq);
./sound/pci/lola/lola.c:653:	chip->irq = pci->irq;
./sound/pci/lola/lola.c:654:	synchronize_irq(chip->irq);
./sound/pci/lola/lola.c:657:	chip->pcm[CAPT].num_streams = (dever >> 0) & 0x3ff;
./sound/pci/lola/lola.c:658:	chip->pcm[PLAY].num_streams = (dever >> 10) & 0x3ff;
./sound/pci/lola/lola.c:659:	chip->version = (dever >> 24) & 0xff;
./sound/pci/lola/lola.c:660:	dev_dbg(chip->card->dev, "streams in=%d, out=%d, version=0x%x\n",
./sound/pci/lola/lola.c:661:		    chip->pcm[CAPT].num_streams, chip->pcm[PLAY].num_streams,
./sound/pci/lola/lola.c:662:		    chip->version);
./sound/pci/lola/lola.c:665:	if (chip->pcm[CAPT].num_streams > MAX_STREAM_IN_COUNT ||
./sound/pci/lola/lola.c:666:	    chip->pcm[PLAY].num_streams > MAX_STREAM_OUT_COUNT ||
./sound/pci/lola/lola.c:667:	    (!chip->pcm[CAPT].num_streams &&
./sound/pci/lola/lola.c:668:	     !chip->pcm[PLAY].num_streams)) {
./sound/pci/lola/lola.c:669:		dev_err(chip->card->dev, "invalid DEVER = %x\n", dever);
./sound/pci/lola/lola.c:680:		dev_err(chip->card->dev, "Error creating device [card]!\n");
./sound/pci/lola/lola.c:688:		 card->shortname, chip->bar[0].addr, chip->irq);
./sound/pci/lola/lola.c:693:	chip->initialized = 1;
./sound/pci/lola/lola_proc.c:124:		    chip->pin[CAPT].num_pins, chip->pin[PLAY].num_pins);
./sound/pci/lola/lola_proc.c:126:	for (i = 0; i < chip->pcm[CAPT].num_streams; i++, nid++)
./sound/pci/lola/lola_proc.c:128:	for (i = 0; i < chip->pcm[PLAY].num_streams; i++, nid++)
./sound/pci/lola/lola_proc.c:130:	for (i = 0; i < chip->pin[CAPT].num_pins; i++, nid++)
./sound/pci/lola/lola_proc.c:133:	for (i = 0; i < chip->pin[PLAY].num_pins; i++, nid++)
./sound/pci/lola/lola_proc.c:136:	if (LOLA_AFG_CLOCK_WIDGET_PRESENT(chip->lola_caps)) {
./sound/pci/lola/lola_proc.c:140:	if (LOLA_AFG_MIXER_WIDGET_PRESENT(chip->lola_caps)) {
./sound/pci/lola/lola_proc.c:157:				&chip->debug_res,
./sound/pci/lola/lola_proc.c:158:				&chip->debug_res_ex);
./sound/pci/lola/lola_proc.c:166:	snd_iprintf(buffer, "0x%x 0x%x\n", chip->debug_res, chip->debug_res_ex);
./sound/pci/lola/lola_proc.c:180:			    readl(chip->bar[BAR0].remap_addr + i));
./sound/pci/lola/lola_proc.c:185:			    readl(chip->bar[BAR1].remap_addr + i));
./sound/pci/lola/lola_proc.c:190:			    readl(chip->bar[BAR1].remap_addr + i));
./sound/pci/lola/lola_proc.c:213:	if (!snd_card_proc_new(chip->card, "codec", &entry))
./sound/pci/lola/lola_proc.c:215:	if (!snd_card_proc_new(chip->card, "codec_rw", &entry)) {
./sound/pci/lola/lola_proc.c:220:	if (!snd_card_proc_new(chip->card, "regs", &entry))
./sound/pci/oxygen/xonar_pcm179x.c:267:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:269:	if ((chip->model.function_flags & OXYGEN_FUNCTION_2WIRE_SPI_MASK) ==
./sound/pci/oxygen/xonar_pcm179x.c:282:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:290:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:298:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:306:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:316:		pcm1796_write(chip, i, 16, chip->dac_volume[i * 2]
./sound/pci/oxygen/xonar_pcm179x.c:318:		pcm1796_write(chip, i, 17, chip->dac_volume[i * 2 + 1]
./sound/pci/oxygen/xonar_pcm179x.c:331:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:347:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:363:	snd_component_add(chip->card, "PCM1796");
./sound/pci/oxygen/xonar_pcm179x.c:364:	snd_component_add(chip->card, "CS5381");
./sound/pci/oxygen/xonar_pcm179x.c:369:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:381:	struct xonar_hdav *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:393:	data->pcm179x.dacs = chip->model.dac_channels_mixer / 2;
./sound/pci/oxygen/xonar_pcm179x.c:394:	data->pcm179x.h6 = chip->model.dac_channels_mixer > 2;
./sound/pci/oxygen/xonar_pcm179x.c:407:	snd_component_add(chip->card, "PCM1796");
./sound/pci/oxygen/xonar_pcm179x.c:408:	snd_component_add(chip->card, "CS5381");
./sound/pci/oxygen/xonar_pcm179x.c:421:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:424:	data->dacs = chip->model.dac_channels_mixer / 2;
./sound/pci/oxygen/xonar_pcm179x.c:425:	data->h6 = chip->model.dac_channels_mixer > 2;
./sound/pci/oxygen/xonar_pcm179x.c:439:	snd_component_add(chip->card, "PCM1792A");
./sound/pci/oxygen/xonar_pcm179x.c:440:	snd_component_add(chip->card, "CS5381");
./sound/pci/oxygen/xonar_pcm179x.c:445:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:470:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:473:	data->h6 = chip->model.dac_channels_mixer > 2;
./sound/pci/oxygen/xonar_pcm179x.c:490:	snd_component_add(chip->card, "CS2000");
./sound/pci/oxygen/xonar_pcm179x.c:495:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:508:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:546:	snd_component_add(chip->card, "PCM1796");
./sound/pci/oxygen/xonar_pcm179x.c:547:	snd_component_add(chip->card, "CS5381");
./sound/pci/oxygen/xonar_pcm179x.c:548:	snd_component_add(chip->card, "CS2000");
./sound/pci/oxygen/xonar_pcm179x.c:591:	struct xonar_hdav *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:612:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:627:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:636:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:642:		pcm1796_write_cached(chip, i, 16, chip->dac_volume[i * 2]
./sound/pci/oxygen/xonar_pcm179x.c:644:		pcm1796_write_cached(chip, i, 17, chip->dac_volume[i * 2 + 1]
./sound/pci/oxygen/xonar_pcm179x.c:652:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:657:	if (chip->dac_mute)
./sound/pci/oxygen/xonar_pcm179x.c:665:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:710:	struct xonar_hdav *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:739:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:751:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:756:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:768:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:820:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:823:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:840:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:858:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:860:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:869:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:879:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:886:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:892:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:933:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:936:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:953:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_pcm179x.c:978:		spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/xonar_pcm179x.c:982:		spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/xonar_pcm179x.c:1006:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:1010:		err = snd_ctl_add(chip->card,
./sound/pci/oxygen/xonar_pcm179x.c:1022:	err = snd_ctl_add(chip->card, snd_ctl_new1(&alt_switch, chip));
./sound/pci/oxygen/xonar_pcm179x.c:1035:	err = snd_ctl_add(chip->card, snd_ctl_new1(&hdav_hdmi_control, chip));
./sound/pci/oxygen/xonar_pcm179x.c:1050:		err = snd_ctl_add(chip->card,
./sound/pci/oxygen/xonar_pcm179x.c:1067:		err = snd_ctl_add(chip->card,
./sound/pci/oxygen/xonar_pcm179x.c:1081:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:1096:	struct xonar_pcm179x *data = chip->model_data;
./sound/pci/oxygen/xonar_pcm179x.c:1224:		chip->model = model_xonar_d2;
./sound/pci/oxygen/xonar_pcm179x.c:1225:		chip->model.shortname = "Xonar D2";
./sound/pci/oxygen/xonar_pcm179x.c:1228:		chip->model = model_xonar_d2;
./sound/pci/oxygen/xonar_pcm179x.c:1229:		chip->model.shortname = "Xonar D2X";
./sound/pci/oxygen/xonar_pcm179x.c:1230:		chip->model.init = xonar_d2x_init;
./sound/pci/oxygen/xonar_pcm179x.c:1233:		chip->model = model_xonar_hdav;
./sound/pci/oxygen/xonar_pcm179x.c:1237:			chip->model.shortname = "Xonar HDAV1.3";
./sound/pci/oxygen/xonar_pcm179x.c:1240:			chip->model.shortname = "Xonar HDAV1.3+H6";
./sound/pci/oxygen/xonar_pcm179x.c:1241:			chip->model.dac_channels_mixer = 8;
./sound/pci/oxygen/xonar_pcm179x.c:1242:			chip->model.dac_mclks = OXYGEN_MCLKS(256, 128, 128);
./sound/pci/oxygen/xonar_pcm179x.c:1247:		chip->model = model_xonar_st;
./sound/pci/oxygen/xonar_pcm179x.c:1251:			chip->model.shortname = "Xonar ST";
./sound/pci/oxygen/xonar_pcm179x.c:1254:			chip->model.shortname = "Xonar ST+H6";
./sound/pci/oxygen/xonar_pcm179x.c:1255:			chip->model.control_filter = xonar_st_h6_control_filter;
./sound/pci/oxygen/xonar_pcm179x.c:1256:			chip->model.dac_channels_pcm = 8;
./sound/pci/oxygen/xonar_pcm179x.c:1257:			chip->model.dac_channels_mixer = 8;
./sound/pci/oxygen/xonar_pcm179x.c:1258:			chip->model.dac_volume_min = 255;
./sound/pci/oxygen/xonar_pcm179x.c:1259:			chip->model.dac_mclks = OXYGEN_MCLKS(256, 128, 128);
./sound/pci/oxygen/xonar_pcm179x.c:1264:		chip->model = model_xonar_st;
./sound/pci/oxygen/xonar_pcm179x.c:1265:		chip->model.shortname = "Xonar STX";
./sound/pci/oxygen/xonar_pcm179x.c:1266:		chip->model.init = xonar_stx_init;
./sound/pci/oxygen/xonar_pcm179x.c:1267:		chip->model.resume = xonar_stx_resume;
./sound/pci/oxygen/xonar_pcm179x.c:1268:		chip->model.set_dac_params = set_pcm1796_params;
./sound/pci/oxygen/xonar_pcm179x.c:1271:		chip->model = model_xonar_st;
./sound/pci/oxygen/xonar_pcm179x.c:1275:			chip->model.shortname = "Xonar STX II";
./sound/pci/oxygen/xonar_pcm179x.c:1278:			chip->model.shortname = "Xonar STX II+H6";
./sound/pci/oxygen/xonar_pcm179x.c:1279:			chip->model.dac_channels_pcm = 8;
./sound/pci/oxygen/xonar_pcm179x.c:1280:			chip->model.dac_channels_mixer = 8;
./sound/pci/oxygen/xonar_pcm179x.c:1281:			chip->model.dac_mclks = OXYGEN_MCLKS(256, 128, 128);
./sound/pci/oxygen/xonar_pcm179x.c:1284:		chip->model.init = xonar_stx_init;
./sound/pci/oxygen/xonar_pcm179x.c:1285:		chip->model.resume = xonar_stx_resume;
./sound/pci/oxygen/xonar_pcm179x.c:1286:		chip->model.set_dac_params = set_pcm1796_params;
./sound/pci/oxygen/xonar_pcm179x.c:1289:		chip->model = model_xonar_st;
./sound/pci/oxygen/xonar_pcm179x.c:1290:		chip->model.shortname = "Xonar Xense";
./sound/pci/oxygen/xonar_pcm179x.c:1291:		chip->model.chip = "AV100";
./sound/pci/oxygen/xonar_pcm179x.c:1292:		chip->model.init = xonar_xense_init;
./sound/pci/oxygen/xonar_pcm179x.c:1293:		chip->model.mixer_init = xonar_xense_mixer_init;
./sound/pci/oxygen/xonar_lib.c:35:	struct xonar_generic *data = chip->model_data;
./sound/pci/oxygen/xonar_lib.c:44:	struct xonar_generic *data = chip->model_data;
./sound/pci/oxygen/xonar_lib.c:51:	struct xonar_generic *data = chip->model_data;
./sound/pci/oxygen/xonar_lib.c:59:			dev_notice(chip->card->dev, "power restored\n");
./sound/pci/oxygen/xonar_lib.c:61:			dev_crit(chip->card->dev,
./sound/pci/oxygen/xonar_lib.c:70:	struct xonar_generic *data = chip->model_data;
./sound/pci/oxygen/xonar_lib.c:74:	chip->interrupt_mask |= OXYGEN_INT_GPIO;
./sound/pci/oxygen/xonar_lib.c:75:	chip->model.gpio_changed = xonar_ext_power_gpio_changed;
./sound/pci/oxygen/xonar_lib.c:123:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/xonar_lib.c:132:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:140:	if (channel == PCM_B && chip->has_ac97_1 &&
./sound/pci/oxygen/oxygen_pcm.c:141:	    (chip->model.device_config & CAPTURE_2_FROM_AC97_1))
./sound/pci/oxygen/oxygen_pcm.c:147:		if (chip->model.device_config & CAPTURE_1_FROM_SPDIF) {
./sound/pci/oxygen/oxygen_pcm.c:158:		runtime->hw.channels_max = chip->model.dac_channels_pcm;
./sound/pci/oxygen/oxygen_pcm.c:161:	if (chip->model.pcm_hardware_filter)
./sound/pci/oxygen/oxygen_pcm.c:162:		chip->model.pcm_hardware_filter(channel, &runtime->hw);
./sound/pci/oxygen/oxygen_pcm.c:184:	chip->streams[channel] = substream;
./sound/pci/oxygen/oxygen_pcm.c:186:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:187:	chip->pcm_active |= 1 << channel;
./sound/pci/oxygen/oxygen_pcm.c:189:		chip->spdif_pcm_bits = chip->spdif_bits;
./sound/pci/oxygen/oxygen_pcm.c:190:		chip->controls[CONTROL_SPDIF_PCM]->vd[0].access &=
./sound/pci/oxygen/oxygen_pcm.c:192:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |
./sound/pci/oxygen/oxygen_pcm.c:194:			       &chip->controls[CONTROL_SPDIF_PCM]->id);
./sound/pci/oxygen/oxygen_pcm.c:196:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:236:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:237:	chip->pcm_active &= ~(1 << channel);
./sound/pci/oxygen/oxygen_pcm.c:239:		chip->controls[CONTROL_SPDIF_PCM]->vd[0].access |=
./sound/pci/oxygen/oxygen_pcm.c:241:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |
./sound/pci/oxygen/oxygen_pcm.c:243:			       &chip->controls[CONTROL_SPDIF_PCM]->id);
./sound/pci/oxygen/oxygen_pcm.c:247:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:249:	chip->streams[channel] = NULL;
./sound/pci/oxygen/oxygen_pcm.c:348:		mclks = chip->model.dac_mclks;
./sound/pci/oxygen/oxygen_pcm.c:350:		mclks = chip->model.adc_mclks;
./sound/pci/oxygen/oxygen_pcm.c:372:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:378:			      chip->model.adc_i2s_format |
./sound/pci/oxygen/oxygen_pcm.c:385:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:387:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:388:	chip->model.set_adc_params(chip, hw_params);
./sound/pci/oxygen/oxygen_pcm.c:389:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:404:	is_ac97 = chip->has_ac97_1 &&
./sound/pci/oxygen/oxygen_pcm.c:405:		(chip->model.device_config & CAPTURE_2_FROM_AC97_1);
./sound/pci/oxygen/oxygen_pcm.c:407:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:414:				      chip->model.adc_i2s_format |
./sound/pci/oxygen/oxygen_pcm.c:421:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:424:		mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:425:		chip->model.set_adc_params(chip, hw_params);
./sound/pci/oxygen/oxygen_pcm.c:426:		mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:442:	is_spdif = chip->model.device_config & CAPTURE_1_FROM_SPDIF;
./sound/pci/oxygen/oxygen_pcm.c:444:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:451:				      chip->model.adc_i2s_format |
./sound/pci/oxygen/oxygen_pcm.c:458:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:461:		mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:462:		chip->model.set_adc_params(chip, hw_params);
./sound/pci/oxygen/oxygen_pcm.c:463:		mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:478:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:479:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:489:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:490:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:504:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:505:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:514:			      chip->model.dac_i2s_format |
./sound/pci/oxygen/oxygen_pcm.c:522:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:524:	chip->model.set_dac_params(chip, hw_params);
./sound/pci/oxygen/oxygen_pcm.c:526:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_pcm.c:536:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:537:	chip->interrupt_mask &= ~channel_mask;
./sound/pci/oxygen/oxygen_pcm.c:538:	oxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);
./sound/pci/oxygen/oxygen_pcm.c:542:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:551:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:554:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:564:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:569:		chip->interrupt_mask &= ~channel_mask;
./sound/pci/oxygen/oxygen_pcm.c:571:		chip->interrupt_mask |= channel_mask;
./sound/pci/oxygen/oxygen_pcm.c:572:	oxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);
./sound/pci/oxygen/oxygen_pcm.c:573:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:605:	spin_lock(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:608:			chip->pcm_running |= mask;
./sound/pci/oxygen/oxygen_pcm.c:610:			chip->pcm_running &= ~mask;
./sound/pci/oxygen/oxygen_pcm.c:611:		oxygen_write8(chip, OXYGEN_DMA_STATUS, chip->pcm_running);
./sound/pci/oxygen/oxygen_pcm.c:618:	spin_unlock(&chip->reg_lock);
./sound/pci/oxygen/oxygen_pcm.c:706:	outs = !!(chip->model.device_config & PLAYBACK_0_TO_I2S);
./sound/pci/oxygen/oxygen_pcm.c:707:	ins = !!(chip->model.device_config & (CAPTURE_0_FROM_I2S_1 |
./sound/pci/oxygen/oxygen_pcm.c:710:		err = snd_pcm_new(chip->card, "Multichannel",
./sound/pci/oxygen/oxygen_pcm.c:717:		if (chip->model.device_config & CAPTURE_0_FROM_I2S_1)
./sound/pci/oxygen/oxygen_pcm.c:720:		else if (chip->model.device_config & CAPTURE_0_FROM_I2S_2)
./sound/pci/oxygen/oxygen_pcm.c:728:						      snd_dma_pci_data(chip->pci),
./sound/pci/oxygen/oxygen_pcm.c:734:						      snd_dma_pci_data(chip->pci),
./sound/pci/oxygen/oxygen_pcm.c:739:	outs = !!(chip->model.device_config & PLAYBACK_1_TO_SPDIF);
./sound/pci/oxygen/oxygen_pcm.c:740:	ins = !!(chip->model.device_config & CAPTURE_1_FROM_SPDIF);
./sound/pci/oxygen/oxygen_pcm.c:742:		err = snd_pcm_new(chip->card, "Digital", 1, outs, ins, &pcm);
./sound/pci/oxygen/oxygen_pcm.c:754:						      snd_dma_pci_data(chip->pci),
./sound/pci/oxygen/oxygen_pcm.c:759:	if (chip->has_ac97_1) {
./sound/pci/oxygen/oxygen_pcm.c:760:		outs = !!(chip->model.device_config & PLAYBACK_2_TO_AC97_1);
./sound/pci/oxygen/oxygen_pcm.c:761:		ins = !!(chip->model.device_config & CAPTURE_2_FROM_AC97_1);
./sound/pci/oxygen/oxygen_pcm.c:764:		ins = !!(chip->model.device_config & CAPTURE_2_FROM_I2S_2);
./sound/pci/oxygen/oxygen_pcm.c:767:		err = snd_pcm_new(chip->card, outs ? "AC97" : "Analog2",
./sound/pci/oxygen/oxygen_pcm.c:784:						      snd_dma_pci_data(chip->pci),
./sound/pci/oxygen/oxygen_pcm.c:789:	ins = !!(chip->model.device_config & CAPTURE_3_FROM_I2S_3);
./sound/pci/oxygen/oxygen_pcm.c:791:		err = snd_pcm_new(chip->card, "Analog3", 3, 0, ins, &pcm);
./sound/pci/oxygen/oxygen_pcm.c:802:						      snd_dma_pci_data(chip->pci),
./sound/pci/oxygen/oxygen_lib.c:57:		if (chip->uart_input_count >= ARRAY_SIZE(chip->uart_input))
./sound/pci/oxygen/oxygen_lib.c:58:			chip->uart_input_count = 0;
./sound/pci/oxygen/oxygen_lib.c:59:		chip->uart_input[chip->uart_input_count++] = data;
./sound/pci/oxygen/oxygen_lib.c:61:	if (chip->model.uart_input)
./sound/pci/oxygen/oxygen_lib.c:62:		chip->model.uart_input(chip);
./sound/pci/oxygen/oxygen_lib.c:74:	spin_lock(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:87:			chip->interrupt_mask &= ~OXYGEN_INT_SPDIF_IN_DETECT;
./sound/pci/oxygen/oxygen_lib.c:89:			       chip->interrupt_mask & ~clear);
./sound/pci/oxygen/oxygen_lib.c:91:			       chip->interrupt_mask);
./sound/pci/oxygen/oxygen_lib.c:94:	elapsed_streams = status & chip->pcm_running;
./sound/pci/oxygen/oxygen_lib.c:96:	spin_unlock(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:99:		if ((elapsed_streams & (1 << i)) && chip->streams[i])
./sound/pci/oxygen/oxygen_lib.c:100:			snd_pcm_period_elapsed(chip->streams[i]);
./sound/pci/oxygen/oxygen_lib.c:103:		spin_lock(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:109:			schedule_work(&chip->spdif_input_bits_work);
./sound/pci/oxygen/oxygen_lib.c:111:		spin_unlock(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:115:		schedule_work(&chip->gpio_work);
./sound/pci/oxygen/oxygen_lib.c:118:		if (chip->midi)
./sound/pci/oxygen/oxygen_lib.c:119:			snd_mpu401_uart_interrupt(0, chip->midi->private_data);
./sound/pci/oxygen/oxygen_lib.c:125:		wake_up(&chip->ac97_waitqueue);
./sound/pci/oxygen/oxygen_lib.c:142:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:153:		spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:155:		spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:173:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:175:	if (chip->controls[CONTROL_SPDIF_INPUT_BITS]) {
./sound/pci/oxygen/oxygen_lib.c:176:		spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:177:		chip->interrupt_mask |= OXYGEN_INT_SPDIF_IN_DETECT;
./sound/pci/oxygen/oxygen_lib.c:179:			       chip->interrupt_mask);
./sound/pci/oxygen/oxygen_lib.c:180:		spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:186:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/pci/oxygen/oxygen_lib.c:187:			       &chip->controls[CONTROL_SPDIF_INPUT_BITS]->id);
./sound/pci/oxygen/oxygen_lib.c:195:	if (chip->model.gpio_changed)
./sound/pci/oxygen/oxygen_lib.c:196:		chip->model.gpio_changed(chip);
./sound/pci/oxygen/oxygen_lib.c:218:	if (mutex_lock_interruptible(&chip->mutex) < 0)
./sound/pci/oxygen/oxygen_lib.c:220:	if (chip->has_ac97_0) {
./sound/pci/oxygen/oxygen_lib.c:230:	if (chip->has_ac97_1) {
./sound/pci/oxygen/oxygen_lib.c:240:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_lib.c:241:	if (chip->model.dump_registers)
./sound/pci/oxygen/oxygen_lib.c:242:		chip->model.dump_registers(chip, buffer);
./sound/pci/oxygen/oxygen_lib.c:249:	if (!snd_card_proc_new(chip->card, "oxygen", &entry))
./sound/pci/oxygen/oxygen_lib.c:305:		pci_write_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID,
./sound/pci/oxygen/oxygen_lib.c:307:		pci_write_config_word(chip->pci, PCI_SUBSYSTEM_ID,
./sound/pci/oxygen/oxygen_lib.c:312:		dev_info(chip->card->dev, "EEPROM ID restored\n");
./sound/pci/oxygen/oxygen_lib.c:372:	chip->dac_routing = 1;
./sound/pci/oxygen/oxygen_lib.c:374:		chip->dac_volume[i] = chip->model.dac_volume_min;
./sound/pci/oxygen/oxygen_lib.c:375:	chip->dac_mute = 1;
./sound/pci/oxygen/oxygen_lib.c:376:	chip->spdif_playback_enable = 1;
./sound/pci/oxygen/oxygen_lib.c:377:	chip->spdif_bits = OXYGEN_SPDIF_C | OXYGEN_SPDIF_ORIGINAL |
./sound/pci/oxygen/oxygen_lib.c:379:	chip->spdif_pcm_bits = chip->spdif_bits;
./sound/pci/oxygen/oxygen_lib.c:386:	chip->has_ac97_0 = (i & OXYGEN_AC97_CODEC_0) != 0;
./sound/pci/oxygen/oxygen_lib.c:387:	chip->has_ac97_1 = (i & OXYGEN_AC97_CODEC_1) != 0;
./sound/pci/oxygen/oxygen_lib.c:391:			     chip->model.function_flags,
./sound/pci/oxygen/oxygen_lib.c:403:			     chip->model.misc_flags,
./sound/pci/oxygen/oxygen_lib.c:419:		       chip->model.dac_i2s_format |
./sound/pci/oxygen/oxygen_lib.c:420:		       OXYGEN_I2S_MCLK(chip->model.dac_mclks) |
./sound/pci/oxygen/oxygen_lib.c:424:	if (chip->model.device_config & CAPTURE_0_FROM_I2S_1)
./sound/pci/oxygen/oxygen_lib.c:427:			       chip->model.adc_i2s_format |
./sound/pci/oxygen/oxygen_lib.c:428:			       OXYGEN_I2S_MCLK(chip->model.adc_mclks) |
./sound/pci/oxygen/oxygen_lib.c:436:	if (chip->model.device_config & (CAPTURE_0_FROM_I2S_2 |
./sound/pci/oxygen/oxygen_lib.c:440:			       chip->model.adc_i2s_format |
./sound/pci/oxygen/oxygen_lib.c:441:			       OXYGEN_I2S_MCLK(chip->model.adc_mclks) |
./sound/pci/oxygen/oxygen_lib.c:449:	if (chip->model.device_config & CAPTURE_3_FROM_I2S_3)
./sound/pci/oxygen/oxygen_lib.c:452:			       chip->model.adc_i2s_format |
./sound/pci/oxygen/oxygen_lib.c:453:			       OXYGEN_I2S_MCLK(chip->model.adc_mclks) |
./sound/pci/oxygen/oxygen_lib.c:464:	if (chip->model.device_config & CAPTURE_1_FROM_SPDIF)
./sound/pci/oxygen/oxygen_lib.c:482:	oxygen_write32(chip, OXYGEN_SPDIF_OUTPUT_BITS, chip->spdif_bits);
./sound/pci/oxygen/oxygen_lib.c:508:	if (chip->has_ac97_0 | chip->has_ac97_1)
./sound/pci/oxygen/oxygen_lib.c:516:	if (!(chip->has_ac97_0 | chip->has_ac97_1))
./sound/pci/oxygen/oxygen_lib.c:519:	if (!chip->has_ac97_0) {
./sound/pci/oxygen/oxygen_lib.c:552:	if (chip->has_ac97_1) {
./sound/pci/oxygen/oxygen_lib.c:575:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:576:	chip->interrupt_mask = 0;
./sound/pci/oxygen/oxygen_lib.c:577:	chip->pcm_running = 0;
./sound/pci/oxygen/oxygen_lib.c:580:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:588:	if (chip->irq >= 0)
./sound/pci/oxygen/oxygen_lib.c:589:		free_irq(chip->irq, chip);
./sound/pci/oxygen/oxygen_lib.c:590:	flush_work(&chip->spdif_input_bits_work);
./sound/pci/oxygen/oxygen_lib.c:591:	flush_work(&chip->gpio_work);
./sound/pci/oxygen/oxygen_lib.c:592:	chip->model.cleanup(chip);
./sound/pci/oxygen/oxygen_lib.c:593:	kfree(chip->model_data);
./sound/pci/oxygen/oxygen_lib.c:594:	mutex_destroy(&chip->mutex);
./sound/pci/oxygen/oxygen_lib.c:595:	pci_release_regions(chip->pci);
./sound/pci/oxygen/oxygen_lib.c:596:	pci_disable_device(chip->pci);
./sound/pci/oxygen/oxygen_lib.c:618:	chip->card = card;
./sound/pci/oxygen/oxygen_lib.c:619:	chip->pci = pci;
./sound/pci/oxygen/oxygen_lib.c:620:	chip->irq = -1;
./sound/pci/oxygen/oxygen_lib.c:621:	spin_lock_init(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:622:	mutex_init(&chip->mutex);
./sound/pci/oxygen/oxygen_lib.c:623:	INIT_WORK(&chip->spdif_input_bits_work,
./sound/pci/oxygen/oxygen_lib.c:625:	INIT_WORK(&chip->gpio_work, oxygen_gpio_changed);
./sound/pci/oxygen/oxygen_lib.c:626:	init_waitqueue_head(&chip->ac97_waitqueue);
./sound/pci/oxygen/oxygen_lib.c:644:	chip->addr = pci_resource_start(pci, 0);
./sound/pci/oxygen/oxygen_lib.c:656:	if (chip->model.model_data_size) {
./sound/pci/oxygen/oxygen_lib.c:657:		chip->model_data = kzalloc(chip->model.model_data_size,
./sound/pci/oxygen/oxygen_lib.c:659:		if (!chip->model_data) {
./sound/pci/oxygen/oxygen_lib.c:670:	chip->model.init(chip);
./sound/pci/oxygen/oxygen_lib.c:678:	chip->irq = pci->irq;
./sound/pci/oxygen/oxygen_lib.c:680:	strcpy(card->driver, chip->model.chip);
./sound/pci/oxygen/oxygen_lib.c:681:	strcpy(card->shortname, chip->model.shortname);
./sound/pci/oxygen/oxygen_lib.c:683:		chip->model.longname, chip->addr, chip->irq);
./sound/pci/oxygen/oxygen_lib.c:684:	strcpy(card->mixername, chip->model.chip);
./sound/pci/oxygen/oxygen_lib.c:685:	snd_component_add(card, chip->model.chip);
./sound/pci/oxygen/oxygen_lib.c:695:	if (chip->model.device_config & (MIDI_OUTPUT | MIDI_INPUT)) {
./sound/pci/oxygen/oxygen_lib.c:698:		if (chip->model.device_config & MIDI_OUTPUT)
./sound/pci/oxygen/oxygen_lib.c:700:		if (chip->model.device_config & MIDI_INPUT)
./sound/pci/oxygen/oxygen_lib.c:703:					  chip->addr + OXYGEN_MPU401,
./sound/pci/oxygen/oxygen_lib.c:704:					  info_flags, -1, &chip->midi);
./sound/pci/oxygen/oxygen_lib.c:711:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:712:	if (chip->model.device_config & CAPTURE_1_FROM_SPDIF)
./sound/pci/oxygen/oxygen_lib.c:713:		chip->interrupt_mask |= OXYGEN_INT_SPDIF_IN_DETECT;
./sound/pci/oxygen/oxygen_lib.c:714:	if (chip->has_ac97_0 | chip->has_ac97_1)
./sound/pci/oxygen/oxygen_lib.c:715:		chip->interrupt_mask |= OXYGEN_INT_AC97;
./sound/pci/oxygen/oxygen_lib.c:716:	oxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);
./sound/pci/oxygen/oxygen_lib.c:717:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:752:		snd_pcm_suspend(chip->streams[i]);
./sound/pci/oxygen/oxygen_lib.c:754:	if (chip->model.suspend)
./sound/pci/oxygen/oxygen_lib.c:755:		chip->model.suspend(chip);
./sound/pci/oxygen/oxygen_lib.c:757:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:758:	saved_interrupt_mask = chip->interrupt_mask;
./sound/pci/oxygen/oxygen_lib.c:759:	chip->interrupt_mask = 0;
./sound/pci/oxygen/oxygen_lib.c:762:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_lib.c:764:	synchronize_irq(chip->irq);
./sound/pci/oxygen/oxygen_lib.c:765:	flush_work(&chip->spdif_input_bits_work);
./sound/pci/oxygen/oxygen_lib.c:766:	flush_work(&chip->gpio_work);
./sound/pci/oxygen/oxygen_lib.c:767:	chip->interrupt_mask = saved_interrupt_mask;
./sound/pci/oxygen/oxygen_lib.c:794:					  chip->saved_ac97_registers[codec][i]);
./sound/pci/oxygen/oxygen_lib.c:807:			oxygen_write8(chip, i, chip->saved_registers._8[i]);
./sound/pci/oxygen/oxygen_lib.c:808:	if (chip->has_ac97_0)
./sound/pci/oxygen/oxygen_lib.c:810:	if (chip->has_ac97_1)
./sound/pci/oxygen/oxygen_lib.c:813:	if (chip->model.resume)
./sound/pci/oxygen/oxygen_lib.c:814:		chip->model.resume(chip);
./sound/pci/oxygen/oxygen_lib.c:816:	oxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);
./sound/pci/oxygen/oxygen_lib.c:832:	chip->model.cleanup(chip);
./sound/pci/oxygen/xonar_dg_mixer.c:34:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:73:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:75:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:77:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:85:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:90:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:97:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:118:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:121:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:126:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:134:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:143:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:153:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:164:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:166:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:169:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:177:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:183:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:189:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:197:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:222:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:225:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:228:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:236:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:246:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:259:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:267:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:293:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:295:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:297:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:305:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:312:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:324:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:340:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:350:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg_mixer.c:354:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:363:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_dg_mixer.c:443:		err = snd_ctl_add(chip->card,
./sound/pci/oxygen/oxygen.c:161:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:175:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:183:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:197:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:208:			     chip->dac_volume[i * 2]);
./sound/pci/oxygen/oxygen.c:210:			     chip->dac_volume[i * 2 + 1]);
./sound/pci/oxygen/oxygen.c:216:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:218:	data->dacs = chip->model.dac_channels_pcm / 2;
./sound/pci/oxygen/oxygen.c:222:	snd_component_add(chip->card, "AK4396");
./sound/pci/oxygen/oxygen.c:229:	snd_component_add(chip->card, "AK5385");
./sound/pci/oxygen/oxygen.c:234:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:243:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:249:	snd_component_add(chip->card, "WM8785");
./sound/pci/oxygen/oxygen.c:296:	snd_component_add(chip->card, "CS5340");
./sound/pci/oxygen/oxygen.c:348:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:375:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:380:				    chip->dac_volume[i * 2]);
./sound/pci/oxygen/oxygen.c:382:				    chip->dac_volume[i * 2 + 1]);
./sound/pci/oxygen/oxygen.c:388:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:393:	if (chip->dac_mute)
./sound/pci/oxygen/oxygen.c:402:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:452:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:463:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:468:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen.c:479:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen.c:503:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:513:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:517:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen.c:524:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen.c:581:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen.c:591:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen.c:602:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen.c:610:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen.c:632:	return snd_ctl_add(chip->card, snd_ctl_new1(&rolloff_control, chip));
./sound/pci/oxygen/oxygen.c:642:	err = snd_ctl_add(chip->card, snd_ctl_new1(&hpf_control, chip));
./sound/pci/oxygen/oxygen.c:655:	err = snd_ctl_add(chip->card,
./sound/pci/oxygen/oxygen.c:669:	err = snd_ctl_add(chip->card,
./sound/pci/oxygen/oxygen.c:683:	err = snd_ctl_add(chip->card,
./sound/pci/oxygen/oxygen.c:693:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:707:	struct generic_data *data = chip->model_data;
./sound/pci/oxygen/oxygen.c:772:	chip->model = model_generic;
./sound/pci/oxygen/oxygen.c:776:		chip->model.init = meridian_init;
./sound/pci/oxygen/oxygen.c:777:		chip->model.mixer_init = meridian_mixer_init;
./sound/pci/oxygen/oxygen.c:778:		chip->model.resume = meridian_resume;
./sound/pci/oxygen/oxygen.c:779:		chip->model.set_adc_params = set_ak5385_params;
./sound/pci/oxygen/oxygen.c:780:		chip->model.dump_registers = dump_ak4396_registers;
./sound/pci/oxygen/oxygen.c:781:		chip->model.device_config = PLAYBACK_0_TO_I2S |
./sound/pci/oxygen/oxygen.c:786:			chip->model.device_config |= AC97_CD_INPUT;
./sound/pci/oxygen/oxygen.c:789:		chip->model.init = claro_init;
./sound/pci/oxygen/oxygen.c:790:		chip->model.mixer_init = claro_mixer_init;
./sound/pci/oxygen/oxygen.c:791:		chip->model.cleanup = claro_cleanup;
./sound/pci/oxygen/oxygen.c:792:		chip->model.suspend = claro_suspend;
./sound/pci/oxygen/oxygen.c:793:		chip->model.resume = claro_resume;
./sound/pci/oxygen/oxygen.c:796:		chip->model.init = claro_halo_init;
./sound/pci/oxygen/oxygen.c:797:		chip->model.mixer_init = claro_halo_mixer_init;
./sound/pci/oxygen/oxygen.c:798:		chip->model.cleanup = claro_cleanup;
./sound/pci/oxygen/oxygen.c:799:		chip->model.suspend = claro_suspend;
./sound/pci/oxygen/oxygen.c:800:		chip->model.resume = claro_resume;
./sound/pci/oxygen/oxygen.c:801:		chip->model.set_adc_params = set_ak5385_params;
./sound/pci/oxygen/oxygen.c:802:		chip->model.dump_registers = dump_ak4396_registers;
./sound/pci/oxygen/oxygen.c:803:		chip->model.device_config = PLAYBACK_0_TO_I2S |
./sound/pci/oxygen/oxygen.c:812:		chip->model.shortname = "C-Media CMI8787";
./sound/pci/oxygen/oxygen.c:813:		chip->model.chip = "CMI8787";
./sound/pci/oxygen/oxygen.c:815:			chip->model.init = fantasia_init;
./sound/pci/oxygen/oxygen.c:817:			chip->model.init = stereo_output_init;
./sound/pci/oxygen/oxygen.c:818:		chip->model.resume = stereo_resume;
./sound/pci/oxygen/oxygen.c:819:		chip->model.mixer_init = generic_mixer_init;
./sound/pci/oxygen/oxygen.c:820:		chip->model.set_adc_params = set_no_params;
./sound/pci/oxygen/oxygen.c:821:		chip->model.dump_registers = dump_ak4396_registers;
./sound/pci/oxygen/oxygen.c:822:		chip->model.device_config = PLAYBACK_0_TO_I2S |
./sound/pci/oxygen/oxygen.c:825:			chip->model.device_config |= CAPTURE_0_FROM_I2S_1;
./sound/pci/oxygen/oxygen.c:826:			chip->model.adc_mclks = OXYGEN_MCLKS(256, 128, 128);
./sound/pci/oxygen/oxygen.c:828:		chip->model.dac_channels_pcm = 2;
./sound/pci/oxygen/oxygen.c:829:		chip->model.dac_channels_mixer = 2;
./sound/pci/oxygen/oxygen.c:832:		chip->model = model_xonar_dg;
./sound/pci/oxygen/oxygen.c:833:		chip->model.shortname = "Xonar DG";
./sound/pci/oxygen/oxygen.c:836:		chip->model = model_xonar_dg;
./sound/pci/oxygen/oxygen.c:837:		chip->model.shortname = "Xonar DGX";
./sound/pci/oxygen/oxygen.c:843:		chip->model.misc_flags = OXYGEN_MISC_MIDI;
./sound/pci/oxygen/oxygen.c:844:		chip->model.device_config |= MIDI_OUTPUT | MIDI_INPUT;
./sound/pci/oxygen/oxygen.c:847:		chip->model.shortname = names[id->driver_data];
./sound/pci/oxygen/oxygen_io.c:30:	return inb(chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:36:	return inw(chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:42:	return inl(chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:48:	outb(value, chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:49:	chip->saved_registers._8[reg] = value;
./sound/pci/oxygen/oxygen_io.c:55:	outw(value, chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:56:	chip->saved_registers._16[reg / 2] = cpu_to_le16(value);
./sound/pci/oxygen/oxygen_io.c:62:	outl(value, chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:63:	chip->saved_registers._32[reg / 4] = cpu_to_le32(value);
./sound/pci/oxygen/oxygen_io.c:70:	u8 tmp = inb(chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:73:	outb(tmp, chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:74:	chip->saved_registers._8[reg] = tmp;
./sound/pci/oxygen/oxygen_io.c:81:	u16 tmp = inw(chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:84:	outw(tmp, chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:85:	chip->saved_registers._16[reg / 2] = cpu_to_le16(tmp);
./sound/pci/oxygen/oxygen_io.c:92:	u32 tmp = inl(chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:95:	outl(tmp, chip->addr + reg);
./sound/pci/oxygen/oxygen_io.c:96:	chip->saved_registers._32[reg / 4] = cpu_to_le32(tmp);
./sound/pci/oxygen/oxygen_io.c:108:	wait_event_timeout(chip->ac97_waitqueue,
./sound/pci/oxygen/oxygen_io.c:146:			chip->saved_ac97_registers[codec][index / 2] = data;
./sound/pci/oxygen/oxygen_io.c:150:	dev_err(chip->card->dev, "AC'97 write timeout\n");
./sound/pci/oxygen/oxygen_io.c:182:	dev_err(chip->card->dev, "AC'97 read timeout on codec %u\n", codec);
./sound/pci/oxygen/oxygen_io.c:211:	dev_err(chip->card->dev, "oxygen: SPI wait timeout\n");
./sound/pci/oxygen/oxygen_io.c:291:	dev_err(chip->card->dev, "EEPROM write timeout\n");
./sound/pci/oxygen/se6x.c:65:	snd_component_add(chip->card, "PCM1792A");
./sound/pci/oxygen/se6x.c:66:	snd_component_add(chip->card, "PCM1804");
./sound/pci/oxygen/se6x.c:125:	chip->model = model_se6x;
./sound/pci/oxygen/xonar_wm87x6.c:122:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:124:	if ((chip->model.function_flags & OXYGEN_FUNCTION_2WIRE_SPI_MASK) ==
./sound/pci/oxygen/xonar_wm87x6.c:139:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:149:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:168:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:177:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:183:	wm8776_write(chip, WM8776_DACMUTE, chip->dac_mute ? WM8776_DMUTE : 0);
./sound/pci/oxygen/xonar_wm87x6.c:196:	wm8776_write(chip, WM8776_DACLVOL, chip->dac_volume[0]);
./sound/pci/oxygen/xonar_wm87x6.c:197:	wm8776_write(chip, WM8776_DACRVOL, chip->dac_volume[1] | WM8776_UPDATE);
./sound/pci/oxygen/xonar_wm87x6.c:202:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:208:		     WM8766_ZCD | (chip->dac_mute ? WM8766_DMUTE_MASK : 0));
./sound/pci/oxygen/xonar_wm87x6.c:209:	wm8766_write(chip, WM8766_LDA1, chip->dac_volume[2]);
./sound/pci/oxygen/xonar_wm87x6.c:210:	wm8766_write(chip, WM8766_RDA1, chip->dac_volume[3]);
./sound/pci/oxygen/xonar_wm87x6.c:211:	wm8766_write(chip, WM8766_LDA2, chip->dac_volume[4]);
./sound/pci/oxygen/xonar_wm87x6.c:212:	wm8766_write(chip, WM8766_RDA2, chip->dac_volume[5]);
./sound/pci/oxygen/xonar_wm87x6.c:213:	wm8766_write(chip, WM8766_LDA3, chip->dac_volume[6]);
./sound/pci/oxygen/xonar_wm87x6.c:214:	wm8766_write(chip, WM8766_RDA3, chip->dac_volume[7] | WM8766_UPDATE);
./sound/pci/oxygen/xonar_wm87x6.c:219:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:236:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:245:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:249:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:265:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:270:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:284:	chip->interrupt_mask |= OXYGEN_INT_GPIO;
./sound/pci/oxygen/xonar_wm87x6.c:288:	snd_jack_new(chip->card, "Headphone",
./sound/pci/oxygen/xonar_wm87x6.c:292:	snd_component_add(chip->card, "WM8776");
./sound/pci/oxygen/xonar_wm87x6.c:293:	snd_component_add(chip->card, "WM8766");
./sound/pci/oxygen/xonar_wm87x6.c:298:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:313:	snd_component_add(chip->card, "WM8776");
./sound/pci/oxygen/xonar_wm87x6.c:350:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:397:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:404:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:407:	if (chip->dac_volume[0] == chip->dac_volume[1]) {
./sound/pci/oxygen/xonar_wm87x6.c:408:		if (chip->dac_volume[0] != data->wm8776_regs[WM8776_DACLVOL] ||
./sound/pci/oxygen/xonar_wm87x6.c:409:		    chip->dac_volume[1] != data->wm8776_regs[WM8776_DACRVOL]) {
./sound/pci/oxygen/xonar_wm87x6.c:411:				     chip->dac_volume[0] | WM8776_UPDATE);
./sound/pci/oxygen/xonar_wm87x6.c:412:			data->wm8776_regs[WM8776_DACLVOL] = chip->dac_volume[0];
./sound/pci/oxygen/xonar_wm87x6.c:413:			data->wm8776_regs[WM8776_DACRVOL] = chip->dac_volume[0];
./sound/pci/oxygen/xonar_wm87x6.c:416:		to_change = (chip->dac_volume[0] !=
./sound/pci/oxygen/xonar_wm87x6.c:418:		to_change |= (chip->dac_volume[1] !=
./sound/pci/oxygen/xonar_wm87x6.c:421:			wm8776_write(chip, WM8776_DACLVOL, chip->dac_volume[0] |
./sound/pci/oxygen/xonar_wm87x6.c:425:				     chip->dac_volume[1] | WM8776_UPDATE);
./sound/pci/oxygen/xonar_wm87x6.c:436:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:441:	if (chip->dac_volume[2] == chip->dac_volume[3] &&
./sound/pci/oxygen/xonar_wm87x6.c:442:	    chip->dac_volume[2] == chip->dac_volume[4] &&
./sound/pci/oxygen/xonar_wm87x6.c:443:	    chip->dac_volume[2] == chip->dac_volume[5] &&
./sound/pci/oxygen/xonar_wm87x6.c:444:	    chip->dac_volume[2] == chip->dac_volume[6] &&
./sound/pci/oxygen/xonar_wm87x6.c:445:	    chip->dac_volume[2] == chip->dac_volume[7]) {
./sound/pci/oxygen/xonar_wm87x6.c:448:			if (chip->dac_volume[2] !=
./sound/pci/oxygen/xonar_wm87x6.c:453:				     chip->dac_volume[2] | WM8766_UPDATE);
./sound/pci/oxygen/xonar_wm87x6.c:456:					chip->dac_volume[2];
./sound/pci/oxygen/xonar_wm87x6.c:461:			to_change |= (chip->dac_volume[2 + i] !=
./sound/pci/oxygen/xonar_wm87x6.c:466:					     chip->dac_volume[2 + i] |
./sound/pci/oxygen/xonar_wm87x6.c:475:			    chip->dac_mute ? WM8776_DMUTE : 0);
./sound/pci/oxygen/xonar_wm87x6.c:482:			    (chip->dac_mute ? WM8766_DMUTE_MASK : 0));
./sound/pci/oxygen/xonar_wm87x6.c:487:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:512:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:526:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:533:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:540:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:620:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:660:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:666:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:710:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:712:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:717:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:725:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:728:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:756:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:764:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:776:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:782:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:794:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/pci/oxygen/xonar_wm87x6.c:806:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:824:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:826:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:831:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:839:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:842:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:851:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:869:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:892:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);
./sound/pci/oxygen/xonar_wm87x6.c:900:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:907:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:938:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:954:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:964:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:968:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:975:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_wm87x6.c:1168:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:1178:		err = snd_ctl_add(chip->card, ctl);
./sound/pci/oxygen/xonar_wm87x6.c:1188:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:1197:		err = snd_ctl_add(chip->card, ctl);
./sound/pci/oxygen/xonar_wm87x6.c:1221:		err = snd_ctl_add(chip->card, ctl);
./sound/pci/oxygen/xonar_wm87x6.c:1232:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:1247:	struct xonar_wm87x6 *data = chip->model_data;
./sound/pci/oxygen/xonar_wm87x6.c:1328:		chip->model = model_xonar_ds;
./sound/pci/oxygen/xonar_wm87x6.c:1329:		chip->model.shortname = "Xonar DS";
./sound/pci/oxygen/xonar_wm87x6.c:1332:		chip->model = model_xonar_ds;
./sound/pci/oxygen/xonar_wm87x6.c:1333:		chip->model.shortname = "Xonar DSX";
./sound/pci/oxygen/xonar_wm87x6.c:1336:		chip->model = model_xonar_hdav_slim;
./sound/pci/oxygen/xonar_hdmi.c:120:	if (chip->uart_input_count >= 2 &&
./sound/pci/oxygen/xonar_hdmi.c:121:	    chip->uart_input[chip->uart_input_count - 2] == 'O' &&
./sound/pci/oxygen/xonar_hdmi.c:122:	    chip->uart_input[chip->uart_input_count - 1] == 'K') {
./sound/pci/oxygen/xonar_hdmi.c:123:		dev_dbg(chip->card->dev, "message from HDMI chip received:\n");
./sound/pci/oxygen/xonar_hdmi.c:125:				     chip->uart_input, chip->uart_input_count);
./sound/pci/oxygen/xonar_hdmi.c:126:		chip->uart_input_count = 0;
./sound/pci/oxygen/oxygen_mixer.c:34:	info->count = chip->model.dac_channels_mixer;
./sound/pci/oxygen/oxygen_mixer.c:35:	info->value.integer.min = chip->model.dac_volume_min;
./sound/pci/oxygen/oxygen_mixer.c:36:	info->value.integer.max = chip->model.dac_volume_max;
./sound/pci/oxygen/oxygen_mixer.c:46:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:47:	for (i = 0; i < chip->model.dac_channels_mixer; ++i)
./sound/pci/oxygen/oxygen_mixer.c:48:		value->value.integer.value[i] = chip->dac_volume[i];
./sound/pci/oxygen/oxygen_mixer.c:49:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:61:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:62:	for (i = 0; i < chip->model.dac_channels_mixer; ++i)
./sound/pci/oxygen/oxygen_mixer.c:63:		if (value->value.integer.value[i] != chip->dac_volume[i]) {
./sound/pci/oxygen/oxygen_mixer.c:64:			chip->dac_volume[i] = value->value.integer.value[i];
./sound/pci/oxygen/oxygen_mixer.c:68:		chip->model.update_dac_volume(chip);
./sound/pci/oxygen/oxygen_mixer.c:69:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:78:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:79:	value->value.integer.value[0] = !chip->dac_mute;
./sound/pci/oxygen/oxygen_mixer.c:80:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:90:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:91:	changed = (!value->value.integer.value[0]) != chip->dac_mute;
./sound/pci/oxygen/oxygen_mixer.c:93:		chip->dac_mute = !value->value.integer.value[0];
./sound/pci/oxygen/oxygen_mixer.c:94:		chip->model.update_dac_mute(chip);
./sound/pci/oxygen/oxygen_mixer.c:96:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:102:	if (chip->model.dac_channels_pcm < 8)
./sound/pci/oxygen/oxygen_mixer.c:104:	else if (chip->model.update_center_lfe_mix)
./sound/pci/oxygen/oxygen_mixer.c:129:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:130:	value->value.enumerated.item[0] = chip->dac_routing;
./sound/pci/oxygen/oxygen_mixer.c:131:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:171:		reg_value = reg_values[chip->dac_routing];
./sound/pci/oxygen/oxygen_mixer.c:183:	if (chip->model.adjust_dac_routing)
./sound/pci/oxygen/oxygen_mixer.c:184:		reg_value = chip->model.adjust_dac_routing(chip, reg_value);
./sound/pci/oxygen/oxygen_mixer.c:190:	if (chip->model.update_center_lfe_mix)
./sound/pci/oxygen/oxygen_mixer.c:191:		chip->model.update_center_lfe_mix(chip, chip->dac_routing > 2);
./sound/pci/oxygen/oxygen_mixer.c:203:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:204:	changed = value->value.enumerated.item[0] != chip->dac_routing;
./sound/pci/oxygen/oxygen_mixer.c:206:		chip->dac_routing = value->value.enumerated.item[0];
./sound/pci/oxygen/oxygen_mixer.c:209:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:218:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:219:	value->value.integer.value[0] = chip->spdif_playback_enable;
./sound/pci/oxygen/oxygen_mixer.c:220:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:254:	if (chip->pcm_active & (1 << PCM_SPDIF)) {
./sound/pci/oxygen/oxygen_mixer.c:261:	} else if ((chip->pcm_active & (1 << PCM_MULTICH)) &&
./sound/pci/oxygen/oxygen_mixer.c:262:		   chip->spdif_playback_enable) {
./sound/pci/oxygen/oxygen_mixer.c:283:			       ((chip->pcm_active & (1 << PCM_SPDIF)) ?
./sound/pci/oxygen/oxygen_mixer.c:284:				chip->spdif_pcm_bits : chip->spdif_bits));
./sound/pci/oxygen/oxygen_mixer.c:294:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:295:	changed = value->value.integer.value[0] != chip->spdif_playback_enable;
./sound/pci/oxygen/oxygen_mixer.c:297:		chip->spdif_playback_enable = !!value->value.integer.value[0];
./sound/pci/oxygen/oxygen_mixer.c:298:		spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_mixer.c:300:		spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_mixer.c:302:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:351:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:352:	oxygen_to_iec958(chip->spdif_bits, value);
./sound/pci/oxygen/oxygen_mixer.c:353:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:365:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:366:	changed = new_bits != chip->spdif_bits;
./sound/pci/oxygen/oxygen_mixer.c:368:		chip->spdif_bits = new_bits;
./sound/pci/oxygen/oxygen_mixer.c:369:		if (!(chip->pcm_active & (1 << PCM_SPDIF)))
./sound/pci/oxygen/oxygen_mixer.c:372:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:391:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:392:	oxygen_to_iec958(chip->spdif_pcm_bits, value);
./sound/pci/oxygen/oxygen_mixer.c:393:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:405:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:406:	changed = new_bits != chip->spdif_pcm_bits;
./sound/pci/oxygen/oxygen_mixer.c:408:		chip->spdif_pcm_bits = new_bits;
./sound/pci/oxygen/oxygen_mixer.c:409:		if (chip->pcm_active & (1 << PCM_SPDIF))
./sound/pci/oxygen/oxygen_mixer.c:412:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:459:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_mixer.c:468:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_mixer.c:503:	spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_mixer.c:512:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/oxygen_mixer.c:526:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:528:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:541:	if (!chip->controls[control])
./sound/pci/oxygen/oxygen_mixer.c:543:	priv_idx = chip->controls[control]->private_value & 0xff;
./sound/pci/oxygen/oxygen_mixer.c:547:		if (chip->model.ac97_switch)
./sound/pci/oxygen/oxygen_mixer.c:548:			chip->model.ac97_switch(chip, priv_idx, 0x8000);
./sound/pci/oxygen/oxygen_mixer.c:549:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/pci/oxygen/oxygen_mixer.c:550:			       &chip->controls[control]->id);
./sound/pci/oxygen/oxygen_mixer.c:565:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:575:		if (codec == 0 && chip->model.ac97_switch)
./sound/pci/oxygen/oxygen_mixer.c:576:			chip->model.ac97_switch(chip, index, newreg & 0x8000);
./sound/pci/oxygen/oxygen_mixer.c:594:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:619:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:621:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:641:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:654:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:671:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:674:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:685:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:694:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:714:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:716:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:729:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:737:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/oxygen_mixer.c:1037:	for (i = 0; i < ARRAY_SIZE(chip->controls); ++i)
./sound/pci/oxygen/oxygen_mixer.c:1038:		chip->controls[i] = NULL;
./sound/pci/oxygen/oxygen_mixer.c:1062:		if (chip->model.control_filter) {
./sound/pci/oxygen/oxygen_mixer.c:1063:			err = chip->model.control_filter(&template);
./sound/pci/oxygen/oxygen_mixer.c:1070:		    chip->model.dac_channels_pcm == 2)
./sound/pci/oxygen/oxygen_mixer.c:1073:		    !(chip->model.device_config & AC97_FMIC_SWITCH))
./sound/pci/oxygen/oxygen_mixer.c:1076:		    !(chip->model.device_config & AC97_CD_INPUT))
./sound/pci/oxygen/oxygen_mixer.c:1079:		    chip->model.dac_tlv) {
./sound/pci/oxygen/oxygen_mixer.c:1080:			template.tlv.p = chip->model.dac_tlv;
./sound/pci/oxygen/oxygen_mixer.c:1086:		err = snd_ctl_add(chip->card, ctl);
./sound/pci/oxygen/oxygen_mixer.c:1091:				chip->controls[j] = ctl;
./sound/pci/oxygen/oxygen_mixer.c:1106:	if (chip->model.device_config & PLAYBACK_1_TO_SPDIF) {
./sound/pci/oxygen/oxygen_mixer.c:1112:	if (chip->model.device_config & CAPTURE_1_FROM_SPDIF) {
./sound/pci/oxygen/oxygen_mixer.c:1119:		if (!(chip->model.device_config & monitor_controls[i].pcm_dev))
./sound/pci/oxygen/oxygen_mixer.c:1126:	if (chip->has_ac97_0) {
./sound/pci/oxygen/oxygen_mixer.c:1132:	if (chip->has_ac97_1) {
./sound/pci/oxygen/oxygen_mixer.c:1138:	return chip->model.mixer_init ? chip->model.mixer_init(chip) : 0;
./sound/pci/oxygen/xonar_cs43xx.c:79:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:88:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:96:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:105:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:113:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:140:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:181:	snd_component_add(chip->card, "CS4398");
./sound/pci/oxygen/xonar_cs43xx.c:182:	snd_component_add(chip->card, "CS4362A");
./sound/pci/oxygen/xonar_cs43xx.c:183:	snd_component_add(chip->card, "CS5361");
./sound/pci/oxygen/xonar_cs43xx.c:188:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:220:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:248:	mute = chip->dac_mute ? CS4362A_MUTE : 0;
./sound/pci/oxygen/xonar_cs43xx.c:251:				     (127 - chip->dac_volume[2 + i]) | mute);
./sound/pci/oxygen/xonar_cs43xx.c:256:	cs4398_write_cached(chip, 5, (127 - chip->dac_volume[0]) * 2);
./sound/pci/oxygen/xonar_cs43xx.c:257:	cs4398_write_cached(chip, 6, (127 - chip->dac_volume[1]) * 2);
./sound/pci/oxygen/xonar_cs43xx.c:266:	if (chip->dac_mute)
./sound/pci/oxygen/xonar_cs43xx.c:274:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:308:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:319:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:323:	mutex_lock(&chip->mutex);
./sound/pci/oxygen/xonar_cs43xx.c:338:	mutex_unlock(&chip->mutex);
./sound/pci/oxygen/xonar_cs43xx.c:354:		spin_lock_irq(&chip->reg_lock);
./sound/pci/oxygen/xonar_cs43xx.c:358:		spin_unlock_irq(&chip->reg_lock);
./sound/pci/oxygen/xonar_cs43xx.c:368:	err = snd_ctl_add(chip->card, snd_ctl_new1(&front_panel_switch, chip));
./sound/pci/oxygen/xonar_cs43xx.c:371:	err = snd_ctl_add(chip->card, snd_ctl_new1(&rolloff_control, chip));
./sound/pci/oxygen/xonar_cs43xx.c:391:	struct xonar_cs43xx *data = chip->model_data;
./sound/pci/oxygen/xonar_cs43xx.c:439:		chip->model = model_xonar_d1;
./sound/pci/oxygen/xonar_cs43xx.c:440:		chip->model.shortname = "Xonar D1";
./sound/pci/oxygen/xonar_cs43xx.c:444:		chip->model = model_xonar_d1;
./sound/pci/oxygen/xonar_cs43xx.c:445:		chip->model.shortname = "Xonar DX";
./sound/pci/oxygen/xonar_cs43xx.c:446:		chip->model.init = xonar_dx_init;
./sound/pci/oxygen/xonar_dg.c:69:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg.c:86:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg.c:112:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg.c:128:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg.c:155:	snd_component_add(chip->card, "CS4245");
./sound/pci/oxygen/xonar_dg.c:160:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg.c:194:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg.c:219:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg.c:255:	struct dg *data = chip->model_data;
./sound/pci/oxygen/xonar_dg.c:287:	struct dg *data = chip->model_data;
./sound/pci/cs46xx/dsp_spos.c:64:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:88:						dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:95:							dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:108:						dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:120:	dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:154:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:165:			dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:186:			dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:199:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:204:		dev_err(chip->card->dev, "dsp_spos: symbol table is full\n");
./sound/pci/cs46xx/dsp_spos.c:211:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:290:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:295:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:309:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:318:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:326:	dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:330:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:343:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:351:	dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:356:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:365:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:371:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:376:	dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:380:		dev_dbg(chip->card->dev, "dsp_spos: clearing parameter area\n");
./sound/pci/cs46xx/dsp_spos.c:390:		dev_dbg(chip->card->dev, "dsp_spos: clearing sample area\n");
./sound/pci/cs46xx/dsp_spos.c:400:		dev_dbg(chip->card->dev, "dsp_spos: clearing code area\n");
./sound/pci/cs46xx/dsp_spos.c:405:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:409:			dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:422:			dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:429:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:436:			dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:457:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:471:	dev_err(chip->card->dev, "dsp_spos: symbol <%s> type %02x not found\n",
./sound/pci/cs46xx/dsp_spos.c:484:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:506:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:534:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:537:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:550:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:557:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:559:	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
./sound/pci/cs46xx/dsp_spos.c:561:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:578:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:585:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:588:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:611:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:618:	/*struct dsp_spos_instance * ins = chip->dsp_spos_instance; */
./sound/pci/cs46xx/dsp_spos.c:620:	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
./sound/pci/cs46xx/dsp_spos.c:647:	void __iomem *dst = chip->region.idx[2].remap_addr;
./sound/pci/cs46xx/dsp_spos.c:793:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:885:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:892:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:899:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:920:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:925:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:937:	void __iomem *spdst = chip->region.idx[1].remap_addr + 
./sound/pci/cs46xx/dsp_spos.c:942:		dev_dbg(chip->card->dev, "addr %p, val %08x\n",
./sound/pci/cs46xx/dsp_spos.c:951:	void __iomem *spdst = chip->region.idx[1].remap_addr + 
./sound/pci/cs46xx/dsp_spos.c:956:		dev_dbg(chip->card->dev, "addr %p, val %08x\n",
./sound/pci/cs46xx/dsp_spos.c:979:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:984:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1012:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1016:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1057:		dev_err(chip->card->dev, "dsp_spos: failed to map SCB\n");
./sound/pci/cs46xx/dsp_spos.c:1078:		dev_err(chip->card->dev, "dsp_spos: failed to map TASK\n");
./sound/pci/cs46xx/dsp_spos.c:1086:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1131:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1138:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1145:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1152:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1159:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1405:	if (snd_BUG_ON(chip->nr_ac97_codecs != 1 && chip->nr_ac97_codecs != 2))
./sound/pci/cs46xx/dsp_spos.c:1408:	if (chip->nr_ac97_codecs == 1) {
./sound/pci/cs46xx/dsp_spos.c:1442:	if (chip->nr_ac97_codecs == 2) {
./sound/pci/cs46xx/dsp_spos.c:1507:	dev_err(chip->card->dev, "dsp_spos: failed to setup SCB's in DSP\n");
./sound/pci/cs46xx/dsp_spos.c:1514:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1522:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1528:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1535:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1691:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1712:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1735:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1738:	chip->active_ctrl(chip, 1);
./sound/pci/cs46xx/dsp_spos.c:1739:	chip->amplifier_ctrl(chip, 1);
./sound/pci/cs46xx/dsp_spos.c:1746:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1769:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs46xx/dsp_spos.c:1782:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs46xx/dsp_spos.c:1790:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1797:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1804:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1814:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1817:	chip->active_ctrl(chip, -1);
./sound/pci/cs46xx/dsp_spos.c:1818:	chip->amplifier_ctrl(chip, -1);
./sound/pci/cs46xx/dsp_spos.c:1825:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1832:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1835:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1842:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1847:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1850:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1857:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1864:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1867:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1874:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1879:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1882:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1917:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos.c:1927:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1930:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1949:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1956:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:1958:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1967:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos.c:1975:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos.c:2043:	if (chip->dsp_spos_instance->spdif_status_in) {
./sound/pci/cs46xx/dsp_spos_scb_lib.c:46:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:79:	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:81:	ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:83:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:111:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:117:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:168:	void __iomem *dst = chip->region.idx[2].remap_addr + sample_buffer_addr;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:179:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:196:	spin_lock_irqsave(&chip->reg_lock, flags);    
./sound/pci/cs46xx/dsp_spos_scb_lib.c:198:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:238:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:252:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:296:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:311:	dev_dbg(chip->card->dev, "dsp_spos: creating SCB <%s>\n", name);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:326:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:329:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:332:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:354:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:359:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:380:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:513:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:595:			dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:620:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:626:	dev_dbg(chip->card->dev, "dsp_spos: setting %s rate to %u\n",
./sound/pci/cs46xx/dsp_spos_scb_lib.c:685:				dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1001:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1161:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1249:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1281:			dev_dbg(chip->card->dev, "IEC958 pass through\n");
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1315:		dev_err(chip->card->dev, "dsp_spos: no free PCM channel\n");
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1321:			dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1348:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1361:			dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1374:	dev_dbg(chip->card->dev, "dsp_spos: creating PCM \"%s\" (%d)\n",
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1388:		dev_err(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1393:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1404:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1439:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1478:		dev_dbg(chip->card->dev,
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1491:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1499:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1505:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1527:		       chip->dsp_spos_instance->npcm_channels <= 0))
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1530:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1532:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1539:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1547:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1552:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1555:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1578:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1586:  	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1619:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1621:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1628:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1654:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1705:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1742:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/dsp_spos_scb_lib.c:1775:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx.c:102:	chip->accept_valid = mmap_valid[dev];
./sound/pci/cs46xx/cs46xx.c:122:	if (chip->nr_ac97_codecs ==2) {
./sound/pci/cs46xx/cs46xx.c:145:		chip->ba0_addr,
./sound/pci/cs46xx/cs46xx.c:146:		chip->ba1_addr,
./sound/pci/cs46xx/cs46xx.c:147:		chip->irq);
./sound/pci/cs46xx/cs46xx_lib.c:100:	chip->active_ctrl(chip, 1);
./sound/pci/cs46xx/cs46xx_lib.c:118:		dev_warn(chip->card->dev, "ACCTL_VFRM not set 0x%x\n", tmp);
./sound/pci/cs46xx/cs46xx_lib.c:170:	dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:190:	dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:202:	dev_dbg(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:211:	chip->active_ctrl(chip, -1);
./sound/pci/cs46xx/cs46xx_lib.c:243:	chip->active_ctrl(chip, 1);
./sound/pci/cs46xx/cs46xx_lib.c:292:	dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:296:	chip->active_ctrl(chip, -1);
./sound/pci/cs46xx/cs46xx_lib.c:329:	dst = chip->region.idx[bank+1].remap_addr + offset;
./sound/pci/cs46xx/cs46xx_lib.c:408:	err = request_firmware(&fw, fw_path, &chip->pci->dev);
./sound/pci/cs46xx/cs46xx_lib.c:492:	dst = chip->region.idx[bank+1].remap_addr + offset;
./sound/pci/cs46xx/cs46xx_lib.c:520:	err = request_firmware(&fw, "cs46xx/ba1", &chip->pci->dev);
./sound/pci/cs46xx/cs46xx_lib.c:523:	if (fw->size != sizeof(*chip->ba1)) {
./sound/pci/cs46xx/cs46xx_lib.c:528:	chip->ba1 = vmalloc(sizeof(*chip->ba1));
./sound/pci/cs46xx/cs46xx_lib.c:529:	if (!chip->ba1) {
./sound/pci/cs46xx/cs46xx_lib.c:534:	memcpy_le32(chip->ba1, fw->data, sizeof(*chip->ba1));
./sound/pci/cs46xx/cs46xx_lib.c:539:		size += chip->ba1->memory[i].size;
./sound/pci/cs46xx/cs46xx_lib.c:552:	struct ba1_struct *ba1 = chip->ba1;
./sound/pci/cs46xx/cs46xx_lib.c:616:		dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:654:			dev_dbg(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:704:		dev_err(chip->card->dev, "SPCR_RUNFR never reset\n");
./sound/pci/cs46xx/cs46xx_lib.c:761:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:765:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:835:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:842:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:865:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:871:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:900:	       chip->capt.hw_buf.area + rec->hw_data, bytes);
./sound/pci/cs46xx/cs46xx_lib.c:906:	snd_pcm_indirect_capture_transfer(substream, &chip->capt.pcm_rec, snd_cs46xx_cp_trans_copy);
./sound/pci/cs46xx/cs46xx_lib.c:948:	size_t ptr = snd_cs46xx_peek(chip, BA1_CBA) - chip->capt.hw_buf.addr;
./sound/pci/cs46xx/cs46xx_lib.c:949:	return ptr >> chip->capt.shift;
./sound/pci/cs46xx/cs46xx_lib.c:955:	size_t ptr = snd_cs46xx_peek(chip, BA1_CBA) - chip->capt.hw_buf.addr;
./sound/pci/cs46xx/cs46xx_lib.c:956:	return snd_pcm_indirect_capture_pointer(substream, &chip->capt.pcm_rec, ptr);
./sound/pci/cs46xx/cs46xx_lib.c:986:		spin_lock(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:992:		snd_cs46xx_poke(chip, BA1_PCTL, chip->play_ctl | tmp);
./sound/pci/cs46xx/cs46xx_lib.c:994:		spin_unlock(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:1007:		spin_lock(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:1013:		spin_unlock(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:1031:	spin_lock(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:1037:		snd_cs46xx_poke(chip, BA1_CCTL, chip->capt.ctl | tmp);
./sound/pci/cs46xx/cs46xx_lib.c:1049:	spin_unlock(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:1064:			dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:1078:			dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:1109:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1112:		mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1118:		mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1124:		 mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1128:	dev_dbg(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:1166:			mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1190:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1300:		if (runtime->dma_area != chip->capt.hw_buf.area)
./sound/pci/cs46xx/cs46xx_lib.c:1302:		runtime->dma_area = chip->capt.hw_buf.area;
./sound/pci/cs46xx/cs46xx_lib.c:1303:		runtime->dma_addr = chip->capt.hw_buf.addr;
./sound/pci/cs46xx/cs46xx_lib.c:1304:		runtime->dma_bytes = chip->capt.hw_buf.bytes;
./sound/pci/cs46xx/cs46xx_lib.c:1307:		if (runtime->dma_area == chip->capt.hw_buf.area) {
./sound/pci/cs46xx/cs46xx_lib.c:1325:	if (runtime->dma_area != chip->capt.hw_buf.area)
./sound/pci/cs46xx/cs46xx_lib.c:1339:	snd_cs46xx_poke(chip, BA1_CBA, chip->capt.hw_buf.addr);
./sound/pci/cs46xx/cs46xx_lib.c:1340:	chip->capt.shift = 2;
./sound/pci/cs46xx/cs46xx_lib.c:1341:	memset(&chip->capt.pcm_rec, 0, sizeof(chip->capt.pcm_rec));
./sound/pci/cs46xx/cs46xx_lib.c:1342:	chip->capt.pcm_rec.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
./sound/pci/cs46xx/cs46xx_lib.c:1343:	chip->capt.pcm_rec.hw_buffer_size = runtime->period_size * CS46XX_FRAGS << 2;
./sound/pci/cs46xx/cs46xx_lib.c:1354:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx_lib.c:1376:					if (chip->capt.substream)
./sound/pci/cs46xx/cs46xx_lib.c:1377:						snd_pcm_period_elapsed(chip->capt.substream);
./sound/pci/cs46xx/cs46xx_lib.c:1401:	if ((status1 & HISR_VC0) && chip->playback_pcm) {
./sound/pci/cs46xx/cs46xx_lib.c:1402:		if (chip->playback_pcm->substream)
./sound/pci/cs46xx/cs46xx_lib.c:1403:			snd_pcm_period_elapsed(chip->playback_pcm->substream);
./sound/pci/cs46xx/cs46xx_lib.c:1405:	if ((status1 & HISR_VC1) && chip->pcm) {
./sound/pci/cs46xx/cs46xx_lib.c:1406:		if (chip->capt.substream)
./sound/pci/cs46xx/cs46xx_lib.c:1407:			snd_pcm_period_elapsed(chip->capt.substream);
./sound/pci/cs46xx/cs46xx_lib.c:1411:	if ((status1 & HISR_MIDI) && chip->rmidi) {
./sound/pci/cs46xx/cs46xx_lib.c:1414:		spin_lock(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:1417:			if ((chip->midcr & MIDCR_RIE) == 0)
./sound/pci/cs46xx/cs46xx_lib.c:1419:			snd_rawmidi_receive(chip->midi_input, &c, 1);
./sound/pci/cs46xx/cs46xx_lib.c:1422:			if ((chip->midcr & MIDCR_TIE) == 0)
./sound/pci/cs46xx/cs46xx_lib.c:1424:			if (snd_rawmidi_transmit(chip->midi_output, &c, 1) != 1) {
./sound/pci/cs46xx/cs46xx_lib.c:1425:				chip->midcr &= ~MIDCR_TIE;
./sound/pci/cs46xx/cs46xx_lib.c:1426:				snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:1431:		spin_unlock(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:1509:	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/cs46xx/cs46xx_lib.c:1521:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1530:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1532:	chip->playback_pcm = cpcm; /* HACK */
./sound/pci/cs46xx/cs46xx_lib.c:1535:	if (chip->accept_valid)
./sound/pci/cs46xx/cs46xx_lib.c:1537:	chip->active_ctrl(chip, 1);
./sound/pci/cs46xx/cs46xx_lib.c:1565:	dev_dbg(chip->card->dev, "open raw iec958 channel\n");
./sound/pci/cs46xx/cs46xx_lib.c:1567:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1569:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1581:	dev_dbg(chip->card->dev, "close raw iec958 channel\n");
./sound/pci/cs46xx/cs46xx_lib.c:1585:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1587:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1597:	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/cs46xx/cs46xx_lib.c:1598:				PAGE_SIZE, &chip->capt.hw_buf) < 0)
./sound/pci/cs46xx/cs46xx_lib.c:1600:	chip->capt.substream = substream;
./sound/pci/cs46xx/cs46xx_lib.c:1603:	if (chip->accept_valid)
./sound/pci/cs46xx/cs46xx_lib.c:1606:	chip->active_ctrl(chip, 1);
./sound/pci/cs46xx/cs46xx_lib.c:1628:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1633:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:1635:	chip->playback_pcm = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:1640:	chip->active_ctrl(chip, -1);
./sound/pci/cs46xx/cs46xx_lib.c:1649:	chip->capt.substream = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:1650:	snd_dma_free_pages(&chip->capt.hw_buf);
./sound/pci/cs46xx/cs46xx_lib.c:1651:	chip->active_ctrl(chip, -1);
./sound/pci/cs46xx/cs46xx_lib.c:1785:	if ((err = snd_pcm_new(chip->card, "CS46xx", device, MAX_PLAYBACK_CHANNELS, 1, &pcm)) < 0)
./sound/pci/cs46xx/cs46xx_lib.c:1796:	chip->pcm = pcm;
./sound/pci/cs46xx/cs46xx_lib.c:1799:					      snd_dma_pci_data(chip->pci), 64*1024, 256*1024);
./sound/pci/cs46xx/cs46xx_lib.c:1811:	if ((err = snd_pcm_new(chip->card, "CS46xx - Rear", device, MAX_PLAYBACK_CHANNELS, 0, &pcm)) < 0)
./sound/pci/cs46xx/cs46xx_lib.c:1821:	chip->pcm_rear = pcm;
./sound/pci/cs46xx/cs46xx_lib.c:1824:					      snd_dma_pci_data(chip->pci), 64*1024, 256*1024);
./sound/pci/cs46xx/cs46xx_lib.c:1834:	if ((err = snd_pcm_new(chip->card, "CS46xx - Center LFE", device, MAX_PLAYBACK_CHANNELS, 0, &pcm)) < 0)
./sound/pci/cs46xx/cs46xx_lib.c:1844:	chip->pcm_center_lfe = pcm;
./sound/pci/cs46xx/cs46xx_lib.c:1847:					      snd_dma_pci_data(chip->pci), 64*1024, 256*1024);
./sound/pci/cs46xx/cs46xx_lib.c:1857:	if ((err = snd_pcm_new(chip->card, "CS46xx - IEC958", device, 1, 0, &pcm)) < 0)
./sound/pci/cs46xx/cs46xx_lib.c:1867:	chip->pcm_iec958 = pcm;
./sound/pci/cs46xx/cs46xx_lib.c:1870:					      snd_dma_pci_data(chip->pci), 64*1024, 256*1024);
./sound/pci/cs46xx/cs46xx_lib.c:1883:	chip->ac97_bus = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:1890:	if (snd_BUG_ON(ac97 != chip->ac97[CS46XX_PRIMARY_CODEC_INDEX] &&
./sound/pci/cs46xx/cs46xx_lib.c:1891:		       ac97 != chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]))
./sound/pci/cs46xx/cs46xx_lib.c:1894:	if (ac97 == chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]) {
./sound/pci/cs46xx/cs46xx_lib.c:1895:		chip->ac97[CS46XX_PRIMARY_CODEC_INDEX] = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:1896:		chip->eapd_switch = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:1899:		chip->ac97[CS46XX_SECONDARY_CODEC_INDEX] = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:1944:	ucontrol->value.integer.value[0] = chip->dsp_spos_instance->dac_volume_left;
./sound/pci/cs46xx/cs46xx_lib.c:1945:	ucontrol->value.integer.value[1] = chip->dsp_spos_instance->dac_volume_right;
./sound/pci/cs46xx/cs46xx_lib.c:1955:	if (chip->dsp_spos_instance->dac_volume_right != ucontrol->value.integer.value[0] ||
./sound/pci/cs46xx/cs46xx_lib.c:1956:	    chip->dsp_spos_instance->dac_volume_left != ucontrol->value.integer.value[1]) {
./sound/pci/cs46xx/cs46xx_lib.c:1971:	ucontrol->value.integer.value[0] = chip->dsp_spos_instance->spdif_input_volume_left;
./sound/pci/cs46xx/cs46xx_lib.c:1972:	ucontrol->value.integer.value[1] = chip->dsp_spos_instance->spdif_input_volume_right;
./sound/pci/cs46xx/cs46xx_lib.c:1981:	if (chip->dsp_spos_instance->spdif_input_volume_left  != ucontrol->value.integer.value[0] ||
./sound/pci/cs46xx/cs46xx_lib.c:1982:	    chip->dsp_spos_instance->spdif_input_volume_right!= ucontrol->value.integer.value[1]) {
./sound/pci/cs46xx/cs46xx_lib.c:2002:		ucontrol->value.integer.value[0] = (chip->dsp_spos_instance->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED);
./sound/pci/cs46xx/cs46xx_lib.c:2004:		ucontrol->value.integer.value[0] = chip->dsp_spos_instance->spdif_status_in;
./sound/pci/cs46xx/cs46xx_lib.c:2017:		mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2018:		change = (chip->dsp_spos_instance->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED);
./sound/pci/cs46xx/cs46xx_lib.c:2024:		res = (change != (chip->dsp_spos_instance->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED));
./sound/pci/cs46xx/cs46xx_lib.c:2025:		mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2028:		change = chip->dsp_spos_instance->spdif_status_in;
./sound/pci/cs46xx/cs46xx_lib.c:2036:		res = (change != chip->dsp_spos_instance->spdif_status_in);
./sound/pci/cs46xx/cs46xx_lib.c:2050:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx_lib.c:2064:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx_lib.c:2081:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx_lib.c:2096:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx_lib.c:2164:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx_lib.c:2166:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2171:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2180:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx_lib.c:2184:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2198:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2217:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx_lib.c:2219:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2224:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2233:	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
./sound/pci/cs46xx/cs46xx_lib.c:2237:	mutex_lock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2251:	mutex_unlock(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:2360:	val = snd_ac97_read(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX], AC97_CSR_ACMODE);
./sound/pci/cs46xx/cs46xx_lib.c:2369:	return snd_ac97_update_bits(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX],
./sound/pci/cs46xx/cs46xx_lib.c:2455:	if (chip->amplifier_ctrl == amp_voyetra)
./sound/pci/cs46xx/cs46xx_lib.c:2462:			dev_dbg(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:2471:			err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97[codec]);
./sound/pci/cs46xx/cs46xx_lib.c:2476:	dev_dbg(chip->card->dev, "codec %d detection timeout\n", codec);
./sound/pci/cs46xx/cs46xx_lib.c:2482:	struct snd_card *card = chip->card;
./sound/pci/cs46xx/cs46xx_lib.c:2495:	chip->nr_ac97_codecs = 0;
./sound/pci/cs46xx/cs46xx_lib.c:2496:	dev_dbg(chip->card->dev, "detecting primary codec\n");
./sound/pci/cs46xx/cs46xx_lib.c:2497:	if ((err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus)) < 0)
./sound/pci/cs46xx/cs46xx_lib.c:2499:	chip->ac97_bus->private_free = snd_cs46xx_mixer_free_ac97_bus;
./sound/pci/cs46xx/cs46xx_lib.c:2503:	chip->nr_ac97_codecs = 1;
./sound/pci/cs46xx/cs46xx_lib.c:2506:	dev_dbg(chip->card->dev, "detecting seconadry codec\n");
./sound/pci/cs46xx/cs46xx_lib.c:2509:		chip->nr_ac97_codecs = 2;
./sound/pci/cs46xx/cs46xx_lib.c:2526:	chip->eapd_switch = snd_ctl_find_id(chip->card, &id);
./sound/pci/cs46xx/cs46xx_lib.c:2529:	if (chip->nr_ac97_codecs == 1) {
./sound/pci/cs46xx/cs46xx_lib.c:2530:		unsigned int id2 = chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]->id & 0xffff;
./sound/pci/cs46xx/cs46xx_lib.c:2535:			snd_ac97_write_cache(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX],
./sound/pci/cs46xx/cs46xx_lib.c:2540:	if (chip->mixer_init) {
./sound/pci/cs46xx/cs46xx_lib.c:2541:		dev_dbg(chip->card->dev, "calling chip->mixer_init(chip);\n");
./sound/pci/cs46xx/cs46xx_lib.c:2542:		chip->mixer_init(chip);
./sound/pci/cs46xx/cs46xx_lib.c:2547:	chip->amplifier_ctrl(chip, 1);
./sound/pci/cs46xx/cs46xx_lib.c:2560:	snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:2567:	chip->active_ctrl(chip, 1);
./sound/pci/cs46xx/cs46xx_lib.c:2568:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:2569:	chip->uartm |= CS46XX_MODE_INPUT;
./sound/pci/cs46xx/cs46xx_lib.c:2570:	chip->midcr |= MIDCR_RXE;
./sound/pci/cs46xx/cs46xx_lib.c:2571:	chip->midi_input = substream;
./sound/pci/cs46xx/cs46xx_lib.c:2572:	if (!(chip->uartm & CS46XX_MODE_OUTPUT)) {
./sound/pci/cs46xx/cs46xx_lib.c:2575:		snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:2577:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:2585:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:2586:	chip->midcr &= ~(MIDCR_RXE | MIDCR_RIE);
./sound/pci/cs46xx/cs46xx_lib.c:2587:	chip->midi_input = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:2588:	if (!(chip->uartm & CS46XX_MODE_OUTPUT)) {
./sound/pci/cs46xx/cs46xx_lib.c:2591:		snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:2593:	chip->uartm &= ~CS46XX_MODE_INPUT;
./sound/pci/cs46xx/cs46xx_lib.c:2594:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:2595:	chip->active_ctrl(chip, -1);
./sound/pci/cs46xx/cs46xx_lib.c:2603:	chip->active_ctrl(chip, 1);
./sound/pci/cs46xx/cs46xx_lib.c:2605:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:2606:	chip->uartm |= CS46XX_MODE_OUTPUT;
./sound/pci/cs46xx/cs46xx_lib.c:2607:	chip->midcr |= MIDCR_TXE;
./sound/pci/cs46xx/cs46xx_lib.c:2608:	chip->midi_output = substream;
./sound/pci/cs46xx/cs46xx_lib.c:2609:	if (!(chip->uartm & CS46XX_MODE_INPUT)) {
./sound/pci/cs46xx/cs46xx_lib.c:2612:		snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:2614:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:2622:	spin_lock_irq(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:2623:	chip->midcr &= ~(MIDCR_TXE | MIDCR_TIE);
./sound/pci/cs46xx/cs46xx_lib.c:2624:	chip->midi_output = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:2625:	if (!(chip->uartm & CS46XX_MODE_INPUT)) {
./sound/pci/cs46xx/cs46xx_lib.c:2628:		snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:2630:	chip->uartm &= ~CS46XX_MODE_OUTPUT;
./sound/pci/cs46xx/cs46xx_lib.c:2631:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:2632:	chip->active_ctrl(chip, -1);
./sound/pci/cs46xx/cs46xx_lib.c:2641:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:2643:		if ((chip->midcr & MIDCR_RIE) == 0) {
./sound/pci/cs46xx/cs46xx_lib.c:2644:			chip->midcr |= MIDCR_RIE;
./sound/pci/cs46xx/cs46xx_lib.c:2645:			snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:2648:		if (chip->midcr & MIDCR_RIE) {
./sound/pci/cs46xx/cs46xx_lib.c:2649:			chip->midcr &= ~MIDCR_RIE;
./sound/pci/cs46xx/cs46xx_lib.c:2650:			snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:2653:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:2662:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:2664:		if ((chip->midcr & MIDCR_TIE) == 0) {
./sound/pci/cs46xx/cs46xx_lib.c:2665:			chip->midcr |= MIDCR_TIE;
./sound/pci/cs46xx/cs46xx_lib.c:2667:			while ((chip->midcr & MIDCR_TIE) &&
./sound/pci/cs46xx/cs46xx_lib.c:2670:					chip->midcr &= ~MIDCR_TIE;
./sound/pci/cs46xx/cs46xx_lib.c:2675:			snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:2678:		if (chip->midcr & MIDCR_TIE) {
./sound/pci/cs46xx/cs46xx_lib.c:2679:			chip->midcr &= ~MIDCR_TIE;
./sound/pci/cs46xx/cs46xx_lib.c:2680:			snd_cs46xx_pokeBA0(chip, BA0_MIDCR, chip->midcr);
./sound/pci/cs46xx/cs46xx_lib.c:2683:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/cs46xx/cs46xx_lib.c:2705:	if ((err = snd_rawmidi_new(chip->card, "CS46XX", device, 1, 1, &rmidi)) < 0)
./sound/pci/cs46xx/cs46xx_lib.c:2712:	chip->rmidi = rmidi;
./sound/pci/cs46xx/cs46xx_lib.c:2782:	chip->gameport = gp = gameport_allocate_port();
./sound/pci/cs46xx/cs46xx_lib.c:2784:		dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:2790:	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
./sound/pci/cs46xx/cs46xx_lib.c:2791:	gameport_set_dev_parent(gp, &chip->pci->dev);
./sound/pci/cs46xx/cs46xx_lib.c:2809:	if (chip->gameport) {
./sound/pci/cs46xx/cs46xx_lib.c:2810:		gameport_unregister_port(chip->gameport);
./sound/pci/cs46xx/cs46xx_lib.c:2811:		chip->gameport = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:2846:		struct snd_cs46xx_region *region = &chip->region.idx[idx];
./sound/pci/cs46xx/cs46xx_lib.c:2930:	if (chip->active_ctrl)
./sound/pci/cs46xx/cs46xx_lib.c:2931:		chip->active_ctrl(chip, 1);
./sound/pci/cs46xx/cs46xx_lib.c:2935:	if (chip->amplifier_ctrl)
./sound/pci/cs46xx/cs46xx_lib.c:2936:		chip->amplifier_ctrl(chip, -chip->amplifier); /* force to off */
./sound/pci/cs46xx/cs46xx_lib.c:2940:	if (chip->region.idx[0].resource)
./sound/pci/cs46xx/cs46xx_lib.c:2943:	if (chip->irq >= 0)
./sound/pci/cs46xx/cs46xx_lib.c:2944:		free_irq(chip->irq, chip);
./sound/pci/cs46xx/cs46xx_lib.c:2946:	if (chip->active_ctrl)
./sound/pci/cs46xx/cs46xx_lib.c:2947:		chip->active_ctrl(chip, -chip->amplifier);
./sound/pci/cs46xx/cs46xx_lib.c:2950:		struct snd_cs46xx_region *region = &chip->region.idx[idx];
./sound/pci/cs46xx/cs46xx_lib.c:2957:	if (chip->dsp_spos_instance) {
./sound/pci/cs46xx/cs46xx_lib.c:2959:		chip->dsp_spos_instance = NULL;
./sound/pci/cs46xx/cs46xx_lib.c:2962:		free_module_desc(chip->modules[idx]);
./sound/pci/cs46xx/cs46xx_lib.c:2964:	vfree(chip->ba1);
./sound/pci/cs46xx/cs46xx_lib.c:2968:	kfree(chip->saved_regs);
./sound/pci/cs46xx/cs46xx_lib.c:2971:	pci_disable_device(chip->pci);
./sound/pci/cs46xx/cs46xx_lib.c:3122:	dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3124:	dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3143:			dev_dbg(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3174:	dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3182:	dev_err(chip->card->dev, "never read ISV3 & ISV4 from AC'97\n");
./sound/pci/cs46xx/cs46xx_lib.c:3183:	dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3185:	dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3187:	dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3255:		err = load_firmware(chip, &chip->modules[i], module_names[i]);
./sound/pci/cs46xx/cs46xx_lib.c:3257:			dev_err(chip->card->dev, "firmware load error [%s]\n",
./sound/pci/cs46xx/cs46xx_lib.c:3261:		err = cs46xx_dsp_load_module(chip, chip->modules[i]);
./sound/pci/cs46xx/cs46xx_lib.c:3263:			dev_err(chip->card->dev, "image download error [%s]\n",
./sound/pci/cs46xx/cs46xx_lib.c:3279:		dev_err(chip->card->dev, "image download error\n");
./sound/pci/cs46xx/cs46xx_lib.c:3287:	chip->play_ctl = tmp & 0xffff0000;
./sound/pci/cs46xx/cs46xx_lib.c:3295:	chip->capt.ctl = tmp & 0x0000ffff;
./sound/pci/cs46xx/cs46xx_lib.c:3332:	dev_dbg(chip->card->dev, "cs46xx_setup_eapd_slot()+\n");
./sound/pci/cs46xx/cs46xx_lib.c:3349:	if(chip->nr_ac97_codecs != 2) {
./sound/pci/cs46xx/cs46xx_lib.c:3350:		dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3392:		dev_dbg(chip->card->dev, "FIFO is busy\n");
./sound/pci/cs46xx/cs46xx_lib.c:3413:			dev_dbg(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3455:	int old = chip->amplifier;
./sound/pci/cs46xx/cs46xx_lib.c:3459:	chip->amplifier += change;
./sound/pci/cs46xx/cs46xx_lib.c:3463:	if (chip->amplifier) {
./sound/pci/cs46xx/cs46xx_lib.c:3473:		if (chip->eapd_switch)
./sound/pci/cs46xx/cs46xx_lib.c:3474:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/pci/cs46xx/cs46xx_lib.c:3475:				       &chip->eapd_switch->id);
./sound/pci/cs46xx/cs46xx_lib.c:3479:	if (chip->amplifier && !old) {
./sound/pci/cs46xx/cs46xx_lib.c:3498:	int old = chip->amplifier;
./sound/pci/cs46xx/cs46xx_lib.c:3502:	chip->amplifier += change;
./sound/pci/cs46xx/cs46xx_lib.c:3503:	if (chip->amplifier && !old) {
./sound/pci/cs46xx/cs46xx_lib.c:3504:		dev_dbg(chip->card->dev, "Hercules amplifier ON\n");
./sound/pci/cs46xx/cs46xx_lib.c:3510:	} else if (old && !chip->amplifier) {
./sound/pci/cs46xx/cs46xx_lib.c:3511:		dev_dbg(chip->card->dev, "Hercules amplifier OFF\n");
./sound/pci/cs46xx/cs46xx_lib.c:3519:	dev_dbg(chip->card->dev, "initializing Voyetra mixer\n");
./sound/pci/cs46xx/cs46xx_lib.c:3531:	struct snd_card *card = chip->card;
./sound/pci/cs46xx/cs46xx_lib.c:3537:	dev_dbg(chip->card->dev, "initializing Hercules mixer\n");
./sound/pci/cs46xx/cs46xx_lib.c:3540:	if (chip->in_suspend)
./sound/pci/cs46xx/cs46xx_lib.c:3565:	chip->amplifier += change;
./sound/pci/cs46xx/cs46xx_lib.c:3567:	if (chip->amplifier) {
./sound/pci/cs46xx/cs46xx_lib.c:3597:	if (!chip->acpi_port)
./sound/pci/cs46xx/cs46xx_lib.c:3600:	chip->amplifier += change;
./sound/pci/cs46xx/cs46xx_lib.c:3603:	nval = control = inw(chip->acpi_port + 0x10);
./sound/pci/cs46xx/cs46xx_lib.c:3606:	if (! chip->amplifier)
./sound/pci/cs46xx/cs46xx_lib.c:3611:		outw(nval, chip->acpi_port + 0x10);
./sound/pci/cs46xx/cs46xx_lib.c:3623:	chip->acpi_port = 0;
./sound/pci/cs46xx/cs46xx_lib.c:3632:	chip->acpi_port = pp << 8;
./sound/pci/cs46xx/cs46xx_lib.c:3781:	chip->in_suspend = 1;
./sound/pci/cs46xx/cs46xx_lib.c:3782:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/cs46xx/cs46xx_lib.c:3784:	snd_pcm_suspend_all(chip->pcm_rear);
./sound/pci/cs46xx/cs46xx_lib.c:3785:	snd_pcm_suspend_all(chip->pcm_center_lfe);
./sound/pci/cs46xx/cs46xx_lib.c:3786:	snd_pcm_suspend_all(chip->pcm_iec958);
./sound/pci/cs46xx/cs46xx_lib.c:3788:	// chip->ac97_powerdown = snd_cs46xx_codec_read(chip, AC97_POWER_CONTROL);
./sound/pci/cs46xx/cs46xx_lib.c:3789:	// chip->ac97_general_purpose = snd_cs46xx_codec_read(chip, BA0_AC97_GENERAL_PURPOSE);
./sound/pci/cs46xx/cs46xx_lib.c:3791:	snd_ac97_suspend(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]);
./sound/pci/cs46xx/cs46xx_lib.c:3792:	snd_ac97_suspend(chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]);
./sound/pci/cs46xx/cs46xx_lib.c:3796:		chip->saved_regs[i] = snd_cs46xx_peekBA0(chip, saved_regs[i]);
./sound/pci/cs46xx/cs46xx_lib.c:3798:	amp_saved = chip->amplifier;
./sound/pci/cs46xx/cs46xx_lib.c:3800:	chip->amplifier_ctrl(chip, -chip->amplifier);
./sound/pci/cs46xx/cs46xx_lib.c:3803:	chip->active_ctrl(chip, -chip->amplifier);
./sound/pci/cs46xx/cs46xx_lib.c:3804:	chip->amplifier = amp_saved; /* restore the status */
./sound/pci/cs46xx/cs46xx_lib.c:3818:	amp_saved = chip->amplifier;
./sound/pci/cs46xx/cs46xx_lib.c:3819:	chip->amplifier = 0;
./sound/pci/cs46xx/cs46xx_lib.c:3820:	chip->active_ctrl(chip, 1); /* force to on */
./sound/pci/cs46xx/cs46xx_lib.c:3829:		snd_cs46xx_pokeBA0(chip, saved_regs[i], chip->saved_regs[i]);
./sound/pci/cs46xx/cs46xx_lib.c:3836:			       chip->ac97_general_purpose);
./sound/pci/cs46xx/cs46xx_lib.c:3838:			       chip->ac97_powerdown);
./sound/pci/cs46xx/cs46xx_lib.c:3841:			       chip->ac97_powerdown);
./sound/pci/cs46xx/cs46xx_lib.c:3845:	snd_ac97_resume(chip->ac97[CS46XX_PRIMARY_CODEC_INDEX]);
./sound/pci/cs46xx/cs46xx_lib.c:3846:	snd_ac97_resume(chip->ac97[CS46XX_SECONDARY_CODEC_INDEX]);
./sound/pci/cs46xx/cs46xx_lib.c:3852:	chip->capt.ctl = tmp & 0x0000ffff;
./sound/pci/cs46xx/cs46xx_lib.c:3865:		chip->amplifier_ctrl(chip, 1); /* turn amp on */
./sound/pci/cs46xx/cs46xx_lib.c:3867:		chip->active_ctrl(chip, -1); /* disable CLKRUN */
./sound/pci/cs46xx/cs46xx_lib.c:3868:	chip->amplifier = amp_saved;
./sound/pci/cs46xx/cs46xx_lib.c:3869:	chip->in_suspend = 0;
./sound/pci/cs46xx/cs46xx_lib.c:3906:	spin_lock_init(&chip->reg_lock);
./sound/pci/cs46xx/cs46xx_lib.c:3908:	mutex_init(&chip->spos_mutex);
./sound/pci/cs46xx/cs46xx_lib.c:3910:	chip->card = card;
./sound/pci/cs46xx/cs46xx_lib.c:3911:	chip->pci = pci;
./sound/pci/cs46xx/cs46xx_lib.c:3912:	chip->irq = -1;
./sound/pci/cs46xx/cs46xx_lib.c:3913:	chip->ba0_addr = pci_resource_start(pci, 0);
./sound/pci/cs46xx/cs46xx_lib.c:3914:	chip->ba1_addr = pci_resource_start(pci, 1);
./sound/pci/cs46xx/cs46xx_lib.c:3915:	if (chip->ba0_addr == 0 || chip->ba0_addr == (unsigned long)~0 ||
./sound/pci/cs46xx/cs46xx_lib.c:3916:	    chip->ba1_addr == 0 || chip->ba1_addr == (unsigned long)~0) {
./sound/pci/cs46xx/cs46xx_lib.c:3917:		dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3919:			   chip->ba0_addr, chip->ba1_addr);
./sound/pci/cs46xx/cs46xx_lib.c:3924:	region = &chip->region.name.ba0;
./sound/pci/cs46xx/cs46xx_lib.c:3926:	region->base = chip->ba0_addr;
./sound/pci/cs46xx/cs46xx_lib.c:3929:	region = &chip->region.name.data0;
./sound/pci/cs46xx/cs46xx_lib.c:3931:	region->base = chip->ba1_addr + BA1_SP_DMEM0;
./sound/pci/cs46xx/cs46xx_lib.c:3934:	region = &chip->region.name.data1;
./sound/pci/cs46xx/cs46xx_lib.c:3936:	region->base = chip->ba1_addr + BA1_SP_DMEM1;
./sound/pci/cs46xx/cs46xx_lib.c:3939:	region = &chip->region.name.pmem;
./sound/pci/cs46xx/cs46xx_lib.c:3941:	region->base = chip->ba1_addr + BA1_SP_PMEM;
./sound/pci/cs46xx/cs46xx_lib.c:3944:	region = &chip->region.name.reg;
./sound/pci/cs46xx/cs46xx_lib.c:3946:	region->base = chip->ba1_addr + BA1_SP_REG;
./sound/pci/cs46xx/cs46xx_lib.c:3955:			dev_dbg(chip->card->dev, "hack for %s enabled\n",
./sound/pci/cs46xx/cs46xx_lib.c:3958:			chip->amplifier_ctrl = cp->amp;
./sound/pci/cs46xx/cs46xx_lib.c:3959:			chip->active_ctrl = cp->active;
./sound/pci/cs46xx/cs46xx_lib.c:3960:			chip->mixer_init = cp->mixer_init;
./sound/pci/cs46xx/cs46xx_lib.c:3969:		dev_info(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3971:		chip->amplifier_ctrl = amp_voyetra;
./sound/pci/cs46xx/cs46xx_lib.c:3975:		dev_info(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:3977:		chip->active_ctrl = clkrun_hack;
./sound/pci/cs46xx/cs46xx_lib.c:3981:	if (chip->amplifier_ctrl == NULL)
./sound/pci/cs46xx/cs46xx_lib.c:3982:		chip->amplifier_ctrl = amp_none;
./sound/pci/cs46xx/cs46xx_lib.c:3983:	if (chip->active_ctrl == NULL)
./sound/pci/cs46xx/cs46xx_lib.c:3984:		chip->active_ctrl = amp_none;
./sound/pci/cs46xx/cs46xx_lib.c:3986:	chip->active_ctrl(chip, 1); /* enable CLKRUN */
./sound/pci/cs46xx/cs46xx_lib.c:3991:		region = &chip->region.idx[idx];
./sound/pci/cs46xx/cs46xx_lib.c:3994:			dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:4002:			dev_err(chip->card->dev,
./sound/pci/cs46xx/cs46xx_lib.c:4011:		dev_err(chip->card->dev, "unable to grab IRQ %d\n", pci->irq);
./sound/pci/cs46xx/cs46xx_lib.c:4015:	chip->irq = pci->irq;
./sound/pci/cs46xx/cs46xx_lib.c:4018:	chip->dsp_spos_instance = cs46xx_dsp_spos_create(chip);
./sound/pci/cs46xx/cs46xx_lib.c:4019:	if (chip->dsp_spos_instance == NULL) {
./sound/pci/cs46xx/cs46xx_lib.c:4039:	chip->saved_regs = kmalloc(sizeof(*chip->saved_regs) *
./sound/pci/cs46xx/cs46xx_lib.c:4041:	if (!chip->saved_regs) {
./sound/pci/cs46xx/cs46xx_lib.c:4047:	chip->active_ctrl(chip, -1); /* disable CLKRUN */
./sound/pci/als300.c:167:	u32 tmp = snd_als300_gcr_read(chip->port, MISC_CONTROL);
./sound/pci/als300.c:172:	if (((chip->revision > 5 || chip->chip_type == DEVICE_ALS300_PLUS) ^
./sound/pci/als300.c:177:	snd_als300_gcr_write(chip->port, MISC_CONTROL, tmp);
./sound/pci/als300.c:183:	if (chip->irq >= 0)
./sound/pci/als300.c:184:		free_irq(chip->irq, chip);
./sound/pci/als300.c:185:	pci_release_regions(chip->pci);
./sound/pci/als300.c:186:	pci_disable_device(chip->pci);
./sound/pci/als300.c:203:	status = inb(chip->port+ALS300_IRQ_STATUS);
./sound/pci/als300.c:208:	outb(status, chip->port+ALS300_IRQ_STATUS);
./sound/pci/als300.c:210:		if (chip->pcm && chip->playback_substream) {
./sound/pci/als300.c:211:			data = chip->playback_substream->runtime->private_data;
./sound/pci/als300.c:213:			snd_pcm_period_elapsed(chip->playback_substream);
./sound/pci/als300.c:218:		if (chip->pcm && chip->capture_substream) {
./sound/pci/als300.c:219:			data = chip->capture_substream->runtime->private_data;
./sound/pci/als300.c:221:			snd_pcm_period_elapsed(chip->capture_substream);
./sound/pci/als300.c:234:	general = inb(chip->port+ALS300P_IRQ_STATUS);
./sound/pci/als300.c:235:	mpu = inb(chip->port+MPU_IRQ_STATUS);
./sound/pci/als300.c:236:	dram = inb(chip->port+ALS300P_DRAM_IRQ_STATUS);
./sound/pci/als300.c:243:		if (chip->pcm && chip->playback_substream) {
./sound/pci/als300.c:244:			outb(IRQ_PLAYBACK, chip->port+ALS300P_IRQ_STATUS);
./sound/pci/als300.c:245:			data = chip->playback_substream->runtime->private_data;
./sound/pci/als300.c:247:			snd_pcm_period_elapsed(chip->playback_substream);
./sound/pci/als300.c:252:		if (chip->pcm && chip->capture_substream) {
./sound/pci/als300.c:253:			outb(IRQ_CAPTURE, chip->port+ALS300P_IRQ_STATUS);
./sound/pci/als300.c:254:			data = chip->capture_substream->runtime->private_data;
./sound/pci/als300.c:256:			snd_pcm_period_elapsed(chip->capture_substream);
./sound/pci/als300.c:277:		if ((inb(chip->port+AC97_STATUS) & (AC97_BUSY)) == 0)
./sound/pci/als300.c:281:	outl((reg << 24) | (1 << 31), chip->port+AC97_ACCESS);
./sound/pci/als300.c:284:		if ((inb(chip->port+AC97_STATUS) & (AC97_DATA_AVAIL)) != 0)
./sound/pci/als300.c:288:	return inw(chip->port+AC97_READ);
./sound/pci/als300.c:298:		if ((inb(chip->port+AC97_STATUS) & (AC97_BUSY)) == 0)
./sound/pci/als300.c:302:	outl((reg << 24) | val, chip->port+AC97_ACCESS);
./sound/pci/als300.c:315:	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &bus)) < 0)
./sound/pci/als300.c:321:	return snd_ac97_mixer(bus, &ac97, &chip->ac97);
./sound/pci/als300.c:378:	chip->playback_substream = substream;
./sound/pci/als300.c:393:	chip->playback_substream = NULL;
./sound/pci/als300.c:407:	chip->capture_substream = substream;
./sound/pci/als300.c:422:	chip->capture_substream = NULL;
./sound/pci/als300.c:447:	spin_lock_irq(&chip->reg_lock);
./sound/pci/als300.c:448:	tmp = snd_als300_gcr_read(chip->port, PLAYBACK_CONTROL);
./sound/pci/als300.c:457:	snd_als300_gcr_write(chip->port, PLAYBACK_CONTROL, tmp);
./sound/pci/als300.c:460:	snd_als300_gcr_write(chip->port, PLAYBACK_START,
./sound/pci/als300.c:462:	snd_als300_gcr_write(chip->port, PLAYBACK_END,
./sound/pci/als300.c:464:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/als300.c:476:	spin_lock_irq(&chip->reg_lock);
./sound/pci/als300.c:477:	tmp = snd_als300_gcr_read(chip->port, RECORD_CONTROL);
./sound/pci/als300.c:488:	snd_als300_gcr_write(chip->port, RECORD_CONTROL, tmp);
./sound/pci/als300.c:489:	snd_als300_gcr_write(chip->port, RECORD_START,
./sound/pci/als300.c:491:	snd_als300_gcr_write(chip->port, RECORD_END,
./sound/pci/als300.c:493:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/als300.c:508:	spin_lock(&chip->reg_lock);
./sound/pci/als300.c:512:		tmp = snd_als300_gcr_read(chip->port, reg);
./sound/pci/als300.c:514:		snd_als300_gcr_write(chip->port, reg, tmp | TRANSFER_START);
./sound/pci/als300.c:519:		tmp = snd_als300_gcr_read(chip->port, reg);
./sound/pci/als300.c:520:		snd_als300_gcr_write(chip->port, reg, tmp & ~TRANSFER_START);
./sound/pci/als300.c:524:		tmp = snd_als300_gcr_read(chip->port, reg);
./sound/pci/als300.c:525:		snd_als300_gcr_write(chip->port, reg, tmp | FIFO_PAUSE);
./sound/pci/als300.c:529:		tmp = snd_als300_gcr_read(chip->port, reg);
./sound/pci/als300.c:530:		snd_als300_gcr_write(chip->port, reg, tmp & ~FIFO_PAUSE);
./sound/pci/als300.c:537:	spin_unlock(&chip->reg_lock);
./sound/pci/als300.c:551:	spin_lock(&chip->reg_lock);
./sound/pci/als300.c:552:	current_ptr = (u16) snd_als300_gcr_read(chip->port,
./sound/pci/als300.c:554:	spin_unlock(&chip->reg_lock);
./sound/pci/als300.c:593:	err = snd_pcm_new(chip->card, "ALS300", 0, 1, 1, &pcm);
./sound/pci/als300.c:598:	chip->pcm = pcm;
./sound/pci/als300.c:608:	snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
./sound/pci/als300.c:617:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/als300.c:618:	chip->revision = (snd_als300_gcr_read(chip->port, MISC_CONTROL) >> 16)
./sound/pci/als300.c:621:	tmp = snd_als300_gcr_read(chip->port, DRAM_WRITE_CONTROL);
./sound/pci/als300.c:622:	snd_als300_gcr_write(chip->port, DRAM_WRITE_CONTROL,
./sound/pci/als300.c:631:	tmp = snd_als300_gcr_read(chip->port, MISC_CONTROL);
./sound/pci/als300.c:632:	snd_als300_gcr_write(chip->port, MISC_CONTROL,
./sound/pci/als300.c:636:	snd_als300_gcr_write(chip->port, MUS_VOC_VOL, 0);
./sound/pci/als300.c:639:	tmp = snd_als300_gcr_read(chip->port, PLAYBACK_CONTROL);
./sound/pci/als300.c:640:	snd_als300_gcr_write(chip->port, PLAYBACK_CONTROL,
./sound/pci/als300.c:642:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/als300.c:675:	chip->card = card;
./sound/pci/als300.c:676:	chip->pci = pci;
./sound/pci/als300.c:677:	chip->irq = -1;
./sound/pci/als300.c:678:	chip->chip_type = chip_type;
./sound/pci/als300.c:679:	spin_lock_init(&chip->reg_lock);
./sound/pci/als300.c:686:	chip->port = pci_resource_start(pci, 0);
./sound/pci/als300.c:688:	if (chip->chip_type == DEVICE_ALS300_PLUS)
./sound/pci/als300.c:699:	chip->irq = pci->irq;
./sound/pci/als300.c:734:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/als300.c:735:	snd_ac97_suspend(chip->ac97);
./sound/pci/als300.c:745:	snd_ac97_resume(chip->ac97);
./sound/pci/als300.c:787:	if (chip->chip_type == DEVICE_ALS300_PLUS)
./sound/pci/als300.c:790:		sprintf(card->shortname, "ALS300+ (Rev. %d)", chip->revision);
./sound/pci/als300.c:793:							chip->revision - 1);
./sound/pci/als300.c:795:				card->shortname, chip->port, chip->irq);
./sound/pci/atiixp_modem.c:284:	void __iomem *addr = chip->remap_addr + reg;
./sound/pci/atiixp_modem.c:299:	writel(value, chip->remap_addr + ATI_REG_##reg)
./sound/pci/atiixp_modem.c:301:	readl(chip->remap_addr + ATI_REG_##reg)
./sound/pci/atiixp_modem.c:338:		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),
./sound/pci/atiixp_modem.c:348:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/atiixp_modem.c:349:	writel(0, chip->remap_addr + dma->ops->llp_offset);
./sound/pci/atiixp_modem.c:352:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/atiixp_modem.c:372:	       chip->remap_addr + dma->ops->llp_offset);
./sound/pci/atiixp_modem.c:388:		writel(0, chip->remap_addr + dma->ops->llp_offset);
./sound/pci/atiixp_modem.c:403:			dev_warn(chip->card->dev, "codec acquire timeout\n");
./sound/pci/atiixp_modem.c:436:		dev_warn(chip->card->dev, "codec read timeout (reg %x)\n", reg);
./sound/pci/atiixp_modem.c:502:			dev_err(chip->card->dev, "codec reset timeout\n");
./sound/pci/atiixp_modem.c:544:	chip->codec_not_ready_bits = 0;
./sound/pci/atiixp_modem.c:550:		if (chip->codec_not_ready_bits)
./sound/pci/atiixp_modem.c:555:	if ((chip->codec_not_ready_bits & ALL_CODEC_NOT_READY) == ALL_CODEC_NOT_READY) {
./sound/pci/atiixp_modem.c:556:		dev_err(chip->card->dev, "no codec detected!\n");
./sound/pci/atiixp_modem.c:619:		curptr = readl(chip->remap_addr + dma->ops->dt_cur);
./sound/pci/atiixp_modem.c:627:	dev_dbg(chip->card->dev, "invalid DMA pointer read 0x%x (buf=%x)\n",
./sound/pci/atiixp_modem.c:628:		   readl(chip->remap_addr + dma->ops->dt_cur), dma->buf_addr);
./sound/pci/atiixp_modem.c:640:	dev_dbg(chip->card->dev, "XRUN detected (DMA %d)\n", dma->ops->type);
./sound/pci/atiixp_modem.c:681:	spin_lock(&chip->reg_lock);
./sound/pci/atiixp_modem.c:702:	spin_unlock(&chip->reg_lock);
./sound/pci/atiixp_modem.c:710: * every callback is supposed to be called in chip->reg_lock spinlock
./sound/pci/atiixp_modem.c:773:	spin_lock_irq(&chip->reg_lock);
./sound/pci/atiixp_modem.c:779:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/atiixp_modem.c:814:		if (! chip->ac97[i])
./sound/pci/atiixp_modem.c:816:		snd_ac97_write(chip->ac97[i], AC97_LINE1_RATE, params_rate(hw_params));
./sound/pci/atiixp_modem.c:817:		snd_ac97_write(chip->ac97[i], AC97_LINE1_LEVEL, 0);
./sound/pci/atiixp_modem.c:888:	spin_lock_irq(&chip->reg_lock);
./sound/pci/atiixp_modem.c:890:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/atiixp_modem.c:903:	spin_lock_irq(&chip->reg_lock);
./sound/pci/atiixp_modem.c:905:	spin_unlock_irq(&chip->reg_lock);
./sound/pci/atiixp_modem.c:918:	mutex_lock(&chip->open_mutex);
./sound/pci/atiixp_modem.c:919:	err = snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_PLAYBACK], 0);
./sound/pci/atiixp_modem.c:920:	mutex_unlock(&chip->open_mutex);
./sound/pci/atiixp_modem.c:930:	mutex_lock(&chip->open_mutex);
./sound/pci/atiixp_modem.c:931:	err = snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_PLAYBACK]);
./sound/pci/atiixp_modem.c:932:	mutex_unlock(&chip->open_mutex);
./sound/pci/atiixp_modem.c:939:	return snd_atiixp_pcm_open(substream, &chip->dmas[ATI_DMA_CAPTURE], 1);
./sound/pci/atiixp_modem.c:945:	return snd_atiixp_pcm_close(substream, &chip->dmas[ATI_DMA_CAPTURE]);
./sound/pci/atiixp_modem.c:997:	chip->dmas[ATI_DMA_PLAYBACK].ops = &snd_atiixp_playback_dma_ops;
./sound/pci/atiixp_modem.c:998:	chip->dmas[ATI_DMA_CAPTURE].ops = &snd_atiixp_capture_dma_ops;
./sound/pci/atiixp_modem.c:1001:	err = snd_pcm_new(chip->card, "ATI IXP MC97", ATI_PCMDEV_ANALOG, 1, 1, &pcm);
./sound/pci/atiixp_modem.c:1009:	chip->pcmdevs[ATI_PCMDEV_ANALOG] = pcm;
./sound/pci/atiixp_modem.c:1012:					      snd_dma_pci_data(chip->pci),
./sound/pci/atiixp_modem.c:1035:		snd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_PLAYBACK]);
./sound/pci/atiixp_modem.c:1037:		snd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_PLAYBACK]);
./sound/pci/atiixp_modem.c:1039:		snd_atiixp_xrun_dma(chip,  &chip->dmas[ATI_DMA_CAPTURE]);
./sound/pci/atiixp_modem.c:1041:		snd_atiixp_update_dma(chip, &chip->dmas[ATI_DMA_CAPTURE]);
./sound/pci/atiixp_modem.c:1047:		spin_lock(&chip->reg_lock);
./sound/pci/atiixp_modem.c:1048:		chip->codec_not_ready_bits |= detected;
./sound/pci/atiixp_modem.c:1050:		spin_unlock(&chip->reg_lock);
./sound/pci/atiixp_modem.c:1083:	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus)) < 0)
./sound/pci/atiixp_modem.c:1086:	chip->ac97_bus = pbus;
./sound/pci/atiixp_modem.c:1090:		if (chip->codec_not_ready_bits & codec_skip[i])
./sound/pci/atiixp_modem.c:1094:		ac97.pci = chip->pci;
./sound/pci/atiixp_modem.c:1097:		if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97[i])) < 0) {
./sound/pci/atiixp_modem.c:1098:			chip->ac97[i] = NULL; /* to be sure */
./sound/pci/atiixp_modem.c:1099:			dev_dbg(chip->card->dev,
./sound/pci/atiixp_modem.c:1107:		dev_err(chip->card->dev, "no codec available\n");
./sound/pci/atiixp_modem.c:1111:	/* snd_ac97_tune_hardware(chip->ac97, ac97_quirks); */
./sound/pci/atiixp_modem.c:1129:		snd_pcm_suspend_all(chip->pcmdevs[i]);
./sound/pci/atiixp_modem.c:1131:		snd_ac97_suspend(chip->ac97[i]);
./sound/pci/atiixp_modem.c:1147:		snd_ac97_resume(chip->ac97[i]);
./sound/pci/atiixp_modem.c:1170:		snd_iprintf(buffer, "%02x: %08x\n", i, readl(chip->remap_addr + i));
./sound/pci/atiixp_modem.c:1177:	if (! snd_card_proc_new(chip->card, "atiixp-modem", &entry))
./sound/pci/atiixp_modem.c:1188:	if (chip->irq < 0)
./sound/pci/atiixp_modem.c:1193:	if (chip->irq >= 0)
./sound/pci/atiixp_modem.c:1194:		free_irq(chip->irq, chip);
./sound/pci/atiixp_modem.c:1195:	iounmap(chip->remap_addr);
./sound/pci/atiixp_modem.c:1196:	pci_release_regions(chip->pci);
./sound/pci/atiixp_modem.c:1197:	pci_disable_device(chip->pci);
./sound/pci/atiixp_modem.c:1230:	spin_lock_init(&chip->reg_lock);
./sound/pci/atiixp_modem.c:1231:	mutex_init(&chip->open_mutex);
./sound/pci/atiixp_modem.c:1232:	chip->card = card;
./sound/pci/atiixp_modem.c:1233:	chip->pci = pci;
./sound/pci/atiixp_modem.c:1234:	chip->irq = -1;
./sound/pci/atiixp_modem.c:1240:	chip->addr = pci_resource_start(pci, 0);
./sound/pci/atiixp_modem.c:1241:	chip->remap_addr = pci_ioremap_bar(pci, 0);
./sound/pci/atiixp_modem.c:1242:	if (chip->remap_addr == NULL) {
./sound/pci/atiixp_modem.c:1254:	chip->irq = pci->irq;
./sound/pci/atiixp_modem.c:1256:	synchronize_irq(chip->irq);
./sound/pci/atiixp_modem.c:1299:		card->shortname, pci->revision, chip->addr, chip->irq);
./sound/pci/es1938.c:262:	spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/pci/es1938.c:265:	spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/pci/es1938.c:266:	dev_dbg(chip->card->dev, "Mixer reg %02x set to %02x\n", reg, val);
./sound/pci/es1938.c:276:	spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/pci/es1938.c:279:	spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/pci/es1938.c:280:	dev_dbg(chip->card->dev, "Mixer reg %02x now is %02x\n", reg, data);
./sound/pci/es1938.c:292:	spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/pci/es1938.c:299:		dev_dbg(chip->card->dev,
./sound/pci/es1938.c:303:	spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/pci/es1938.c:320:	dev_err(chip->card->dev,
./sound/pci/es1938.c:334:	dev_err(chip->card->dev, "get_byte timeout: status 0x02%x\n", v);
./sound/pci/es1938.c:344:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1938.c:347:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1938.c:348:	dev_dbg(chip->card->dev, "Reg %02x set to %02x\n", reg, val);
./sound/pci/es1938.c:358:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1938.c:362:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1938.c:363:	dev_dbg(chip->card->dev, "Reg %02x now is %02x\n", reg, val);
./sound/pci/es1938.c:375:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/pci/es1938.c:384:		dev_dbg(chip->card->dev, "Reg %02x was %02x, set to %02x\n",
./sound/pci/es1938.c:387:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/pci/es1938.c:407:	dev_err(chip->card->dev, "ESS Solo-1 reset failed\n");
./sound/pci/es1938.c:490:	outl(chip->dma2_start, SLIO_REG(chip, AUDIO2DMAADDR));
./sound/pci/es1938.c:492:	outw(chip->dma2_size, SLIO_REG(chip, AUDIO2DMACOUNT));
./sound/pci/es1938.c:504:	outl(chip->dma1_start, SLDM_REG(chip, DMAADDR));
./sound/pci/es1938.c:505:	outw(chip->dma1_size - 1, SLDM_REG(chip, DMACOUNT));
./sound/pci/es1938.c:519:	outl(chip->dma1_start, SLDM_REG(chip, DMAADDR));
./sound/pci/es1938.c:520:	chip->last_capture_dmaaddr = chip->dma1_start;
./sound/pci/es1938.c:521:	outw(chip->dma1_size - 1, SLDM_REG(chip, DMACOUNT));
./sound/pci/es1938.c:540:		chip->active |= ADC1;
./sound/pci/es1938.c:545:		chip->active &= ~ADC1;
./sound/pci/es1938.c:570:		chip->active |= DAC2;
./sound/pci/es1938.c:576:		chip->active &= ~DAC2;
./sound/pci/es1938.c:593:		chip->active |= DAC1;
./sound/pci/es1938.c:598:		chip->active &= ~DAC1;
./sound/pci/es1938.c:631:	chip->dma1_size = size;
./sound/pci/es1938.c:632:	chip->dma1_start = runtime->dma_addr;
./sound/pci/es1938.c:638:	chip->dma1_shift = 2 - mono - is8;
./sound/pci/es1938.c:679:	chip->dma2_size = size;
./sound/pci/es1938.c:680:	chip->dma2_start = runtime->dma_addr;
./sound/pci/es1938.c:686:	chip->dma2_shift = 2 - mono - is8;
./sound/pci/es1938.c:716:	chip->dma1_size = size;
./sound/pci/es1938.c:717:	chip->dma1_start = runtime->dma_addr;
./sound/pci/es1938.c:723:	chip->dma1_shift = 2 - mono - is8;
./sound/pci/es1938.c:780:	ptr = chip->dma1_size - 1 - new;
./sound/pci/es1938.c:787:	diff = chip->dma1_start + chip->dma1_size - ptr - count;
./sound/pci/es1938.c:789:	if (diff > 3 || ptr < chip->dma1_start
./sound/pci/es1938.c:790:	      || ptr >= chip->dma1_start+chip->dma1_size)
./sound/pci/es1938.c:791:	  ptr = chip->last_capture_dmaaddr;            /* bad, use last saved */
./sound/pci/es1938.c:793:	  chip->last_capture_dmaaddr = ptr;            /* good, remember it */
./sound/pci/es1938.c:795:	ptr -= chip->dma1_start;
./sound/pci/es1938.c:797:	return ptr >> chip->dma1_shift;
./sound/pci/es1938.c:805:	ptr = chip->dma2_size - inw(SLIO_REG(chip, AUDIO2DMACOUNT));
./sound/pci/es1938.c:807:	ptr = inl(SLIO_REG(chip, AUDIO2DMAADDR)) - chip->dma2_start;
./sound/pci/es1938.c:809:	return ptr >> chip->dma2_shift;
./sound/pci/es1938.c:822:	ptr = chip->dma1_size - 1 - new;
./sound/pci/es1938.c:824:	ptr = inl(SLDM_REG(chip, DMAADDR)) - chip->dma1_start;
./sound/pci/es1938.c:826:	return ptr >> chip->dma1_shift;
./sound/pci/es1938.c:849:	pos <<= chip->dma1_shift;
./sound/pci/es1938.c:850:	count <<= chip->dma1_shift;
./sound/pci/es1938.c:851:	if (snd_BUG_ON(pos + count > chip->dma1_size))
./sound/pci/es1938.c:853:	if (pos + count < chip->dma1_size) {
./sound/pci/es1938.c:934:	if (chip->playback2_substream)
./sound/pci/es1938.c:936:	chip->capture_substream = substream;
./sound/pci/es1938.c:951:		chip->playback1_substream = substream;
./sound/pci/es1938.c:954:		if (chip->capture_substream)
./sound/pci/es1938.c:956:		chip->playback2_substream = substream;
./sound/pci/es1938.c:973:	chip->capture_substream = NULL;
./sound/pci/es1938.c:983:		chip->playback1_substream = NULL;
./sound/pci/es1938.c:986:		chip->playback2_substream = NULL;
./sound/pci/es1938.c:1023:	if ((err = snd_pcm_new(chip->card, "es-1938-1946", device, 2, 1, &pcm)) < 0)
./sound/pci/es1938.c:1033:					      snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
./sound/pci/es1938.c:1035:	chip->pcm = pcm;
./sound/pci/es1938.c:1134:	chip->master_volume = NULL;
./sound/pci/es1938.c:1135:	chip->master_switch = NULL;
./sound/pci/es1938.c:1136:	chip->hw_volume = NULL;
./sound/pci/es1938.c:1137:	chip->hw_switch = NULL;
./sound/pci/es1938.c:1423:	pci_set_master(chip->pci);
./sound/pci/es1938.c:1426:	pci_write_config_word(chip->pci, SL_PCI_LEGACYCONTROL, 0x805f);
./sound/pci/es1938.c:1429:	pci_write_config_word(chip->pci, SL_PCI_DDMACONTROL, chip->ddma_port | 1);
./sound/pci/es1938.c:1432:	pci_write_config_dword(chip->pci, SL_PCI_CONFIG, 0);
./sound/pci/es1938.c:1461:	snd_pcm_suspend_all(chip->pcm);
./sound/pci/es1938.c:1464:	for (s = saved_regs, d = chip->saved_regs; *s; s++, d++)
./sound/pci/es1938.c:1468:	if (chip->irq >= 0) {
./sound/pci/es1938.c:1469:		free_irq(chip->irq, chip);
./sound/pci/es1938.c:1470:		chip->irq = -1;
./sound/pci/es1938.c:1489:	chip->irq = pci->irq;
./sound/pci/es1938.c:1493:	for (s = saved_regs, d = chip->saved_regs; *s; s++, d++) {
./sound/pci/es1938.c:1515:	chip->gameport = gp = gameport_allocate_port();
./sound/pci/es1938.c:1517:		dev_err(chip->card->dev,
./sound/pci/es1938.c:1523:	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
./sound/pci/es1938.c:1524:	gameport_set_dev_parent(gp, &chip->pci->dev);
./sound/pci/es1938.c:1525:	gp->io = chip->game_port;
./sound/pci/es1938.c:1534:	if (chip->gameport) {
./sound/pci/es1938.c:1535:		gameport_unregister_port(chip->gameport);
./sound/pci/es1938.c:1536:		chip->gameport = NULL;
./sound/pci/es1938.c:1548:	if (chip->rmidi)
./sound/pci/es1938.c:1553:	if (chip->irq >= 0)
./sound/pci/es1938.c:1554:		free_irq(chip->irq, chip);
./sound/pci/es1938.c:1555:	pci_release_regions(chip->pci);
./sound/pci/es1938.c:1556:	pci_disable_device(chip->pci);
./sound/pci/es1938.c:1596:	spin_lock_init(&chip->reg_lock);
./sound/pci/es1938.c:1597:	spin_lock_init(&chip->mixer_lock);
./sound/pci/es1938.c:1598:	chip->card = card;
./sound/pci/es1938.c:1599:	chip->pci = pci;
./sound/pci/es1938.c:1600:	chip->irq = -1;
./sound/pci/es1938.c:1606:	chip->io_port = pci_resource_start(pci, 0);
./sound/pci/es1938.c:1607:	chip->sb_port = pci_resource_start(pci, 1);
./sound/pci/es1938.c:1608:	chip->vc_port = pci_resource_start(pci, 2);
./sound/pci/es1938.c:1609:	chip->mpu_port = pci_resource_start(pci, 3);
./sound/pci/es1938.c:1610:	chip->game_port = pci_resource_start(pci, 4);
./sound/pci/es1938.c:1617:	chip->irq = pci->irq;
./sound/pci/es1938.c:1620:		   chip->io_port, chip->sb_port, chip->vc_port, chip->mpu_port, chip->game_port);
./sound/pci/es1938.c:1622:	chip->ddma_port = chip->vc_port + 0x00;		/* fix from Thomas Sailer */
./sound/pci/es1938.c:1646:	dev_dbg(chip->card->dev,
./sound/pci/es1938.c:1653:		dev_dbg(chip->card->dev,
./sound/pci/es1938.c:1655:		dev_dbg(chip->card->dev,
./sound/pci/es1938.c:1658:		dev_dbg(chip->card->dev,
./sound/pci/es1938.c:1661:		dev_dbg(chip->card->dev,
./sound/pci/es1938.c:1668:		if (chip->active & ADC1)
./sound/pci/es1938.c:1669:			snd_pcm_period_elapsed(chip->capture_substream);
./sound/pci/es1938.c:1670:		else if (chip->active & DAC1)
./sound/pci/es1938.c:1671:			snd_pcm_period_elapsed(chip->playback2_substream);
./sound/pci/es1938.c:1677:		dev_dbg(chip->card->dev,
./sound/pci/es1938.c:1679:		dev_dbg(chip->card->dev,
./sound/pci/es1938.c:1682:		dev_dbg(chip->card->dev,
./sound/pci/es1938.c:1690:		if (chip->active & DAC2)
./sound/pci/es1938.c:1691:			snd_pcm_period_elapsed(chip->playback1_substream);
./sound/pci/es1938.c:1698:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE, &chip->hw_switch->id);
./sound/pci/es1938.c:1699:		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE, &chip->hw_volume->id);
./sound/pci/es1938.c:1701:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/pci/es1938.c:1702:				       &chip->master_switch->id);
./sound/pci/es1938.c:1703:			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/pci/es1938.c:1704:				       &chip->master_volume->id);
./sound/pci/es1938.c:1716:		if (chip->rmidi) {
./sound/pci/es1938.c:1718:			snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
./sound/pci/es1938.c:1732:	card = chip->card;
./sound/pci/es1938.c:1741:				chip->master_volume = kctl;
./sound/pci/es1938.c:1745:				chip->master_switch = kctl;
./sound/pci/es1938.c:1749:				chip->hw_volume = kctl;
./sound/pci/es1938.c:1753:				chip->hw_switch = kctl;
./sound/pci/es1938.c:1801:		chip->revision,
./sound/pci/es1938.c:1802:		chip->irq);
./sound/pci/es1938.c:1829:				chip->mpu_port,
./sound/pci/es1938.c:1831:				-1, &chip->rmidi) < 0) {
./sound/pci/ice1712/maya44.c:189:		&chip->wm[snd_ctl_get_ioff(kcontrol, &ucontrol->id)];
./sound/pci/ice1712/maya44.c:192:	mutex_lock(&chip->mutex);
./sound/pci/ice1712/maya44.c:195:	mutex_unlock(&chip->mutex);
./sound/pci/ice1712/maya44.c:204:		&chip->wm[snd_ctl_get_ioff(kcontrol, &ucontrol->id)];
./sound/pci/ice1712/maya44.c:210:	mutex_lock(&chip->mutex);
./sound/pci/ice1712/maya44.c:222:		changed |= wm8776_write_bits(chip->ice, wm, vol->regs[ch],
./sound/pci/ice1712/maya44.c:225:			wm8776_write_bits(chip->ice, wm, WM8776_REG_ADC_MUX,
./sound/pci/ice1712/maya44.c:230:	mutex_unlock(&chip->mutex);
./sound/pci/ice1712/maya44.c:250:		&chip->wm[snd_ctl_get_ioff(kcontrol, &ucontrol->id)];
./sound/pci/ice1712/maya44.c:262:		&chip->wm[snd_ctl_get_ioff(kcontrol, &ucontrol->id)];
./sound/pci/ice1712/maya44.c:267:	mutex_lock(&chip->mutex);
./sound/pci/ice1712/maya44.c:274:	changed = wm8776_write_bits(chip->ice, wm,
./sound/pci/ice1712/maya44.c:277:	mutex_unlock(&chip->mutex);
./sound/pci/ice1712/maya44.c:317:	val = (snd_ice1712_gpio_read(chip->ice) >> shift) & 1;
./sound/pci/ice1712/maya44.c:332:	mutex_lock(&chip->mutex);
./sound/pci/ice1712/maya44.c:338:	changed = maya_set_gpio_bits(chip->ice, mask, val);
./sound/pci/ice1712/maya44.c:339:	mutex_unlock(&chip->mutex);
./sound/pci/ice1712/maya44.c:353:	wm8776_write_bits(chip->ice, &chip->wm[idx], WM8776_REG_ADC_MUX,
./sound/pci/ice1712/maya44.c:371:	if (snd_ice1712_gpio_read(chip->ice) & (1 << GPIO_MIC_RELAY))
./sound/pci/ice1712/maya44.c:386:	mutex_lock(&chip->mutex);
./sound/pci/ice1712/maya44.c:387:	changed = maya_set_gpio_bits(chip->ice, 1 << GPIO_MIC_RELAY,
./sound/pci/ice1712/maya44.c:390:	mutex_unlock(&chip->mutex);
./sound/pci/ice1712/maya44.c:422:		snd_ice1724_get_route_val(chip->ice, maya_pb_route_shift(idx));
./sound/pci/ice1712/maya44.c:431:	return snd_ice1724_put_route_val(chip->ice,
./sound/pci/ice1712/maya44.c:652:	mutex_lock(&chip->mutex);
./sound/pci/ice1712/maya44.c:654:		wm8776_write_bits(ice, &chip->wm[i],
./sound/pci/ice1712/maya44.c:657:	mutex_unlock(&chip->mutex);
./sound/pci/ice1712/maya44.c:694:	mutex_init(&chip->mutex);
./sound/pci/ice1712/maya44.c:695:	chip->ice = ice;
./sound/pci/ice1712/maya44.c:704:		wm8776_init(ice, &chip->wm[i], wm8776_addr[i]);
./sound/sparc/cs4231.c:299:	__cs4231_writeb(chip, chip->mce_bit | reg, CS4231U(chip, REGSEL));
./sound/sparc/cs4231.c:308:	unsigned char tmp = (chip->image[reg] & mask) | value;
./sound/sparc/cs4231.c:310:	chip->image[reg] = tmp;
./sound/sparc/cs4231.c:311:	if (!chip->calibrate_mute)
./sound/sparc/cs4231.c:319:	chip->image[reg] = value;
./sound/sparc/cs4231.c:331:	__cs4231_writeb(chip, chip->mce_bit | reg, CS4231U(chip, REGSEL));
./sound/sparc/cs4231.c:362:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:368:	chip->mce_bit |= CS4231_MCE;
./sound/sparc/cs4231.c:373:			    chip->port);
./sound/sparc/cs4231.c:375:		__cs4231_writeb(chip, chip->mce_bit | (timeout & 0x1f),
./sound/sparc/cs4231.c:377:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:386:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:392:	chip->mce_bit &= ~CS4231_MCE;
./sound/sparc/cs4231.c:394:	__cs4231_writeb(chip, chip->mce_bit | (reg & 0x1f),
./sound/sparc/cs4231.c:398:			    "- codec still busy\n", chip->port);
./sound/sparc/cs4231.c:400:		spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:409:		spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:411:		spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:415:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:449:		dma_cont = &chip->p_dma;
./sound/sparc/cs4231.c:454:				chip->playback_substream,
./sound/sparc/cs4231.c:455:				&chip->p_periods_sent);
./sound/sparc/cs4231.c:461:		dma_cont = &chip->c_dma;
./sound/sparc/cs4231.c:466:				chip->capture_substream,
./sound/sparc/cs4231.c:467:				&chip->c_periods_sent);
./sound/sparc/cs4231.c:488:			if (s == chip->playback_substream) {
./sound/sparc/cs4231.c:491:			} else if (s == chip->capture_substream) {
./sound/sparc/cs4231.c:497:		spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:500:			chip->image[CS4231_IFACE_CTRL] |= what;
./sound/sparc/cs4231.c:503:			chip->image[CS4231_IFACE_CTRL] &= ~what;
./sound/sparc/cs4231.c:506:			       chip->image[CS4231_IFACE_CTRL]);
./sound/sparc/cs4231.c:507:		spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:566:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:567:	if (chip->calibrate_mute == mute) {
./sound/sparc/cs4231.c:568:		spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:573:				chip->image[CS4231_LEFT_INPUT]);
./sound/sparc/cs4231.c:575:				chip->image[CS4231_RIGHT_INPUT]);
./sound/sparc/cs4231.c:577:				chip->image[CS4231_LOOPBACK]);
./sound/sparc/cs4231.c:580:			mute ? 0x80 : chip->image[CS4231_AUX1_LEFT_INPUT]);
./sound/sparc/cs4231.c:582:			mute ? 0x80 : chip->image[CS4231_AUX1_RIGHT_INPUT]);
./sound/sparc/cs4231.c:584:			mute ? 0x80 : chip->image[CS4231_AUX2_LEFT_INPUT]);
./sound/sparc/cs4231.c:586:			mute ? 0x80 : chip->image[CS4231_AUX2_RIGHT_INPUT]);
./sound/sparc/cs4231.c:588:			mute ? 0x80 : chip->image[CS4231_LEFT_OUTPUT]);
./sound/sparc/cs4231.c:590:			mute ? 0x80 : chip->image[CS4231_RIGHT_OUTPUT]);
./sound/sparc/cs4231.c:592:			mute ? 0x80 : chip->image[CS4231_LEFT_LINE_IN]);
./sound/sparc/cs4231.c:594:			mute ? 0x80 : chip->image[CS4231_RIGHT_LINE_IN]);
./sound/sparc/cs4231.c:596:			mute ? 0xc0 : chip->image[CS4231_MONO_CTRL]);
./sound/sparc/cs4231.c:597:	chip->calibrate_mute = mute;
./sound/sparc/cs4231.c:598:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:607:	mutex_lock(&chip->mce_mutex);
./sound/sparc/cs4231.c:612:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:614:		       (chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE) ?
./sound/sparc/cs4231.c:615:		       (pdfr & 0xf0) | (chip->image[CS4231_REC_FORMAT] & 0x0f) :
./sound/sparc/cs4231.c:617:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:622:	mutex_unlock(&chip->mce_mutex);
./sound/sparc/cs4231.c:631:	mutex_lock(&chip->mce_mutex);
./sound/sparc/cs4231.c:636:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:637:	if (!(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE)) {
./sound/sparc/cs4231.c:639:			       ((chip->image[CS4231_PLAYBK_FORMAT]) & 0xf0) |
./sound/sparc/cs4231.c:641:		spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:644:		spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:647:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:652:	mutex_unlock(&chip->mce_mutex);
./sound/sparc/cs4231.c:663:	return chip->image[CS4231_PLAYBK_FORMAT] & 1 ? 9969 : 9920;
./sound/sparc/cs4231.c:672:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:674:	if ((chip->image[CS4231_ALT_FEATURE_1] & CS4231_TIMER_ENABLE) == 0 ||
./sound/sparc/cs4231.c:675:	    (unsigned char)(ticks >> 8) != chip->image[CS4231_TIMER_HIGH] ||
./sound/sparc/cs4231.c:676:	    (unsigned char)ticks != chip->image[CS4231_TIMER_LOW]) {
./sound/sparc/cs4231.c:678:			       chip->image[CS4231_TIMER_HIGH] =
./sound/sparc/cs4231.c:681:			       chip->image[CS4231_TIMER_LOW] =
./sound/sparc/cs4231.c:684:			       chip->image[CS4231_ALT_FEATURE_1] |
./sound/sparc/cs4231.c:687:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:697:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:698:	chip->image[CS4231_ALT_FEATURE_1] &= ~CS4231_TIMER_ENABLE;
./sound/sparc/cs4231.c:700:		       chip->image[CS4231_ALT_FEATURE_1]);
./sound/sparc/cs4231.c:701:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:716:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:717:	chip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE |
./sound/sparc/cs4231.c:722:	chip->image[CS4231_IFACE_CTRL] |= CS4231_AUTOCALIB;
./sound/sparc/cs4231.c:723:	snd_cs4231_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);
./sound/sparc/cs4231.c:724:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:732:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:734:			chip->image[CS4231_ALT_FEATURE_1]);
./sound/sparc/cs4231.c:735:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:740:		    chip->image[CS4231_ALT_FEATURE_1]);
./sound/sparc/cs4231.c:743:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:745:			chip->image[CS4231_ALT_FEATURE_2]);
./sound/sparc/cs4231.c:746:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:749:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:751:			chip->image[CS4231_PLAYBK_FORMAT]);
./sound/sparc/cs4231.c:752:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:760:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:761:	snd_cs4231_out(chip, CS4231_REC_FORMAT, chip->image[CS4231_REC_FORMAT]);
./sound/sparc/cs4231.c:762:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:774:	mutex_lock(&chip->open_mutex);
./sound/sparc/cs4231.c:775:	if ((chip->mode & mode)) {
./sound/sparc/cs4231.c:776:		mutex_unlock(&chip->open_mutex);
./sound/sparc/cs4231.c:779:	if (chip->mode & CS4231_MODE_OPEN) {
./sound/sparc/cs4231.c:780:		chip->mode |= mode;
./sound/sparc/cs4231.c:781:		mutex_unlock(&chip->open_mutex);
./sound/sparc/cs4231.c:785:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:798:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:800:	chip->mode = mode;
./sound/sparc/cs4231.c:801:	mutex_unlock(&chip->open_mutex);
./sound/sparc/cs4231.c:809:	mutex_lock(&chip->open_mutex);
./sound/sparc/cs4231.c:810:	chip->mode &= ~mode;
./sound/sparc/cs4231.c:811:	if (chip->mode & CS4231_MODE_OPEN) {
./sound/sparc/cs4231.c:812:		mutex_unlock(&chip->open_mutex);
./sound/sparc/cs4231.c:818:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:825:	if (chip->image[CS4231_IFACE_CTRL] &
./sound/sparc/cs4231.c:828:		spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:830:		spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:831:		chip->image[CS4231_IFACE_CTRL] &=
./sound/sparc/cs4231.c:835:				chip->image[CS4231_IFACE_CTRL]);
./sound/sparc/cs4231.c:836:		spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:838:		spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:845:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:849:	chip->mode = 0;
./sound/sparc/cs4231.c:850:	mutex_unlock(&chip->open_mutex);
./sound/sparc/cs4231.c:912:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:914:	chip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE |
./sound/sparc/cs4231.c:922:	chip->p_periods_sent = 0;
./sound/sparc/cs4231.c:925:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:954:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:955:	chip->image[CS4231_IFACE_CTRL] &= ~(CS4231_RECORD_ENABLE |
./sound/sparc/cs4231.c:959:	chip->c_periods_sent = 0;
./sound/sparc/cs4231.c:960:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:970:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:972:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:976:		chip->capture_substream->runtime->overrange++;
./sound/sparc/cs4231.c:981:	if (chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE) {
./sound/sparc/cs4231.c:982:		snd_pcm_period_elapsed(chip->playback_substream);
./sound/sparc/cs4231.c:983:		snd_cs4231_advance_dma(&chip->p_dma, chip->playback_substream,
./sound/sparc/cs4231.c:984:					    &chip->p_periods_sent);
./sound/sparc/cs4231.c:990:	if (chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE) {
./sound/sparc/cs4231.c:991:		snd_pcm_period_elapsed(chip->capture_substream);
./sound/sparc/cs4231.c:992:		snd_cs4231_advance_dma(&chip->c_dma, chip->capture_substream,
./sound/sparc/cs4231.c:993:					    &chip->c_periods_sent);
./sound/sparc/cs4231.c:1001:	struct cs4231_dma_control *dma_cont = &chip->p_dma;
./sound/sparc/cs4231.c:1004:	if (!(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE))
./sound/sparc/cs4231.c:1017:	struct cs4231_dma_control *dma_cont = &chip->c_dma;
./sound/sparc/cs4231.c:1020:	if (!(chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE))
./sound/sparc/cs4231.c:1042:			spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1046:			spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1051:	snd_printdd("cs4231: port = %p, id = 0x%x\n", chip->port, id);
./sound/sparc/cs4231.c:1055:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1062:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1064:	chip->image[CS4231_MISC_INFO] = CS4231_MODE2;
./sound/sparc/cs4231.c:1065:	chip->image[CS4231_IFACE_CTRL] =
./sound/sparc/cs4231.c:1066:		chip->image[CS4231_IFACE_CTRL] & ~CS4231_SINGLE_DMA;
./sound/sparc/cs4231.c:1067:	chip->image[CS4231_ALT_FEATURE_1] = 0x80;
./sound/sparc/cs4231.c:1068:	chip->image[CS4231_ALT_FEATURE_2] = 0x01;
./sound/sparc/cs4231.c:1070:		chip->image[CS4231_ALT_FEATURE_2] |= 0x02;
./sound/sparc/cs4231.c:1072:	ptr = (unsigned char *) &chip->image;
./sound/sparc/cs4231.c:1076:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1081:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1153:	chip->playback_substream = substream;
./sound/sparc/cs4231.c:1154:	chip->p_periods_sent = 0;
./sound/sparc/cs4231.c:1174:	chip->capture_substream = substream;
./sound/sparc/cs4231.c:1175:	chip->c_periods_sent = 0;
./sound/sparc/cs4231.c:1187:	chip->playback_substream = NULL;
./sound/sparc/cs4231.c:1197:	chip->capture_substream = NULL;
./sound/sparc/cs4231.c:1249:					      &chip->op->dev,
./sound/sparc/cs4231.c:1252:	chip->pcm = pcm;
./sound/sparc/cs4231.c:1276:	chip->timer = timer;
./sound/sparc/cs4231.c:1301:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1303:		(chip->image[CS4231_LEFT_INPUT] & CS4231_MIXS_ALL) >> 6;
./sound/sparc/cs4231.c:1305:		(chip->image[CS4231_RIGHT_INPUT] & CS4231_MIXS_ALL) >> 6;
./sound/sparc/cs4231.c:1306:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1325:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1327:	left = (chip->image[CS4231_LEFT_INPUT] & ~CS4231_MIXS_ALL) | left;
./sound/sparc/cs4231.c:1328:	right = (chip->image[CS4231_RIGHT_INPUT] & ~CS4231_MIXS_ALL) | right;
./sound/sparc/cs4231.c:1329:	change = left != chip->image[CS4231_LEFT_INPUT] ||
./sound/sparc/cs4231.c:1330:		 right != chip->image[CS4231_RIGHT_INPUT];
./sound/sparc/cs4231.c:1334:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1363:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1365:	ucontrol->value.integer.value[0] = (chip->image[reg] >> shift) & mask;
./sound/sparc/cs4231.c:1367:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1393:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1395:	val = (chip->image[reg] & ~(mask << shift)) | val;
./sound/sparc/cs4231.c:1396:	change = val != chip->image[reg];
./sound/sparc/cs4231.c:1399:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1430:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1433:		(chip->image[left_reg] >> shift_left) & mask;
./sound/sparc/cs4231.c:1435:		(chip->image[right_reg] >> shift_right) & mask;
./sound/sparc/cs4231.c:1437:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1472:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1474:	val1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;
./sound/sparc/cs4231.c:1475:	val2 = (chip->image[right_reg] & ~(mask << shift_right)) | val2;
./sound/sparc/cs4231.c:1476:	change = val1 != chip->image[left_reg];
./sound/sparc/cs4231.c:1477:	change |= val2 != chip->image[right_reg];
./sound/sparc/cs4231.c:1481:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1544:	if (snd_BUG_ON(!chip || !chip->pcm))
./sound/sparc/cs4231.c:1547:	strcpy(card->mixername, chip->pcm->name);
./sound/sparc/cs4231.c:1586:	chip->card = card;
./sound/sparc/cs4231.c:1613:	dev_set_drvdata(&chip->op->dev, chip);
./sound/sparc/cs4231.c:1637:	csr = sbus_readl(chip->port + APCCSR);
./sound/sparc/cs4231.c:1639:	sbus_writel(csr, chip->port + APCCSR);
./sound/sparc/cs4231.c:1656:		if (chip->timer)
./sound/sparc/cs4231.c:1657:			snd_timer_interrupt(chip->timer, chip->timer->sticks);
./sound/sparc/cs4231.c:1664:	spin_lock_irqsave(&chip->lock, flags);
./sound/sparc/cs4231.c:1666:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/sparc/cs4231.c:1774:	struct platform_device *op = chip->op;
./sound/sparc/cs4231.c:1776:	if (chip->irq[0])
./sound/sparc/cs4231.c:1777:		free_irq(chip->irq[0], chip);
./sound/sparc/cs4231.c:1779:	if (chip->port)
./sound/sparc/cs4231.c:1780:		of_iounmap(&op->resource[0], chip->port, chip->regs_size);
./sound/sparc/cs4231.c:1803:	spin_lock_init(&chip->lock);
./sound/sparc/cs4231.c:1804:	spin_lock_init(&chip->c_dma.sbus_info.lock);
./sound/sparc/cs4231.c:1805:	spin_lock_init(&chip->p_dma.sbus_info.lock);
./sound/sparc/cs4231.c:1806:	mutex_init(&chip->mce_mutex);
./sound/sparc/cs4231.c:1807:	mutex_init(&chip->open_mutex);
./sound/sparc/cs4231.c:1808:	chip->op = op;
./sound/sparc/cs4231.c:1809:	chip->regs_size = resource_size(&op->resource[0]);
./sound/sparc/cs4231.c:1810:	memcpy(&chip->image, &snd_cs4231_original_image,
./sound/sparc/cs4231.c:1813:	chip->port = of_ioremap(&op->resource[0], 0,
./sound/sparc/cs4231.c:1814:				chip->regs_size, "cs4231");
./sound/sparc/cs4231.c:1815:	if (!chip->port) {
./sound/sparc/cs4231.c:1820:	chip->c_dma.sbus_info.regs = chip->port;
./sound/sparc/cs4231.c:1821:	chip->p_dma.sbus_info.regs = chip->port;
./sound/sparc/cs4231.c:1822:	chip->c_dma.sbus_info.dir = APC_RECORD;
./sound/sparc/cs4231.c:1823:	chip->p_dma.sbus_info.dir = APC_PLAY;
./sound/sparc/cs4231.c:1825:	chip->p_dma.prepare = sbus_dma_prepare;
./sound/sparc/cs4231.c:1826:	chip->p_dma.enable = sbus_dma_enable;
./sound/sparc/cs4231.c:1827:	chip->p_dma.request = sbus_dma_request;
./sound/sparc/cs4231.c:1828:	chip->p_dma.address = sbus_dma_addr;
./sound/sparc/cs4231.c:1830:	chip->c_dma.prepare = sbus_dma_prepare;
./sound/sparc/cs4231.c:1831:	chip->c_dma.enable = sbus_dma_enable;
./sound/sparc/cs4231.c:1832:	chip->c_dma.request = sbus_dma_request;
./sound/sparc/cs4231.c:1833:	chip->c_dma.address = sbus_dma_addr;
./sound/sparc/cs4231.c:1842:	chip->irq[0] = op->archdata.irqs[0];
./sound/sparc/cs4231.c:1934:	struct platform_device *op = chip->op;
./sound/sparc/cs4231.c:1936:	if (chip->c_dma.ebus_info.regs) {
./sound/sparc/cs4231.c:1937:		ebus_dma_unregister(&chip->c_dma.ebus_info);
./sound/sparc/cs4231.c:1938:		of_iounmap(&op->resource[2], chip->c_dma.ebus_info.regs, 0x10);
./sound/sparc/cs4231.c:1940:	if (chip->p_dma.ebus_info.regs) {
./sound/sparc/cs4231.c:1941:		ebus_dma_unregister(&chip->p_dma.ebus_info);
./sound/sparc/cs4231.c:1942:		of_iounmap(&op->resource[1], chip->p_dma.ebus_info.regs, 0x10);
./sound/sparc/cs4231.c:1945:	if (chip->port)
./sound/sparc/cs4231.c:1946:		of_iounmap(&op->resource[0], chip->port, 0x10);
./sound/sparc/cs4231.c:1969:	spin_lock_init(&chip->lock);
./sound/sparc/cs4231.c:1970:	spin_lock_init(&chip->c_dma.ebus_info.lock);
./sound/sparc/cs4231.c:1971:	spin_lock_init(&chip->p_dma.ebus_info.lock);
./sound/sparc/cs4231.c:1972:	mutex_init(&chip->mce_mutex);
./sound/sparc/cs4231.c:1973:	mutex_init(&chip->open_mutex);
./sound/sparc/cs4231.c:1974:	chip->flags |= CS4231_FLAG_EBUS;
./sound/sparc/cs4231.c:1975:	chip->op = op;
./sound/sparc/cs4231.c:1976:	memcpy(&chip->image, &snd_cs4231_original_image,
./sound/sparc/cs4231.c:1978:	strcpy(chip->c_dma.ebus_info.name, "cs4231(capture)");
./sound/sparc/cs4231.c:1979:	chip->c_dma.ebus_info.flags = EBUS_DMA_FLAG_USE_EBDMA_HANDLER;
./sound/sparc/cs4231.c:1980:	chip->c_dma.ebus_info.callback = snd_cs4231_ebus_capture_callback;
./sound/sparc/cs4231.c:1981:	chip->c_dma.ebus_info.client_cookie = chip;
./sound/sparc/cs4231.c:1982:	chip->c_dma.ebus_info.irq = op->archdata.irqs[0];
./sound/sparc/cs4231.c:1983:	strcpy(chip->p_dma.ebus_info.name, "cs4231(play)");
./sound/sparc/cs4231.c:1984:	chip->p_dma.ebus_info.flags = EBUS_DMA_FLAG_USE_EBDMA_HANDLER;
./sound/sparc/cs4231.c:1985:	chip->p_dma.ebus_info.callback = snd_cs4231_ebus_play_callback;
./sound/sparc/cs4231.c:1986:	chip->p_dma.ebus_info.client_cookie = chip;
./sound/sparc/cs4231.c:1987:	chip->p_dma.ebus_info.irq = op->archdata.irqs[1];
./sound/sparc/cs4231.c:1989:	chip->p_dma.prepare = _ebus_dma_prepare;
./sound/sparc/cs4231.c:1990:	chip->p_dma.enable = _ebus_dma_enable;
./sound/sparc/cs4231.c:1991:	chip->p_dma.request = _ebus_dma_request;
./sound/sparc/cs4231.c:1992:	chip->p_dma.address = _ebus_dma_addr;
./sound/sparc/cs4231.c:1994:	chip->c_dma.prepare = _ebus_dma_prepare;
./sound/sparc/cs4231.c:1995:	chip->c_dma.enable = _ebus_dma_enable;
./sound/sparc/cs4231.c:1996:	chip->c_dma.request = _ebus_dma_request;
./sound/sparc/cs4231.c:1997:	chip->c_dma.address = _ebus_dma_addr;
./sound/sparc/cs4231.c:1999:	chip->port = of_ioremap(&op->resource[0], 0, 0x10, "cs4231");
./sound/sparc/cs4231.c:2000:	chip->p_dma.ebus_info.regs =
./sound/sparc/cs4231.c:2002:	chip->c_dma.ebus_info.regs =
./sound/sparc/cs4231.c:2004:	if (!chip->port || !chip->p_dma.ebus_info.regs ||
./sound/sparc/cs4231.c:2005:	    !chip->c_dma.ebus_info.regs) {
./sound/sparc/cs4231.c:2011:	if (ebus_dma_register(&chip->c_dma.ebus_info)) {
./sound/sparc/cs4231.c:2017:	if (ebus_dma_irq_enable(&chip->c_dma.ebus_info, 1)) {
./sound/sparc/cs4231.c:2024:	if (ebus_dma_register(&chip->p_dma.ebus_info)) {
./sound/sparc/cs4231.c:2030:	if (ebus_dma_irq_enable(&chip->p_dma.ebus_info, 1)) {
./sound/sparc/cs4231.c:2093:	snd_card_free(chip->card);
./sound/usb/format.c:82:		if (((chip->usb_id == USB_ID(0x0582, 0x0016)) ||
./sound/usb/format.c:84:		     (chip->usb_id == USB_ID(0x0582, 0x000c))) &&
./sound/usb/format.c:124:		if (chip->usb_id == USB_ID(0x04fa, 0x4201))
./sound/usb/format.c:193:			    (chip->usb_id == USB_ID(0x0d8c, 0x0201) ||
./sound/usb/format.c:194:			     chip->usb_id == USB_ID(0x0d8c, 0x0102) ||
./sound/usb/format.c:195:			     chip->usb_id == USB_ID(0x0ccd, 0x00b1)) &&
./sound/usb/format.c:200:			    (chip->usb_id == USB_ID(0x041e, 0x4064) ||
./sound/usb/format.c:201:			     chip->usb_id == USB_ID(0x041e, 0x4068)))
./sound/usb/format.c:291:	struct usb_device *dev = chip->dev;
./sound/usb/format.c:384:		switch (chip->usb_id) {
./sound/usb/format.c:387:			if (chip->setup == 0x00 && 
./sound/usb/format.c:513:	if (chip->usb_id == USB_ID(0x041e, 0x3000) ||
./sound/usb/format.c:514:	    chip->usb_id == USB_ID(0x041e, 0x3020) ||
./sound/usb/format.c:515:	    chip->usb_id == USB_ID(0x041e, 0x3061)) {
./sound/usb/mixer.c:206:	int len = usb_string(state->chip->dev, index, buf, maxlen - 1);
./sound/usb/mixer.c:321:		if (snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), request,
./sound/usb/mixer.c:363:	ret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), bRequest,
./sound/usb/mixer.c:486:		if (snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer.c:487:				    usb_sndctrlpipe(chip->dev, 0), request,
./sound/usb/mixer.c:583:	while (snd_ctl_find_id(mixer->chip->card, &kctl->id))
./sound/usb/mixer.c:585:	if ((err = snd_ctl_add(mixer->chip->card, kctl)) < 0) {
./sound/usb/mixer.c:849:	switch (chip->usb_id) {
./sound/usb/mixer.c:1082:				snd_ctl_notify(cval->head.mixer->chip->card,
./sound/usb/mixer.c:1322:			check_no_speaker_on_headset(kctl, state->mixer->chip->card);
./sound/usb/mixer.c:1502:	switch (state->chip->usb_id) {
./sound/usb/mixer.c:2265:		if (map->id == state.chip->usb_id) {
./sound/usb/mixer.c:2322:		snd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/usb/mixer.c:2348:	list_for_each_entry(mixer, &chip->mixer_list, list) {
./sound/usb/mixer.c:2351:				chip->usb_id, snd_usb_ctrl_intf(chip),
./sound/usb/mixer.c:2353:		snd_iprintf(buffer, "Card: %s\n", chip->card->longname);
./sound/usb/mixer.c:2410:			snd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
./sound/usb/mixer.c:2481:		urb->dev = mixer->chip->dev;
./sound/usb/mixer.c:2511:	usb_fill_int_urb(mixer->urb, mixer->chip->dev,
./sound/usb/mixer.c:2512:			 usb_rcvintpipe(mixer->chip->dev, epnum),
./sound/usb/mixer.c:2529:	strcpy(chip->card->mixername, "USB Mixer");
./sound/usb/mixer.c:2543:	mixer->hostif = &usb_ifnum_to_if(chip->dev, ctrlif)->altsetting[0];
./sound/usb/mixer.c:2560:	err = snd_device_new(chip->card, SNDRV_DEV_CODEC, mixer, &dev_ops);
./sound/usb/mixer.c:2564:	if (list_empty(&chip->mixer_list) &&
./sound/usb/mixer.c:2565:	    !snd_card_proc_new(chip->card, "usbmixer", &entry))
./sound/usb/mixer.c:2568:	list_add(&mixer->list, &chip->mixer_list);
./sound/usb/mixer_quirks.c:256:		if (rc_configs[i].usb_id == mixer->chip->usb_id)
./sound/usb/mixer_quirks.c:265:	err = snd_hwdep_new(mixer->chip->card, "SB remote control", 0, &hwdep);
./sound/usb/mixer_quirks.c:269:		 "%s remote control", mixer->chip->card->shortname);
./sound/usb/mixer_quirks.c:291:	usb_fill_control_urb(mixer->rc_urb, mixer->chip->dev,
./sound/usb/mixer_quirks.c:292:			     usb_rcvctrlpipe(mixer->chip->dev, 0),
./sound/usb/mixer_quirks.c:316:	if (chip->usb_id == USB_ID(0x041e, 0x3042))
./sound/usb/mixer_quirks.c:317:		err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:318:			      usb_sndctrlpipe(chip->dev, 0), 0x24,
./sound/usb/mixer_quirks.c:322:	if (chip->usb_id == USB_ID(0x041e, 0x30df))
./sound/usb/mixer_quirks.c:323:		err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:324:			      usb_sndctrlpipe(chip->dev, 0), 0x24,
./sound/usb/mixer_quirks.c:328:		err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:329:			      usb_sndctrlpipe(chip->dev, 0), 0x24,
./sound/usb/mixer_quirks.c:385:		if ((mixer->chip->usb_id == USB_ID(0x041e, 0x3042)) && i == 0)
./sound/usb/mixer_quirks.c:388:		if ((mixer->chip->usb_id == USB_ID(0x041e, 0x30df)) && i == 0)
./sound/usb/mixer_quirks.c:391:			(mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||
./sound/usb/mixer_quirks.c:392:			 mixer->chip->usb_id == USB_ID(0x041e, 0x3042) ||
./sound/usb/mixer_quirks.c:393:			 mixer->chip->usb_id == USB_ID(0x041e, 0x30df) ||
./sound/usb/mixer_quirks.c:394:			 mixer->chip->usb_id == USB_ID(0x041e, 0x3048)))
./sound/usb/mixer_quirks.c:432:	snd_iprintf(buffer, "%s jacks\n\n", mixer->chip->card->shortname);
./sound/usb/mixer_quirks.c:433:	if (mixer->chip->usb_id == USB_ID(0x041e, 0x3020))
./sound/usb/mixer_quirks.c:435:	else if (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||
./sound/usb/mixer_quirks.c:436:		 mixer->chip->usb_id == USB_ID(0x041e, 0x3048))
./sound/usb/mixer_quirks.c:446:		err = snd_usb_ctl_msg(mixer->chip->dev,
./sound/usb/mixer_quirks.c:447:				      usb_rcvctrlpipe(mixer->chip->dev, 0),
./sound/usb/mixer_quirks.c:488:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:489:		      usb_sndctrlpipe(chip->dev, 0), UAC_SET_CUR,
./sound/usb/mixer_quirks.c:555:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:556:			      usb_sndctrlpipe(chip->dev, 0), 0x08,
./sound/usb/mixer_quirks.c:625:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:626:				usb_rcvctrlpipe(chip->dev, 0), 0x81,
./sound/usb/mixer_quirks.c:632:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:633:				usb_rcvctrlpipe(chip->dev, 0), 0x81,
./sound/usb/mixer_quirks.c:656:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:657:				usb_sndctrlpipe(chip->dev, 0), 0x1,
./sound/usb/mixer_quirks.c:662:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:663:				usb_rcvctrlpipe(chip->dev, 0), 0x81,
./sound/usb/mixer_quirks.c:669:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:670:				usb_rcvctrlpipe(chip->dev, 0), 0x81,
./sound/usb/mixer_quirks.c:741:	struct usb_device *dev = mixer->chip->dev;
./sound/usb/mixer_quirks.c:776:	err = usb_control_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0),
./sound/usb/mixer_quirks.c:901:	struct usb_device *dev = mixer->chip->dev;
./sound/usb/mixer_quirks.c:941:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:942:			      usb_sndctrlpipe(chip->dev, 0),
./sound/usb/mixer_quirks.c:1172:	list_for_each_entry(mixer, &chip->mixer_list, list) {
./sound/usb/mixer_quirks.c:1198:	switch (mixer->chip->usb_id) {
./sound/usb/mixer_quirks.c:1285:	switch (mixer->chip->usb_id) {
./sound/usb/mixer_quirks.c:1330:	switch (mixer->chip->usb_id) {
./sound/usb/mixer_quirks.c:1521:	iface = usb_ifnum_to_if(chip->dev, 1);
./sound/usb/mixer_quirks.c:1529:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:1530:			usb_rcvctrlpipe(chip->dev, 0),
./sound/usb/mixer_quirks.c:1562:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:1563:			usb_sndctrlpipe(chip->dev, 0),
./sound/usb/mixer_quirks.c:1575:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:1576:			usb_sndctrlpipe(chip->dev, 0),
./sound/usb/mixer_quirks.c:1647:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_quirks.c:1648:			usb_sndctrlpipe(chip->dev, 0),
./sound/usb/mixer_quirks.c:1731:	switch (mixer->chip->usb_id) {
./sound/usb/mixer_quirks.c:1740:		if (!snd_card_proc_new(mixer->chip->card, "audigy2nx", &entry))
./sound/usb/mixer_quirks.c:1813:		mixer->rc_urb->dev = mixer->chip->dev;
./sound/usb/mixer_quirks.c:1823:		if (mixer->chip->usb_id == USB_ID(0x041e, 0x3040) ||
./sound/usb/mixer_quirks.c:1824:		    mixer->chip->usb_id == USB_ID(0x041e, 0x3048))
./sound/usb/mixer_quirks.c:1861:	switch (mixer->chip->usb_id) {
./sound/usb/helper.c:119:	switch (snd_usb_get_speed(chip->dev)) {
./sound/usb/pcm.c:83:	if (atomic_read(&subs->stream->chip->shutdown))
./sound/usb/pcm.c:157:	struct usb_device *dev = chip->dev;
./sound/usb/pcm.c:183:	struct usb_device *dev = chip->dev;
./sound/usb/pcm.c:329:	switch (subs->stream->chip->usb_id) {
./sound/usb/pcm.c:356:	    USB_ID_VENDOR(subs->stream->chip->usb_id) == 0x0582 /* Roland */ &&
./sound/usb/proc.c:49:	if (!atomic_read(&chip->shutdown))
./sound/usb/proc.c:50:		snd_iprintf(buffer, "%03d/%03d\n", chip->dev->bus->busnum, chip->dev->devnum);
./sound/usb/proc.c:56:	if (!atomic_read(&chip->shutdown))
./sound/usb/proc.c:58:			    USB_ID_VENDOR(chip->usb_id),
./sound/usb/proc.c:59:			    USB_ID_PRODUCT(chip->usb_id));
./sound/usb/proc.c:65:	if (!snd_card_proc_new(chip->card, "usbbus", &entry))
./sound/usb/proc.c:67:	if (!snd_card_proc_new(chip->card, "usbid", &entry))
./sound/usb/proc.c:154:	snd_iprintf(buffer, "%s : %s\n", stream->chip->card->longname, stream->pcm->name);
./sound/usb/proc.c:172:	struct snd_card *card = stream->chip->card;
./sound/usb/caiaq/control.c:37:	struct snd_usb_caiaqdev *cdev = caiaqdev(chip->card);
./sound/usb/caiaq/control.c:83:	struct snd_usb_caiaqdev *cdev = caiaqdev(chip->card);
./sound/usb/caiaq/control.c:100:	struct snd_usb_caiaqdev *cdev = caiaqdev(chip->card);
./sound/usb/stream.c:93:	subs->dev = as->chip->dev;
./sound/usb/stream.c:94:	subs->txfr_quirk = as->chip->txfr_quirk;
./sound/usb/stream.c:95:	subs->tx_length_quirk = as->chip->tx_length_quirk;
./sound/usb/stream.c:330:	list_for_each_entry(as, &chip->pcm_list, list) {
./sound/usb/stream.c:342:	list_for_each_entry(as, &chip->pcm_list, list) {
./sound/usb/stream.c:359:	as->pcm_index = chip->pcm_devs;
./sound/usb/stream.c:362:	err = snd_pcm_new(chip->card, "USB Audio", chip->pcm_devs,
./sound/usb/stream.c:374:	if (chip->pcm_devs > 0)
./sound/usb/stream.c:375:		sprintf(pcm->name, "USB Audio #%d", chip->pcm_devs);
./sound/usb/stream.c:385:	if (chip->usb_id == USB_ID(0x0763, 0x2003))
./sound/usb/stream.c:386:		list_add(&as->list, &chip->pcm_list);
./sound/usb/stream.c:388:		list_add_tail(&as->list, &chip->pcm_list);
./sound/usb/stream.c:390:	chip->pcm_devs++;
./sound/usb/stream.c:493:	dev = chip->dev;
./sound/usb/stream.c:504:	if (chip->usb_id == USB_ID(0x04fa, 0x4201))
./sound/usb/stream.c:535:		if (USB_ID_VENDOR(chip->usb_id) == 0x0582 &&
./sound/usb/stream.c:570:			iterm = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,
./sound/usb/stream.c:606:			input_term = snd_usb_find_input_terminal_descriptor(chip->ctrl_intf,
./sound/usb/stream.c:615:			output_term = snd_usb_find_output_terminal_descriptor(chip->ctrl_intf,
./sound/usb/stream.c:684:		switch (chip->usb_id) {
./sound/usb/stream.c:736:		usb_set_interface(chip->dev, iface_no, altno);
./sound/usb/quirks.c:53:		iface = usb_ifnum_to_if(chip->dev, quirk->ifnum);
./sound/usb/quirks.c:65:		iface = usb_ifnum_to_if(chip->dev, quirk->ifnum);
./sound/usb/quirks.c:94:	chip->txfr_quirk = 1;
./sound/usb/quirks.c:103:	return snd_usbmidi_create(chip->card, intf, &chip->midi_list, quirk);
./sound/usb/quirks.c:118:	if (chip->usb_id == USB_ID(0x1686, 0x00dd)) /* Zoom R16/24 */
./sound/usb/quirks.c:119:		chip->tx_length_quirk = 1;
./sound/usb/quirks.c:130:	usb_set_interface(chip->dev, altsd->bInterfaceNumber, 0);
./sound/usb/quirks.c:191:	usb_set_interface(chip->dev, fp->iface, 0);
./sound/usb/quirks.c:346:	switch (USB_ID_VENDOR(chip->usb_id)) {
./sound/usb/quirks.c:390:	ifcount = chip->dev->actconfig->desc.bNumInterfaces;
./sound/usb/quirks.c:394:		iface = usb_ifnum_to_if(chip->dev, ifnum);
./sound/usb/quirks.c:455:			chip->usb_id == USB_ID(0x0582, 0x002b)
./sound/usb/quirks.c:457:		return __snd_usbmidi_create(chip->card, iface,
./sound/usb/quirks.c:458:					  &chip->midi_list, quirk,
./sound/usb/quirks.c:459:					  chip->usb_id);
./sound/usb/quirks.c:502:	usb_set_interface(chip->dev, fp->iface, 0);
./sound/usb/quirks.c:876:	usb_set_interface(chip->dev, iface, 0);
./sound/usb/quirks.c:877:	if (chip->setup & MAUDIO_SET) {
./sound/usb/quirks.c:878:		if (chip->setup & MAUDIO_SET_COMPATIBLE) {
./sound/usb/quirks.c:885:			if ((chip->setup & MAUDIO_SET_96K) && altno != 1)
./sound/usb/quirks.c:887:			mask = chip->setup & MAUDIO_SET_MASK;
./sound/usb/quirks.c:898:		    altno, iface, chip->setup);
./sound/usb/quirks.c:909:	usb_set_interface(chip->dev, iface, 0);
./sound/usb/quirks.c:911:	if (chip->setup & MAUDIO_SET) {
./sound/usb/quirks.c:913:		if ((chip->setup & MAUDIO_SET_DTS) && altno != 6)
./sound/usb/quirks.c:915:		if ((chip->setup & MAUDIO_SET_96K) && altno != 1)
./sound/usb/quirks.c:917:		mask = chip->setup & MAUDIO_SET_MASK;
./sound/usb/quirks.c:937:	usb_set_interface(chip->dev, iface, 0);
./sound/usb/quirks.c:942:	if (chip->setup & (MAUDIO_SET | MAUDIO_SET_24B)) {
./sound/usb/quirks.c:943:		if (chip->setup & MAUDIO_SET_96K) {
./sound/usb/quirks.c:946:		} else if (chip->setup & MAUDIO_SET_DI) {
./sound/usb/quirks.c:965:		    altno, iface, chip->setup);
./sound/usb/quirks.c:974:	if (chip->usb_id == USB_ID(0x0763, 0x2003))
./sound/usb/quirks.c:977:	if (chip->usb_id == USB_ID(0x0763, 0x2001))
./sound/usb/quirks.c:980:	if (chip->usb_id == USB_ID(0x0763, 0x2012))
./sound/usb/quirks.c:1041:	switch (chip->usb_id) {
./sound/usb/quirks.c:1048:		if (chip->setup == 0x00 ||
./sound/usb/quirks.c:1117:	switch (subs->stream->chip->usb_id) {
./sound/usb/quirks.c:1130:	switch (chip->usb_id) {
./sound/usb/quirks.c:1174:	if (is_marantz_denon_dac(subs->stream->chip->usb_id)) {
./sound/usb/quirks.c:1205:	if (USB_ID_VENDOR(ep->chip->usb_id) == 0x23ba &&
./sound/usb/quirks.c:1216:	if ((ep->chip->usb_id == USB_ID(0x0763, 0x2030) ||
./sound/usb/quirks.c:1217:	     ep->chip->usb_id == USB_ID(0x0763, 0x2031)) &&
./sound/usb/quirks.c:1232:	switch (USB_ID_VENDOR(chip->usb_id)) {
./sound/usb/quirks.c:1253:	if (USB_ID_VENDOR(chip->usb_id) == 0x23ba &&
./sound/usb/quirks.c:1261:	if (USB_ID_VENDOR(chip->usb_id) == 0x0644 &&
./sound/usb/quirks.c:1268:	if (is_marantz_denon_dac(chip->usb_id)
./sound/usb/quirks.c:1275:	if (chip->usb_id == USB_ID(0x1686, 0x00dd) &&
./sound/usb/quirks.c:1292:	if (USB_ID_VENDOR(chip->usb_id) == 0x23ba) {
./sound/usb/quirks.c:1307:	switch (chip->usb_id) {
./sound/usb/quirks.c:1329:	if (is_marantz_denon_dac(chip->usb_id)) {
./sound/usb/mixer_scarlett.c:468:	err = snd_usb_ctl_msg(chip->dev,
./sound/usb/mixer_scarlett.c:469:				usb_rcvctrlpipe(chip->dev, 0),
./sound/usb/mixer_scarlett.c:919:	switch (mixer->chip->usb_id) {
./sound/usb/mixer_scarlett.c:995:	err = snd_usb_ctl_msg(mixer->chip->dev,
./sound/usb/mixer_scarlett.c:996:		usb_sndctrlpipe(mixer->chip->dev, 0), UAC2_CS_CUR,
./sound/usb/6fire/control.c:66:	struct comm_runtime *comm_rt = rt->chip->comm;
./sound/usb/6fire/control.c:80:	struct comm_runtime *comm_rt = rt->chip->comm;
./sound/usb/6fire/control.c:88:	struct comm_runtime *comm_rt = rt->chip->comm;
./sound/usb/6fire/control.c:102:	struct comm_runtime *comm_rt = rt->chip->comm;
./sound/usb/6fire/control.c:111:	struct comm_runtime *comm_rt = rt->chip->comm;
./sound/usb/6fire/control.c:121:	struct usb_device *device = rt->chip->dev;
./sound/usb/6fire/control.c:122:	struct comm_runtime *comm_rt = rt->chip->comm;
./sound/usb/6fire/control.c:145:	struct comm_runtime *comm_rt = rt->chip->comm;
./sound/usb/6fire/control.c:166:	struct comm_runtime *comm_rt = rt->chip->comm;
./sound/usb/6fire/control.c:197:		dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/control.c:226:		dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/control.c:245:		dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/control.c:271:		dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/control.c:560:	struct comm_runtime *comm_rt = chip->comm;
./sound/usb/6fire/control.c:584:	ret = usb6fire_control_add_virtual(rt, chip->card,
./sound/usb/6fire/control.c:587:		dev_err(&chip->dev->dev, "cannot add control.\n");
./sound/usb/6fire/control.c:591:	ret = usb6fire_control_add_virtual(rt, chip->card,
./sound/usb/6fire/control.c:594:		dev_err(&chip->dev->dev, "cannot add control.\n");
./sound/usb/6fire/control.c:601:		ret = snd_ctl_add(chip->card, snd_ctl_new1(&elements[i], rt));
./sound/usb/6fire/control.c:604:			dev_err(&chip->dev->dev, "cannot add control.\n");
./sound/usb/6fire/control.c:610:	chip->control = rt;
./sound/usb/6fire/control.c:619:	kfree(chip->control);
./sound/usb/6fire/control.c:620:	chip->control = NULL;
./sound/usb/6fire/midi.c:160:	struct comm_runtime *comm_rt = chip->comm;
./sound/usb/6fire/midi.c:182:	ret = snd_rawmidi_new(chip->card, "6FireUSB", 0, 1, 1, &rt->instance);
./sound/usb/6fire/midi.c:186:		dev_err(&chip->dev->dev, "unable to create midi.\n");
./sound/usb/6fire/midi.c:199:	chip->midi = rt;
./sound/usb/6fire/midi.c:205:	struct midi_runtime *rt = chip->midi;
./sound/usb/6fire/midi.c:213:	struct midi_runtime *rt = chip->midi;
./sound/usb/6fire/midi.c:217:	chip->midi = NULL;
./sound/usb/6fire/pcm.c:77:	struct control_runtime *ctrl_rt = rt->chip->control;
./sound/usb/6fire/pcm.c:82:		dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/pcm.c:90:		dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/pcm.c:99:		dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/pcm.c:108:		dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/pcm.c:130:	dev_err(&rt->chip->dev->dev, "error getting pcm substream slot.\n");
./sound/usb/6fire/pcm.c:138:	struct control_runtime *ctrl_rt = rt->chip->control;
./sound/usb/6fire/pcm.c:263:		dev_err(&rt->chip->dev->dev, "Unknown sample format.");
./sound/usb/6fire/pcm.c:294:	struct pcm_runtime *rt = in_urb->chip->pcm;
./sound/usb/6fire/pcm.c:313:		dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/pcm.c:382:	struct pcm_runtime *rt = urb->chip->pcm;
./sound/usb/6fire/pcm.c:416:		dev_err(&rt->chip->dev->dev, "invalid stream type.\n");
./sound/usb/6fire/pcm.c:487:			dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/pcm.c:501:			dev_err(&rt->chip->dev->dev,
./sound/usb/6fire/pcm.c:580:	urb->instance.dev = chip->dev;
./sound/usb/6fire/pcm.c:581:	urb->instance.pipe = in ? usb_rcvisocpipe(chip->dev, ep)
./sound/usb/6fire/pcm.c:582:			: usb_sndisocpipe(chip->dev, ep);
./sound/usb/6fire/pcm.c:653:	ret = snd_pcm_new(chip->card, "DMX6FireUSB", 0, 1, 1, &pcm);
./sound/usb/6fire/pcm.c:657:		dev_err(&chip->dev->dev, "cannot create pcm instance.\n");
./sound/usb/6fire/pcm.c:669:		dev_err(&chip->dev->dev,
./sound/usb/6fire/pcm.c:675:	chip->pcm = rt;
./sound/usb/6fire/pcm.c:681:	struct pcm_runtime *rt = chip->pcm;
./sound/usb/6fire/pcm.c:703:	struct pcm_runtime *rt = chip->pcm;
./sound/usb/6fire/pcm.c:707:	chip->pcm = NULL;
./sound/usb/6fire/comm.c:30:	urb->pipe = usb_sndintpipe(rt->chip->dev, COMM_EP);
./sound/usb/6fire/comm.c:34:	urb->dev = rt->chip->dev;
./sound/usb/6fire/comm.c:40:	struct midi_runtime *midi_rt = rt->chip->midi;
./sound/usb/6fire/comm.c:50:	if (!rt->chip->shutdown) {
./sound/usb/6fire/comm.c:122:	ret = usb6fire_comm_send_buffer(buffer, rt->chip->dev);
./sound/usb/6fire/comm.c:140:	ret = usb6fire_comm_send_buffer(buffer, rt->chip->dev);
./sound/usb/6fire/comm.c:173:	urb->pipe = usb_rcvintpipe(chip->dev, COMM_EP);
./sound/usb/6fire/comm.c:174:	urb->dev = chip->dev;
./sound/usb/6fire/comm.c:182:		dev_err(&chip->dev->dev, "cannot create comm data receiver.");
./sound/usb/6fire/comm.c:185:	chip->comm = rt;
./sound/usb/6fire/comm.c:191:	struct comm_runtime *rt = chip->comm;
./sound/usb/6fire/comm.c:199:	struct comm_runtime *rt = chip->comm;
./sound/usb/6fire/comm.c:203:	chip->comm = NULL;
./sound/usb/6fire/chip.c:53:		if (chip->pcm)
./sound/usb/6fire/chip.c:55:		if (chip->midi)
./sound/usb/6fire/chip.c:57:		if (chip->comm)
./sound/usb/6fire/chip.c:59:		if (chip->control)
./sound/usb/6fire/chip.c:61:		if (chip->card) {
./sound/usb/6fire/chip.c:62:			snd_card_disconnect(chip->card);
./sound/usb/6fire/chip.c:63:			snd_card_free_when_closed(chip->card);
./sound/usb/6fire/chip.c:64:			chip->card = NULL;
./sound/usb/6fire/chip.c:72:		if (chip->pcm)
./sound/usb/6fire/chip.c:74:		if (chip->midi)
./sound/usb/6fire/chip.c:76:		if (chip->comm)
./sound/usb/6fire/chip.c:78:		if (chip->control)
./sound/usb/6fire/chip.c:80:		if (chip->card)
./sound/usb/6fire/chip.c:81:			snd_card_free(chip->card);
./sound/usb/6fire/chip.c:140:	chip->dev = device;
./sound/usb/6fire/chip.c:141:	chip->regidx = regidx;
./sound/usb/6fire/chip.c:142:	chip->intf_count = 1;
./sound/usb/6fire/chip.c:143:	chip->card = card;
./sound/usb/6fire/chip.c:186:		card = chip->card;
./sound/usb/6fire/chip.c:187:		chip->intf_count--;
./sound/usb/6fire/chip.c:188:		if (!chip->intf_count) {
./sound/usb/6fire/chip.c:190:			devices[chip->regidx] = NULL;
./sound/usb/6fire/chip.c:191:			chips[chip->regidx] = NULL;
./sound/usb/6fire/chip.c:194:			chip->shutdown = true;
./sound/usb/clock.c:90:	ret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0),
./sound/usb/clock.c:108:	ret = snd_usb_ctl_msg(chip->dev, usb_sndctrlpipe(chip->dev, 0),
./sound/usb/clock.c:142:	struct usb_device *dev = chip->dev;
./sound/usb/clock.c:144:		snd_usb_find_clock_source(chip->ctrl_intf, source_id);
./sound/usb/clock.c:188:	source = snd_usb_find_clock_source(chip->ctrl_intf, entity_id);
./sound/usb/clock.c:200:	selector = snd_usb_find_clock_selector(chip->ctrl_intf, entity_id);
./sound/usb/clock.c:223:		if (!validate || ret > 0 || !chip->autoclock)
./sound/usb/clock.c:252:	multiplier = snd_usb_find_clock_multiplier(chip->ctrl_intf, entity_id);
./sound/usb/clock.c:283:	struct usb_device *dev = chip->dev;
./sound/usb/clock.c:313:	if (chip->sample_rate_read_error > 2)
./sound/usb/clock.c:322:		chip->sample_rate_read_error++;
./sound/usb/clock.c:338:	struct usb_device *dev = chip->dev;
./sound/usb/clock.c:360:	struct usb_device *dev = chip->dev;
./sound/usb/clock.c:375:	cs_desc = snd_usb_find_clock_source(chip->ctrl_intf, clock);
./sound/usb/card.c:137:	struct usb_device *dev = chip->dev;
./sound/usb/card.c:155:	if ((chip->usb_id == USB_ID(0x18d1, 0x2d04) ||
./sound/usb/card.c:156:	     chip->usb_id == USB_ID(0x18d1, 0x2d05)) &&
./sound/usb/card.c:177:		int err = __snd_usbmidi_create(chip->card, iface,
./sound/usb/card.c:178:					     &chip->midi_list, NULL,
./sound/usb/card.c:179:					     chip->usb_id);
./sound/usb/card.c:220:	struct usb_device *dev = chip->dev;
./sound/usb/card.c:314:	list_for_each_entry_safe(ep, n, &chip->ep_list, list)
./sound/usb/card.c:317:	mutex_destroy(&chip->mutex);
./sound/usb/card.c:318:	dev_set_drvdata(&chip->dev->dev, NULL);
./sound/usb/card.c:373:	mutex_init(&chip->mutex);
./sound/usb/card.c:374:	init_waitqueue_head(&chip->shutdown_wait);
./sound/usb/card.c:375:	chip->index = idx;
./sound/usb/card.c:376:	chip->dev = dev;
./sound/usb/card.c:377:	chip->card = card;
./sound/usb/card.c:378:	chip->setup = device_setup[idx];
./sound/usb/card.c:379:	chip->autoclock = autoclock;
./sound/usb/card.c:380:	atomic_set(&chip->active, 1); /* avoid autopm during probing */
./sound/usb/card.c:381:	atomic_set(&chip->usage_count, 0);
./sound/usb/card.c:382:	atomic_set(&chip->shutdown, 0);
./sound/usb/card.c:384:	chip->usb_id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
./sound/usb/card.c:386:	INIT_LIST_HEAD(&chip->pcm_list);
./sound/usb/card.c:387:	INIT_LIST_HEAD(&chip->ep_list);
./sound/usb/card.c:388:	INIT_LIST_HEAD(&chip->midi_list);
./sound/usb/card.c:389:	INIT_LIST_HEAD(&chip->mixer_list);
./sound/usb/card.c:399:		USB_ID_VENDOR(chip->usb_id), USB_ID_PRODUCT(chip->usb_id));
./sound/usb/card.c:411:				USB_ID_VENDOR(chip->usb_id),
./sound/usb/card.c:412:				USB_ID_PRODUCT(chip->usb_id));
./sound/usb/card.c:559:			atomic_inc(&chip->active); /* avoid autopm */
./sound/usb/card.c:575:				chip->pm_intf = intf;
./sound/usb/card.c:591:	if (!chip->ctrl_intf)
./sound/usb/card.c:592:		chip->ctrl_intf = alts;
./sound/usb/card.c:594:	chip->txfr_quirk = 0;
./sound/usb/card.c:614:	err = snd_card_register(chip->card);
./sound/usb/card.c:618:	usb_chip[chip->index] = chip;
./sound/usb/card.c:619:	chip->num_interfaces++;
./sound/usb/card.c:621:	atomic_dec(&chip->active);
./sound/usb/card.c:627:		if (!chip->num_interfaces)
./sound/usb/card.c:628:			snd_card_free(chip->card);
./sound/usb/card.c:629:		atomic_dec(&chip->active);
./sound/usb/card.c:648:	card = chip->card;
./sound/usb/card.c:651:	if (atomic_inc_return(&chip->shutdown) == 1) {
./sound/usb/card.c:659:		wait_event(chip->shutdown_wait,
./sound/usb/card.c:660:			   !atomic_read(&chip->usage_count));
./sound/usb/card.c:663:		list_for_each_entry(as, &chip->pcm_list, list) {
./sound/usb/card.c:667:		list_for_each_entry(ep, &chip->ep_list, list) {
./sound/usb/card.c:671:		list_for_each(p, &chip->midi_list) {
./sound/usb/card.c:675:		list_for_each_entry(mixer, &chip->mixer_list, list) {
./sound/usb/card.c:680:	chip->num_interfaces--;
./sound/usb/card.c:681:	if (chip->num_interfaces <= 0) {
./sound/usb/card.c:682:		usb_chip[chip->index] = NULL;
./sound/usb/card.c:695:	atomic_inc(&chip->usage_count);
./sound/usb/card.c:696:	if (atomic_read(&chip->shutdown)) {
./sound/usb/card.c:706:	if (atomic_dec_and_test(&chip->usage_count))
./sound/usb/card.c:707:		wake_up(&chip->shutdown_wait);
./sound/usb/card.c:715:	if (atomic_dec_and_test(&chip->usage_count))
./sound/usb/card.c:716:		wake_up(&chip->shutdown_wait);
./sound/usb/card.c:723:	if (atomic_read(&chip->shutdown))
./sound/usb/card.c:725:	if (atomic_inc_return(&chip->active) == 1)
./sound/usb/card.c:726:		return usb_autopm_get_interface(chip->pm_intf);
./sound/usb/card.c:732:	if (atomic_read(&chip->shutdown))
./sound/usb/card.c:734:	if (atomic_dec_and_test(&chip->active))
./sound/usb/card.c:735:		usb_autopm_put_interface(chip->pm_intf);
./sound/usb/card.c:748:	chip->autosuspended = !!PMSG_IS_AUTO(message);
./sound/usb/card.c:749:	if (!chip->autosuspended)
./sound/usb/card.c:750:		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
./sound/usb/card.c:751:	if (!chip->num_suspended_intf++) {
./sound/usb/card.c:752:		list_for_each_entry(as, &chip->pcm_list, list) {
./sound/usb/card.c:757:		list_for_each(p, &chip->midi_list)
./sound/usb/card.c:759:		list_for_each_entry(mixer, &chip->mixer_list, list)
./sound/usb/card.c:775:	if (--chip->num_suspended_intf)
./sound/usb/card.c:778:	atomic_inc(&chip->active); /* avoid autopm */
./sound/usb/card.c:783:	list_for_each_entry(mixer, &chip->mixer_list, list) {
./sound/usb/card.c:789:	list_for_each(p, &chip->midi_list) {
./sound/usb/card.c:793:	if (!chip->autosuspended)
./sound/usb/card.c:794:		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
./sound/usb/card.c:795:	chip->autosuspended = 0;
./sound/usb/card.c:798:	atomic_dec(&chip->active); /* allow autopm after this point */
./sound/usb/endpoint.c:90:		usb_free_coherent(u->ep->chip->dev, u->buffer_size,
./sound/usb/endpoint.c:196:	if (ep->chip->tx_length_quirk)
./sound/usb/endpoint.c:236:	urb->dev = ep->chip->dev; /* we need to set this at each time */
./sound/usb/endpoint.c:249:		if (snd_usb_get_speed(ep->chip->dev) >= USB_SPEED_HIGH) {
./sound/usb/endpoint.c:285:	urb->dev = ep->chip->dev; /* we need to set this at each time */
./sound/usb/endpoint.c:384:	if (unlikely(atomic_read(&ep->chip->shutdown)))
./sound/usb/endpoint.c:439: * New endpoints will be added to chip->ep_list and must be freed by
./sound/usb/endpoint.c:455:	mutex_lock(&chip->mutex);
./sound/usb/endpoint.c:457:	list_for_each_entry(ep, &chip->ep_list, list) {
./sound/usb/endpoint.c:487:		ep->pipe = usb_sndisocpipe(chip->dev, ep_num);
./sound/usb/endpoint.c:489:		ep->pipe = usb_rcvisocpipe(chip->dev, ep_num);
./sound/usb/endpoint.c:496:		else if (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL)
./sound/usb/endpoint.c:506:		if (chip->usb_id == USB_ID(0x0644, 0x8038) /* TEAC UD-H01 */ &&
./sound/usb/endpoint.c:511:	list_add_tail(&ep->list, &chip->ep_list);
./sound/usb/endpoint.c:514:	mutex_unlock(&chip->mutex);
./sound/usb/endpoint.c:560:	if (!force && atomic_read(&ep->chip->shutdown)) /* to be sure... */
./sound/usb/endpoint.c:600:		usb_free_coherent(ep->chip->dev, SYNC_URBS * 4,
./sound/usb/endpoint.c:623:	int tx_length_quirk = (ep->chip->tx_length_quirk &&
./sound/usb/endpoint.c:677:	if (snd_usb_get_speed(ep->chip->dev) != USB_SPEED_FULL) {
./sound/usb/endpoint.c:707:		if (snd_usb_get_speed(ep->chip->dev) == USB_SPEED_WIRELESS) {
./sound/usb/endpoint.c:769:			usb_alloc_coherent(ep->chip->dev, u->buffer_size,
./sound/usb/endpoint.c:795:	ep->syncbuf = usb_alloc_coherent(ep->chip->dev, SYNC_URBS * 4,
./sound/usb/endpoint.c:871:	if (snd_usb_get_speed(ep->chip->dev) == USB_SPEED_FULL)
./sound/usb/endpoint.c:922:	if (atomic_read(&ep->chip->shutdown))
./sound/usb/hiface/pcm.c:118:	struct usb_device *device = rt->chip->dev;
./sound/usb/hiface/pcm.c:179:	struct device *device = &rt->chip->dev->dev;
./sound/usb/hiface/pcm.c:238:			struct device *device = &rt->chip->dev->dev;
./sound/usb/hiface/pcm.c:264:	struct device *device = &urb->chip->dev->dev;
./sound/usb/hiface/pcm.c:311:	struct pcm_runtime *rt = out_urb->chip->pcm;
./sound/usb/hiface/pcm.c:372:		struct device *device = &rt->chip->dev->dev;
./sound/usb/hiface/pcm.c:539:	usb_fill_bulk_urb(&urb->instance, chip->dev,
./sound/usb/hiface/pcm.c:540:			  usb_sndbulkpipe(chip->dev, ep), (void *)urb->buffer,
./sound/usb/hiface/pcm.c:549:	struct pcm_runtime *rt = chip->pcm;
./sound/usb/hiface/pcm.c:562:	struct pcm_runtime *rt = chip->pcm;
./sound/usb/hiface/pcm.c:568:	kfree(chip->pcm);
./sound/usb/hiface/pcm.c:569:	chip->pcm = NULL;
./sound/usb/hiface/pcm.c:604:	ret = snd_pcm_new(chip->card, "USB-SPDIF Audio", 0, 1, 0, &pcm);
./sound/usb/hiface/pcm.c:607:		dev_err(&chip->dev->dev, "Cannot create pcm instance\n");
./sound/usb/hiface/pcm.c:619:	chip->pcm = rt;
./sound/usb/hiface/chip.c:101:	chip->dev = device;
./sound/usb/hiface/chip.c:102:	chip->card = card;
./sound/usb/hiface/chip.c:145:	ret = snd_card_register(chip->card);
./sound/usb/hiface/chip.c:157:	snd_card_free(chip->card);
./sound/usb/hiface/chip.c:172:	card = chip->card;
./sound/atmel/ac97c.c:98:	snd_pcm_period_elapsed(chip->playback_substream);
./sound/atmel/ac97c.c:104:	snd_pcm_period_elapsed(chip->capture_substream);
./sound/atmel/ac97c.c:121:		dev_dbg(&chip->pdev->dev, "too complex transfer\n");
./sound/atmel/ac97c.c:126:		chan = chip->dma.tx_chan;
./sound/atmel/ac97c.c:128:		chan = chip->dma.rx_chan;
./sound/atmel/ac97c.c:136:		dev_dbg(&chip->pdev->dev, "could not prepare cyclic DMA\n");
./sound/atmel/ac97c.c:142:		set_bit(DMA_TX_READY, &chip->flags);
./sound/atmel/ac97c.c:145:		set_bit(DMA_RX_READY, &chip->flags);
./sound/atmel/ac97c.c:181:	chip->opened++;
./sound/atmel/ac97c.c:183:	if (chip->cur_rate) {
./sound/atmel/ac97c.c:184:		runtime->hw.rate_min = chip->cur_rate;
./sound/atmel/ac97c.c:185:		runtime->hw.rate_max = chip->cur_rate;
./sound/atmel/ac97c.c:187:	if (chip->cur_format)
./sound/atmel/ac97c.c:188:		runtime->hw.formats = pcm_format_to_bits(chip->cur_format);
./sound/atmel/ac97c.c:190:	chip->playback_substream = substream;
./sound/atmel/ac97c.c:200:	chip->opened++;
./sound/atmel/ac97c.c:202:	if (chip->cur_rate) {
./sound/atmel/ac97c.c:203:		runtime->hw.rate_min = chip->cur_rate;
./sound/atmel/ac97c.c:204:		runtime->hw.rate_max = chip->cur_rate;
./sound/atmel/ac97c.c:206:	if (chip->cur_format)
./sound/atmel/ac97c.c:207:		runtime->hw.formats = pcm_format_to_bits(chip->cur_format);
./sound/atmel/ac97c.c:209:	chip->capture_substream = substream;
./sound/atmel/ac97c.c:218:	chip->opened--;
./sound/atmel/ac97c.c:219:	if (!chip->opened) {
./sound/atmel/ac97c.c:220:		chip->cur_rate = 0;
./sound/atmel/ac97c.c:221:		chip->cur_format = 0;
./sound/atmel/ac97c.c:225:	chip->playback_substream = NULL;
./sound/atmel/ac97c.c:235:	chip->opened--;
./sound/atmel/ac97c.c:236:	if (!chip->opened) {
./sound/atmel/ac97c.c:237:		chip->cur_rate = 0;
./sound/atmel/ac97c.c:238:		chip->cur_format = 0;
./sound/atmel/ac97c.c:242:	chip->capture_substream = NULL;
./sound/atmel/ac97c.c:261:			if (test_and_clear_bit(DMA_TX_READY, &chip->flags))
./sound/atmel/ac97c.c:262:				dw_dma_cyclic_free(chip->dma.tx_chan);
./sound/atmel/ac97c.c:266:	chip->cur_rate = params_rate(hw_params);
./sound/atmel/ac97c.c:267:	chip->cur_format = params_format(hw_params);
./sound/atmel/ac97c.c:285:		if (test_and_clear_bit(DMA_RX_READY, &chip->flags))
./sound/atmel/ac97c.c:286:			dw_dma_cyclic_free(chip->dma.rx_chan);
./sound/atmel/ac97c.c:290:	chip->cur_rate = params_rate(hw_params);
./sound/atmel/ac97c.c:291:	chip->cur_format = params_format(hw_params);
./sound/atmel/ac97c.c:301:		if (test_and_clear_bit(DMA_TX_READY, &chip->flags))
./sound/atmel/ac97c.c:302:			dw_dma_cyclic_free(chip->dma.tx_chan);
./sound/atmel/ac97c.c:311:		if (test_and_clear_bit(DMA_RX_READY, &chip->flags))
./sound/atmel/ac97c.c:312:			dw_dma_cyclic_free(chip->dma.rx_chan);
./sound/atmel/ac97c.c:325:	chip->playback_period = 0;
./sound/atmel/ac97c.c:345:	if (chip->opened <= 1)
./sound/atmel/ac97c.c:386:	retval = snd_ac97_set_rate(chip->ac97, AC97_PCM_FRONT_DAC_RATE,
./sound/atmel/ac97c.c:389:		dev_dbg(&chip->pdev->dev, "could not set rate %d Hz\n",
./sound/atmel/ac97c.c:393:		if (!test_bit(DMA_TX_READY, &chip->flags))
./sound/atmel/ac97c.c:398:		writel(runtime->dma_addr, chip->regs + ATMEL_PDC_TPR);
./sound/atmel/ac97c.c:399:		writel(block_size / 2, chip->regs + ATMEL_PDC_TCR);
./sound/atmel/ac97c.c:401:				chip->regs + ATMEL_PDC_TNPR);
./sound/atmel/ac97c.c:402:		writel(block_size / 2, chip->regs + ATMEL_PDC_TNCR);
./sound/atmel/ac97c.c:416:	chip->capture_period = 0;
./sound/atmel/ac97c.c:436:	if (chip->opened <= 1)
./sound/atmel/ac97c.c:477:	retval = snd_ac97_set_rate(chip->ac97, AC97_PCM_LR_ADC_RATE,
./sound/atmel/ac97c.c:480:		dev_dbg(&chip->pdev->dev, "could not set rate %d Hz\n",
./sound/atmel/ac97c.c:484:		if (!test_bit(DMA_RX_READY, &chip->flags))
./sound/atmel/ac97c.c:489:		writel(runtime->dma_addr, chip->regs + ATMEL_PDC_RPR);
./sound/atmel/ac97c.c:490:		writel(block_size / 2, chip->regs + ATMEL_PDC_RCR);
./sound/atmel/ac97c.c:492:				chip->regs + ATMEL_PDC_RNPR);
./sound/atmel/ac97c.c:493:		writel(block_size / 2, chip->regs + ATMEL_PDC_RNCR);
./sound/atmel/ac97c.c:513:			retval = dw_dma_cyclic_start(chip->dma.tx_chan);
./sound/atmel/ac97c.c:525:			dw_dma_cyclic_stop(chip->dma.tx_chan);
./sound/atmel/ac97c.c:528:		if (chip->opened <= 1)
./sound/atmel/ac97c.c:538:		writel(ptcr, chip->regs + ATMEL_PDC_PTCR);
./sound/atmel/ac97c.c:551:	ptcr = readl(chip->regs + ATMEL_PDC_PTSR);
./sound/atmel/ac97c.c:558:			retval = dw_dma_cyclic_start(chip->dma.rx_chan);
./sound/atmel/ac97c.c:570:			dw_dma_cyclic_stop(chip->dma.rx_chan);
./sound/atmel/ac97c.c:573:		if (chip->opened <= 1)
./sound/atmel/ac97c.c:583:		writel(ptcr, chip->regs + ATMEL_PDC_PTCR);
./sound/atmel/ac97c.c:597:		bytes = dw_dma_get_src_addr(chip->dma.tx_chan);
./sound/atmel/ac97c.c:599:		bytes = readl(chip->regs + ATMEL_PDC_TPR);
./sound/atmel/ac97c.c:617:		bytes = dw_dma_get_dst_addr(chip->dma.rx_chan);
./sound/atmel/ac97c.c:619:		bytes = readl(chip->regs + ATMEL_PDC_RPR);
./sound/atmel/ac97c.c:662:		dev_dbg(&chip->pdev->dev, "channel A event%s%s%s%s%s%s\n",
./sound/atmel/ac97c.c:671:				runtime = chip->playback_substream->runtime;
./sound/atmel/ac97c.c:674:				chip->playback_period++;
./sound/atmel/ac97c.c:676:				if (chip->playback_period == runtime->periods)
./sound/atmel/ac97c.c:677:					chip->playback_period = 0;
./sound/atmel/ac97c.c:678:				next_period = chip->playback_period + 1;
./sound/atmel/ac97c.c:685:						chip->regs + ATMEL_PDC_TNPR);
./sound/atmel/ac97c.c:687:						chip->regs + ATMEL_PDC_TNCR);
./sound/atmel/ac97c.c:690:						chip->playback_substream);
./sound/atmel/ac97c.c:693:				runtime = chip->capture_substream->runtime;
./sound/atmel/ac97c.c:696:				chip->capture_period++;
./sound/atmel/ac97c.c:698:				if (chip->capture_period == runtime->periods)
./sound/atmel/ac97c.c:699:					chip->capture_period = 0;
./sound/atmel/ac97c.c:700:				next_period = chip->capture_period + 1;
./sound/atmel/ac97c.c:707:						chip->regs + ATMEL_PDC_RNPR);
./sound/atmel/ac97c.c:709:						chip->regs + ATMEL_PDC_RNCR);
./sound/atmel/ac97c.c:710:				snd_pcm_period_elapsed(chip->capture_substream);
./sound/atmel/ac97c.c:717:		dev_info(&chip->pdev->dev, "codec channel event%s%s%s%s%s\n",
./sound/atmel/ac97c.c:727:		dev_err(&chip->pdev->dev, "spurious interrupt sr 0x%08x "
./sound/atmel/ac97c.c:768:	capture = test_bit(DMA_RX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:769:	playback = test_bit(DMA_TX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:772:		err = snd_ac97_pcm_assign(chip->ac97_bus,
./sound/atmel/ac97c.c:778:	retval = snd_pcm_new(chip->card, chip->card->shortname,
./sound/atmel/ac97c.c:791:			&chip->pdev->dev, hw.periods_min * hw.period_bytes_min,
./sound/atmel/ac97c.c:798:	strcpy(pcm->name, chip->card->shortname);
./sound/atmel/ac97c.c:799:	chip->pcm = pcm;
./sound/atmel/ac97c.c:809:	return snd_ac97_mixer(chip->ac97_bus, &template, &chip->ac97);
./sound/atmel/ac97c.c:829:	dev_dbg(&chip->pdev->dev, "codec write timeout\n");
./sound/atmel/ac97c.c:874:	dev_dbg(&chip->pdev->dev, "codec read timeout\n");
./sound/atmel/ac97c.c:896:	if (gpio_is_valid(chip->reset_pin)) {
./sound/atmel/ac97c.c:897:		gpio_set_value(chip->reset_pin, 0);
./sound/atmel/ac97c.c:900:		gpio_set_value(chip->reset_pin, 1);
./sound/atmel/ac97c.c:1001:	chip->irq = irq;
./sound/atmel/ac97c.c:1003:	spin_lock_init(&chip->lock);
./sound/atmel/ac97c.c:1009:	chip->card = card;
./sound/atmel/ac97c.c:1010:	chip->pclk = pclk;
./sound/atmel/ac97c.c:1011:	chip->pdev = pdev;
./sound/atmel/ac97c.c:1012:	chip->regs = ioremap(regs->start, resource_size(regs));
./sound/atmel/ac97c.c:1014:	if (!chip->regs) {
./sound/atmel/ac97c.c:1023:			chip->reset_pin = -ENODEV;
./sound/atmel/ac97c.c:1026:			chip->reset_pin = pdata->reset_pin;
./sound/atmel/ac97c.c:1029:		chip->reset_pin = -EINVAL;
./sound/atmel/ac97c.c:1038:	retval = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus);
./sound/atmel/ac97c.c:1057:			chip->dma.rx_chan = dma_request_channel(mask, filter,
./sound/atmel/ac97c.c:1059:			if (chip->dma.rx_chan) {
./sound/atmel/ac97c.c:1071:				dmaengine_slave_config(chip->dma.rx_chan,
./sound/atmel/ac97c.c:1075:			dev_info(&chip->pdev->dev, "using %s for DMA RX\n",
./sound/atmel/ac97c.c:1076:				dev_name(&chip->dma.rx_chan->dev->device));
./sound/atmel/ac97c.c:1077:			set_bit(DMA_RX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:1086:			chip->dma.tx_chan = dma_request_channel(mask, filter,
./sound/atmel/ac97c.c:1088:			if (chip->dma.tx_chan) {
./sound/atmel/ac97c.c:1100:				dmaengine_slave_config(chip->dma.tx_chan,
./sound/atmel/ac97c.c:1104:			dev_info(&chip->pdev->dev, "using %s for DMA TX\n",
./sound/atmel/ac97c.c:1105:				dev_name(&chip->dma.tx_chan->dev->device));
./sound/atmel/ac97c.c:1106:			set_bit(DMA_TX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:1109:		if (!test_bit(DMA_RX_CHAN_PRESENT, &chip->flags) &&
./sound/atmel/ac97c.c:1110:				!test_bit(DMA_TX_CHAN_PRESENT, &chip->flags)) {
./sound/atmel/ac97c.c:1118:		set_bit(DMA_RX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:1119:		set_bit(DMA_TX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:1137:			chip->regs, irq);
./sound/atmel/ac97c.c:1143:		if (test_bit(DMA_RX_CHAN_PRESENT, &chip->flags))
./sound/atmel/ac97c.c:1144:			dma_release_channel(chip->dma.rx_chan);
./sound/atmel/ac97c.c:1145:		if (test_bit(DMA_TX_CHAN_PRESENT, &chip->flags))
./sound/atmel/ac97c.c:1146:			dma_release_channel(chip->dma.tx_chan);
./sound/atmel/ac97c.c:1147:		clear_bit(DMA_RX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:1148:		clear_bit(DMA_TX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:1149:		chip->dma.rx_chan = NULL;
./sound/atmel/ac97c.c:1150:		chip->dma.tx_chan = NULL;
./sound/atmel/ac97c.c:1153:	if (gpio_is_valid(chip->reset_pin))
./sound/atmel/ac97c.c:1154:		gpio_free(chip->reset_pin);
./sound/atmel/ac97c.c:1156:	iounmap(chip->regs);
./sound/atmel/ac97c.c:1174:		if (test_bit(DMA_RX_READY, &chip->flags))
./sound/atmel/ac97c.c:1175:			dw_dma_cyclic_stop(chip->dma.rx_chan);
./sound/atmel/ac97c.c:1176:		if (test_bit(DMA_TX_READY, &chip->flags))
./sound/atmel/ac97c.c:1177:			dw_dma_cyclic_stop(chip->dma.tx_chan);
./sound/atmel/ac97c.c:1179:	clk_disable_unprepare(chip->pclk);
./sound/atmel/ac97c.c:1189:	clk_prepare_enable(chip->pclk);
./sound/atmel/ac97c.c:1191:		if (test_bit(DMA_RX_READY, &chip->flags))
./sound/atmel/ac97c.c:1192:			dw_dma_cyclic_start(chip->dma.rx_chan);
./sound/atmel/ac97c.c:1193:		if (test_bit(DMA_TX_READY, &chip->flags))
./sound/atmel/ac97c.c:1194:			dw_dma_cyclic_start(chip->dma.tx_chan);
./sound/atmel/ac97c.c:1210:	if (gpio_is_valid(chip->reset_pin))
./sound/atmel/ac97c.c:1211:		gpio_free(chip->reset_pin);
./sound/atmel/ac97c.c:1217:	clk_disable_unprepare(chip->pclk);
./sound/atmel/ac97c.c:1218:	clk_put(chip->pclk);
./sound/atmel/ac97c.c:1219:	iounmap(chip->regs);
./sound/atmel/ac97c.c:1220:	free_irq(chip->irq, chip);
./sound/atmel/ac97c.c:1223:		if (test_bit(DMA_RX_CHAN_PRESENT, &chip->flags))
./sound/atmel/ac97c.c:1224:			dma_release_channel(chip->dma.rx_chan);
./sound/atmel/ac97c.c:1225:		if (test_bit(DMA_TX_CHAN_PRESENT, &chip->flags))
./sound/atmel/ac97c.c:1226:			dma_release_channel(chip->dma.tx_chan);
./sound/atmel/ac97c.c:1227:		clear_bit(DMA_RX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:1228:		clear_bit(DMA_TX_CHAN_PRESENT, &chip->flags);
./sound/atmel/ac97c.c:1229:		chip->dma.rx_chan = NULL;
./sound/atmel/ac97c.c:1230:		chip->dma.tx_chan = NULL;
./sound/sh/sh_dac_audio.c:71:	hrtimer_start(&chip->hrtimer, chip->wakeups_per_second,
./sound/sh/sh_dac_audio.c:77:	hrtimer_cancel(&chip->hrtimer);
./sound/sh/sh_dac_audio.c:83:	chip->buffer_begin = chip->buffer_end = chip->data_buffer;
./sound/sh/sh_dac_audio.c:84:	chip->processed = 0;
./sound/sh/sh_dac_audio.c:85:	chip->empty = 1;
./sound/sh/sh_dac_audio.c:90:	chip->wakeups_per_second = ktime_set(0, 1000000000 / chip->rate);
./sound/sh/sh_dac_audio.c:121:	chip->substream = substream;
./sound/sh/sh_dac_audio.c:122:	chip->buffer_begin = chip->buffer_end = chip->data_buffer;
./sound/sh/sh_dac_audio.c:123:	chip->processed = 0;
./sound/sh/sh_dac_audio.c:124:	chip->empty = 1;
./sound/sh/sh_dac_audio.c:126:	chip->pdata->start(chip->pdata);
./sound/sh/sh_dac_audio.c:135:	chip->substream = NULL;
./sound/sh/sh_dac_audio.c:138:	chip->pdata->stop(chip->pdata);
./sound/sh/sh_dac_audio.c:158:	struct snd_pcm_runtime *runtime = chip->substream->runtime;
./sound/sh/sh_dac_audio.c:160:	chip->buffer_size = runtime->buffer_size;
./sound/sh/sh_dac_audio.c:161:	memset(chip->data_buffer, 0, chip->pdata->buffer_size);
./sound/sh/sh_dac_audio.c:175:		chip->buffer_begin = chip->buffer_end = chip->data_buffer;
./sound/sh/sh_dac_audio.c:176:		chip->processed = 0;
./sound/sh/sh_dac_audio.c:177:		chip->empty = 1;
./sound/sh/sh_dac_audio.c:202:	memcpy_toio(chip->data_buffer + b_pos, src, b_count);
./sound/sh/sh_dac_audio.c:203:	chip->buffer_end = chip->data_buffer + b_pos + b_count;
./sound/sh/sh_dac_audio.c:205:	if (chip->empty) {
./sound/sh/sh_dac_audio.c:206:		chip->empty = 0;
./sound/sh/sh_dac_audio.c:229:	memset_io(chip->data_buffer + b_pos, 0, b_count);
./sound/sh/sh_dac_audio.c:230:	chip->buffer_end = chip->data_buffer + b_pos + b_count;
./sound/sh/sh_dac_audio.c:232:	if (chip->empty) {
./sound/sh/sh_dac_audio.c:233:		chip->empty = 0;
./sound/sh/sh_dac_audio.c:244:	int pointer = chip->buffer_begin - chip->data_buffer;
./sound/sh/sh_dac_audio.c:270:	err = snd_pcm_new(chip->card, "SH_DAC PCM", device, 1, 0, &pcm);
./sound/sh/sh_dac_audio.c:300:	kfree(chip->data_buffer);
./sound/sh/sh_dac_audio.c:317:	struct snd_pcm_runtime *runtime = chip->substream->runtime;
./sound/sh/sh_dac_audio.c:320:	if (!chip->empty) {
./sound/sh/sh_dac_audio.c:321:		sh_dac_output(*chip->buffer_begin, chip->pdata->channel);
./sound/sh/sh_dac_audio.c:322:		chip->buffer_begin++;
./sound/sh/sh_dac_audio.c:324:		chip->processed++;
./sound/sh/sh_dac_audio.c:325:		if (chip->processed >= b_ps) {
./sound/sh/sh_dac_audio.c:326:			chip->processed -= b_ps;
./sound/sh/sh_dac_audio.c:327:			snd_pcm_period_elapsed(chip->substream);
./sound/sh/sh_dac_audio.c:330:		if (chip->buffer_begin == (chip->data_buffer +
./sound/sh/sh_dac_audio.c:331:					   chip->buffer_size - 1))
./sound/sh/sh_dac_audio.c:332:			chip->buffer_begin = chip->data_buffer;
./sound/sh/sh_dac_audio.c:334:		if (chip->buffer_begin == chip->buffer_end)
./sound/sh/sh_dac_audio.c:335:			chip->empty = 1;
./sound/sh/sh_dac_audio.c:339:	if (!chip->empty)
./sound/sh/sh_dac_audio.c:340:		hrtimer_start(&chip->hrtimer, chip->wakeups_per_second,
./sound/sh/sh_dac_audio.c:346:/* create  --  chip-specific constructor for the cards components */
./sound/sh/sh_dac_audio.c:364:	chip->card = card;
./sound/sh/sh_dac_audio.c:366:	hrtimer_init(&chip->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
./sound/sh/sh_dac_audio.c:367:	chip->hrtimer.function = sh_dac_audio_timer;
./sound/sh/sh_dac_audio.c:370:	chip->rate = 8000;
./sound/sh/sh_dac_audio.c:373:	chip->pdata = devptr->dev.platform_data;
./sound/sh/sh_dac_audio.c:375:	chip->data_buffer = kmalloc(chip->pdata->buffer_size, GFP_KERNEL);
./sound/sh/sh_dac_audio.c:376:	if (chip->data_buffer == NULL) {
./sound/soc/codecs/88pm860x-codec.c:1385:	pm860x->i2c = (chip->id == CHIP_PM8607) ? chip->client
./sound/soc/codecs/88pm860x-codec.c:1386:			: chip->companion;
./sound/soc/codecs/88pm860x-codec.c:1387:	pm860x->regmap = (chip->id == CHIP_PM8607) ? chip->regmap
./sound/soc/codecs/88pm860x-codec.c:1388:			: chip->regmap_companion;
./sound/soc/codecs/88pm860x-codec.c:1397:		pm860x->irq[i] = res->start + chip->irq_base;
./sound/soc/codecs/tas571x.c:62:		return priv->chip->vol_reg_size;
./sound/soc/codecs/tas571x.c:521:	BUG_ON(priv->chip->num_supply_names > TAS571X_MAX_SUPPLIES);
./sound/soc/codecs/tas571x.c:522:	for (i = 0; i < priv->chip->num_supply_names; i++)
./sound/soc/codecs/tas571x.c:523:		priv->supplies[i].supply = priv->chip->supply_names[i];
./sound/soc/codecs/tas571x.c:525:	ret = devm_regulator_bulk_get(dev, priv->chip->num_supply_names,
./sound/soc/codecs/tas571x.c:531:	ret = regulator_bulk_enable(priv->chip->num_supply_names,
./sound/soc/codecs/tas571x.c:539:					priv->chip->regmap_config);
./sound/soc/codecs/tas571x.c:569:	priv->codec_driver.controls = priv->chip->controls;
./sound/soc/codecs/tas571x.c:570:	priv->codec_driver.num_controls = priv->chip->num_controls;
./sound/soc/codecs/tas571x.c:572:	if (priv->chip->vol_reg_size == 2) {
./sound/soc/codecs/tas571x.c:595:	regulator_bulk_disable(priv->chip->num_supply_names, priv->supplies);
./sound/soc/rockchip/rockchip_max98090.c:34:#define DRV_NAME "rockchip-snd-max98090"
./sound/soc/rockchip/rockchip_max98090.c:222:	{ .compatible = "rockchip,rockchip-audio-max98090", },
./sound/soc/rockchip/rockchip_rt5645.c:33:#define DRV_NAME "rockchip-snd-rt5645"
./sound/soc/rockchip/rockchip_rt5645.c:211:	{ .compatible = "rockchip,rockchip-audio-rt5645", },
./sound/soc/rockchip/rockchip_spdif.c:229:	.name = "rockchip-spdif",
./sound/soc/rockchip/rockchip_spdif.c:404:		.name = "rockchip-spdif",
./sound/soc/rockchip/rockchip_spdif.c:411:MODULE_ALIAS("platform:rockchip-spdif");
./sound/soc/rockchip/rockchip_i2s.c:24:#define DRV_NAME "rockchip-i2s"
./sound/soc/intel/common/sst-firmware.c:195:	chip->irq = irq;
./sound/soc/intel/common/sst-firmware.c:196:	chip->regs = devm_ioremap_resource(dev, mem);
./sound/soc/intel/common/sst-firmware.c:197:	if (IS_ERR(chip->regs))
./sound/soc/intel/common/sst-firmware.c:198:		return ERR_CAST(chip->regs);
./sound/soc/intel/common/sst-firmware.c:204:	chip->dev = dev;
./sound/spi/at73c213.c:98:	chip->spi_wbuffer[0] = reg;
./sound/spi/at73c213.c:99:	chip->spi_wbuffer[1] = val;
./sound/spi/at73c213.c:101:	msg_xfer.tx_buf = chip->spi_wbuffer;
./sound/spi/at73c213.c:102:	msg_xfer.rx_buf = chip->spi_rbuffer;
./sound/spi/at73c213.c:105:	retval = spi_sync(chip->spi, &msg);
./sound/spi/at73c213.c:108:		chip->reg_image[reg] = val;
./sound/spi/at73c213.c:118:	.rate_min	= 8000,  /* Replaced by chip->bitrate later. */
./sound/spi/at73c213.c:119:	.rate_max	= 50000, /* Replaced by chip->bitrate later. */
./sound/spi/at73c213.c:134:	unsigned long ssc_rate = clk_get_rate(chip->ssc->clk);
./sound/spi/at73c213.c:176:		status = clk_round_rate(chip->board->dac_clk, dac_rate_new);
./sound/spi/at73c213.c:191:	status = clk_set_rate(chip->board->dac_clk, status);
./sound/spi/at73c213.c:196:	ssc_writel(chip->ssc->regs, CMR, ssc_div/2);
./sound/spi/at73c213.c:199:	chip->bitrate = ssc_rate / (ssc_div * 16 * 2);
./sound/spi/at73c213.c:201:	dev_info(&chip->spi->dev,
./sound/spi/at73c213.c:203:			chip->bitrate, ssc_div);
./sound/spi/at73c213.c:219:	snd_at73c213_playback_hw.rate_min = chip->bitrate;
./sound/spi/at73c213.c:220:	snd_at73c213_playback_hw.rate_max = chip->bitrate;
./sound/spi/at73c213.c:222:	chip->substream = substream;
./sound/spi/at73c213.c:224:	clk_enable(chip->ssc->clk);
./sound/spi/at73c213.c:232:	chip->substream = NULL;
./sound/spi/at73c213.c:233:	clk_disable(chip->ssc->clk);
./sound/spi/at73c213.c:244:	val = ssc_readl(chip->ssc->regs, TFMR);
./sound/spi/at73c213.c:246:	ssc_writel(chip->ssc->regs, TFMR, val);
./sound/spi/at73c213.c:265:	chip->period = 0;
./sound/spi/at73c213.c:267:	ssc_writel(chip->ssc->regs, PDC_TPR,
./sound/spi/at73c213.c:269:	ssc_writel(chip->ssc->regs, PDC_TCR,
./sound/spi/at73c213.c:271:	ssc_writel(chip->ssc->regs, PDC_TNPR,
./sound/spi/at73c213.c:273:	ssc_writel(chip->ssc->regs, PDC_TNCR,
./sound/spi/at73c213.c:285:	spin_lock(&chip->lock);
./sound/spi/at73c213.c:289:		ssc_writel(chip->ssc->regs, IER, SSC_BIT(IER_ENDTX));
./sound/spi/at73c213.c:290:		ssc_writel(chip->ssc->regs, PDC_PTCR, SSC_BIT(PDC_PTCR_TXTEN));
./sound/spi/at73c213.c:293:		ssc_writel(chip->ssc->regs, PDC_PTCR, SSC_BIT(PDC_PTCR_TXTDIS));
./sound/spi/at73c213.c:294:		ssc_writel(chip->ssc->regs, IDR, SSC_BIT(IDR_ENDTX));
./sound/spi/at73c213.c:297:		dev_dbg(&chip->spi->dev, "spurious command %x\n", cmd);
./sound/spi/at73c213.c:302:	spin_unlock(&chip->lock);
./sound/spi/at73c213.c:315:	bytes = ssc_readl(chip->ssc->regs, PDC_TPR)
./sound/spi/at73c213.c:341:	retval = snd_pcm_new(chip->card, chip->card->shortname,
./sound/spi/at73c213.c:349:	chip->pcm = pcm;
./sound/spi/at73c213.c:353:	retval = snd_pcm_lib_preallocate_pages_for_all(chip->pcm,
./sound/spi/at73c213.c:354:			SNDRV_DMA_TYPE_DEV, &chip->ssc->pdev->dev,
./sound/spi/at73c213.c:363:	struct snd_pcm_runtime *runtime = chip->substream->runtime;
./sound/spi/at73c213.c:370:	spin_lock(&chip->lock);
./sound/spi/at73c213.c:373:	status = ssc_readl(chip->ssc->regs, IMR);
./sound/spi/at73c213.c:376:		chip->period++;
./sound/spi/at73c213.c:377:		if (chip->period == runtime->periods)
./sound/spi/at73c213.c:378:			chip->period = 0;
./sound/spi/at73c213.c:379:		next_period = chip->period + 1;
./sound/spi/at73c213.c:385:		ssc_writel(chip->ssc->regs, PDC_TNPR,
./sound/spi/at73c213.c:387:		ssc_writel(chip->ssc->regs, PDC_TNCR,
./sound/spi/at73c213.c:392:	ssc_readl(chip->ssc->regs, IMR);
./sound/spi/at73c213.c:393:	spin_unlock(&chip->lock);
./sound/spi/at73c213.c:396:		snd_pcm_period_elapsed(chip->substream);
./sound/spi/at73c213.c:413:	mutex_lock(&chip->mixer_lock);
./sound/spi/at73c213.c:416:		(chip->reg_image[reg] >> shift) & mask;
./sound/spi/at73c213.c:422:	mutex_unlock(&chip->mixer_lock);
./sound/spi/at73c213.c:443:	mutex_lock(&chip->mixer_lock);
./sound/spi/at73c213.c:445:	val = (chip->reg_image[reg] & ~(mask << shift)) | val;
./sound/spi/at73c213.c:446:	change = val != chip->reg_image[reg];
./sound/spi/at73c213.c:449:	mutex_unlock(&chip->mixer_lock);
./sound/spi/at73c213.c:485:	mutex_lock(&chip->mixer_lock);
./sound/spi/at73c213.c:488:		(chip->reg_image[left_reg] >> shift_left) & mask;
./sound/spi/at73c213.c:490:		(chip->reg_image[right_reg] >> shift_right) & mask;
./sound/spi/at73c213.c:499:	mutex_unlock(&chip->mixer_lock);
./sound/spi/at73c213.c:526:	mutex_lock(&chip->mixer_lock);
./sound/spi/at73c213.c:528:	val1 = (chip->reg_image[left_reg] & ~(mask << shift_left)) | val1;
./sound/spi/at73c213.c:529:	val2 = (chip->reg_image[right_reg] & ~(mask << shift_right)) | val2;
./sound/spi/at73c213.c:530:	change = val1 != chip->reg_image[left_reg]
./sound/spi/at73c213.c:531:		|| val2 != chip->reg_image[right_reg];
./sound/spi/at73c213.c:534:		mutex_unlock(&chip->mixer_lock);
./sound/spi/at73c213.c:539:		mutex_unlock(&chip->mixer_lock);
./sound/spi/at73c213.c:543:	mutex_unlock(&chip->mixer_lock);
./sound/spi/at73c213.c:561:	mutex_lock(&chip->mixer_lock);
./sound/spi/at73c213.c:564:		(chip->reg_image[reg] >> shift) & 0x01;
./sound/spi/at73c213.c:570:	mutex_unlock(&chip->mixer_lock);
./sound/spi/at73c213.c:595:	mutex_lock(&chip->mixer_lock);
./sound/spi/at73c213.c:597:	val |= (chip->reg_image[reg] & ~(mask << shift));
./sound/spi/at73c213.c:598:	change = val != chip->reg_image[reg];
./sound/spi/at73c213.c:602:	mutex_unlock(&chip->mixer_lock);
./sound/spi/at73c213.c:720:	if (chip == NULL || chip->pcm == NULL)
./sound/spi/at73c213.c:723:	card = chip->card;
./sound/spi/at73c213.c:725:	strcpy(card->mixername, chip->pcm->name);
./sound/spi/at73c213.c:758:	ssc_writel(chip->ssc->regs, TCMR,
./sound/spi/at73c213.c:770:	ssc_writel(chip->ssc->regs, TFMR,
./sound/spi/at73c213.c:790:	clk_enable(chip->board->dac_clk);
./sound/spi/at73c213.c:862:	ssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXEN));
./sound/spi/at73c213.c:867:	clk_disable(chip->board->dac_clk);
./sound/spi/at73c213.c:876:	ssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXDIS));
./sound/spi/at73c213.c:877:	if (chip->irq >= 0) {
./sound/spi/at73c213.c:878:		free_irq(chip->irq, chip);
./sound/spi/at73c213.c:879:		chip->irq = -1;
./sound/spi/at73c213.c:894:	irq = chip->ssc->irq;
./sound/spi/at73c213.c:898:	spin_lock_init(&chip->lock);
./sound/spi/at73c213.c:899:	mutex_init(&chip->mixer_lock);
./sound/spi/at73c213.c:900:	chip->card = card;
./sound/spi/at73c213.c:901:	chip->irq = -1;
./sound/spi/at73c213.c:903:	clk_enable(chip->ssc->clk);
./sound/spi/at73c213.c:907:		dev_dbg(&chip->spi->dev, "unable to request irq %d\n", irq);
./sound/spi/at73c213.c:910:	chip->irq = irq;
./sound/spi/at73c213.c:912:	memcpy(&chip->reg_image, &snd_at73c213_original_image,
./sound/spi/at73c213.c:940:	free_irq(chip->irq, chip);
./sound/spi/at73c213.c:941:	chip->irq = -1;
./sound/spi/at73c213.c:943:	clk_disable(chip->ssc->clk);
./sound/spi/at73c213.c:980:	chip->spi = spi;
./sound/spi/at73c213.c:981:	chip->board = board;
./sound/spi/at73c213.c:983:	chip->ssc = ssc_request(board->ssc_id);
./sound/spi/at73c213.c:984:	if (IS_ERR(chip->ssc)) {
./sound/spi/at73c213.c:987:		retval = PTR_ERR(chip->ssc);
./sound/spi/at73c213.c:997:	sprintf(card->longname, "%s on irq %d", card->shortname, chip->irq);
./sound/spi/at73c213.c:1008:	ssc_free(chip->ssc);
./sound/spi/at73c213.c:1022:	clk_enable(chip->ssc->clk);
./sound/spi/at73c213.c:1023:	ssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXDIS));
./sound/spi/at73c213.c:1024:	clk_disable(chip->ssc->clk);
./sound/spi/at73c213.c:1051:					chip->reg_image[PA_CTRL] | 0x0f);
./sound/spi/at73c213.c:1076:	clk_disable(chip->board->dac_clk);
./sound/spi/at73c213.c:1078:	ssc_free(chip->ssc);
./sound/spi/at73c213.c:1091:	ssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXDIS));
./sound/spi/at73c213.c:1092:	clk_disable(chip->ssc->clk);
./sound/spi/at73c213.c:1093:	clk_disable(chip->board->dac_clk);
./sound/spi/at73c213.c:1103:	clk_enable(chip->board->dac_clk);
./sound/spi/at73c213.c:1104:	clk_enable(chip->ssc->clk);
./sound/spi/at73c213.c:1105:	ssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXEN));
./sound/mips/sgio2audio.c:93:/* definition of the chip-specific record */
./sound/mips/sgio2audio.c:122:	spin_lock_irqsave(&chip->ad1843_lock, flags);
./sound/mips/sgio2audio.c:132:	spin_unlock_irqrestore(&chip->ad1843_lock, flags);
./sound/mips/sgio2audio.c:145:	spin_lock_irqsave(&chip->ad1843_lock, flags);
./sound/mips/sgio2audio.c:154:	spin_unlock_irqrestore(&chip->ad1843_lock, flags);
./sound/mips/sgio2audio.c:166:	uinfo->value.integer.max = ad1843_get_gain_max(&chip->ad1843,
./sound/mips/sgio2audio.c:177:	vol = ad1843_get_gain(&chip->ad1843, (int)kcontrol->private_value);
./sound/mips/sgio2audio.c:191:	oldvol = ad1843_get_gain(&chip->ad1843, kcontrol->private_value);
./sound/mips/sgio2audio.c:195:	newvol = ad1843_set_gain(&chip->ad1843, kcontrol->private_value,
./sound/mips/sgio2audio.c:215:	ucontrol->value.enumerated.item[0] = ad1843_get_recsrc(&chip->ad1843);
./sound/mips/sgio2audio.c:225:	oldsrc = ad1843_get_recsrc(&chip->ad1843);
./sound/mips/sgio2audio.c:226:	newsrc = ad1843_set_recsrc(&chip->ad1843,
./sound/mips/sgio2audio.c:317:	err = snd_ctl_add(chip->card,
./sound/mips/sgio2audio.c:322:	err = snd_ctl_add(chip->card,
./sound/mips/sgio2audio.c:327:	err = snd_ctl_add(chip->card,
./sound/mips/sgio2audio.c:332:	err = snd_ctl_add(chip->card,
./sound/mips/sgio2audio.c:336:	err = snd_ctl_add(chip->card,
./sound/mips/sgio2audio.c:341:	err = snd_ctl_add(chip->card,
./sound/mips/sgio2audio.c:346:	err = snd_ctl_add(chip->card,
./sound/mips/sgio2audio.c:369:	struct snd_pcm_runtime *runtime = chip->channel[ch].substream->runtime;
./sound/mips/sgio2audio.c:371:	spin_lock_irqsave(&chip->channel[ch].lock, flags);
./sound/mips/sgio2audio.c:373:	src_base = (unsigned long) chip->ring_base | (ch << CHANNEL_RING_SHIFT);
./sound/mips/sgio2audio.c:376:	dst_pos = chip->channel[ch].pos;
./sound/mips/sgio2audio.c:380:	chip->channel[ch].size += (count >> 3); /* in frames */
./sound/mips/sgio2audio.c:381:	ret = chip->channel[ch].size >= runtime->period_size;
./sound/mips/sgio2audio.c:382:	chip->channel[ch].size %= runtime->period_size;
./sound/mips/sgio2audio.c:398:	chip->channel[ch].pos = dst_pos;
./sound/mips/sgio2audio.c:400:	spin_unlock_irqrestore(&chip->channel[ch].lock, flags);
./sound/mips/sgio2audio.c:417:	struct snd_pcm_runtime *runtime = chip->channel[ch].substream->runtime;
./sound/mips/sgio2audio.c:419:	spin_lock_irqsave(&chip->channel[ch].lock, flags);
./sound/mips/sgio2audio.c:421:	dst_base = (unsigned long)chip->ring_base | (ch << CHANNEL_RING_SHIFT);
./sound/mips/sgio2audio.c:424:	src_pos = chip->channel[ch].pos;
./sound/mips/sgio2audio.c:428:	chip->channel[ch].size += (count >> 3); /* in frames */
./sound/mips/sgio2audio.c:429:	ret = chip->channel[ch].size >= runtime->period_size;
./sound/mips/sgio2audio.c:430:	chip->channel[ch].size %= runtime->period_size;
./sound/mips/sgio2audio.c:448:	chip->channel[ch].pos = src_pos;
./sound/mips/sgio2audio.c:450:	spin_unlock_irqrestore(&chip->channel[ch].lock, flags);
./sound/mips/sgio2audio.c:560:	runtime->private_data = &chip->channel[1];
./sound/mips/sgio2audio.c:570:	runtime->private_data = &chip->channel[2];
./sound/mips/sgio2audio.c:581:	runtime->private_data = &chip->channel[0];
./sound/mips/sgio2audio.c:618:	spin_lock_irqsave(&chip->channel[ch].lock, flags);
./sound/mips/sgio2audio.c:621:	chip->channel[ch].pos = 0;
./sound/mips/sgio2audio.c:622:	chip->channel[ch].size = 0;
./sound/mips/sgio2audio.c:623:	chip->channel[ch].substream = substream;
./sound/mips/sgio2audio.c:629:		ad1843_setup_dac(&chip->ad1843,
./sound/mips/sgio2audio.c:636:		ad1843_setup_adc(&chip->ad1843,
./sound/mips/sgio2audio.c:642:	spin_unlock_irqrestore(&chip->channel[ch].lock, flags);
./sound/mips/sgio2audio.c:674:			       chip->channel[chan->idx].pos);
./sound/mips/sgio2audio.c:728:	err = snd_pcm_new(chip->card, "SGI O2 Audio", 0, 1, 1, &pcm);
./sound/mips/sgio2audio.c:742:	err = snd_pcm_new(chip->card, "SGI O2 Audio", 1, 1, 0, &pcm);
./sound/mips/sgio2audio.c:809:			 &chip->channel[snd_sgio2_isr_table[i].idx]);
./sound/mips/sgio2audio.c:812:			  chip->ring_base, chip->ring_base_dma);
./sound/mips/sgio2audio.c:847:	chip->card = card;
./sound/mips/sgio2audio.c:849:	chip->ring_base = dma_alloc_coherent(NULL, MACEISA_RINGBUFFERS_SIZE,
./sound/mips/sgio2audio.c:850:					     &chip->ring_base_dma, GFP_USER);
./sound/mips/sgio2audio.c:851:	if (chip->ring_base == NULL) {
./sound/mips/sgio2audio.c:858:	spin_lock_init(&chip->ad1843_lock);
./sound/mips/sgio2audio.c:862:		spin_lock_init(&chip->channel[i].lock);
./sound/mips/sgio2audio.c:863:		chip->channel[i].idx = i;
./sound/mips/sgio2audio.c:872:				&chip->channel[snd_sgio2_isr_table[i].idx])) {
./sound/mips/sgio2audio.c:887:	writeq(chip->ring_base_dma, &mace->perif.ctrl.ringbase);
./sound/mips/sgio2audio.c:890:	chip->ad1843.read = read_ad1843_reg;
./sound/mips/sgio2audio.c:891:	chip->ad1843.write = write_ad1843_reg;
./sound/mips/sgio2audio.c:892:	chip->ad1843.chip = chip;
./sound/mips/sgio2audio.c:895:	err = ad1843_init(&chip->ad1843);
./sound/isa/es1688/es1688.c:152:	strlcpy(card->shortname, chip->pcm->name, sizeof(card->shortname));
./sound/isa/es1688/es1688.c:154:		"%s at 0x%lx, irq %i, dma %i", chip->pcm->name, chip->port,
./sound/isa/es1688/es1688.c:155:		 chip->irq, chip->dma8);
./sound/isa/es1688/es1688.c:173:			chip->mpu_port > 0) {
./sound/isa/es1688/es1688.c:175:				chip->mpu_port, 0,
./sound/isa/es1688/es1688.c:309:	snd_pcm_suspend_all(chip->pcm);
./sound/isa/es1688/es1688_lib.c:113:		snd_printd("ess_reset at 0x%lx: failed!!!\n", chip->port);
./sound/isa/es1688/es1688_lib.c:131:	spin_lock_irqsave(&chip->reg_lock, flags);	/* Some ESS1688 cards need this */
./sound/isa/es1688/es1688_lib.c:145:		snd_printdd("ESS: [0x%lx] reset failed... 0x%x\n", chip->port, inb(ES1688P(chip, READ)));
./sound/isa/es1688/es1688_lib.c:146:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:161:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:163:	snd_printdd("ESS: [0x%lx] found.. major = 0x%x, minor = 0x%x\n", chip->port, major, minor);
./sound/isa/es1688/es1688_lib.c:165:	chip->version = (major << 8) | minor;
./sound/isa/es1688/es1688_lib.c:166:	if (!chip->version)
./sound/isa/es1688/es1688_lib.c:170:	switch (chip->version & 0xfff0) {
./sound/isa/es1688/es1688_lib.c:173:			   "but driver is in another place\n", chip->port);
./sound/isa/es1688/es1688_lib.c:176:		hw = (chip->version & 0x0f) >= 8 ? ES1688_HW_1688 : ES1688_HW_688;
./sound/isa/es1688/es1688_lib.c:181:			   chip->port, chip->version);
./sound/isa/es1688/es1688_lib.c:185:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:188:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:191:	spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/es1688/es1688_lib.c:193:	spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/es1688/es1688_lib.c:206:	if (enable && chip->mpu_port >= 0x300 && chip->mpu_irq > 0 && chip->hardware != ES1688_HW_688) {
./sound/isa/es1688/es1688_lib.c:207:		tmp = (chip->mpu_port & 0x0f0) >> 4;
./sound/isa/es1688/es1688_lib.c:209:			switch (chip->mpu_irq) {
./sound/isa/es1688/es1688_lib.c:233:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:235:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:237:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:240:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:243:		irq_bits = irqs[chip->irq & 0x0f];
./sound/isa/es1688/es1688_lib.c:247:				   chip->port, chip->irq);
./sound/isa/es1688/es1688_lib.c:254:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:256:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:258:		dma = chip->dma8;
./sound/isa/es1688/es1688_lib.c:261:				   "for ES1688 chip!!\n", chip->port, dma);
./sound/isa/es1688/es1688_lib.c:272:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:274:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:276:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:279:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:281:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:285:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:344:	spin_lock(&chip->reg_lock);
./sound/isa/es1688/es1688_lib.c:345:	chip->trigger_value = value;
./sound/isa/es1688/es1688_lib.c:348:		spin_unlock(&chip->reg_lock);
./sound/isa/es1688/es1688_lib.c:354:	       snd_dma_pointer(chip->dma8, chip->dma_size));
./sound/isa/es1688/es1688_lib.c:357:	spin_unlock(&chip->reg_lock);
./sound/isa/es1688/es1688_lib.c:380:	chip->dma_size = size;
./sound/isa/es1688/es1688_lib.c:381:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:415:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:418:	snd_dma_program(chip->dma8, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);
./sound/isa/es1688/es1688_lib.c:419:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:422:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:441:	chip->dma_size = size;
./sound/isa/es1688/es1688_lib.c:442:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:472:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:475:	snd_dma_program(chip->dma8, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);
./sound/isa/es1688/es1688_lib.c:476:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:479:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:494:	if (chip->trigger_value == 0x05)	/* ok.. playback is active */
./sound/isa/es1688/es1688_lib.c:495:		snd_pcm_period_elapsed(chip->playback_substream);
./sound/isa/es1688/es1688_lib.c:496:	if (chip->trigger_value == 0x0f)	/* ok.. capture is active */
./sound/isa/es1688/es1688_lib.c:497:		snd_pcm_period_elapsed(chip->capture_substream);
./sound/isa/es1688/es1688_lib.c:508:	if (chip->trigger_value != 0x05)
./sound/isa/es1688/es1688_lib.c:510:	ptr = snd_dma_pointer(chip->dma8, chip->dma_size);
./sound/isa/es1688/es1688_lib.c:519:	if (chip->trigger_value != 0x0f)
./sound/isa/es1688/es1688_lib.c:521:	ptr = snd_dma_pointer(chip->dma8, chip->dma_size);
./sound/isa/es1688/es1688_lib.c:574:	if (chip->capture_substream != NULL)
./sound/isa/es1688/es1688_lib.c:576:	chip->playback_substream = substream;
./sound/isa/es1688/es1688_lib.c:588:	if (chip->playback_substream != NULL)
./sound/isa/es1688/es1688_lib.c:590:	chip->capture_substream = substream;
./sound/isa/es1688/es1688_lib.c:601:	chip->playback_substream = NULL;
./sound/isa/es1688/es1688_lib.c:609:	chip->capture_substream = NULL;
./sound/isa/es1688/es1688_lib.c:615:	if (chip->hardware != ES1688_HW_UNDEF)
./sound/isa/es1688/es1688_lib.c:617:	release_and_free_resource(chip->res_port);
./sound/isa/es1688/es1688_lib.c:618:	if (chip->irq >= 0)
./sound/isa/es1688/es1688_lib.c:619:		free_irq(chip->irq, (void *) chip);
./sound/isa/es1688/es1688_lib.c:620:	if (chip->dma8 >= 0) {
./sound/isa/es1688/es1688_lib.c:621:		disable_dma(chip->dma8);
./sound/isa/es1688/es1688_lib.c:622:		free_dma(chip->dma8);
./sound/isa/es1688/es1688_lib.c:636:	sprintf(tmp, "ES%s688 rev %i", chip->hardware == ES1688_HW_688 ? "" : "1", chip->version & 0x0f);
./sound/isa/es1688/es1688_lib.c:657:	chip->irq = -1;
./sound/isa/es1688/es1688_lib.c:658:	chip->dma8 = -1;
./sound/isa/es1688/es1688_lib.c:659:	chip->hardware = ES1688_HW_UNDEF;
./sound/isa/es1688/es1688_lib.c:661:	chip->res_port = request_region(port + 4, 12, "ES1688");
./sound/isa/es1688/es1688_lib.c:662:	if (chip->res_port == NULL) {
./sound/isa/es1688/es1688_lib.c:674:	chip->irq = irq;
./sound/isa/es1688/es1688_lib.c:681:	chip->dma8 = dma8;
./sound/isa/es1688/es1688_lib.c:683:	spin_lock_init(&chip->reg_lock);
./sound/isa/es1688/es1688_lib.c:684:	spin_lock_init(&chip->mixer_lock);
./sound/isa/es1688/es1688_lib.c:685:	chip->port = port;
./sound/isa/es1688/es1688_lib.c:689:	chip->mpu_port = mpu_port;
./sound/isa/es1688/es1688_lib.c:690:	chip->mpu_irq = mpu_irq;
./sound/isa/es1688/es1688_lib.c:691:	chip->hardware = hardware;
./sound/isa/es1688/es1688_lib.c:746:	chip->pcm = pcm;
./sound/isa/es1688/es1688_lib.c:784:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:790:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:820:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:822:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:843:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:849:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:882:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:894:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:925:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es1688/es1688_lib.c:963:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/ad1848/ad1848.c:114:	strcpy(card->shortname, chip->pcm->name);
./sound/isa/ad1848/ad1848.c:117:		chip->pcm->name, chip->port, irq[n], dma1[n]);
./sound/isa/ad1848/ad1848.c:145:	chip->suspend(chip);
./sound/isa/ad1848/ad1848.c:154:	chip->resume(chip);
./sound/isa/gus/gusmax.c:145:	struct snd_card *card = chip->card;
./sound/isa/gus/interwave.c:506:	struct snd_card *card = chip->card;
./sound/isa/als100.c:226:			card->shortname, chip->name, chip->port,
./sound/isa/als100.c:232:			card->shortname, chip->name, chip->port,
./sound/isa/als100.c:324:	snd_pcm_suspend_all(chip->pcm);
./sound/isa/cs423x/cs4236_lib.c:125:	outb(reg, chip->cport + 3);
./sound/isa/cs423x/cs4236_lib.c:126:	outb(chip->cimage[reg] = val, chip->cport + 4);
./sound/isa/cs423x/cs4236_lib.c:131:	outb(reg, chip->cport + 3);
./sound/isa/cs423x/cs4236_lib.c:132:	return inb(chip->cport + 4);
./sound/isa/cs423x/cs4236_lib.c:189:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:192:		    chip->image[CS4231_ALT_FEATURE_1] | 0x10);
./sound/isa/cs423x/cs4236_lib.c:195:		    chip->image[CS4231_ALT_FEATURE_1] & ~0x10);
./sound/isa/cs423x/cs4236_lib.c:197:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:207:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:210:		    chip->image[CS4231_ALT_FEATURE_1] | 0x20);
./sound/isa/cs423x/cs4236_lib.c:213:		    chip->image[CS4231_ALT_FEATURE_1] & ~0x20);
./sound/isa/cs423x/cs4236_lib.c:215:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:225:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:227:		chip->image[reg] = snd_wss_in(chip, reg);
./sound/isa/cs423x/cs4236_lib.c:229:		chip->eimage[reg] = snd_cs4236_ext_in(chip, CS4236_I23VAL(reg));
./sound/isa/cs423x/cs4236_lib.c:231:		chip->cimage[reg] = snd_cs4236_ctrl_in(chip, reg);
./sound/isa/cs423x/cs4236_lib.c:232:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:241:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:250:			snd_wss_out(chip, reg, chip->image[reg]);
./sound/isa/cs423x/cs4236_lib.c:255:		snd_cs4236_ext_out(chip, CS4236_I23VAL(reg), chip->eimage[reg]);
./sound/isa/cs423x/cs4236_lib.c:261:			snd_cs4236_ctrl_out(chip, reg, chip->cimage[reg]);
./sound/isa/cs423x/cs4236_lib.c:264:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:295:	if ((chip->hardware & WSS_HW_CS4236B_MASK) == 0) {
./sound/isa/cs423x/cs4236_lib.c:297:			   chip->hardware);
./sound/isa/cs423x/cs4236_lib.c:306:				   idx, inb(chip->cport + idx));
./sound/isa/cs423x/cs4236_lib.c:344:	chip->rate_constraint = snd_cs4236_xrate;
./sound/isa/cs423x/cs4236_lib.c:345:	chip->set_playback_format = snd_cs4236_playback_format;
./sound/isa/cs423x/cs4236_lib.c:346:	chip->set_capture_format = snd_cs4236_capture_format;
./sound/isa/cs423x/cs4236_lib.c:348:	chip->suspend = snd_cs4236_suspend;
./sound/isa/cs423x/cs4236_lib.c:349:	chip->resume = snd_cs4236_resume;
./sound/isa/cs423x/cs4236_lib.c:367:	switch (chip->hardware) {
./sound/isa/cs423x/cs4236_lib.c:386:	chip->pcm->info_flags &= ~SNDRV_PCM_INFO_JOINT_DUPLEX;
./sound/isa/cs423x/cs4236_lib.c:428:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:429:	ucontrol->value.integer.value[0] = (chip->eimage[CS4236_REG(reg)] >> shift) & mask;
./sound/isa/cs423x/cs4236_lib.c:430:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:451:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:452:	val = (chip->eimage[CS4236_REG(reg)] & ~(mask << shift)) | val;
./sound/isa/cs423x/cs4236_lib.c:453:	change = val != chip->eimage[CS4236_REG(reg)];
./sound/isa/cs423x/cs4236_lib.c:455:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:474:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:475:	ucontrol->value.integer.value[0] = (chip->cimage[reg] >> shift) & mask;
./sound/isa/cs423x/cs4236_lib.c:476:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:497:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:498:	val = (chip->cimage[reg] & ~(mask << shift)) | val;
./sound/isa/cs423x/cs4236_lib.c:499:	change = val != chip->cimage[reg];
./sound/isa/cs423x/cs4236_lib.c:501:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:543:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:544:	ucontrol->value.integer.value[0] = (chip->eimage[CS4236_REG(left_reg)] >> shift_left) & mask;
./sound/isa/cs423x/cs4236_lib.c:545:	ucontrol->value.integer.value[1] = (chip->eimage[CS4236_REG(right_reg)] >> shift_right) & mask;
./sound/isa/cs423x/cs4236_lib.c:546:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:575:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:577:		val1 = (chip->eimage[CS4236_REG(left_reg)] & ~(mask << shift_left)) | val1;
./sound/isa/cs423x/cs4236_lib.c:578:		val2 = (chip->eimage[CS4236_REG(right_reg)] & ~(mask << shift_right)) | val2;
./sound/isa/cs423x/cs4236_lib.c:579:		change = val1 != chip->eimage[CS4236_REG(left_reg)] || val2 != chip->eimage[CS4236_REG(right_reg)];
./sound/isa/cs423x/cs4236_lib.c:583:		val1 = (chip->eimage[CS4236_REG(left_reg)] & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;
./sound/isa/cs423x/cs4236_lib.c:584:		change = val1 != chip->eimage[CS4236_REG(left_reg)];
./sound/isa/cs423x/cs4236_lib.c:587:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:619:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:620:	ucontrol->value.integer.value[0] = (chip->image[left_reg] >> shift_left) & mask;
./sound/isa/cs423x/cs4236_lib.c:621:	ucontrol->value.integer.value[1] = (chip->eimage[CS4236_REG(right_reg)] >> shift_right) & mask;
./sound/isa/cs423x/cs4236_lib.c:622:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:651:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:652:	val1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;
./sound/isa/cs423x/cs4236_lib.c:653:	val2 = (chip->eimage[CS4236_REG(right_reg)] & ~(mask << shift_right)) | val2;
./sound/isa/cs423x/cs4236_lib.c:654:	change = val1 != chip->image[left_reg] || val2 != chip->eimage[CS4236_REG(right_reg)];
./sound/isa/cs423x/cs4236_lib.c:657:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:679:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:680:	ucontrol->value.integer.value[0] = snd_cs4236_mixer_master_digital_invert_volume(chip->eimage[CS4236_REG(CS4236_LEFT_MASTER)] & 0x7f);
./sound/isa/cs423x/cs4236_lib.c:681:	ucontrol->value.integer.value[1] = snd_cs4236_mixer_master_digital_invert_volume(chip->eimage[CS4236_REG(CS4236_RIGHT_MASTER)] & 0x7f);
./sound/isa/cs423x/cs4236_lib.c:682:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:695:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:696:	val1 = (chip->eimage[CS4236_REG(CS4236_LEFT_MASTER)] & ~0x7f) | val1;
./sound/isa/cs423x/cs4236_lib.c:697:	val2 = (chip->eimage[CS4236_REG(CS4236_RIGHT_MASTER)] & ~0x7f) | val2;
./sound/isa/cs423x/cs4236_lib.c:698:	change = val1 != chip->eimage[CS4236_REG(CS4236_LEFT_MASTER)] || val2 != chip->eimage[CS4236_REG(CS4236_RIGHT_MASTER)];
./sound/isa/cs423x/cs4236_lib.c:701:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:740:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:741:	ucontrol->value.integer.value[0] = snd_cs4235_mixer_output_accu_get_volume(chip->image[CS4235_LEFT_MASTER]);
./sound/isa/cs423x/cs4236_lib.c:742:	ucontrol->value.integer.value[1] = snd_cs4235_mixer_output_accu_get_volume(chip->image[CS4235_RIGHT_MASTER]);
./sound/isa/cs423x/cs4236_lib.c:743:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:756:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:757:	val1 = (chip->image[CS4235_LEFT_MASTER] & ~(3 << 5)) | val1;
./sound/isa/cs423x/cs4236_lib.c:758:	val2 = (chip->image[CS4235_RIGHT_MASTER] & ~(3 << 5)) | val2;
./sound/isa/cs423x/cs4236_lib.c:759:	change = val1 != chip->image[CS4235_LEFT_MASTER] || val2 != chip->image[CS4235_RIGHT_MASTER];
./sound/isa/cs423x/cs4236_lib.c:762:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:950:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:951:	ucontrol->value.integer.value[0] = chip->image[CS4231_ALT_FEATURE_1] & 0x02 ? 1 : 0;
./sound/isa/cs423x/cs4236_lib.c:962:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:975:	mutex_lock(&chip->mce_mutex);
./sound/isa/cs423x/cs4236_lib.c:977:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:978:	val = (chip->image[CS4231_ALT_FEATURE_1] & ~0x0e) | (0<<2) | (enable << 1);
./sound/isa/cs423x/cs4236_lib.c:979:	change = val != chip->image[CS4231_ALT_FEATURE_1];
./sound/isa/cs423x/cs4236_lib.c:986:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/cs423x/cs4236_lib.c:988:	mutex_unlock(&chip->mce_mutex);
./sound/isa/cs423x/cs4236_lib.c:1039:	if (snd_BUG_ON(!chip || !chip->card))
./sound/isa/cs423x/cs4236_lib.c:1041:	card = chip->card;
./sound/isa/cs423x/cs4236_lib.c:1044:	if (chip->hardware == WSS_HW_CS4235 ||
./sound/isa/cs423x/cs4236_lib.c:1045:	    chip->hardware == WSS_HW_CS4239) {
./sound/isa/cs423x/cs4236_lib.c:1056:	switch (chip->hardware) {
./sound/isa/cs423x/cs4236_lib.c:1078:	if (chip->hardware == WSS_HW_CS4237B ||
./sound/isa/cs423x/cs4236_lib.c:1079:	    chip->hardware == WSS_HW_CS4238B) {
./sound/isa/cs423x/cs4236.c:404:	if (chip->hardware & WSS_HW_CS4236B_MASK) {
./sound/isa/cs423x/cs4236.c:422:	strcpy(card->driver, chip->pcm->name);
./sound/isa/cs423x/cs4236.c:423:	strcpy(card->shortname, chip->pcm->name);
./sound/isa/cs423x/cs4236.c:425:		chip->pcm->name,
./sound/isa/cs423x/cs4236.c:426:		chip->port,
./sound/isa/cs423x/cs4236.c:514:	acard->chip->suspend(acard->chip);
./sound/isa/cs423x/cs4236.c:521:	acard->chip->resume(acard->chip);
./sound/isa/cs423x/cs4231.c:113:	strcpy(card->shortname, chip->pcm->name);
./sound/isa/cs423x/cs4231.c:116:		chip->pcm->name, chip->port, irq[n], dma1[n]);
./sound/isa/cs423x/cs4231.c:161:	chip->suspend(chip);
./sound/isa/cs423x/cs4231.c:170:	chip->resume(chip);
./sound/isa/wavefront/wavefront.c:520:		chip->port,
./sound/isa/wss/wss_lib.c:167:	outb(val, chip->port + offset);
./sound/isa/wss/wss_lib.c:172:	return inb(chip->port + offset);
./sound/isa/wss/wss_lib.c:194:	wss_outb(chip, CS4231P(REGSEL), chip->mce_bit | reg);
./sound/isa/wss/wss_lib.c:207:	wss_outb(chip, CS4231P(REGSEL), chip->mce_bit | reg);
./sound/isa/wss/wss_lib.c:209:	chip->image[reg] = value;
./sound/isa/wss/wss_lib.c:212:			chip->mce_bit | reg, value);
./sound/isa/wss/wss_lib.c:224:	wss_outb(chip, CS4231P(REGSEL), chip->mce_bit | reg);
./sound/isa/wss/wss_lib.c:233:	wss_outb(chip, CS4231P(REGSEL), chip->mce_bit | 0x17);
./sound/isa/wss/wss_lib.c:235:		 reg | (chip->image[CS4236_EXT_REG] & 0x01));
./sound/isa/wss/wss_lib.c:237:	chip->eimage[CS4236_REG(reg)] = val;
./sound/isa/wss/wss_lib.c:246:	wss_outb(chip, CS4231P(REGSEL), chip->mce_bit | 0x17);
./sound/isa/wss/wss_lib.c:248:		 reg | (chip->image[CS4236_EXT_REG] & 0x01));
./sound/isa/wss/wss_lib.c:385:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:386:	chip->mce_bit |= CS4231_MCE;
./sound/isa/wss/wss_lib.c:391:			   chip->port);
./sound/isa/wss/wss_lib.c:394:			 chip->mce_bit | (timeout & 0x1f));
./sound/isa/wss/wss_lib.c:395:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:414:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:415:	chip->mce_bit &= ~CS4231_MCE;
./sound/isa/wss/wss_lib.c:417:	wss_outb(chip, CS4231P(REGSEL), chip->mce_bit | (timeout & 0x1f));
./sound/isa/wss/wss_lib.c:418:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:422:			   chip->port);
./sound/isa/wss/wss_lib.c:423:	if ((timeout & CS4231_MCE) == 0 || !(chip->hardware & hw_mask))
./sound/isa/wss/wss_lib.c:502:		if (s == chip->playback_substream) {
./sound/isa/wss/wss_lib.c:505:		} else if (s == chip->capture_substream) {
./sound/isa/wss/wss_lib.c:510:	spin_lock(&chip->reg_lock);
./sound/isa/wss/wss_lib.c:512:		chip->image[CS4231_IFACE_CTRL] |= what;
./sound/isa/wss/wss_lib.c:513:		if (chip->trigger)
./sound/isa/wss/wss_lib.c:514:			chip->trigger(chip, what, 1);
./sound/isa/wss/wss_lib.c:516:		chip->image[CS4231_IFACE_CTRL] &= ~what;
./sound/isa/wss/wss_lib.c:517:		if (chip->trigger)
./sound/isa/wss/wss_lib.c:518:			chip->trigger(chip, what, 0);
./sound/isa/wss/wss_lib.c:520:	snd_wss_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);
./sound/isa/wss/wss_lib.c:521:	spin_unlock(&chip->reg_lock);
./sound/isa/wss/wss_lib.c:570:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:571:	if (chip->calibrate_mute == mute) {
./sound/isa/wss/wss_lib.c:572:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:577:			     chip->image[CS4231_LEFT_INPUT]);
./sound/isa/wss/wss_lib.c:579:			     chip->image[CS4231_RIGHT_INPUT]);
./sound/isa/wss/wss_lib.c:581:			     chip->image[CS4231_LOOPBACK]);
./sound/isa/wss/wss_lib.c:592:		     mute | chip->image[CS4231_AUX1_LEFT_INPUT]);
./sound/isa/wss/wss_lib.c:594:		     mute | chip->image[CS4231_AUX1_RIGHT_INPUT]);
./sound/isa/wss/wss_lib.c:596:		     mute | chip->image[CS4231_AUX2_LEFT_INPUT]);
./sound/isa/wss/wss_lib.c:598:		     mute | chip->image[CS4231_AUX2_RIGHT_INPUT]);
./sound/isa/wss/wss_lib.c:600:		     mute | chip->image[CS4231_LEFT_OUTPUT]);
./sound/isa/wss/wss_lib.c:602:		     mute | chip->image[CS4231_RIGHT_OUTPUT]);
./sound/isa/wss/wss_lib.c:603:	if (!(chip->hardware & WSS_HW_AD1848_MASK)) {
./sound/isa/wss/wss_lib.c:605:			     mute | chip->image[CS4231_LEFT_LINE_IN]);
./sound/isa/wss/wss_lib.c:607:			     mute | chip->image[CS4231_RIGHT_LINE_IN]);
./sound/isa/wss/wss_lib.c:609:			     mute ? 0xc0 : chip->image[CS4231_MONO_CTRL]);
./sound/isa/wss/wss_lib.c:611:	if (chip->hardware == WSS_HW_INTERWAVE) {
./sound/isa/wss/wss_lib.c:613:			     mute | chip->image[CS4231_LEFT_MIC_INPUT]);
./sound/isa/wss/wss_lib.c:615:			     mute | chip->image[CS4231_RIGHT_MIC_INPUT]);
./sound/isa/wss/wss_lib.c:617:			     mute | chip->image[CS4231_LINE_LEFT_OUTPUT]);
./sound/isa/wss/wss_lib.c:619:			     mute | chip->image[CS4231_LINE_RIGHT_OUTPUT]);
./sound/isa/wss/wss_lib.c:621:	chip->calibrate_mute = mute;
./sound/isa/wss/wss_lib.c:622:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:632:	mutex_lock(&chip->mce_mutex);
./sound/isa/wss/wss_lib.c:633:	if (chip->hardware == WSS_HW_CS4231A ||
./sound/isa/wss/wss_lib.c:634:	    (chip->hardware & WSS_HW_CS4232_MASK)) {
./sound/isa/wss/wss_lib.c:635:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:636:		if ((chip->image[CS4231_PLAYBK_FORMAT] & 0x0f) == (pdfr & 0x0f)) {	/* rate is same? */
./sound/isa/wss/wss_lib.c:638:				    chip->image[CS4231_ALT_FEATURE_1] | 0x10);
./sound/isa/wss/wss_lib.c:639:			chip->image[CS4231_PLAYBK_FORMAT] = pdfr;
./sound/isa/wss/wss_lib.c:641:				    chip->image[CS4231_PLAYBK_FORMAT]);
./sound/isa/wss/wss_lib.c:643:				    chip->image[CS4231_ALT_FEATURE_1] &= ~0x10);
./sound/isa/wss/wss_lib.c:647:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:648:	} else if (chip->hardware == WSS_HW_AD1845) {
./sound/isa/wss/wss_lib.c:660:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:665:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:669:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:670:		if (chip->hardware != WSS_HW_INTERWAVE && !chip->single_dma) {
./sound/isa/wss/wss_lib.c:671:			if (chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE)
./sound/isa/wss/wss_lib.c:673:				       (chip->image[CS4231_REC_FORMAT] & 0x0f);
./sound/isa/wss/wss_lib.c:675:			chip->image[CS4231_PLAYBK_FORMAT] = pdfr;
./sound/isa/wss/wss_lib.c:678:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:679:		if (chip->hardware == WSS_HW_OPL3SA2)
./sound/isa/wss/wss_lib.c:683:	mutex_unlock(&chip->mce_mutex);
./sound/isa/wss/wss_lib.c:693:	mutex_lock(&chip->mce_mutex);
./sound/isa/wss/wss_lib.c:694:	if (chip->hardware == WSS_HW_CS4231A ||
./sound/isa/wss/wss_lib.c:695:	    (chip->hardware & WSS_HW_CS4232_MASK)) {
./sound/isa/wss/wss_lib.c:696:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:697:		if ((chip->image[CS4231_PLAYBK_FORMAT] & 0x0f) == (cdfr & 0x0f) ||	/* rate is same? */
./sound/isa/wss/wss_lib.c:698:		    (chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE)) {
./sound/isa/wss/wss_lib.c:700:				chip->image[CS4231_ALT_FEATURE_1] | 0x20);
./sound/isa/wss/wss_lib.c:702:				chip->image[CS4231_REC_FORMAT] = cdfr);
./sound/isa/wss/wss_lib.c:704:				chip->image[CS4231_ALT_FEATURE_1] &= ~0x20);
./sound/isa/wss/wss_lib.c:707:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:708:	} else if (chip->hardware == WSS_HW_AD1845) {
./sound/isa/wss/wss_lib.c:720:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:725:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:729:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:730:		if (chip->hardware != WSS_HW_INTERWAVE &&
./sound/isa/wss/wss_lib.c:731:		    !(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE)) {
./sound/isa/wss/wss_lib.c:732:			if (chip->single_dma)
./sound/isa/wss/wss_lib.c:736:				   (chip->image[CS4231_PLAYBK_FORMAT] & 0xf0) |
./sound/isa/wss/wss_lib.c:738:			spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:741:			spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:743:		if (chip->hardware & WSS_HW_AD1848_MASK)
./sound/isa/wss/wss_lib.c:747:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:750:	mutex_unlock(&chip->mce_mutex);
./sound/isa/wss/wss_lib.c:760:	if (chip->hardware & WSS_HW_CS4236B_MASK)
./sound/isa/wss/wss_lib.c:763:		return chip->image[CS4231_PLAYBK_FORMAT] & 1 ? 9969 : 9920;
./sound/isa/wss/wss_lib.c:771:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:773:	if ((chip->image[CS4231_ALT_FEATURE_1] & CS4231_TIMER_ENABLE) == 0 ||
./sound/isa/wss/wss_lib.c:774:	    (unsigned char)(ticks >> 8) != chip->image[CS4231_TIMER_HIGH] ||
./sound/isa/wss/wss_lib.c:775:	    (unsigned char)ticks != chip->image[CS4231_TIMER_LOW]) {
./sound/isa/wss/wss_lib.c:776:		chip->image[CS4231_TIMER_HIGH] = (unsigned char) (ticks >> 8);
./sound/isa/wss/wss_lib.c:778:			    chip->image[CS4231_TIMER_HIGH]);
./sound/isa/wss/wss_lib.c:779:		chip->image[CS4231_TIMER_LOW] = (unsigned char) ticks;
./sound/isa/wss/wss_lib.c:781:			    chip->image[CS4231_TIMER_LOW]);
./sound/isa/wss/wss_lib.c:783:			    chip->image[CS4231_ALT_FEATURE_1] |
./sound/isa/wss/wss_lib.c:786:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:794:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:795:	chip->image[CS4231_ALT_FEATURE_1] &= ~CS4231_TIMER_ENABLE;
./sound/isa/wss/wss_lib.c:797:		    chip->image[CS4231_ALT_FEATURE_1]);
./sound/isa/wss/wss_lib.c:798:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:813:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:814:	chip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE |
./sound/isa/wss/wss_lib.c:819:	chip->image[CS4231_IFACE_CTRL] |= CS4231_AUTOCALIB;
./sound/isa/wss/wss_lib.c:820:	snd_wss_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);
./sound/isa/wss/wss_lib.c:821:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:829:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:830:	chip->image[CS4231_IFACE_CTRL] &= ~CS4231_AUTOCALIB;
./sound/isa/wss/wss_lib.c:831:	snd_wss_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);
./sound/isa/wss/wss_lib.c:833:		    CS4231_ALT_FEATURE_1, chip->image[CS4231_ALT_FEATURE_1]);
./sound/isa/wss/wss_lib.c:834:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:839:		   chip->image[CS4231_ALT_FEATURE_1]);
./sound/isa/wss/wss_lib.c:842:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:844:		    chip->image[CS4231_ALT_FEATURE_2]);
./sound/isa/wss/wss_lib.c:845:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:848:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:850:		    chip->image[CS4231_PLAYBK_FORMAT]);
./sound/isa/wss/wss_lib.c:851:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:859:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:860:	if (!(chip->hardware & WSS_HW_AD1848_MASK))
./sound/isa/wss/wss_lib.c:862:			    chip->image[CS4231_REC_FORMAT]);
./sound/isa/wss/wss_lib.c:863:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:876:	mutex_lock(&chip->open_mutex);
./sound/isa/wss/wss_lib.c:877:	if ((chip->mode & mode) ||
./sound/isa/wss/wss_lib.c:878:	    ((chip->mode & WSS_MODE_OPEN) && chip->single_dma)) {
./sound/isa/wss/wss_lib.c:879:		mutex_unlock(&chip->open_mutex);
./sound/isa/wss/wss_lib.c:882:	if (chip->mode & WSS_MODE_OPEN) {
./sound/isa/wss/wss_lib.c:883:		chip->mode |= mode;
./sound/isa/wss/wss_lib.c:884:		mutex_unlock(&chip->open_mutex);
./sound/isa/wss/wss_lib.c:888:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:889:	if (!(chip->hardware & WSS_HW_AD1848_MASK)) {
./sound/isa/wss/wss_lib.c:898:	chip->image[CS4231_PIN_CTRL] |= CS4231_IRQ_ENABLE;
./sound/isa/wss/wss_lib.c:899:	snd_wss_out(chip, CS4231_PIN_CTRL, chip->image[CS4231_PIN_CTRL]);
./sound/isa/wss/wss_lib.c:900:	if (!(chip->hardware & WSS_HW_AD1848_MASK)) {
./sound/isa/wss/wss_lib.c:907:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:909:	chip->mode = mode;
./sound/isa/wss/wss_lib.c:910:	mutex_unlock(&chip->open_mutex);
./sound/isa/wss/wss_lib.c:918:	mutex_lock(&chip->open_mutex);
./sound/isa/wss/wss_lib.c:919:	chip->mode &= ~mode;
./sound/isa/wss/wss_lib.c:920:	if (chip->mode & WSS_MODE_OPEN) {
./sound/isa/wss/wss_lib.c:921:		mutex_unlock(&chip->open_mutex);
./sound/isa/wss/wss_lib.c:925:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:926:	if (!(chip->hardware & WSS_HW_AD1848_MASK))
./sound/isa/wss/wss_lib.c:930:	chip->image[CS4231_PIN_CTRL] &= ~CS4231_IRQ_ENABLE;
./sound/isa/wss/wss_lib.c:931:	snd_wss_out(chip, CS4231_PIN_CTRL, chip->image[CS4231_PIN_CTRL]);
./sound/isa/wss/wss_lib.c:935:	if (chip->image[CS4231_IFACE_CTRL] & (CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO |
./sound/isa/wss/wss_lib.c:937:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:939:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:940:		chip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO |
./sound/isa/wss/wss_lib.c:943:			    chip->image[CS4231_IFACE_CTRL]);
./sound/isa/wss/wss_lib.c:944:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:946:		spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:950:	if (!(chip->hardware & WSS_HW_AD1848_MASK))
./sound/isa/wss/wss_lib.c:954:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:956:	chip->mode = 0;
./sound/isa/wss/wss_lib.c:957:	mutex_unlock(&chip->open_mutex);
./sound/isa/wss/wss_lib.c:1006:	chip->set_playback_format(chip, hw_params, new_pdfr);
./sound/isa/wss/wss_lib.c:1023:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1024:	chip->p_dma_size = size;
./sound/isa/wss/wss_lib.c:1025:	chip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO);
./sound/isa/wss/wss_lib.c:1026:	snd_dma_program(chip->dma1, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);
./sound/isa/wss/wss_lib.c:1027:	count = snd_wss_get_count(chip->image[CS4231_PLAYBK_FORMAT], count) - 1;
./sound/isa/wss/wss_lib.c:1030:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1049:	chip->set_capture_format(chip, hw_params, new_cdfr);
./sound/isa/wss/wss_lib.c:1066:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1067:	chip->c_dma_size = size;
./sound/isa/wss/wss_lib.c:1068:	chip->image[CS4231_IFACE_CTRL] &= ~(CS4231_RECORD_ENABLE | CS4231_RECORD_PIO);
./sound/isa/wss/wss_lib.c:1069:	snd_dma_program(chip->dma2, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);
./sound/isa/wss/wss_lib.c:1070:	if (chip->hardware & WSS_HW_AD1848_MASK)
./sound/isa/wss/wss_lib.c:1071:		count = snd_wss_get_count(chip->image[CS4231_PLAYBK_FORMAT],
./sound/isa/wss/wss_lib.c:1074:		count = snd_wss_get_count(chip->image[CS4231_REC_FORMAT],
./sound/isa/wss/wss_lib.c:1077:	if (chip->single_dma && chip->hardware != WSS_HW_INTERWAVE) {
./sound/isa/wss/wss_lib.c:1086:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1095:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1097:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1099:		chip->capture_substream->runtime->overrange++;
./sound/isa/wss/wss_lib.c:1108:	if (chip->hardware & WSS_HW_AD1848_MASK)
./sound/isa/wss/wss_lib.c:1114:		if (chip->timer)
./sound/isa/wss/wss_lib.c:1115:			snd_timer_interrupt(chip->timer, chip->timer->sticks);
./sound/isa/wss/wss_lib.c:1117:	if (chip->single_dma && chip->hardware != WSS_HW_INTERWAVE) {
./sound/isa/wss/wss_lib.c:1119:			if (chip->mode & WSS_MODE_PLAY) {
./sound/isa/wss/wss_lib.c:1120:				if (chip->playback_substream)
./sound/isa/wss/wss_lib.c:1121:					snd_pcm_period_elapsed(chip->playback_substream);
./sound/isa/wss/wss_lib.c:1123:			if (chip->mode & WSS_MODE_RECORD) {
./sound/isa/wss/wss_lib.c:1124:				if (chip->capture_substream) {
./sound/isa/wss/wss_lib.c:1126:					snd_pcm_period_elapsed(chip->capture_substream);
./sound/isa/wss/wss_lib.c:1132:			if (chip->playback_substream)
./sound/isa/wss/wss_lib.c:1133:				snd_pcm_period_elapsed(chip->playback_substream);
./sound/isa/wss/wss_lib.c:1136:			if (chip->capture_substream) {
./sound/isa/wss/wss_lib.c:1138:				snd_pcm_period_elapsed(chip->capture_substream);
./sound/isa/wss/wss_lib.c:1143:	spin_lock(&chip->reg_lock);
./sound/isa/wss/wss_lib.c:1145:	if (chip->hardware & WSS_HW_AD1848_MASK)
./sound/isa/wss/wss_lib.c:1149:	spin_unlock(&chip->reg_lock);
./sound/isa/wss/wss_lib.c:1159:	if (!(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE))
./sound/isa/wss/wss_lib.c:1161:	ptr = snd_dma_pointer(chip->dma1, chip->p_dma_size);
./sound/isa/wss/wss_lib.c:1170:	if (!(chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE))
./sound/isa/wss/wss_lib.c:1172:	ptr = snd_dma_pointer(chip->dma2, chip->c_dma_size);
./sound/isa/wss/wss_lib.c:1194:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1223:	if ((chip->hardware & WSS_HW_TYPE_MASK) != WSS_HW_DETECT)
./sound/isa/wss/wss_lib.c:1227:		chip->hardware = hardware;
./sound/isa/wss/wss_lib.c:1247:				chip->hardware = WSS_HW_CMI8330;
./sound/isa/wss/wss_lib.c:1252:		chip->hardware = WSS_HW_CS4248;
./sound/isa/wss/wss_lib.c:1254:		chip->hardware = WSS_HW_AD1848;
./sound/isa/wss/wss_lib.c:1258:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1273:	hw = chip->hardware;
./sound/isa/wss/wss_lib.c:1280:				spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1284:				spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1289:		snd_printdd("wss: port = 0x%lx, id = 0x%x\n", chip->port, id);
./sound/isa/wss/wss_lib.c:1299:				chip->hardware = WSS_HW_AD1845;
./sound/isa/wss/wss_lib.c:1301:				chip->hardware = WSS_HW_CS4231;
./sound/isa/wss/wss_lib.c:1303:			chip->hardware = WSS_HW_CS4231A;
./sound/isa/wss/wss_lib.c:1305:			chip->hardware = WSS_HW_CS4232;
./sound/isa/wss/wss_lib.c:1307:			chip->hardware = WSS_HW_CS4232A;
./sound/isa/wss/wss_lib.c:1309:			chip->hardware = WSS_HW_CS4236;
./sound/isa/wss/wss_lib.c:1311:			chip->hardware = WSS_HW_CS4236B;
./sound/isa/wss/wss_lib.c:1318:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1322:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1324:	if (!(chip->hardware & WSS_HW_AD1848_MASK))
./sound/isa/wss/wss_lib.c:1325:		chip->image[CS4231_MISC_INFO] = CS4231_MODE2;
./sound/isa/wss/wss_lib.c:1326:	switch (chip->hardware) {
./sound/isa/wss/wss_lib.c:1328:		chip->image[CS4231_MISC_INFO] = CS4231_IW_MODE3;
./sound/isa/wss/wss_lib.c:1336:			chip->image[CS4231_MISC_INFO] = CS4231_4236_MODE3;
./sound/isa/wss/wss_lib.c:1338:			chip->hardware = WSS_HW_CS4236;
./sound/isa/wss/wss_lib.c:1342:	chip->image[CS4231_IFACE_CTRL] =
./sound/isa/wss/wss_lib.c:1343:	    (chip->image[CS4231_IFACE_CTRL] & ~CS4231_SINGLE_DMA) |
./sound/isa/wss/wss_lib.c:1344:	    (chip->single_dma ? CS4231_SINGLE_DMA : 0);
./sound/isa/wss/wss_lib.c:1345:	if (chip->hardware != WSS_HW_OPTI93X) {
./sound/isa/wss/wss_lib.c:1346:		chip->image[CS4231_ALT_FEATURE_1] = 0x80;
./sound/isa/wss/wss_lib.c:1347:		chip->image[CS4231_ALT_FEATURE_2] =
./sound/isa/wss/wss_lib.c:1348:			chip->hardware == WSS_HW_INTERWAVE ? 0xc2 : 0x01;
./sound/isa/wss/wss_lib.c:1351:	if (chip->hardware == WSS_HW_AD1845)
./sound/isa/wss/wss_lib.c:1352:		chip->image[AD1845_PWR_DOWN] = 8;
./sound/isa/wss/wss_lib.c:1354:	ptr = (unsigned char *) &chip->image;
./sound/isa/wss/wss_lib.c:1355:	regnum = (chip->hardware & WSS_HW_AD1848_MASK) ? 16 : 32;
./sound/isa/wss/wss_lib.c:1357:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1360:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1368:		if (chip->hardware == WSS_HW_CS4236B) {
./sound/isa/wss/wss_lib.c:1375:				chip->hardware = WSS_HW_CS4235;
./sound/isa/wss/wss_lib.c:1393:					chip->hardware = WSS_HW_CS4236B;
./sound/isa/wss/wss_lib.c:1402:				chip->hardware = WSS_HW_CS4237B;
./sound/isa/wss/wss_lib.c:1416:				chip->hardware = WSS_HW_CS4238B;
./sound/isa/wss/wss_lib.c:1429:				chip->hardware = WSS_HW_CS4239;
./sound/isa/wss/wss_lib.c:1509:	if (chip->hardware & WSS_HW_AD1848_MASK)
./sound/isa/wss/wss_lib.c:1514:	if (chip->hardware == WSS_HW_INTERWAVE && chip->dma1 > 3)
./sound/isa/wss/wss_lib.c:1518:	if (chip->hardware == WSS_HW_CS4235 ||
./sound/isa/wss/wss_lib.c:1519:	    chip->hardware == WSS_HW_CS4239)
./sound/isa/wss/wss_lib.c:1522:	snd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.buffer_bytes_max);
./sound/isa/wss/wss_lib.c:1523:	snd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.period_bytes_max);
./sound/isa/wss/wss_lib.c:1525:	if (chip->claim_dma) {
./sound/isa/wss/wss_lib.c:1526:		if ((err = chip->claim_dma(chip, chip->dma_private_data, chip->dma1)) < 0)
./sound/isa/wss/wss_lib.c:1532:		if (chip->release_dma)
./sound/isa/wss/wss_lib.c:1533:			chip->release_dma(chip, chip->dma_private_data, chip->dma1);
./sound/isa/wss/wss_lib.c:1537:	chip->playback_substream = substream;
./sound/isa/wss/wss_lib.c:1539:	chip->rate_constraint(runtime);
./sound/isa/wss/wss_lib.c:1552:	if (chip->hardware & WSS_HW_AD1848_MASK)
./sound/isa/wss/wss_lib.c:1557:	if (chip->hardware == WSS_HW_CS4235 ||
./sound/isa/wss/wss_lib.c:1558:	    chip->hardware == WSS_HW_CS4239 ||
./sound/isa/wss/wss_lib.c:1559:	    chip->hardware == WSS_HW_OPTI93X)
./sound/isa/wss/wss_lib.c:1563:	snd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.buffer_bytes_max);
./sound/isa/wss/wss_lib.c:1564:	snd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.period_bytes_max);
./sound/isa/wss/wss_lib.c:1566:	if (chip->claim_dma) {
./sound/isa/wss/wss_lib.c:1567:		if ((err = chip->claim_dma(chip, chip->dma_private_data, chip->dma2)) < 0)
./sound/isa/wss/wss_lib.c:1573:		if (chip->release_dma)
./sound/isa/wss/wss_lib.c:1574:			chip->release_dma(chip, chip->dma_private_data, chip->dma2);
./sound/isa/wss/wss_lib.c:1578:	chip->capture_substream = substream;
./sound/isa/wss/wss_lib.c:1580:	chip->rate_constraint(runtime);
./sound/isa/wss/wss_lib.c:1588:	chip->playback_substream = NULL;
./sound/isa/wss/wss_lib.c:1597:	chip->capture_substream = NULL;
./sound/isa/wss/wss_lib.c:1606:	if (!chip->thinkpad_flag)
./sound/isa/wss/wss_lib.c:1630:	snd_pcm_suspend_all(chip->pcm);
./sound/isa/wss/wss_lib.c:1631:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1633:		chip->image[reg] = snd_wss_in(chip, reg);
./sound/isa/wss/wss_lib.c:1634:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1635:	if (chip->thinkpad_flag)
./sound/isa/wss/wss_lib.c:1646:	if (chip->thinkpad_flag)
./sound/isa/wss/wss_lib.c:1649:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1655:			snd_wss_out(chip, reg, chip->image[reg]);
./sound/isa/wss/wss_lib.c:1660:	if (chip->hardware == WSS_HW_OPL3SA2)
./sound/isa/wss/wss_lib.c:1662:			    chip->image[CS4231_PLAYBK_FORMAT]);
./sound/isa/wss/wss_lib.c:1663:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1672:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1673:	chip->mce_bit &= ~CS4231_MCE;
./sound/isa/wss/wss_lib.c:1675:	wss_outb(chip, CS4231P(REGSEL), chip->mce_bit | (timeout & 0x1f));
./sound/isa/wss/wss_lib.c:1676:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:1679:			   "- codec still busy\n", chip->port);
./sound/isa/wss/wss_lib.c:1681:	    !(chip->hardware & (WSS_HW_CS4231_MASK | WSS_HW_CS4232_MASK))) {
./sound/isa/wss/wss_lib.c:1691:	release_and_free_resource(chip->res_port);
./sound/isa/wss/wss_lib.c:1692:	release_and_free_resource(chip->res_cport);
./sound/isa/wss/wss_lib.c:1693:	if (chip->irq >= 0) {
./sound/isa/wss/wss_lib.c:1694:		disable_irq(chip->irq);
./sound/isa/wss/wss_lib.c:1695:		if (!(chip->hwshare & WSS_HWSHARE_IRQ))
./sound/isa/wss/wss_lib.c:1696:			free_irq(chip->irq, (void *) chip);
./sound/isa/wss/wss_lib.c:1698:	if (!(chip->hwshare & WSS_HWSHARE_DMA1) && chip->dma1 >= 0) {
./sound/isa/wss/wss_lib.c:1699:		snd_dma_disable(chip->dma1);
./sound/isa/wss/wss_lib.c:1700:		free_dma(chip->dma1);
./sound/isa/wss/wss_lib.c:1702:	if (!(chip->hwshare & WSS_HWSHARE_DMA2) &&
./sound/isa/wss/wss_lib.c:1703:	    chip->dma2 >= 0 && chip->dma2 != chip->dma1) {
./sound/isa/wss/wss_lib.c:1704:		snd_dma_disable(chip->dma2);
./sound/isa/wss/wss_lib.c:1705:		free_dma(chip->dma2);
./sound/isa/wss/wss_lib.c:1707:	if (chip->timer)
./sound/isa/wss/wss_lib.c:1708:		snd_device_free(chip->card, chip->timer);
./sound/isa/wss/wss_lib.c:1721:	switch (chip->hardware) {
./sound/isa/wss/wss_lib.c:1745:		return chip->card->shortname;
./sound/isa/wss/wss_lib.c:1775:	chip->hardware = hardware;
./sound/isa/wss/wss_lib.c:1776:	chip->hwshare = hwshare;
./sound/isa/wss/wss_lib.c:1778:	spin_lock_init(&chip->reg_lock);
./sound/isa/wss/wss_lib.c:1779:	mutex_init(&chip->mce_mutex);
./sound/isa/wss/wss_lib.c:1780:	mutex_init(&chip->open_mutex);
./sound/isa/wss/wss_lib.c:1781:	chip->card = card;
./sound/isa/wss/wss_lib.c:1782:	chip->rate_constraint = snd_wss_xrate;
./sound/isa/wss/wss_lib.c:1783:	chip->set_playback_format = snd_wss_playback_format;
./sound/isa/wss/wss_lib.c:1784:	chip->set_capture_format = snd_wss_capture_format;
./sound/isa/wss/wss_lib.c:1785:	if (chip->hardware == WSS_HW_OPTI93X)
./sound/isa/wss/wss_lib.c:1786:		memcpy(&chip->image, &snd_opti93x_original_image,
./sound/isa/wss/wss_lib.c:1789:		memcpy(&chip->image, &snd_wss_original_image,
./sound/isa/wss/wss_lib.c:1791:	if (chip->hardware & WSS_HW_AD1848_MASK) {
./sound/isa/wss/wss_lib.c:1792:		chip->image[CS4231_PIN_CTRL] = 0;
./sound/isa/wss/wss_lib.c:1793:		chip->image[CS4231_TEST_INIT] = 0;
./sound/isa/wss/wss_lib.c:1818:	chip->irq = -1;
./sound/isa/wss/wss_lib.c:1819:	chip->dma1 = -1;
./sound/isa/wss/wss_lib.c:1820:	chip->dma2 = -1;
./sound/isa/wss/wss_lib.c:1822:	chip->res_port = request_region(port, 4, "WSS");
./sound/isa/wss/wss_lib.c:1823:	if (!chip->res_port) {
./sound/isa/wss/wss_lib.c:1828:	chip->port = port;
./sound/isa/wss/wss_lib.c:1830:		chip->res_cport = request_region(cport, 8, "CS4232 Control");
./sound/isa/wss/wss_lib.c:1831:		if (!chip->res_cport) {
./sound/isa/wss/wss_lib.c:1838:	chip->cport = cport;
./sound/isa/wss/wss_lib.c:1846:	chip->irq = irq;
./sound/isa/wss/wss_lib.c:1852:	chip->dma1 = dma1;
./sound/isa/wss/wss_lib.c:1860:		chip->single_dma = 1;
./sound/isa/wss/wss_lib.c:1861:		chip->dma2 = chip->dma1;
./sound/isa/wss/wss_lib.c:1863:		chip->dma2 = dma2;
./sound/isa/wss/wss_lib.c:1866:		chip->thinkpad_flag = 1;
./sound/isa/wss/wss_lib.c:1867:		chip->hardware = WSS_HW_DETECT; /* reset */
./sound/isa/wss/wss_lib.c:1879:	if (chip->hardware & WSS_HW_CS4232_MASK) {
./sound/isa/wss/wss_lib.c:1880:		if (chip->res_cport == NULL)
./sound/isa/wss/wss_lib.c:1895:	chip->suspend = snd_wss_suspend;
./sound/isa/wss/wss_lib.c:1896:	chip->resume = snd_wss_resume;
./sound/isa/wss/wss_lib.c:1931:	err = snd_pcm_new(chip->card, "WSS", device, 1, 1, &pcm);
./sound/isa/wss/wss_lib.c:1941:	if (chip->single_dma)
./sound/isa/wss/wss_lib.c:1943:	if (chip->hardware != WSS_HW_INTERWAVE)
./sound/isa/wss/wss_lib.c:1949:					      64*1024, chip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024);
./sound/isa/wss/wss_lib.c:1951:	chip->pcm = pcm;
./sound/isa/wss/wss_lib.c:1959:	chip->timer = NULL;
./sound/isa/wss/wss_lib.c:1971:	tid.card = chip->card->number;
./sound/isa/wss/wss_lib.c:1974:	if ((err = snd_timer_new(chip->card, "CS4231", &tid, &timer)) < 0)
./sound/isa/wss/wss_lib.c:1980:	chip->timer = timer;
./sound/isa/wss/wss_lib.c:2004:	if (snd_BUG_ON(!chip->card))
./sound/isa/wss/wss_lib.c:2006:	if (!strcmp(chip->card->driver, "GUS MAX"))
./sound/isa/wss/wss_lib.c:2008:	switch (chip->hardware) {
./sound/isa/wss/wss_lib.c:2026:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2027:	ucontrol->value.enumerated.item[0] = (chip->image[CS4231_LEFT_INPUT] & CS4231_MIXS_ALL) >> 6;
./sound/isa/wss/wss_lib.c:2028:	ucontrol->value.enumerated.item[1] = (chip->image[CS4231_RIGHT_INPUT] & CS4231_MIXS_ALL) >> 6;
./sound/isa/wss/wss_lib.c:2029:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2046:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2047:	left = (chip->image[CS4231_LEFT_INPUT] & ~CS4231_MIXS_ALL) | left;
./sound/isa/wss/wss_lib.c:2048:	right = (chip->image[CS4231_RIGHT_INPUT] & ~CS4231_MIXS_ALL) | right;
./sound/isa/wss/wss_lib.c:2049:	change = left != chip->image[CS4231_LEFT_INPUT] ||
./sound/isa/wss/wss_lib.c:2050:		 right != chip->image[CS4231_RIGHT_INPUT];
./sound/isa/wss/wss_lib.c:2053:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2080:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2081:	ucontrol->value.integer.value[0] = (chip->image[reg] >> shift) & mask;
./sound/isa/wss/wss_lib.c:2082:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2105:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2106:	val = (chip->image[reg] & ~(mask << shift)) | val;
./sound/isa/wss/wss_lib.c:2107:	change = val != chip->image[reg];
./sound/isa/wss/wss_lib.c:2109:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2139:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2140:	ucontrol->value.integer.value[0] = (chip->image[left_reg] >> shift_left) & mask;
./sound/isa/wss/wss_lib.c:2141:	ucontrol->value.integer.value[1] = (chip->image[right_reg] >> shift_right) & mask;
./sound/isa/wss/wss_lib.c:2142:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2173:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2175:		val1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;
./sound/isa/wss/wss_lib.c:2176:		val2 = (chip->image[right_reg] & ~(mask << shift_right)) | val2;
./sound/isa/wss/wss_lib.c:2177:		change = val1 != chip->image[left_reg] ||
./sound/isa/wss/wss_lib.c:2178:			 val2 != chip->image[right_reg];
./sound/isa/wss/wss_lib.c:2183:		val1 = (chip->image[left_reg] & ~mask) | val1 | val2;
./sound/isa/wss/wss_lib.c:2184:		change = val1 != chip->image[left_reg];
./sound/isa/wss/wss_lib.c:2187:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/wss/wss_lib.c:2251:	if (snd_BUG_ON(!chip || !chip->pcm))
./sound/isa/wss/wss_lib.c:2254:	card = chip->card;
./sound/isa/wss/wss_lib.c:2256:	strcpy(card->mixername, chip->pcm->name);
./sound/isa/wss/wss_lib.c:2259:	if (chip->hardware & WSS_HW_AD1848_MASK)
./sound/isa/wss/wss_lib.c:2262:	else if (chip->hardware == WSS_HW_OPTI93X)
./sound/isa/azt2320.c:216:		card->shortname, chip->port, irq[dev], dma1[dev], dma2[dev]);
./sound/isa/azt2320.c:302:	chip->suspend(chip);
./sound/isa/azt2320.c:312:	chip->resume(chip);
./sound/isa/sb/sb16_csp.c:129:	if ((err = snd_hwdep_new(chip->card, "SB16-CSP", device, &hw)) < 0)
./sound/isa/sb/sb16_csp.c:133:		snd_device_free(chip->card, hw);
./sound/isa/sb/sb16_csp.c:448:			spin_lock_irqsave(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:451:			spin_unlock_irqrestore(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:564:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:588:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:628:	spin_lock_irqsave(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:667:		spin_lock(&p->chip->mixer_lock);
./sound/isa/sb/sb16_csp.c:669:		spin_unlock(&p->chip->mixer_lock);
./sound/isa/sb/sb16_csp.c:683:	spin_unlock_irqrestore(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:717:				       p->chip->card->dev);
./sound/isa/sb/sb16_csp.c:772:				spin_lock_irqsave(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:775:				spin_unlock_irqrestore(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:826:	spin_lock_irqsave(&p->chip->mixer_lock, flags);
./sound/isa/sb/sb16_csp.c:832:	spin_lock(&p->chip->reg_lock);
./sound/isa/sb/sb16_csp.c:867:	spin_unlock(&p->chip->reg_lock);
./sound/isa/sb/sb16_csp.c:872:	spin_unlock_irqrestore(&p->chip->mixer_lock, flags);
./sound/isa/sb/sb16_csp.c:890:	spin_lock_irqsave(&p->chip->mixer_lock, flags);
./sound/isa/sb/sb16_csp.c:896:	spin_lock(&p->chip->reg_lock);
./sound/isa/sb/sb16_csp.c:906:	spin_unlock(&p->chip->reg_lock);
./sound/isa/sb/sb16_csp.c:911:	spin_unlock_irqrestore(&p->chip->mixer_lock, flags);
./sound/isa/sb/sb16_csp.c:929:	spin_lock_irqsave(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:931:	spin_unlock_irqrestore(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:949:	spin_lock_irqsave(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:951:	spin_unlock_irqrestore(&p->chip->reg_lock, flags);
./sound/isa/sb/sb16_csp.c:1056:	card = p->chip->card;
./sound/isa/sb/sb16_csp.c:1082:	card = p->chip->card;	
./sound/isa/sb/sb16_csp.c:1131:	if (! snd_card_proc_new(p->chip->card, name, &entry))
./sound/isa/sb/sb8_midi.c:44:	rmidi = chip->rmidi;
./sound/isa/sb/sb8_midi.c:50:	spin_lock(&chip->midi_input_lock);
./sound/isa/sb/sb8_midi.c:54:			if (chip->open & SB_OPEN_MIDI_INPUT_TRIGGER) {
./sound/isa/sb/sb8_midi.c:55:				snd_rawmidi_receive(chip->midi_substream_input, &byte, 1);
./sound/isa/sb/sb8_midi.c:59:	spin_unlock(&chip->midi_input_lock);
./sound/isa/sb/sb8_midi.c:70:	valid_open_flags = chip->hardware >= SB_HW_20
./sound/isa/sb/sb8_midi.c:72:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:73:	if (chip->open & ~valid_open_flags) {
./sound/isa/sb/sb8_midi.c:74:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:77:	chip->open |= SB_OPEN_MIDI_INPUT;
./sound/isa/sb/sb8_midi.c:78:	chip->midi_substream_input = substream;
./sound/isa/sb/sb8_midi.c:79:	if (!(chip->open & SB_OPEN_MIDI_OUTPUT)) {
./sound/isa/sb/sb8_midi.c:80:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:82:		if (chip->hardware >= SB_HW_20)
./sound/isa/sb/sb8_midi.c:85:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:97:	valid_open_flags = chip->hardware >= SB_HW_20
./sound/isa/sb/sb8_midi.c:99:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:100:	if (chip->open & ~valid_open_flags) {
./sound/isa/sb/sb8_midi.c:101:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:104:	chip->open |= SB_OPEN_MIDI_OUTPUT;
./sound/isa/sb/sb8_midi.c:105:	chip->midi_substream_output = substream;
./sound/isa/sb/sb8_midi.c:106:	if (!(chip->open & SB_OPEN_MIDI_INPUT)) {
./sound/isa/sb/sb8_midi.c:107:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:109:		if (chip->hardware >= SB_HW_20)
./sound/isa/sb/sb8_midi.c:112:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:123:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:124:	chip->open &= ~(SB_OPEN_MIDI_INPUT | SB_OPEN_MIDI_INPUT_TRIGGER);
./sound/isa/sb/sb8_midi.c:125:	chip->midi_substream_input = NULL;
./sound/isa/sb/sb8_midi.c:126:	if (!(chip->open & SB_OPEN_MIDI_OUTPUT)) {
./sound/isa/sb/sb8_midi.c:127:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:130:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:141:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:142:	chip->open &= ~(SB_OPEN_MIDI_OUTPUT | SB_OPEN_MIDI_OUTPUT_TRIGGER);
./sound/isa/sb/sb8_midi.c:143:	chip->midi_substream_output = NULL;
./sound/isa/sb/sb8_midi.c:144:	if (!(chip->open & SB_OPEN_MIDI_INPUT)) {
./sound/isa/sb/sb8_midi.c:145:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:148:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:159:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:161:		if (!(chip->open & SB_OPEN_MIDI_INPUT_TRIGGER)) {
./sound/isa/sb/sb8_midi.c:162:			if (chip->hardware < SB_HW_20)
./sound/isa/sb/sb8_midi.c:164:			chip->open |= SB_OPEN_MIDI_INPUT_TRIGGER;
./sound/isa/sb/sb8_midi.c:167:		if (chip->open & SB_OPEN_MIDI_INPUT_TRIGGER) {
./sound/isa/sb/sb8_midi.c:168:			if (chip->hardware < SB_HW_20)
./sound/isa/sb/sb8_midi.c:170:			chip->open &= ~SB_OPEN_MIDI_INPUT_TRIGGER;
./sound/isa/sb/sb8_midi.c:173:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:186:		spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:188:			chip->open &= ~SB_OPEN_MIDI_OUTPUT_TRIGGER;
./sound/isa/sb/sb8_midi.c:189:			del_timer(&chip->midi_timer);
./sound/isa/sb/sb8_midi.c:190:			spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:193:		if (chip->hardware >= SB_HW_20) {
./sound/isa/sb/sb8_midi.c:199:				spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:208:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:218:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:219:	mod_timer(&chip->midi_timer, 1 + jiffies);
./sound/isa/sb/sb8_midi.c:220:	spin_unlock_irqrestore(&chip->open_lock, flags);	
./sound/isa/sb/sb8_midi.c:230:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:232:		if (!(chip->open & SB_OPEN_MIDI_OUTPUT_TRIGGER)) {
./sound/isa/sb/sb8_midi.c:233:			setup_timer(&chip->midi_timer,
./sound/isa/sb/sb8_midi.c:236:			mod_timer(&chip->midi_timer, 1 + jiffies);
./sound/isa/sb/sb8_midi.c:237:			chip->open |= SB_OPEN_MIDI_OUTPUT_TRIGGER;
./sound/isa/sb/sb8_midi.c:240:		if (chip->open & SB_OPEN_MIDI_OUTPUT_TRIGGER) {
./sound/isa/sb/sb8_midi.c:241:			chip->open &= ~SB_OPEN_MIDI_OUTPUT_TRIGGER;
./sound/isa/sb/sb8_midi.c:244:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_midi.c:269:	if ((err = snd_rawmidi_new(chip->card, "SB8 MIDI", device, 1, 1, &rmidi)) < 0)
./sound/isa/sb/sb8_midi.c:275:	if (chip->hardware >= SB_HW_20)
./sound/isa/sb/sb8_midi.c:278:	chip->rmidi = rmidi;
./sound/isa/sb/sb16_main.c:55:	if (chip->hardware == SB_HW_16CSP) {
./sound/isa/sb/sb16_main.c:56:		struct snd_sb_csp *csp = chip->csp;
./sound/isa/sb/sb16_main.c:86:				if (csp->ops.csp_start(csp, (chip->mode & SB_MODE_PLAYBACK_16) ?
./sound/isa/sb/sb16_main.c:94:					chip->open = SNDRV_SB_CSP_MODE_DSP_WRITE;
./sound/isa/sb/sb16_main.c:103:	if (chip->hardware == SB_HW_16CSP) {
./sound/isa/sb/sb16_main.c:104:		struct snd_sb_csp *csp = chip->csp;
./sound/isa/sb/sb16_main.c:124:				if (csp->ops.csp_start(csp, (chip->mode & SB_MODE_CAPTURE_16) ?
./sound/isa/sb/sb16_main.c:132:					chip->open = SNDRV_SB_CSP_MODE_DSP_READ;
./sound/isa/sb/sb16_main.c:141:	if (chip->hardware == SB_HW_16CSP) {
./sound/isa/sb/sb16_main.c:142:		struct snd_sb_csp *csp = chip->csp;
./sound/isa/sb/sb16_main.c:145:			spin_lock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:147:			spin_unlock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:155:	if (chip->hardware == SB_HW_16CSP) {
./sound/isa/sb/sb16_main.c:156:		struct snd_sb_csp *csp = chip->csp;
./sound/isa/sb/sb16_main.c:173:	if ((chip->hardware == SB_HW_16CSP) && (chip->open == SNDRV_SB_CSP_MODE_DSP_WRITE)) {
./sound/isa/sb/sb16_main.c:174:		struct snd_sb_csp *csp = chip->csp;
./sound/isa/sb/sb16_main.c:178:			chip->open = 0;
./sound/isa/sb/sb16_main.c:186:	if (chip->hardware == SB_HW_16CSP) {
./sound/isa/sb/sb16_main.c:187:		struct snd_sb_csp *csp = chip->csp;
./sound/isa/sb/sb16_main.c:204:	if ((chip->hardware == SB_HW_16CSP) && (chip->open == SNDRV_SB_CSP_MODE_DSP_READ)) {
./sound/isa/sb/sb16_main.c:205:		struct snd_sb_csp *csp = chip->csp;
./sound/isa/sb/sb16_main.c:209:			chip->open = 0;
./sound/isa/sb/sb16_main.c:230:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:231:	if (chip->mode & (channel == SNDRV_PCM_STREAM_PLAYBACK ? SB_MODE_PLAYBACK_16 : SB_MODE_CAPTURE_16))
./sound/isa/sb/sb16_main.c:235:	if (!(chip->mode & SB_RATE_LOCK)) {
./sound/isa/sb/sb16_main.c:236:		chip->locked_rate = rate;
./sound/isa/sb/sb16_main.c:244:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:275:	size = chip->p_dma_size = snd_pcm_lib_buffer_bytes(substream);
./sound/isa/sb/sb16_main.c:276:	dma = (chip->mode & SB_MODE_PLAYBACK_8) ? chip->dma8 : chip->dma16;
./sound/isa/sb/sb16_main.c:280:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:281:	if (chip->mode & SB_MODE_PLAYBACK_16) {
./sound/isa/sb/sb16_main.c:297:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:307:	spin_lock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:311:		chip->mode |= SB_RATE_LOCK_PLAYBACK;
./sound/isa/sb/sb16_main.c:312:		snd_sbdsp_command(chip, chip->mode & SB_MODE_PLAYBACK_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);
./sound/isa/sb/sb16_main.c:316:		snd_sbdsp_command(chip, chip->mode & SB_MODE_PLAYBACK_16 ? SB_DSP_DMA16_OFF : SB_DSP_DMA8_OFF);
./sound/isa/sb/sb16_main.c:318:		if (chip->mode & SB_RATE_LOCK_CAPTURE)
./sound/isa/sb/sb16_main.c:319:			snd_sbdsp_command(chip, chip->mode & SB_MODE_CAPTURE_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);
./sound/isa/sb/sb16_main.c:320:		chip->mode &= ~SB_RATE_LOCK_PLAYBACK;
./sound/isa/sb/sb16_main.c:325:	spin_unlock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:344:	size = chip->c_dma_size = snd_pcm_lib_buffer_bytes(substream);
./sound/isa/sb/sb16_main.c:345:	dma = (chip->mode & SB_MODE_CAPTURE_8) ? chip->dma8 : chip->dma16;
./sound/isa/sb/sb16_main.c:349:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:350:	if (chip->mode & SB_MODE_CAPTURE_16) {
./sound/isa/sb/sb16_main.c:366:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:376:	spin_lock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:380:		chip->mode |= SB_RATE_LOCK_CAPTURE;
./sound/isa/sb/sb16_main.c:381:		snd_sbdsp_command(chip, chip->mode & SB_MODE_CAPTURE_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);
./sound/isa/sb/sb16_main.c:385:		snd_sbdsp_command(chip, chip->mode & SB_MODE_CAPTURE_16 ? SB_DSP_DMA16_OFF : SB_DSP_DMA8_OFF);
./sound/isa/sb/sb16_main.c:387:		if (chip->mode & SB_RATE_LOCK_PLAYBACK)
./sound/isa/sb/sb16_main.c:388:			snd_sbdsp_command(chip, chip->mode & SB_MODE_PLAYBACK_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);
./sound/isa/sb/sb16_main.c:389:		chip->mode &= ~SB_RATE_LOCK_CAPTURE;
./sound/isa/sb/sb16_main.c:394:	spin_unlock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:404:	spin_lock(&chip->mixer_lock);
./sound/isa/sb/sb16_main.c:406:	spin_unlock(&chip->mixer_lock);
./sound/isa/sb/sb16_main.c:407:	if ((status & SB_IRQTYPE_MPUIN) && chip->rmidi_callback)
./sound/isa/sb/sb16_main.c:408:		chip->rmidi_callback(irq, chip->rmidi->private_data);
./sound/isa/sb/sb16_main.c:411:		if (chip->mode & SB_MODE_PLAYBACK_8) {
./sound/isa/sb/sb16_main.c:412:			snd_pcm_period_elapsed(chip->playback_substream);
./sound/isa/sb/sb16_main.c:416:		if (chip->mode & SB_MODE_CAPTURE_8) {
./sound/isa/sb/sb16_main.c:417:			snd_pcm_period_elapsed(chip->capture_substream);
./sound/isa/sb/sb16_main.c:420:		spin_lock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:424:		spin_unlock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:428:		if (chip->mode & SB_MODE_PLAYBACK_16) {
./sound/isa/sb/sb16_main.c:429:			snd_pcm_period_elapsed(chip->playback_substream);
./sound/isa/sb/sb16_main.c:433:		if (chip->mode & SB_MODE_CAPTURE_16) {
./sound/isa/sb/sb16_main.c:434:			snd_pcm_period_elapsed(chip->capture_substream);
./sound/isa/sb/sb16_main.c:437:		spin_lock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:441:		spin_unlock(&chip->reg_lock);
./sound/isa/sb/sb16_main.c:456:	dma = (chip->mode & SB_MODE_PLAYBACK_8) ? chip->dma8 : chip->dma16;
./sound/isa/sb/sb16_main.c:457:	ptr = snd_dma_pointer(dma, chip->p_dma_size);
./sound/isa/sb/sb16_main.c:467:	dma = (chip->mode & SB_MODE_CAPTURE_8) ? chip->dma8 : chip->dma16;
./sound/isa/sb/sb16_main.c:468:	ptr = snd_dma_pointer(dma, chip->c_dma_size);
./sound/isa/sb/sb16_main.c:522:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:523:	if (chip->mode & SB_MODE_PLAYBACK) {
./sound/isa/sb/sb16_main.c:524:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:530:	if (chip->force_mode16 & SB_MODE_CAPTURE_16)
./sound/isa/sb/sb16_main.c:533:	if (chip->dma16 >= 0 && !(chip->mode & SB_MODE_CAPTURE_16)) {
./sound/isa/sb/sb16_main.c:534:		chip->mode |= SB_MODE_PLAYBACK_16;
./sound/isa/sb/sb16_main.c:537:		if (chip->dma16 <= 3) {
./sound/isa/sb/sb16_main.c:547:	if (chip->dma8 >= 0 && !(chip->mode & SB_MODE_CAPTURE_8)) {
./sound/isa/sb/sb16_main.c:548:		chip->mode |= SB_MODE_PLAYBACK_8;
./sound/isa/sb/sb16_main.c:550:		if (chip->dma16 < 0) {
./sound/isa/sb/sb16_main.c:552:			chip->mode |= SB_MODE_PLAYBACK_16;
./sound/isa/sb/sb16_main.c:560:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:564:	if (chip->hardware == SB_HW_ALS100)
./sound/isa/sb/sb16_main.c:566:	if (chip->hardware == SB_HW_CS5530) {
./sound/isa/sb/sb16_main.c:571:	if (chip->mode & SB_RATE_LOCK)
./sound/isa/sb/sb16_main.c:572:		runtime->hw.rate_min = runtime->hw.rate_max = chip->locked_rate;
./sound/isa/sb/sb16_main.c:573:	chip->playback_substream = substream;
./sound/isa/sb/sb16_main.c:574:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:584:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:585:	chip->playback_substream = NULL;
./sound/isa/sb/sb16_main.c:586:	chip->mode &= ~SB_MODE_PLAYBACK;
./sound/isa/sb/sb16_main.c:587:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:597:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:598:	if (chip->mode & SB_MODE_CAPTURE) {
./sound/isa/sb/sb16_main.c:599:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:605:	if (chip->force_mode16 & SB_MODE_PLAYBACK_16)
./sound/isa/sb/sb16_main.c:608:	if (chip->dma16 >= 0 && !(chip->mode & SB_MODE_PLAYBACK_16)) {
./sound/isa/sb/sb16_main.c:609:		chip->mode |= SB_MODE_CAPTURE_16;
./sound/isa/sb/sb16_main.c:612:		if (chip->dma16 <= 3) {
./sound/isa/sb/sb16_main.c:622:	if (chip->dma8 >= 0 && !(chip->mode & SB_MODE_PLAYBACK_8)) {
./sound/isa/sb/sb16_main.c:623:		chip->mode |= SB_MODE_CAPTURE_8;
./sound/isa/sb/sb16_main.c:625:		if (chip->dma16 < 0) {
./sound/isa/sb/sb16_main.c:627:			chip->mode |= SB_MODE_CAPTURE_16;
./sound/isa/sb/sb16_main.c:635:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:639:	if (chip->hardware == SB_HW_ALS100)
./sound/isa/sb/sb16_main.c:641:	if (chip->hardware == SB_HW_CS5530) {
./sound/isa/sb/sb16_main.c:646:	if (chip->mode & SB_RATE_LOCK)
./sound/isa/sb/sb16_main.c:647:		runtime->hw.rate_min = runtime->hw.rate_max = chip->locked_rate;
./sound/isa/sb/sb16_main.c:648:	chip->capture_substream = substream;
./sound/isa/sb/sb16_main.c:649:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:659:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:660:	chip->capture_substream = NULL;
./sound/isa/sb/sb16_main.c:661:	chip->mode &= ~SB_MODE_CAPTURE;
./sound/isa/sb/sb16_main.c:662:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb16_main.c:672:	if (chip->dma8 < 0 || chip->dma16 < 0) {
./sound/isa/sb/sb16_main.c:678:		chip->force_mode16 = 0;
./sound/isa/sb/sb16_main.c:680:		chip->force_mode16 = SB_MODE_PLAYBACK_16;
./sound/isa/sb/sb16_main.c:682:		chip->force_mode16 = SB_MODE_CAPTURE_16;
./sound/isa/sb/sb16_main.c:691:	if (chip->dma8 < 0 || chip->dma16 < 0)
./sound/isa/sb/sb16_main.c:693:	switch (chip->force_mode16) {
./sound/isa/sb/sb16_main.c:717:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:719:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:732:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:736:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb16_main.c:759:	// printk(KERN_DEBUG "codec->irq=%i, codec->dma8=%i, codec->dma16=%i\n", chip->irq, chip->dma8, chip->dma16);
./sound/isa/sb/sb16_main.c:760:	spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/sb/sb16_main.c:762:	spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/sb/sb16_main.c:763:	switch (chip->irq) {
./sound/isa/sb/sb16_main.c:780:	if (chip->dma8 >= 0) {
./sound/isa/sb/sb16_main.c:781:		switch (chip->dma8) {
./sound/isa/sb/sb16_main.c:795:	if (chip->dma16 >= 0 && chip->dma16 != chip->dma8) {
./sound/isa/sb/sb16_main.c:796:		switch (chip->dma16) {
./sound/isa/sb/sb16_main.c:810:	switch (chip->mpu_port) {
./sound/isa/sb/sb16_main.c:820:	spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/sb/sb16_main.c:831:	spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/sb/sb16_main.c:833:		snd_printk(KERN_ERR "SB16 [0x%lx]: unable to set DMA & IRQ (PnP device?)\n", chip->port);
./sound/isa/sb/sb16_main.c:834:		snd_printk(KERN_ERR "SB16 [0x%lx]: wanted: irqreg=0x%x, dmareg=0x%x, mpureg = 0x%x\n", chip->port, realirq, realdma, realmpureg);
./sound/isa/sb/sb16_main.c:835:		snd_printk(KERN_ERR "SB16 [0x%lx]:    got: irqreg=0x%x, dmareg=0x%x, mpureg = 0x%x\n", chip->port, irqreg, dmareg, mpureg);
./sound/isa/sb/sb16_main.c:865:	struct snd_card *card = chip->card;
./sound/isa/sb/sb16_main.c:871:	sprintf(pcm->name, "DSP v%i.%i", chip->version >> 8, chip->version & 0xff);
./sound/isa/sb/sb16_main.c:874:	chip->pcm = pcm;
./sound/isa/sb/sb16_main.c:879:	if (chip->dma16 >= 0 && chip->dma8 != chip->dma16)
./sound/isa/sb/sb16.c:369:	if (chip->hardware != SB_HW_16) {
./sound/isa/sb/sb16.c:373:	chip->mpu_port = mpu_port[dev];
./sound/isa/sb/sb16.c:385:	strcpy(card->shortname, chip->name);
./sound/isa/sb/sb16.c:387:		chip->name,
./sound/isa/sb/sb16.c:388:		chip->port,
./sound/isa/sb/sb16.c:396:	if (chip->mpu_port > 0 && chip->mpu_port != SNDRV_AUTO_PORT) {
./sound/isa/sb/sb16.c:398:					       chip->mpu_port,
./sound/isa/sb/sb16.c:400:					       &chip->rmidi)) < 0)
./sound/isa/sb/sb16.c:402:		chip->rmidi_callback = snd_mpu401_uart_interrupt;
./sound/isa/sb/sb16.c:433:	if ((chip->hardware == SB_HW_16) && csp[dev]) {
./sound/isa/sb/sb16.c:436:			chip->csp = xcsp->private_data;
./sound/isa/sb/sb16.c:437:			chip->hardware = SB_HW_16CSP;
./sound/isa/sb/sb16.c:455:	spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/sb/sb16.c:459:	spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/sb/sb16.c:474:	snd_pcm_suspend_all(chip->pcm);
./sound/isa/sb/jazz16.c:165:	if (jazz_dma_bits[chip->dma8] == 0 ||
./sound/isa/sb/jazz16.c:166:	    jazz_dma_bits[chip->dma16] == 0 ||
./sound/isa/sb/jazz16.c:167:	    jazz_irq_bits[chip->irq] == 0)
./sound/isa/sb/jazz16.c:174:			       jazz_dma_bits[chip->dma8] |
./sound/isa/sb/jazz16.c:175:			       (jazz_dma_bits[chip->dma16] << 4)))
./sound/isa/sb/jazz16.c:179:			       jazz_irq_bits[chip->irq] |
./sound/isa/sb/jazz16.c:307:	err = snd_opl3_create(card, chip->port, chip->port + 2,
./sound/isa/sb/jazz16.c:311:			   chip->port, chip->port + 2);
./sound/isa/sb/jazz16.c:359:	snd_pcm_suspend_all(chip->pcm);
./sound/isa/sb/sb_common.c:55:	snd_printd("%s [0x%lx]: timeout (0x%x)\n", __func__, chip->port, val);
./sound/isa/sb/sb_common.c:72:	snd_printd("%s [0x%lx]: timeout\n", __func__, chip->port);
./sound/isa/sb/sb_common.c:91:	snd_printdd("%s [0x%lx] failed...\n", __func__, chip->port);
./sound/isa/sb/sb_common.c:116:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb_common.c:118:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb_common.c:123:		spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb_common.c:126:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb_common.c:130:		    chip->port, major, minor);
./sound/isa/sb/sb_common.c:132:	switch (chip->hardware) {
./sound/isa/sb/sb_common.c:136:			chip->hardware = SB_HW_10;
./sound/isa/sb/sb_common.c:141:				chip->hardware = SB_HW_201;
./sound/isa/sb/sb_common.c:144:				chip->hardware = SB_HW_20;
./sound/isa/sb/sb_common.c:149:			chip->hardware = SB_HW_PRO;
./sound/isa/sb/sb_common.c:153:			chip->hardware = SB_HW_16;
./sound/isa/sb/sb_common.c:158:				   chip->port, major, minor);
./sound/isa/sb/sb_common.c:180:	sprintf(chip->name, "Sound Blaster %s", str);
./sound/isa/sb/sb_common.c:181:	chip->version = (major << 8) | minor;
./sound/isa/sb/sb_common.c:187:	release_and_free_resource(chip->res_port);
./sound/isa/sb/sb_common.c:188:	if (chip->irq >= 0)
./sound/isa/sb/sb_common.c:189:		free_irq(chip->irq, (void *) chip);
./sound/isa/sb/sb_common.c:191:	if (chip->dma8 >= 0) {
./sound/isa/sb/sb_common.c:192:		disable_dma(chip->dma8);
./sound/isa/sb/sb_common.c:193:		free_dma(chip->dma8);
./sound/isa/sb/sb_common.c:195:	if (chip->dma16 >= 0 && chip->dma16 != chip->dma8) {
./sound/isa/sb/sb_common.c:196:		disable_dma(chip->dma16);
./sound/isa/sb/sb_common.c:197:		free_dma(chip->dma16);
./sound/isa/sb/sb_common.c:231:	spin_lock_init(&chip->reg_lock);
./sound/isa/sb/sb_common.c:232:	spin_lock_init(&chip->open_lock);
./sound/isa/sb/sb_common.c:233:	spin_lock_init(&chip->midi_input_lock);
./sound/isa/sb/sb_common.c:234:	spin_lock_init(&chip->mixer_lock);
./sound/isa/sb/sb_common.c:235:	chip->irq = -1;
./sound/isa/sb/sb_common.c:236:	chip->dma8 = -1;
./sound/isa/sb/sb_common.c:237:	chip->dma16 = -1;
./sound/isa/sb/sb_common.c:238:	chip->port = port;
./sound/isa/sb/sb_common.c:249:	chip->irq = irq;
./sound/isa/sb/sb_common.c:254:	if ((chip->res_port = request_region(port, 16, "SoundBlaster")) == NULL) {
./sound/isa/sb/sb_common.c:266:	chip->dma8 = dma8;
./sound/isa/sb/sb_common.c:277:	chip->dma16 = dma16;
./sound/isa/sb/sb_common.c:281:	chip->card = card;
./sound/isa/sb/sb_common.c:282:	chip->hardware = hardware;
./sound/isa/sb/sb8.c:66:	if (chip->open & SB_OPEN_PCM) {
./sound/isa/sb/sb8.c:149:	if (chip->hardware >= SB_HW_16) {
./sound/isa/sb/sb8.c:150:		if (chip->hardware == SB_HW_ALS100)
./sound/isa/sb/sb8.c:166:	if (chip->hardware == SB_HW_10 || chip->hardware == SB_HW_20) {
./sound/isa/sb/sb8.c:167:		if ((err = snd_opl3_create(card, chip->port + 8, 0,
./sound/isa/sb/sb8.c:170:			snd_printk(KERN_WARNING "sb8: no OPL device at 0x%lx\n", chip->port + 8);
./sound/isa/sb/sb8.c:173:		if ((err = snd_opl3_create(card, chip->port, chip->port + 2,
./sound/isa/sb/sb8.c:177:				   chip->port, chip->port + 2);
./sound/isa/sb/sb8.c:188:	strcpy(card->driver, chip->hardware == SB_HW_PRO ? "SB Pro" : "SB8");
./sound/isa/sb/sb8.c:189:	strcpy(card->shortname, chip->name);
./sound/isa/sb/sb8.c:191:		chip->name,
./sound/isa/sb/sb8.c:192:		chip->port,
./sound/isa/sb/sb8.c:221:	snd_pcm_suspend_all(chip->pcm);
./sound/isa/sb/sb_mixer.c:503:	if ((err = snd_ctl_add(chip->card, ctl)) < 0)
./sound/isa/sb/sb_mixer.c:714:	struct snd_card *card = chip->card;
./sound/isa/sb/sb_mixer.c:718:	spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/sb/sb_mixer.c:720:	spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/sb/sb_mixer.c:724:		spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/sb/sb_mixer.c:726:		spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/sb/sb_mixer.c:744:	if (snd_BUG_ON(!chip || !chip->card))
./sound/isa/sb/sb_mixer.c:747:	card = chip->card;
./sound/isa/sb/sb_mixer.c:749:	switch (chip->hardware) {
./sound/isa/sb/sb_mixer.c:892:	unsigned char *val = chip->saved_regs;
./sound/isa/sb/sb_mixer.c:893:	if (snd_BUG_ON(num_regs > ARRAY_SIZE(chip->saved_regs)))
./sound/isa/sb/sb_mixer.c:901:	unsigned char *val = chip->saved_regs;
./sound/isa/sb/sb_mixer.c:902:	if (snd_BUG_ON(num_regs > ARRAY_SIZE(chip->saved_regs)))
./sound/isa/sb/sb_mixer.c:910:	switch (chip->hardware) {
./sound/isa/sb/sb_mixer.c:937:	switch (chip->hardware) {
./sound/isa/sb/sb8_main.c:115:	switch (chip->hardware) {
./sound/isa/sb/sb8_main.c:118:			if (chip->mode & SB_MODE_CAPTURE_16)
./sound/isa/sb/sb8_main.c:121:				chip->mode |= SB_MODE_PLAYBACK_16;
./sound/isa/sb/sb8_main.c:123:		chip->playback_format = SB_DSP_LO_OUTPUT_AUTO;
./sound/isa/sb/sb8_main.c:130:			chip->playback_format = SB_DSP_HI_OUTPUT_AUTO;
./sound/isa/sb/sb8_main.c:136:			chip->playback_format = SB_DSP_HI_OUTPUT_AUTO;
./sound/isa/sb/sb8_main.c:141:		chip->playback_format = SB_DSP_LO_OUTPUT_AUTO;
./sound/isa/sb/sb8_main.c:144:		chip->playback_format = SB_DSP_OUTPUT;
./sound/isa/sb/sb8_main.c:149:	if (chip->mode & SB_MODE_PLAYBACK_16) {
./sound/isa/sb/sb8_main.c:151:		dma = chip->dma16;
./sound/isa/sb/sb8_main.c:154:		chip->mode |= SB_MODE_PLAYBACK_8;
./sound/isa/sb/sb8_main.c:155:		dma = chip->dma8;
./sound/isa/sb/sb8_main.c:157:	size = chip->p_dma_size = snd_pcm_lib_buffer_bytes(substream);
./sound/isa/sb/sb8_main.c:158:	count = chip->p_period_size = snd_pcm_lib_period_bytes(substream);
./sound/isa/sb/sb8_main.c:159:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb8_main.c:161:	if (chip->hardware == SB_HW_JAZZ16)
./sound/isa/sb/sb8_main.c:165:		spin_lock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:168:		spin_unlock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:182:		spin_lock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:186:		spin_unlock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:188:		chip->force_mode16 = mixreg;
./sound/isa/sb/sb8_main.c:192:	if (chip->playback_format != SB_DSP_OUTPUT) {
./sound/isa/sb/sb8_main.c:193:		if (chip->mode & SB_MODE_PLAYBACK_16)
./sound/isa/sb/sb8_main.c:200:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb8_main.c:213:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb8_main.c:216:		snd_sbdsp_command(chip, chip->playback_format);
./sound/isa/sb/sb8_main.c:217:		if (chip->playback_format == SB_DSP_OUTPUT) {
./sound/isa/sb/sb8_main.c:218:			count = chip->p_period_size - 1;
./sound/isa/sb/sb8_main.c:224:		if (chip->playback_format == SB_DSP_HI_OUTPUT_AUTO) {
./sound/isa/sb/sb8_main.c:228:				spin_lock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:230:				snd_sbmixer_write(chip, SB_DSP_STEREO_SW, chip->force_mode16 & ~0x02);
./sound/isa/sb/sb8_main.c:231:				spin_unlock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:238:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb8_main.c:265:	switch (chip->hardware) {
./sound/isa/sb/sb8_main.c:268:			if (chip->mode & SB_MODE_PLAYBACK_16)
./sound/isa/sb/sb8_main.c:271:				chip->mode |= SB_MODE_CAPTURE_16;
./sound/isa/sb/sb8_main.c:273:		chip->capture_format = SB_DSP_LO_INPUT_AUTO;
./sound/isa/sb/sb8_main.c:280:			chip->capture_format = SB_DSP_HI_INPUT_AUTO;
./sound/isa/sb/sb8_main.c:283:		chip->capture_format = (rate > 23000) ? SB_DSP_HI_INPUT_AUTO : SB_DSP_LO_INPUT_AUTO;
./sound/isa/sb/sb8_main.c:287:			chip->capture_format = SB_DSP_HI_INPUT_AUTO;
./sound/isa/sb/sb8_main.c:292:		chip->capture_format = SB_DSP_LO_INPUT_AUTO;
./sound/isa/sb/sb8_main.c:295:		chip->capture_format = SB_DSP_INPUT;
./sound/isa/sb/sb8_main.c:300:	if (chip->mode & SB_MODE_CAPTURE_16) {
./sound/isa/sb/sb8_main.c:302:		dma = chip->dma16;
./sound/isa/sb/sb8_main.c:305:		chip->mode |= SB_MODE_CAPTURE_8;
./sound/isa/sb/sb8_main.c:306:		dma = chip->dma8;
./sound/isa/sb/sb8_main.c:308:	size = chip->c_dma_size = snd_pcm_lib_buffer_bytes(substream);
./sound/isa/sb/sb8_main.c:309:	count = chip->c_period_size = snd_pcm_lib_period_bytes(substream);
./sound/isa/sb/sb8_main.c:310:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb8_main.c:312:	if (chip->hardware == SB_HW_JAZZ16)
./sound/isa/sb/sb8_main.c:319:		spin_lock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:323:		spin_unlock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:325:		chip->force_mode16 = mixreg;
./sound/isa/sb/sb8_main.c:329:	if (chip->capture_format != SB_DSP_INPUT) {
./sound/isa/sb/sb8_main.c:330:		if (chip->mode & SB_MODE_PLAYBACK_16)
./sound/isa/sb/sb8_main.c:337:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb8_main.c:350:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sb/sb8_main.c:353:		snd_sbdsp_command(chip, chip->capture_format);
./sound/isa/sb/sb8_main.c:354:		if (chip->capture_format == SB_DSP_INPUT) {
./sound/isa/sb/sb8_main.c:355:			count = chip->c_period_size - 1;
./sound/isa/sb/sb8_main.c:361:		if (chip->capture_format == SB_DSP_HI_INPUT_AUTO) {
./sound/isa/sb/sb8_main.c:366:				spin_lock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:367:				snd_sbmixer_write(chip, SB_DSP_CAPTURE_FILT, chip->force_mode16);
./sound/isa/sb/sb8_main.c:368:				spin_unlock(&chip->mixer_lock);
./sound/isa/sb/sb8_main.c:377:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sb/sb8_main.c:387:	switch (chip->mode) {
./sound/isa/sb/sb8_main.c:389:		if (chip->hardware != SB_HW_JAZZ16)
./sound/isa/sb/sb8_main.c:393:		substream = chip->playback_substream;
./sound/isa/sb/sb8_main.c:395:		if (chip->playback_format == SB_DSP_OUTPUT)
./sound/isa/sb/sb8_main.c:400:		if (chip->hardware != SB_HW_JAZZ16)
./sound/isa/sb/sb8_main.c:404:		substream = chip->capture_substream;
./sound/isa/sb/sb8_main.c:406:		if (chip->capture_format == SB_DSP_INPUT)
./sound/isa/sb/sb8_main.c:420:	if (chip->mode & SB_MODE_PLAYBACK_8)
./sound/isa/sb/sb8_main.c:421:		dma = chip->dma8;
./sound/isa/sb/sb8_main.c:422:	else if (chip->mode & SB_MODE_PLAYBACK_16)
./sound/isa/sb/sb8_main.c:423:		dma = chip->dma16;
./sound/isa/sb/sb8_main.c:426:	ptr = snd_dma_pointer(dma, chip->p_dma_size);
./sound/isa/sb/sb8_main.c:436:	if (chip->mode & SB_MODE_CAPTURE_8)
./sound/isa/sb/sb8_main.c:437:		dma = chip->dma8;
./sound/isa/sb/sb8_main.c:438:	else if (chip->mode & SB_MODE_CAPTURE_16)
./sound/isa/sb/sb8_main.c:439:		dma = chip->dma16;
./sound/isa/sb/sb8_main.c:442:	ptr = snd_dma_pointer(dma, chip->c_dma_size);
./sound/isa/sb/sb8_main.c:498:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_main.c:499:	if (chip->open) {
./sound/isa/sb/sb8_main.c:500:		spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_main.c:503:	chip->open |= SB_OPEN_PCM;
./sound/isa/sb/sb8_main.c:504:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_main.c:506:		chip->playback_substream = substream;
./sound/isa/sb/sb8_main.c:509:		chip->capture_substream = substream;
./sound/isa/sb/sb8_main.c:512:	switch (chip->hardware) {
./sound/isa/sb/sb8_main.c:514:		if (chip->dma16 == 5 || chip->dma16 == 7)
./sound/isa/sb/sb8_main.c:543:	if (chip->dma8 > 3 || chip->dma16 >= 0) {
./sound/isa/sb/sb8_main.c:559:	chip->playback_substream = NULL;
./sound/isa/sb/sb8_main.c:560:	chip->capture_substream = NULL;
./sound/isa/sb/sb8_main.c:561:	spin_lock_irqsave(&chip->open_lock, flags);
./sound/isa/sb/sb8_main.c:562:	chip->open &= ~SB_OPEN_PCM;
./sound/isa/sb/sb8_main.c:564:		chip->mode &= ~SB_MODE_PLAYBACK;
./sound/isa/sb/sb8_main.c:566:		chip->mode &= ~SB_MODE_CAPTURE;
./sound/isa/sb/sb8_main.c:567:	spin_unlock_irqrestore(&chip->open_lock, flags);
./sound/isa/sb/sb8_main.c:599:	struct snd_card *card = chip->card;
./sound/isa/sb/sb8_main.c:606:	sprintf(pcm->name, "DSP v%i.%i", chip->version >> 8, chip->version & 0xff);
./sound/isa/sb/sb8_main.c:613:	if (chip->dma8 > 3 || chip->dma16 >= 0)
./sound/isa/ad1816a/ad1816a.c:167:		chip->clock_freq = clockfreq[dev];
./sound/isa/ad1816a/ad1816a.c:172:		card->shortname, chip->port, irq[dev], dma1[dev], dma2[dev]);
./sound/isa/ad1816a/ad1816a_lib.c:112:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:114:	if (chip->mode & mode) {
./sound/isa/ad1816a/ad1816a_lib.c:115:		spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:138:	chip->mode |= mode;
./sound/isa/ad1816a/ad1816a_lib.c:140:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:148:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:169:	if (!((chip->mode &= ~mode) & AD1816A_MODE_OPEN))
./sound/isa/ad1816a/ad1816a_lib.c:170:		chip->mode = 0;
./sound/isa/ad1816a/ad1816a_lib.c:172:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:184:		spin_lock(&chip->lock);
./sound/isa/ad1816a/ad1816a_lib.c:196:		spin_unlock(&chip->lock);
./sound/isa/ad1816a/ad1816a_lib.c:238:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:240:	chip->p_dma_size = size = snd_pcm_lib_buffer_bytes(substream);
./sound/isa/ad1816a/ad1816a_lib.c:244:	snd_dma_program(chip->dma1, runtime->dma_addr, size,
./sound/isa/ad1816a/ad1816a_lib.c:248:	if (chip->clock_freq)
./sound/isa/ad1816a/ad1816a_lib.c:249:		rate = (rate * 33000) / chip->clock_freq;
./sound/isa/ad1816a/ad1816a_lib.c:259:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:270:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:272:	chip->c_dma_size = size = snd_pcm_lib_buffer_bytes(substream);
./sound/isa/ad1816a/ad1816a_lib.c:276:	snd_dma_program(chip->dma2, runtime->dma_addr, size,
./sound/isa/ad1816a/ad1816a_lib.c:280:	if (chip->clock_freq)
./sound/isa/ad1816a/ad1816a_lib.c:281:		rate = (rate * 33000) / chip->clock_freq;
./sound/isa/ad1816a/ad1816a_lib.c:291:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:300:	if (!(chip->mode & AD1816A_MODE_PLAYBACK))
./sound/isa/ad1816a/ad1816a_lib.c:302:	ptr = snd_dma_pointer(chip->dma1, chip->p_dma_size);
./sound/isa/ad1816a/ad1816a_lib.c:310:	if (!(chip->mode & AD1816A_MODE_CAPTURE))
./sound/isa/ad1816a/ad1816a_lib.c:312:	ptr = snd_dma_pointer(chip->dma2, chip->c_dma_size);
./sound/isa/ad1816a/ad1816a_lib.c:322:	spin_lock(&chip->lock);
./sound/isa/ad1816a/ad1816a_lib.c:324:	spin_unlock(&chip->lock);
./sound/isa/ad1816a/ad1816a_lib.c:326:	if ((status & AD1816A_PLAYBACK_IRQ_PENDING) && chip->playback_substream)
./sound/isa/ad1816a/ad1816a_lib.c:327:		snd_pcm_period_elapsed(chip->playback_substream);
./sound/isa/ad1816a/ad1816a_lib.c:329:	if ((status & AD1816A_CAPTURE_IRQ_PENDING) && chip->capture_substream)
./sound/isa/ad1816a/ad1816a_lib.c:330:		snd_pcm_period_elapsed(chip->capture_substream);
./sound/isa/ad1816a/ad1816a_lib.c:332:	if ((status & AD1816A_TIMER_IRQ_PENDING) && chip->timer)
./sound/isa/ad1816a/ad1816a_lib.c:333:		snd_timer_interrupt(chip->timer, chip->timer->sticks);
./sound/isa/ad1816a/ad1816a_lib.c:335:	spin_lock(&chip->lock);
./sound/isa/ad1816a/ad1816a_lib.c:337:	spin_unlock(&chip->lock);
./sound/isa/ad1816a/ad1816a_lib.c:407:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:417:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:425:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:430:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:454:	snd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.buffer_bytes_max);
./sound/isa/ad1816a/ad1816a_lib.c:455:	snd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.period_bytes_max);
./sound/isa/ad1816a/ad1816a_lib.c:456:	chip->playback_substream = substream;
./sound/isa/ad1816a/ad1816a_lib.c:469:	snd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.buffer_bytes_max);
./sound/isa/ad1816a/ad1816a_lib.c:470:	snd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.period_bytes_max);
./sound/isa/ad1816a/ad1816a_lib.c:471:	chip->capture_substream = substream;
./sound/isa/ad1816a/ad1816a_lib.c:479:	chip->playback_substream = NULL;
./sound/isa/ad1816a/ad1816a_lib.c:488:	chip->capture_substream = NULL;
./sound/isa/ad1816a/ad1816a_lib.c:498:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:511:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:520:	snd_pcm_suspend_all(chip->pcm);
./sound/isa/ad1816a/ad1816a_lib.c:521:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:523:		chip->image[reg] = snd_ad1816a_read(chip, reg);
./sound/isa/ad1816a/ad1816a_lib.c:524:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:533:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:535:		snd_ad1816a_write(chip, reg, chip->image[reg]);
./sound/isa/ad1816a/ad1816a_lib.c:536:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:544:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:546:	switch (chip->version = snd_ad1816a_read(chip, AD1816A_VERSION_ID)) {
./sound/isa/ad1816a/ad1816a_lib.c:548:		chip->hardware = AD1816A_HW_AD1815;
./sound/isa/ad1816a/ad1816a_lib.c:551:		chip->hardware = AD1816A_HW_AD18MAX10;
./sound/isa/ad1816a/ad1816a_lib.c:554:		chip->hardware = AD1816A_HW_AD1816A;
./sound/isa/ad1816a/ad1816a_lib.c:557:		chip->hardware = AD1816A_HW_AUTO;
./sound/isa/ad1816a/ad1816a_lib.c:560:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:566:	release_and_free_resource(chip->res_port);
./sound/isa/ad1816a/ad1816a_lib.c:567:	if (chip->irq >= 0)
./sound/isa/ad1816a/ad1816a_lib.c:568:		free_irq(chip->irq, (void *) chip);
./sound/isa/ad1816a/ad1816a_lib.c:569:	if (chip->dma1 >= 0) {
./sound/isa/ad1816a/ad1816a_lib.c:570:		snd_dma_disable(chip->dma1);
./sound/isa/ad1816a/ad1816a_lib.c:571:		free_dma(chip->dma1);
./sound/isa/ad1816a/ad1816a_lib.c:573:	if (chip->dma2 >= 0) {
./sound/isa/ad1816a/ad1816a_lib.c:574:		snd_dma_disable(chip->dma2);
./sound/isa/ad1816a/ad1816a_lib.c:575:		free_dma(chip->dma2);
./sound/isa/ad1816a/ad1816a_lib.c:588:	switch (chip->hardware) {
./sound/isa/ad1816a/ad1816a_lib.c:594:			chip->version, chip->hardware);
./sound/isa/ad1816a/ad1816a_lib.c:608:	chip->irq = -1;
./sound/isa/ad1816a/ad1816a_lib.c:609:	chip->dma1 = -1;
./sound/isa/ad1816a/ad1816a_lib.c:610:	chip->dma2 = -1;
./sound/isa/ad1816a/ad1816a_lib.c:612:	if ((chip->res_port = request_region(port, 16, "AD1816A")) == NULL) {
./sound/isa/ad1816a/ad1816a_lib.c:622:	chip->irq = irq;
./sound/isa/ad1816a/ad1816a_lib.c:628:	chip->dma1 = dma1;
./sound/isa/ad1816a/ad1816a_lib.c:634:	chip->dma2 = dma2;
./sound/isa/ad1816a/ad1816a_lib.c:636:	chip->card = card;
./sound/isa/ad1816a/ad1816a_lib.c:637:	chip->port = port;
./sound/isa/ad1816a/ad1816a_lib.c:638:	spin_lock_init(&chip->lock);
./sound/isa/ad1816a/ad1816a_lib.c:683:	if ((error = snd_pcm_new(chip->card, "AD1816A", device, 1, 1, &pcm)))
./sound/isa/ad1816a/ad1816a_lib.c:690:	pcm->info_flags = (chip->dma1 == chip->dma2 ) ? SNDRV_PCM_INFO_JOINT_DUPLEX : 0;
./sound/isa/ad1816a/ad1816a_lib.c:697:					      64*1024, chip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024);
./sound/isa/ad1816a/ad1816a_lib.c:699:	chip->pcm = pcm;
./sound/isa/ad1816a/ad1816a_lib.c:711:	tid.card = chip->card->number;
./sound/isa/ad1816a/ad1816a_lib.c:714:	if ((error = snd_timer_new(chip->card, "AD1816A", &tid, &timer)) < 0)
./sound/isa/ad1816a/ad1816a_lib.c:718:	chip->timer = timer;
./sound/isa/ad1816a/ad1816a_lib.c:743:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:745:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:763:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:766:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:802:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:804:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:825:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:830:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:869:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:873:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:901:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:906:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/ad1816a/ad1816a_lib.c:968:	if (snd_BUG_ON(!chip || !chip->card))
./sound/isa/ad1816a/ad1816a_lib.c:971:	card = chip->card;
./sound/isa/es18xx.c:182:                if ((inb(chip->port + 0x0C) & 0x80) == 0) {
./sound/isa/es18xx.c:183:                        outb(val, chip->port + 0x0C);
./sound/isa/es18xx.c:195:                if (inb(chip->port + 0x0C) & 0x40)
./sound/isa/es18xx.c:196:                        return inb(chip->port + 0x0A);
./sound/isa/es18xx.c:198:		   chip->port + 0x0A, inb(chip->port + 0x0A));
./sound/isa/es18xx.c:210:        spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es18xx.c:216:        spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es18xx.c:227:        spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es18xx.c:240:        spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es18xx.c:251:        spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/es18xx.c:279:        spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/es18xx.c:287:        spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/es18xx.c:288:        outb(reg, chip->port + 0x04);
./sound/isa/es18xx.c:289:        outb(data, chip->port + 0x05);
./sound/isa/es18xx.c:290:        spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/es18xx.c:300:        spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/es18xx.c:301:        outb(reg, chip->port + 0x04);
./sound/isa/es18xx.c:302:	data = inb(chip->port + 0x05);
./sound/isa/es18xx.c:303:        spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/es18xx.c:316:        spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/es18xx.c:317:        outb(reg, chip->port + 0x04);
./sound/isa/es18xx.c:318:	old = inb(chip->port + 0x05);
./sound/isa/es18xx.c:322:		outb(new, chip->port + 0x05);
./sound/isa/es18xx.c:328:        spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/es18xx.c:337:        spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/es18xx.c:338:        outb(reg, chip->port + 0x04);
./sound/isa/es18xx.c:339:	old = inb(chip->port + 0x05);
./sound/isa/es18xx.c:341:	outb(expected, chip->port + 0x05);
./sound/isa/es18xx.c:342:	new = inb(chip->port + 0x05);
./sound/isa/es18xx.c:343:        spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/es18xx.c:355:        outb(0x03, chip->port + 0x06);
./sound/isa/es18xx.c:356:        inb(chip->port + 0x06);
./sound/isa/es18xx.c:357:        outb(0x00, chip->port + 0x06);
./sound/isa/es18xx.c:358:        for(i = 0; i < MILLISECOND && !(inb(chip->port + 0x0E) & 0x80); i++);
./sound/isa/es18xx.c:359:        if (inb(chip->port + 0x0A) != 0xAA)
./sound/isa/es18xx.c:366:        outb(0x02, chip->port + 0x06);
./sound/isa/es18xx.c:367:        inb(chip->port + 0x06);
./sound/isa/es18xx.c:368:        outb(0x00, chip->port + 0x06);
./sound/isa/es18xx.c:419:	if (chip->caps & ES18XX_NEW_RATE) {
./sound/isa/es18xx.c:434:	if ((chip->caps & ES18XX_PCM2) && mode == DAC2) {
./sound/isa/es18xx.c:460:	if (substream->number == 0 && (chip->caps & ES18XX_PCM2)) {
./sound/isa/es18xx.c:461:		if ((chip->caps & ES18XX_DUPLEX_MONO) &&
./sound/isa/es18xx.c:462:		    (chip->capture_a_substream) &&
./sound/isa/es18xx.c:467:		chip->dma2_shift = shift;
./sound/isa/es18xx.c:469:		chip->dma1_shift = shift;
./sound/isa/es18xx.c:502:        snd_dma_program(chip->dma2, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);
./sound/isa/es18xx.c:514:		if (chip->active & DAC2)
./sound/isa/es18xx.c:516:		chip->active |= DAC2;
./sound/isa/es18xx.c:518:		if (chip->dma2 >= 4)
./sound/isa/es18xx.c:525:		if (chip->caps & ES18XX_PCM2)
./sound/isa/es18xx.c:527:			snd_es18xx_mixer_write(chip, 0x7C, chip->audio2_vol);
./sound/isa/es18xx.c:535:		if (!(chip->active & DAC2))
./sound/isa/es18xx.c:537:		chip->active &= ~DAC2;
./sound/isa/es18xx.c:542:		if (chip->caps & ES18XX_PCM2)
./sound/isa/es18xx.c:564:	if ((chip->caps & ES18XX_DUPLEX_MONO) &&
./sound/isa/es18xx.c:565:	    chip->playback_a_substream &&
./sound/isa/es18xx.c:574:	chip->dma1_shift = shift;
./sound/isa/es18xx.c:612:        snd_dma_program(chip->dma1, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);
./sound/isa/es18xx.c:625:		if (chip->active & ADC1)
./sound/isa/es18xx.c:627:		chip->active |= ADC1;
./sound/isa/es18xx.c:633:		if (!(chip->active & ADC1))
./sound/isa/es18xx.c:635:		chip->active &= ~ADC1;
./sound/isa/es18xx.c:676:        snd_dma_program(chip->dma1, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);
./sound/isa/es18xx.c:688:		if (chip->active & DAC1)
./sound/isa/es18xx.c:690:		chip->active |= DAC1;
./sound/isa/es18xx.c:702:		if (!(chip->active & DAC1))
./sound/isa/es18xx.c:704:		chip->active &= ~DAC1;
./sound/isa/es18xx.c:724:	if (substream->number == 0 && (chip->caps & ES18XX_PCM2))
./sound/isa/es18xx.c:734:	if (substream->number == 0 && (chip->caps & ES18XX_PCM2))
./sound/isa/es18xx.c:746:	if (chip->caps & ES18XX_CONTROL) {
./sound/isa/es18xx.c:748:		status = inb(chip->ctrl_port + 6);
./sound/isa/es18xx.c:756:		if (inb(chip->port + 0x0C) & 0x01)
./sound/isa/es18xx.c:760:		if ((chip->caps & ES18XX_HWV) &&
./sound/isa/es18xx.c:768:                if (chip->active & DAC2)
./sound/isa/es18xx.c:769:                	snd_pcm_period_elapsed(chip->playback_a_substream);
./sound/isa/es18xx.c:775:                if (chip->active & ADC1)
./sound/isa/es18xx.c:776:                	snd_pcm_period_elapsed(chip->capture_a_substream);
./sound/isa/es18xx.c:778:                else if (chip->active & DAC1)
./sound/isa/es18xx.c:779:                	snd_pcm_period_elapsed(chip->playback_b_substream);
./sound/isa/es18xx.c:781:		inb(chip->port + 0x0E);
./sound/isa/es18xx.c:785:	if ((status & MPU_IRQ) && chip->rmidi)
./sound/isa/es18xx.c:786:		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
./sound/isa/es18xx.c:791:		if (chip->caps & ES18XX_HWV) {
./sound/isa/es18xx.c:794:					&chip->hw_switch->id);
./sound/isa/es18xx.c:796:					&chip->hw_volume->id);
./sound/isa/es18xx.c:800:					&chip->master_switch->id);
./sound/isa/es18xx.c:802:					&chip->master_volume->id);
./sound/isa/es18xx.c:816:	if (substream->number == 0 && (chip->caps & ES18XX_PCM2)) {
./sound/isa/es18xx.c:817:		if (!(chip->active & DAC2))
./sound/isa/es18xx.c:819:		pos = snd_dma_pointer(chip->dma2, size);
./sound/isa/es18xx.c:820:		return pos >> chip->dma2_shift;
./sound/isa/es18xx.c:822:		if (!(chip->active & DAC1))
./sound/isa/es18xx.c:824:		pos = snd_dma_pointer(chip->dma1, size);
./sound/isa/es18xx.c:825:		return pos >> chip->dma1_shift;
./sound/isa/es18xx.c:835:        if (!(chip->active & ADC1))
./sound/isa/es18xx.c:837:	pos = snd_dma_pointer(chip->dma1, size);
./sound/isa/es18xx.c:838:	return pos >> chip->dma1_shift;
./sound/isa/es18xx.c:886:	if (substream->number == 0 && (chip->caps & ES18XX_PCM2)) {
./sound/isa/es18xx.c:887:		if ((chip->caps & ES18XX_DUPLEX_MONO) &&
./sound/isa/es18xx.c:888:		    chip->capture_a_substream && 
./sound/isa/es18xx.c:889:		    chip->capture_a_substream->runtime->channels != 1)
./sound/isa/es18xx.c:891:		chip->playback_a_substream = substream;
./sound/isa/es18xx.c:893:		if (chip->capture_a_substream)
./sound/isa/es18xx.c:895:		chip->playback_b_substream = substream;
./sound/isa/es18xx.c:902:				      (chip->caps & ES18XX_NEW_RATE) ? &new_hw_constraints_clocks : &old_hw_constraints_clocks);
./sound/isa/es18xx.c:911:        if (chip->playback_b_substream)
./sound/isa/es18xx.c:913:	if ((chip->caps & ES18XX_DUPLEX_MONO) &&
./sound/isa/es18xx.c:914:	    chip->playback_a_substream &&
./sound/isa/es18xx.c:915:	    chip->playback_a_substream->runtime->channels != 1)
./sound/isa/es18xx.c:917:        chip->capture_a_substream = substream;
./sound/isa/es18xx.c:920:				      (chip->caps & ES18XX_NEW_RATE) ? &new_hw_constraints_clocks : &old_hw_constraints_clocks);
./sound/isa/es18xx.c:928:	if (substream->number == 0 && (chip->caps & ES18XX_PCM2))
./sound/isa/es18xx.c:929:		chip->playback_a_substream = NULL;
./sound/isa/es18xx.c:931:		chip->playback_b_substream = NULL;
./sound/isa/es18xx.c:941:        chip->capture_a_substream = NULL;
./sound/isa/es18xx.c:977:	switch (chip->version) {
./sound/isa/es18xx.c:997:	if (!(chip->version == 0x1869 || chip->version == 0x1879)) {
./sound/isa/es18xx.c:1000:		    (chip->version == 0x1887 || chip->version == 0x1888) &&
./sound/isa/es18xx.c:1016:	switch (chip->version) {
./sound/isa/es18xx.c:1101:	chip->master_volume = NULL;
./sound/isa/es18xx.c:1102:	chip->master_switch = NULL;
./sound/isa/es18xx.c:1103:	chip->hw_volume = NULL;
./sound/isa/es18xx.c:1104:	chip->hw_switch = NULL;
./sound/isa/es18xx.c:1155:		val = inb(chip->port + ES18XX_PM);
./sound/isa/es18xx.c:1180:		unsigned char cur = inb(chip->port + ES18XX_PM);
./sound/isa/es18xx.c:1184:		outb((cur & ~mask) | val, chip->port + ES18XX_PM);
./sound/isa/es18xx.c:1377:	outb(reg, chip->ctrl_port);
./sound/isa/es18xx.c:1378:	data = inb(chip->ctrl_port + 1);
./sound/isa/es18xx.c:1387:	outb(reg, chip->ctrl_port);
./sound/isa/es18xx.c:1388:	outb(data, chip->ctrl_port + 1);
./sound/isa/es18xx.c:1407:	if (chip->caps & ES18XX_CONTROL) {
./sound/isa/es18xx.c:1409:		snd_es18xx_config_write(chip, 0x27, chip->irq);
./sound/isa/es18xx.c:1420:			snd_es18xx_config_write(chip, 0x28, chip->irq);
./sound/isa/es18xx.c:1423:		snd_es18xx_config_write(chip, 0x70, chip->irq);
./sound/isa/es18xx.c:1425:		snd_es18xx_config_write(chip, 0x72, chip->irq);
./sound/isa/es18xx.c:1427:		snd_es18xx_config_write(chip, 0x74, chip->dma1);
./sound/isa/es18xx.c:1429:		snd_es18xx_config_write(chip, 0x75, chip->dma2);
./sound/isa/es18xx.c:1444:		switch (chip->irq) {
./sound/isa/es18xx.c:1459:			snd_printk(KERN_ERR "invalid irq %d\n", chip->irq);
./sound/isa/es18xx.c:1462:		switch (chip->dma1) {
./sound/isa/es18xx.c:1473:			snd_printk(KERN_ERR "invalid dma1 %d\n", chip->dma1);
./sound/isa/es18xx.c:1476:		switch (chip->dma2) {
./sound/isa/es18xx.c:1490:			snd_printk(KERN_ERR "invalid dma2 %d\n", chip->dma2);
./sound/isa/es18xx.c:1514:	if (chip->caps & ES18XX_NEW_RATE) {
./sound/isa/es18xx.c:1520:	if (!(chip->caps & ES18XX_PCM2)) {
./sound/isa/es18xx.c:1524:	if (chip->caps & ES18XX_SPATIALIZER) {
./sound/isa/es18xx.c:1532:	switch (chip->version) {
./sound/isa/es18xx.c:1543:	if (chip->caps & ES18XX_MUTEREC)
./sound/isa/es18xx.c:1545:	if (chip->caps & ES18XX_RECMIX)
./sound/isa/es18xx.c:1565:		snd_printk(KERN_ERR "reset at 0x%lx failed!!!\n", chip->port);
./sound/isa/es18xx.c:1579:		chip->version = 0x488;
./sound/isa/es18xx.c:1586:		chip->version = 0x688;
./sound/isa/es18xx.c:1590:        outb(0x40, chip->port + 0x04);
./sound/isa/es18xx.c:1592:	hi = inb(chip->port + 0x05);
./sound/isa/es18xx.c:1594:	lo = inb(chip->port + 0x05);
./sound/isa/es18xx.c:1596:		chip->version = hi << 8 | lo;
./sound/isa/es18xx.c:1597:		chip->ctrl_port = inb(chip->port + 0x05) << 8;
./sound/isa/es18xx.c:1599:		chip->ctrl_port += inb(chip->port + 0x05);
./sound/isa/es18xx.c:1601:		if ((chip->res_ctrl_port = request_region(chip->ctrl_port, 8, "ES18xx - CTRL")) == NULL) {
./sound/isa/es18xx.c:1602:			snd_printk(KERN_ERR PFX "unable go grab port 0x%lx\n", chip->ctrl_port);
./sound/isa/es18xx.c:1615:				chip->version = 0x1887;
./sound/isa/es18xx.c:1617:				chip->version = 0x1888;
./sound/isa/es18xx.c:1620:			chip->version = 0x1788;
./sound/isa/es18xx.c:1624:		chip->version = 0x1688;
./sound/isa/es18xx.c:1633:		snd_printk(KERN_ERR PFX "[0x%lx] ESS chip not found\n", chip->port);
./sound/isa/es18xx.c:1637:	switch (chip->version) {
./sound/isa/es18xx.c:1639:		chip->caps = ES18XX_DUPLEX_MONO | ES18XX_DUPLEX_SAME | ES18XX_CONTROL | ES18XX_GPO_2BIT;
./sound/isa/es18xx.c:1642:		chip->caps = ES18XX_PCM2 | ES18XX_SPATIALIZER | ES18XX_RECMIX | ES18XX_NEW_RATE | ES18XX_AUXB | ES18XX_MONO | ES18XX_MUTEREC | ES18XX_CONTROL | ES18XX_HWV | ES18XX_GPO_2BIT;
./sound/isa/es18xx.c:1645:		chip->caps = ES18XX_DUPLEX_MONO | ES18XX_DUPLEX_SAME | ES18XX_I2S | ES18XX_CONTROL;
./sound/isa/es18xx.c:1648:		chip->caps = ES18XX_PCM2 | ES18XX_SPATIALIZER | ES18XX_RECMIX | ES18XX_NEW_RATE | ES18XX_AUXB | ES18XX_I2S | ES18XX_CONTROL | ES18XX_HWV;
./sound/isa/es18xx.c:1652:		chip->caps = ES18XX_PCM2 | ES18XX_RECMIX | ES18XX_AUXB | ES18XX_DUPLEX_SAME | ES18XX_GPO_2BIT;
./sound/isa/es18xx.c:1656:                           chip->port, chip->version);
./sound/isa/es18xx.c:1660:        snd_printd("[0x%lx] ESS%x chip found\n", chip->port, chip->version);
./sound/isa/es18xx.c:1662:	if (chip->dma1 == chip->dma2)
./sound/isa/es18xx.c:1663:		chip->caps &= ~(ES18XX_PCM2 | ES18XX_DUPLEX_SAME);
./sound/isa/es18xx.c:1697:	sprintf(str, "ES%x", chip->version);
./sound/isa/es18xx.c:1698:	if (chip->caps & ES18XX_PCM2)
./sound/isa/es18xx.c:1711:	if (chip->caps & ES18XX_DUPLEX_SAME)
./sound/isa/es18xx.c:1713:	if (! (chip->caps & ES18XX_PCM2))
./sound/isa/es18xx.c:1715:	sprintf(pcm->name, "ESS AudioDrive ES%x", chip->version);
./sound/isa/es18xx.c:1716:        chip->pcm = pcm;
./sound/isa/es18xx.c:1721:					      chip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024);
./sound/isa/es18xx.c:1733:	snd_pcm_suspend_all(chip->pcm);
./sound/isa/es18xx.c:1736:	chip->pm_reg = (unsigned char)snd_es18xx_read(chip, ES18XX_PM);
./sound/isa/es18xx.c:1737:	chip->pm_reg |= (ES18XX_PM_FM | ES18XX_PM_SUS);
./sound/isa/es18xx.c:1738:	snd_es18xx_write(chip, ES18XX_PM, chip->pm_reg);
./sound/isa/es18xx.c:1739:	snd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_SUS);
./sound/isa/es18xx.c:1749:	snd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_FM);
./sound/isa/es18xx.c:1760:	release_and_free_resource(chip->res_port);
./sound/isa/es18xx.c:1761:	release_and_free_resource(chip->res_ctrl_port);
./sound/isa/es18xx.c:1762:	release_and_free_resource(chip->res_mpu_port);
./sound/isa/es18xx.c:1763:	if (chip->irq >= 0)
./sound/isa/es18xx.c:1764:		free_irq(chip->irq, (void *) card);
./sound/isa/es18xx.c:1765:	if (chip->dma1 >= 0) {
./sound/isa/es18xx.c:1766:		disable_dma(chip->dma1);
./sound/isa/es18xx.c:1767:		free_dma(chip->dma1);
./sound/isa/es18xx.c:1769:	if (chip->dma2 >= 0 && chip->dma1 != chip->dma2) {
./sound/isa/es18xx.c:1770:		disable_dma(chip->dma2);
./sound/isa/es18xx.c:1771:		free_dma(chip->dma2);
./sound/isa/es18xx.c:1793:	spin_lock_init(&chip->reg_lock);
./sound/isa/es18xx.c:1794: 	spin_lock_init(&chip->mixer_lock);
./sound/isa/es18xx.c:1795:        chip->port = port;
./sound/isa/es18xx.c:1796:        chip->irq = -1;
./sound/isa/es18xx.c:1797:        chip->dma1 = -1;
./sound/isa/es18xx.c:1798:        chip->dma2 = -1;
./sound/isa/es18xx.c:1799:        chip->audio2_vol = 0x00;
./sound/isa/es18xx.c:1800:	chip->active = 0;
./sound/isa/es18xx.c:1802:	chip->res_port = request_region(port, 16, "ES18xx");
./sound/isa/es18xx.c:1803:	if (chip->res_port == NULL) {
./sound/isa/es18xx.c:1815:	chip->irq = irq;
./sound/isa/es18xx.c:1822:	chip->dma1 = dma1;
./sound/isa/es18xx.c:1829:	chip->dma2 = dma2;
./sound/isa/es18xx.c:1849:	strcpy(card->mixername, chip->pcm->name);
./sound/isa/es18xx.c:1854:		if (chip->caps & ES18XX_HWV) {
./sound/isa/es18xx.c:1857:				chip->master_volume = kctl;
./sound/isa/es18xx.c:1861:				chip->master_switch = kctl;
./sound/isa/es18xx.c:1869:	if (chip->caps & ES18XX_PCM2) {
./sound/isa/es18xx.c:1881:	if (chip->caps & ES18XX_RECMIX) {
./sound/isa/es18xx.c:1887:	switch (chip->version) {
./sound/isa/es18xx.c:1898:	if (chip->caps & ES18XX_SPATIALIZER) {
./sound/isa/es18xx.c:1904:	if (chip->caps & ES18XX_HWV) {
./sound/isa/es18xx.c:1909:				chip->hw_volume = kctl;
./sound/isa/es18xx.c:1911:				chip->hw_switch = kctl;
./sound/isa/es18xx.c:1920:	if (chip->version != 0x1868) {
./sound/isa/es18xx.c:1926:	if (chip->version == 0x1869) {
./sound/isa/es18xx.c:1934:	} else if (chip->version == 0x1878) {
./sound/isa/es18xx.c:1939:	} else if (chip->version == 0x1879) {
./sound/isa/es18xx.c:1948:	if (chip->caps & ES18XX_GPO_2BIT) {
./sound/isa/es18xx.c:2059:	chip->dev = pdev;
./sound/isa/es18xx.c:2060:	if (snd_audiodrive_pnp_init_main(dev, chip->dev) < 0)
./sound/isa/es18xx.c:2090:	chip->dev = pnp_request_card_device(card, id->devs[0].id, NULL);
./sound/isa/es18xx.c:2091:	if (chip->dev == NULL)
./sound/isa/es18xx.c:2094:	chip->devc = pnp_request_card_device(card, id->devs[1].id, NULL);
./sound/isa/es18xx.c:2095:	if (chip->devc == NULL)
./sound/isa/es18xx.c:2099:	if (pnp_activate_dev(chip->devc) < 0) {
./sound/isa/es18xx.c:2104:			(unsigned long long)pnp_port_start(chip->devc, 0));
./sound/isa/es18xx.c:2105:	if (snd_audiodrive_pnp_init_main(dev, chip->dev) < 0)
./sound/isa/es18xx.c:2137:	sprintf(card->driver, "ES%x", chip->version);
./sound/isa/es18xx.c:2139:	sprintf(card->shortname, "ESS AudioDrive ES%x", chip->version);
./sound/isa/es18xx.c:2143:			chip->port,
./sound/isa/es18xx.c:2148:			chip->port,
./sound/isa/es18xx.c:2175:					  -1, &chip->rmidi);
./sound/isa/opl3sa2.c:182:	outb(reg, chip->port);	/* register */
./sound/isa/opl3sa2.c:183:	result = inb(chip->port + 1);
./sound/isa/opl3sa2.c:197:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:199:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:209:	outb(reg, chip->port);	/* register */
./sound/isa/opl3sa2.c:210:	outb(value, chip->port + 1);
./sound/isa/opl3sa2.c:211:	chip->ctlregs[reg] = value;
./sound/isa/opl3sa2.c:218:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:220:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:230:	port = chip->port;
./sound/isa/opl3sa2.c:231:	if ((chip->res_port = request_region(port, 2, "OPL3-SA control")) == NULL) {
./sound/isa/opl3sa2.c:239:	chip->version = 0;
./sound/isa/opl3sa2.c:247:		chip->version = 2; /* YMF711 */
./sound/isa/opl3sa2.c:250:		chip->version = 3;
./sound/isa/opl3sa2.c:258:	str[0] = chip->version + '0';
./sound/isa/opl3sa2.c:277:	if (chip->version > 2) {
./sound/isa/opl3sa2.c:279:		snd_opl3sa2_write(chip, OPL3SA2_SYS_CTRL, (chip->ymode << 4));
./sound/isa/opl3sa2.c:285:	if (chip->single_dma) {
./sound/isa/opl3sa2.c:291:	if (chip->version > 2) {
./sound/isa/opl3sa2.c:313:		snd_opl3_interrupt(chip->synth);
./sound/isa/opl3sa2.c:316:	if ((status & 0x10) && chip->rmidi != NULL) {
./sound/isa/opl3sa2.c:318:		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
./sound/isa/opl3sa2.c:323:		snd_wss_interrupt(irq, chip->wss);
./sound/isa/opl3sa2.c:331:		if (chip->master_switch && chip->master_volume) {
./sound/isa/opl3sa2.c:333:					&chip->master_switch->id);
./sound/isa/opl3sa2.c:335:					&chip->master_volume->id);
./sound/isa/opl3sa2.c:364:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:365:	ucontrol->value.integer.value[0] = (chip->ctlregs[reg] >> shift) & mask;
./sound/isa/opl3sa2.c:366:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:387:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:388:	oval = chip->ctlregs[reg];
./sound/isa/opl3sa2.c:392:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:421:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:422:	ucontrol->value.integer.value[0] = (chip->ctlregs[left_reg] >> shift_left) & mask;
./sound/isa/opl3sa2.c:423:	ucontrol->value.integer.value[1] = (chip->ctlregs[right_reg] >> shift_right) & mask;
./sound/isa/opl3sa2.c:424:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:453:	spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:455:		oval1 = chip->ctlregs[left_reg];
./sound/isa/opl3sa2.c:456:		oval2 = chip->ctlregs[right_reg];
./sound/isa/opl3sa2.c:463:		oval1 = chip->ctlregs[left_reg];
./sound/isa/opl3sa2.c:468:	spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/opl3sa2.c:494:	chip->master_switch = NULL;
./sound/isa/opl3sa2.c:495:	chip->master_volume = NULL;
./sound/isa/opl3sa2.c:540:		case 0: chip->master_switch = kctl; kctl->private_free = snd_opl3sa2_master_free; break;
./sound/isa/opl3sa2.c:541:		case 1: chip->master_volume = kctl; kctl->private_free = snd_opl3sa2_master_free; break;
./sound/isa/opl3sa2.c:544:	if (chip->version > 2) {
./sound/isa/opl3sa2.c:560:		chip->wss->suspend(chip->wss);
./sound/isa/opl3sa2.c:583:			snd_opl3sa2_write(chip, i, chip->ctlregs[i]);
./sound/isa/opl3sa2.c:585:	if (chip->version > 2) {
./sound/isa/opl3sa2.c:587:			snd_opl3sa2_write(chip, i, chip->ctlregs[i]);
./sound/isa/opl3sa2.c:590:	chip->wss->resume(chip->wss);
./sound/isa/opl3sa2.c:624:	if (chip->irq >= 0)
./sound/isa/opl3sa2.c:625:		free_irq(chip->irq, card);
./sound/isa/opl3sa2.c:626:	release_and_free_resource(chip->res_port);
./sound/isa/opl3sa2.c:643:	spin_lock_init(&chip->reg_lock);
./sound/isa/opl3sa2.c:644:	chip->irq = -1;
./sound/isa/opl3sa2.c:660:	chip->ymode = opl3sa3_ymode[dev] & 0x03 ;
./sound/isa/opl3sa2.c:661:	chip->port = port[dev];
./sound/isa/opl3sa2.c:666:		chip->single_dma = 1;
./sound/isa/opl3sa2.c:676:	chip->irq = xirq;
./sound/isa/opl3sa2.c:685:	chip->wss = wss;
./sound/isa/opl3sa2.c:705:		if ((err = snd_opl3_hwdep_new(opl3, 0, 1, &chip->synth)) < 0)
./sound/isa/opl3sa2.c:712:					       &chip->rmidi)) < 0)
./sound/isa/opl3sa2.c:716:		card->shortname, chip->port, xirq, xdma1);
./sound/isa/sscape.c:351:	free_dma(sscape->chip->dma1);
./sound/isa/sscape.c:460:	val = (s->chip->dma1 << 4) | DMA_8BIT;
./sound/isa/sscape.c:482:		snd_dma_program(s->chip->dma1, dma.addr, len, DMA_MODE_WRITE);
./sound/isa/sscape.c:619:	struct snd_card *card = chip->card;
./sound/isa/sscape.c:633:	struct snd_card *card = chip->card;
./sound/isa/sscape.c:889:			spin_lock_irqsave(&chip->reg_lock, flags);
./sound/isa/sscape.c:891:			spin_unlock_irqrestore(&chip->reg_lock, flags);
./sound/isa/sscape.c:909:		if (chip->hardware != WSS_HW_AD1848) {
./sound/isa/sscape.c:1082:		 name, sscape->chip->port, sscape->chip->irq,
./sound/isa/sscape.c:1083:		 sscape->chip->dma1, sscape->chip->dma2);
./sound/isa/msnd/msnd_pinnacle.c:85:	chip->play_sample_size = DEFSAMPLESIZE;
./sound/isa/msnd/msnd_pinnacle.c:86:	chip->play_sample_rate = DEFSAMPLERATE;
./sound/isa/msnd/msnd_pinnacle.c:87:	chip->play_channels = DEFCHANNELS;
./sound/isa/msnd/msnd_pinnacle.c:88:	chip->capture_sample_size = DEFSAMPLESIZE;
./sound/isa/msnd/msnd_pinnacle.c:89:	chip->capture_sample_rate = DEFSAMPLERATE;
./sound/isa/msnd/msnd_pinnacle.c:90:	chip->capture_channels = DEFCHANNELS;
./sound/isa/msnd/msnd_pinnacle.c:97:		if (chip->banksPlayed < 3)
./sound/isa/msnd/msnd_pinnacle.c:101:		if (chip->last_playbank == LOBYTE(wMessage)) {
./sound/isa/msnd/msnd_pinnacle.c:105:		chip->banksPlayed++;
./sound/isa/msnd/msnd_pinnacle.c:107:		if (test_bit(F_WRITING, &chip->flags))
./sound/isa/msnd/msnd_pinnacle.c:110:		chip->last_playbank = LOBYTE(wMessage);
./sound/isa/msnd/msnd_pinnacle.c:111:		chip->playDMAPos += chip->play_period_bytes;
./sound/isa/msnd/msnd_pinnacle.c:112:		if (chip->playDMAPos > chip->playLimit)
./sound/isa/msnd/msnd_pinnacle.c:113:			chip->playDMAPos = 0;
./sound/isa/msnd/msnd_pinnacle.c:114:		snd_pcm_period_elapsed(chip->playback_substream);
./sound/isa/msnd/msnd_pinnacle.c:119:		if (chip->last_recbank == LOBYTE(wMessage))
./sound/isa/msnd/msnd_pinnacle.c:121:		chip->last_recbank = LOBYTE(wMessage);
./sound/isa/msnd/msnd_pinnacle.c:122:		chip->captureDMAPos += chip->capturePeriodBytes;
./sound/isa/msnd/msnd_pinnacle.c:123:		if (chip->captureDMAPos > (chip->captureLimit))
./sound/isa/msnd/msnd_pinnacle.c:124:			chip->captureDMAPos = 0;
./sound/isa/msnd/msnd_pinnacle.c:126:		if (test_bit(F_READING, &chip->flags))
./sound/isa/msnd/msnd_pinnacle.c:127:			snd_msnd_DARQ(chip, chip->last_recbank);
./sound/isa/msnd/msnd_pinnacle.c:129:		snd_pcm_period_elapsed(chip->capture_substream);
./sound/isa/msnd/msnd_pinnacle.c:139:				chip->banksPlayed);
./sound/isa/msnd/msnd_pinnacle.c:140:			if (chip->banksPlayed > 2)
./sound/isa/msnd/msnd_pinnacle.c:141:				clear_bit(F_WRITING, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:146:			clear_bit(F_READING, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:158:		if (chip->msndmidi_mpu)
./sound/isa/msnd/msnd_pinnacle.c:159:			snd_msndmidi_input_read(chip->msndmidi_mpu);
./sound/isa/msnd/msnd_pinnacle.c:172:	void *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;
./sound/isa/msnd/msnd_pinnacle.c:175:	/* inb(chip->io + HP_RXL); */
./sound/isa/msnd/msnd_pinnacle.c:178:	while (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {
./sound/isa/msnd/msnd_pinnacle.c:182:			readw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));
./sound/isa/msnd/msnd_pinnacle.c:184:		wTmp = readw(chip->DSPQ + JQS_wHead) + 1;
./sound/isa/msnd/msnd_pinnacle.c:185:		if (wTmp > readw(chip->DSPQ + JQS_wSize))
./sound/isa/msnd/msnd_pinnacle.c:186:			writew(0, chip->DSPQ + JQS_wHead);
./sound/isa/msnd/msnd_pinnacle.c:188:			writew(wTmp, chip->DSPQ + JQS_wHead);
./sound/isa/msnd/msnd_pinnacle.c:191:	inb(chip->io + HP_RXL);
./sound/isa/msnd/msnd_pinnacle.c:228:	if (!request_region(chip->io, DSP_NUMIO, "probing")) {
./sound/isa/msnd/msnd_pinnacle.c:233:	if (snd_msnd_reset_dsp(chip->io, &info) < 0) {
./sound/isa/msnd/msnd_pinnacle.c:234:		release_region(chip->io, DSP_NUMIO);
./sound/isa/msnd/msnd_pinnacle.c:244:	       chip->io, chip->io + DSP_NUMIO - 1,
./sound/isa/msnd/msnd_pinnacle.c:245:	       chip->irq,
./sound/isa/msnd/msnd_pinnacle.c:246:	       chip->base, chip->base + 0x7fff);
./sound/isa/msnd/msnd_pinnacle.c:305:	       chip->io, chip->io + DSP_NUMIO - 1,
./sound/isa/msnd/msnd_pinnacle.c:306:	       chip->irq,
./sound/isa/msnd/msnd_pinnacle.c:307:	       chip->base, chip->base + 0x7fff);
./sound/isa/msnd/msnd_pinnacle.c:310:	release_region(chip->io, DSP_NUMIO);
./sound/isa/msnd/msnd_pinnacle.c:321:	outb(chip->memid, chip->io + HP_MEMM);
./sound/isa/msnd/msnd_pinnacle.c:323:	outb(HPBLKSEL_0, chip->io + HP_BLKS);
./sound/isa/msnd/msnd_pinnacle.c:325:	chip->SMA = chip->mappedbase + SMA_STRUCT_START;
./sound/isa/msnd/msnd_pinnacle.c:328:		mastVolLeft = readw(chip->SMA + SMA_wCurrMastVolLeft);
./sound/isa/msnd/msnd_pinnacle.c:329:		mastVolRight = readw(chip->SMA + SMA_wCurrMastVolRight);
./sound/isa/msnd/msnd_pinnacle.c:332:	memset_io(chip->mappedbase, 0, 0x8000);
./sound/isa/msnd/msnd_pinnacle.c:335:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/msnd/msnd_pinnacle.c:336:	outb(HPBLKSEL_1, chip->io + HP_BLKS);
./sound/isa/msnd/msnd_pinnacle.c:337:	memset_io(chip->mappedbase, 0, 0x8000);
./sound/isa/msnd/msnd_pinnacle.c:338:	outb(HPBLKSEL_0, chip->io + HP_BLKS);
./sound/isa/msnd/msnd_pinnacle.c:339:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/msnd/msnd_pinnacle.c:342:	chip->DAPQ = chip->mappedbase + DAPQ_OFFSET;
./sound/isa/msnd/msnd_pinnacle.c:343:	snd_msnd_init_queue(chip->DAPQ, DAPQ_DATA_BUFF, DAPQ_BUFF_SIZE);
./sound/isa/msnd/msnd_pinnacle.c:346:	chip->DARQ = chip->mappedbase + DARQ_OFFSET;
./sound/isa/msnd/msnd_pinnacle.c:347:	snd_msnd_init_queue(chip->DARQ, DARQ_DATA_BUFF, DARQ_BUFF_SIZE);
./sound/isa/msnd/msnd_pinnacle.c:350:	chip->MODQ = chip->mappedbase + MODQ_OFFSET;
./sound/isa/msnd/msnd_pinnacle.c:351:	snd_msnd_init_queue(chip->MODQ, MODQ_DATA_BUFF, MODQ_BUFF_SIZE);
./sound/isa/msnd/msnd_pinnacle.c:354:	chip->MIDQ = chip->mappedbase + MIDQ_OFFSET;
./sound/isa/msnd/msnd_pinnacle.c:355:	snd_msnd_init_queue(chip->MIDQ, MIDQ_DATA_BUFF, MIDQ_BUFF_SIZE);
./sound/isa/msnd/msnd_pinnacle.c:358:	chip->DSPQ = chip->mappedbase + DSPQ_OFFSET;
./sound/isa/msnd/msnd_pinnacle.c:359:	snd_msnd_init_queue(chip->DSPQ, DSPQ_DATA_BUFF, DSPQ_BUFF_SIZE);
./sound/isa/msnd/msnd_pinnacle.c:363:	writew(1, chip->SMA + SMA_wCurrPlayFormat);
./sound/isa/msnd/msnd_pinnacle.c:364:	writew(chip->play_sample_size, chip->SMA + SMA_wCurrPlaySampleSize);
./sound/isa/msnd/msnd_pinnacle.c:365:	writew(chip->play_channels, chip->SMA + SMA_wCurrPlayChannels);
./sound/isa/msnd/msnd_pinnacle.c:366:	writew(chip->play_sample_rate, chip->SMA + SMA_wCurrPlaySampleRate);
./sound/isa/msnd/msnd_pinnacle.c:368:	writew(chip->play_sample_rate, chip->SMA + SMA_wCalFreqAtoD);
./sound/isa/msnd/msnd_pinnacle.c:369:	writew(mastVolLeft, chip->SMA + SMA_wCurrMastVolLeft);
./sound/isa/msnd/msnd_pinnacle.c:370:	writew(mastVolRight, chip->SMA + SMA_wCurrMastVolRight);
./sound/isa/msnd/msnd_pinnacle.c:372:	writel(0x00010000, chip->SMA + SMA_dwCurrPlayPitch);
./sound/isa/msnd/msnd_pinnacle.c:373:	writel(0x00000001, chip->SMA + SMA_dwCurrPlayRate);
./sound/isa/msnd/msnd_pinnacle.c:375:	writew(0x303, chip->SMA + SMA_wCurrInputTagBits);
./sound/isa/msnd/msnd_pinnacle.c:389:	outb(HPBLKSEL_0, chip->io + HP_BLKS);
./sound/isa/msnd/msnd_pinnacle.c:402:	memcpy_toio(chip->mappedbase, perm_fw->data, perm_fw->size);
./sound/isa/msnd/msnd_pinnacle.c:421:	outb(HPPRORESET_ON, chip->io + HP_PROR);
./sound/isa/msnd/msnd_pinnacle.c:423:	outb(HPPRORESET_OFF, chip->io + HP_PROR);
./sound/isa/msnd/msnd_pinnacle.c:434:	outb(HPWAITSTATE_0, chip->io + HP_WAIT);
./sound/isa/msnd/msnd_pinnacle.c:435:	outb(HPBITMODE_16, chip->io + HP_BITM);
./sound/isa/msnd/msnd_pinnacle.c:445:	err = snd_msnd_reset_dsp(chip->io, NULL);
./sound/isa/msnd/msnd_pinnacle.c:457:	while (readw(chip->mappedbase)) {
./sound/isa/msnd/msnd_pinnacle.c:474:	if (test_bit(F_RESETTING, &chip->flags) || ++chip->nresets > 10)
./sound/isa/msnd/msnd_pinnacle.c:477:	set_bit(F_RESETTING, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:484:	clear_bit(F_RESETTING, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:498:	snd_msnd_dsp_full_reset(chip->card);
./sound/isa/msnd/msnd_pinnacle.c:505:	writew(srate, chip->SMA + SMA_wCalFreqAtoD);
./sound/isa/msnd/msnd_pinnacle.c:506:	if (chip->calibrate_signal == 0)
./sound/isa/msnd/msnd_pinnacle.c:507:		writew(readw(chip->SMA + SMA_wCurrHostStatusFlags)
./sound/isa/msnd/msnd_pinnacle.c:508:		       | 0x0001, chip->SMA + SMA_wCurrHostStatusFlags);
./sound/isa/msnd/msnd_pinnacle.c:510:		writew(readw(chip->SMA + SMA_wCurrHostStatusFlags)
./sound/isa/msnd/msnd_pinnacle.c:511:		       & ~0x0001, chip->SMA + SMA_wCurrHostStatusFlags);
./sound/isa/msnd/msnd_pinnacle.c:548:	err = request_irq(chip->irq, snd_msnd_interrupt, 0, card->shortname,
./sound/isa/msnd/msnd_pinnacle.c:551:		printk(KERN_ERR LOGNAME ": Couldn't grab IRQ %d\n", chip->irq);
./sound/isa/msnd/msnd_pinnacle.c:554:	if (request_region(chip->io, DSP_NUMIO, card->shortname) == NULL) {
./sound/isa/msnd/msnd_pinnacle.c:555:		free_irq(chip->irq, chip);
./sound/isa/msnd/msnd_pinnacle.c:559:	if (!request_mem_region(chip->base, BUFFSIZE, card->shortname)) {
./sound/isa/msnd/msnd_pinnacle.c:562:			chip->base, chip->base + BUFFSIZE - 1);
./sound/isa/msnd/msnd_pinnacle.c:563:		release_region(chip->io, DSP_NUMIO);
./sound/isa/msnd/msnd_pinnacle.c:564:		free_irq(chip->irq, chip);
./sound/isa/msnd/msnd_pinnacle.c:567:	chip->mappedbase = ioremap_nocache(chip->base, 0x8000);
./sound/isa/msnd/msnd_pinnacle.c:568:	if (!chip->mappedbase) {
./sound/isa/msnd/msnd_pinnacle.c:571:			chip->base, chip->base + BUFFSIZE - 1);
./sound/isa/msnd/msnd_pinnacle.c:606:					  &chip->rmidi);
./sound/isa/msnd/msnd_pinnacle.c:612:		mpu = chip->rmidi->private_data;
./sound/isa/msnd/msnd_pinnacle.c:619:	disable_irq(chip->irq);
./sound/isa/msnd/msnd_pinnacle.c:620:	snd_msnd_calibrate_adc(chip, chip->play_sample_rate);
./sound/isa/msnd/msnd_pinnacle.c:630:	iounmap(chip->mappedbase);
./sound/isa/msnd/msnd_pinnacle.c:631:	release_mem_region(chip->base, BUFFSIZE);
./sound/isa/msnd/msnd_pinnacle.c:632:	release_region(chip->io, DSP_NUMIO);
./sound/isa/msnd/msnd_pinnacle.c:633:	free_irq(chip->irq, chip);
./sound/isa/msnd/msnd_pinnacle.c:642:	iounmap(chip->mappedbase);
./sound/isa/msnd/msnd_pinnacle.c:643:	release_mem_region(chip->base, BUFFSIZE);
./sound/isa/msnd/msnd_pinnacle.c:644:	release_region(chip->io, DSP_NUMIO);
./sound/isa/msnd/msnd_pinnacle.c:645:	free_irq(chip->irq, chip);
./sound/isa/msnd/msnd_pinnacle.c:913:	chip->card = card;
./sound/isa/msnd/msnd_pinnacle.c:918:		chip->irqid = HPIRQ_5; break;
./sound/isa/msnd/msnd_pinnacle.c:920:		chip->irqid = HPIRQ_7; break;
./sound/isa/msnd/msnd_pinnacle.c:922:		chip->irqid = HPIRQ_9; break;
./sound/isa/msnd/msnd_pinnacle.c:924:		chip->irqid = HPIRQ_10; break;
./sound/isa/msnd/msnd_pinnacle.c:926:		chip->irqid = HPIRQ_11; break;
./sound/isa/msnd/msnd_pinnacle.c:928:		chip->irqid = HPIRQ_12; break;
./sound/isa/msnd/msnd_pinnacle.c:933:		chip->memid = HPMEM_B000; break;
./sound/isa/msnd/msnd_pinnacle.c:935:		chip->memid = HPMEM_C800; break;
./sound/isa/msnd/msnd_pinnacle.c:937:		chip->memid = HPMEM_D000; break;
./sound/isa/msnd/msnd_pinnacle.c:939:		chip->memid = HPMEM_D800; break;
./sound/isa/msnd/msnd_pinnacle.c:941:		chip->memid = HPMEM_E000; break;
./sound/isa/msnd/msnd_pinnacle.c:943:		chip->memid = HPMEM_E800; break;
./sound/isa/msnd/msnd_pinnacle.c:1018:	chip->type = msndClassic;
./sound/isa/msnd/msnd_pinnacle.c:1020:	chip->type = msndPinnacle;
./sound/isa/msnd/msnd_pinnacle.c:1022:	chip->io = io[idx];
./sound/isa/msnd/msnd_pinnacle.c:1023:	chip->irq = irq[idx];
./sound/isa/msnd/msnd_pinnacle.c:1024:	chip->base = mem[idx];
./sound/isa/msnd/msnd_pinnacle.c:1026:	chip->calibrate_signal = calibrate_signal ? 1 : 0;
./sound/isa/msnd/msnd_pinnacle.c:1027:	chip->recsrc = 0;
./sound/isa/msnd/msnd_pinnacle.c:1028:	chip->dspq_data_buff = DSPQ_DATA_BUFF;
./sound/isa/msnd/msnd_pinnacle.c:1029:	chip->dspq_buff_size = DSPQ_BUFF_SIZE;
./sound/isa/msnd/msnd_pinnacle.c:1031:		clear_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:1033:		set_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:1036:		set_bit(F_HAVEDIGITAL, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:1038:	spin_lock_init(&chip->lock);
./sound/isa/msnd/msnd_pinnacle.c:1130:	chip->card = card;
./sound/isa/msnd/msnd_pinnacle.c:1143:	chip->type = msndClassic;
./sound/isa/msnd/msnd_pinnacle.c:1145:	chip->type = msndPinnacle;
./sound/isa/msnd/msnd_pinnacle.c:1147:	chip->io = io[idx];
./sound/isa/msnd/msnd_pinnacle.c:1148:	chip->irq = irq[idx];
./sound/isa/msnd/msnd_pinnacle.c:1149:	chip->base = mem[idx];
./sound/isa/msnd/msnd_pinnacle.c:1151:	chip->calibrate_signal = calibrate_signal ? 1 : 0;
./sound/isa/msnd/msnd_pinnacle.c:1152:	chip->recsrc = 0;
./sound/isa/msnd/msnd_pinnacle.c:1153:	chip->dspq_data_buff = DSPQ_DATA_BUFF;
./sound/isa/msnd/msnd_pinnacle.c:1154:	chip->dspq_buff_size = DSPQ_BUFF_SIZE;
./sound/isa/msnd/msnd_pinnacle.c:1156:		clear_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:1158:		set_bit(F_DISABLE_WRITE_NDELAY, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:1161:		set_bit(F_HAVEDIGITAL, &chip->flags);
./sound/isa/msnd/msnd_pinnacle.c:1163:	spin_lock_init(&chip->lock);
./sound/isa/msnd/msnd.c:209:	long tmp = (size * HZ * chip->play_sample_size) / 8;
./sound/isa/msnd/msnd.c:210:	return tmp / (chip->play_sample_rate * chip->play_channels);
./sound/isa/msnd/msnd.c:215:	if (!(chip->mode & FMODE_WRITE) || !test_bit(F_WRITING, &chip->flags))
./sound/isa/msnd/msnd.c:217:	set_bit(F_WRITEFLUSH, &chip->flags);
./sound/isa/msnd/msnd.c:219:		&chip->writeflush,
./sound/isa/msnd/msnd.c:220:		get_play_delay_jiffies(&chip, chip->DAPF.len));*/
./sound/isa/msnd/msnd.c:221:	clear_bit(F_WRITEFLUSH, &chip->flags);
./sound/isa/msnd/msnd.c:224:			get_play_delay_jiffies(chip, chip->play_period_bytes));
./sound/isa/msnd/msnd.c:225:	clear_bit(F_WRITING, &chip->flags);
./sound/isa/msnd/msnd.c:230:	if ((file ? file->f_mode : chip->mode) & FMODE_READ) {
./sound/isa/msnd/msnd.c:231:		clear_bit(F_READING, &chip->flags);
./sound/isa/msnd/msnd.c:237:			chip->mode &= ~FMODE_READ;
./sound/isa/msnd/msnd.c:239:		clear_bit(F_AUDIO_READ_INUSE, &chip->flags);
./sound/isa/msnd/msnd.c:241:	if ((file ? file->f_mode : chip->mode) & FMODE_WRITE) {
./sound/isa/msnd/msnd.c:242:		if (test_bit(F_WRITING, &chip->flags)) {
./sound/isa/msnd/msnd.c:250:			chip->mode &= ~FMODE_WRITE;
./sound/isa/msnd/msnd.c:252:		clear_bit(F_AUDIO_WRITE_INUSE, &chip->flags);
./sound/isa/msnd/msnd.c:265:	wTmp = readw(chip->DARQ + JQS_wTail) + PCTODSP_OFFSET(DAQDS__size);
./sound/isa/msnd/msnd.c:266:	if (wTmp > readw(chip->DARQ + JQS_wSize))
./sound/isa/msnd/msnd.c:268:	while (wTmp == readw(chip->DARQ + JQS_wHead) && timeout--)
./sound/isa/msnd/msnd.c:271:	if (chip->capturePeriods == 2) {
./sound/isa/msnd/msnd.c:272:		void *pDAQ = chip->mappedbase + DARQ_DATA_BUFF +
./sound/isa/msnd/msnd.c:274:		unsigned short offset = 0x3000 + chip->capturePeriodBytes;
./sound/isa/msnd/msnd.c:281:	writew(wTmp, chip->DARQ + JQS_wTail);
./sound/isa/msnd/msnd.c:285:	DAQD = bank * DAQDS__size + chip->mappedbase + DARQ_DATA_BUFF;
./sound/isa/msnd/msnd.c:292:	outb(HPBLKSEL_1, chip->io + HP_BLKS);
./sound/isa/msnd/msnd.c:293:	n = msnd_fifo_write(&chip->DARF,
./sound/isa/msnd/msnd.c:294:			    (char *)(chip->base + bank * DAR_BUFF_SIZE),
./sound/isa/msnd/msnd.c:297:		outb(HPBLKSEL_0, chip->io + HP_BLKS);
./sound/isa/msnd/msnd.c:300:	outb(HPBLKSEL_0, chip->io + HP_BLKS);
./sound/isa/msnd/msnd.c:314:	spin_lock_irqsave(&chip->lock, flags); not necessary */
./sound/isa/msnd/msnd.c:316:	DAPQ_tail = readw(chip->DAPQ + JQS_wTail);
./sound/isa/msnd/msnd.c:317:	while (DAPQ_tail != readw(chip->DAPQ + JQS_wHead) || start) {
./sound/isa/msnd/msnd.c:326:		DAQD = bank_num * DAQDS__size + chip->mappedbase +
./sound/isa/msnd/msnd.c:330:		writew(chip->play_period_bytes, DAQD + DAQDS_wSize);
./sound/isa/msnd/msnd.c:333:		else if (chip->playPeriods == 2) {
./sound/isa/msnd/msnd.c:334:			unsigned short offset = chip->play_period_bytes;
./sound/isa/msnd/msnd.c:351:		writew(DAPQ_tail, chip->DAPQ + JQS_wTail);
./sound/isa/msnd/msnd.c:362:	/* spin_unlock_irqrestore(&chip->lock, flags); not necessary */
./sound/isa/msnd/msnd.c:372:	void	*pDAQ = chip->mappedbase + DAPQ_DATA_BUFF;
./sound/isa/msnd/msnd.c:374:	chip->last_playbank = -1;
./sound/isa/msnd/msnd.c:375:	chip->playLimit = pcm_count * (pcm_periods - 1);
./sound/isa/msnd/msnd.c:376:	chip->playPeriods = pcm_periods;
./sound/isa/msnd/msnd.c:377:	writew(PCTODSP_OFFSET(0 * DAQDS__size), chip->DAPQ + JQS_wHead);
./sound/isa/msnd/msnd.c:378:	writew(PCTODSP_OFFSET(0 * DAQDS__size), chip->DAPQ + JQS_wTail);
./sound/isa/msnd/msnd.c:380:	chip->play_period_bytes = pcm_count;
./sound/isa/msnd/msnd.c:387:		writew(chip->play_sample_size, pDAQ + DAQDS_wSampleSize);
./sound/isa/msnd/msnd.c:388:		writew(chip->play_channels, pDAQ + DAQDS_wChannels);
./sound/isa/msnd/msnd.c:389:		writew(chip->play_sample_rate, pDAQ + DAQDS_wSampleRate);
./sound/isa/msnd/msnd.c:403:	/* snd_msnd_init_queue(chip->DARQ, DARQ_DATA_BUFF, DARQ_BUFF_SIZE); */
./sound/isa/msnd/msnd.c:405:	chip->last_recbank = 2;
./sound/isa/msnd/msnd.c:406:	chip->captureLimit = pcm_count * (pcm_periods - 1);
./sound/isa/msnd/msnd.c:407:	chip->capturePeriods = pcm_periods;
./sound/isa/msnd/msnd.c:408:	writew(PCTODSP_OFFSET(0 * DAQDS__size), chip->DARQ + JQS_wHead);
./sound/isa/msnd/msnd.c:409:	writew(PCTODSP_OFFSET(chip->last_recbank * DAQDS__size),
./sound/isa/msnd/msnd.c:410:		chip->DARQ + JQS_wTail);
./sound/isa/msnd/msnd.c:413:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/msnd/msnd.c:414:	outb(HPBLKSEL_1, chip->io + HP_BLKS);
./sound/isa/msnd/msnd.c:415:	memset_io(chip->mappedbase, 0, DAR_BUFF_SIZE * 3);
./sound/isa/msnd/msnd.c:416:	outb(HPBLKSEL_0, chip->io + HP_BLKS);
./sound/isa/msnd/msnd.c:417:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/msnd/msnd.c:420:	chip->capturePeriodBytes = pcm_count;
./sound/isa/msnd/msnd.c:423:	pDAQ = chip->mappedbase + DARQ_DATA_BUFF;
./sound/isa/msnd/msnd.c:431:		writew(chip->capture_sample_size, pDAQ + DAQDS_wSampleSize);
./sound/isa/msnd/msnd.c:432:		writew(chip->capture_channels, pDAQ + DAQDS_wChannels);
./sound/isa/msnd/msnd.c:433:		writew(chip->capture_sample_rate, pDAQ + DAQDS_wSampleRate);
./sound/isa/msnd/msnd.c:483:	set_bit(F_AUDIO_WRITE_INUSE, &chip->flags);
./sound/isa/msnd/msnd.c:484:	clear_bit(F_WRITING, &chip->flags);
./sound/isa/msnd/msnd.c:487:	runtime->dma_area = chip->mappedbase;
./sound/isa/msnd/msnd.c:490:	chip->playback_substream = substream;
./sound/isa/msnd/msnd.c:500:	clear_bit(F_AUDIO_WRITE_INUSE, &chip->flags);
./sound/isa/msnd/msnd.c:510:	void	*pDAQ =	chip->mappedbase + DAPQ_DATA_BUFF;
./sound/isa/msnd/msnd.c:512:	chip->play_sample_size = snd_pcm_format_width(params_format(params));
./sound/isa/msnd/msnd.c:513:	chip->play_channels = params_channels(params);
./sound/isa/msnd/msnd.c:514:	chip->play_sample_rate = params_rate(params);
./sound/isa/msnd/msnd.c:517:		writew(chip->play_sample_size, pDAQ + DAQDS_wSampleSize);
./sound/isa/msnd/msnd.c:518:		writew(chip->play_channels, pDAQ + DAQDS_wChannels);
./sound/isa/msnd/msnd.c:519:		writew(chip->play_sample_rate, pDAQ + DAQDS_wSampleRate);
./sound/isa/msnd/msnd.c:522:	 * snd_msnd_calibrate_adc(chip->play_sample_rate);
./sound/isa/msnd/msnd.c:536:	chip->playDMAPos = 0;
./sound/isa/msnd/msnd.c:548:		chip->banksPlayed = 0;
./sound/isa/msnd/msnd.c:549:		set_bit(F_WRITING, &chip->flags);
./sound/isa/msnd/msnd.c:554:		clear_bit(F_WRITING, &chip->flags);
./sound/isa/msnd/msnd.c:570:	return bytes_to_frames(substream->runtime, chip->playDMAPos);
./sound/isa/msnd/msnd.c:589:	set_bit(F_AUDIO_READ_INUSE, &chip->flags);
./sound/isa/msnd/msnd.c:591:	runtime->dma_area = chip->mappedbase + 0x3000;
./sound/isa/msnd/msnd.c:594:	chip->capture_substream = substream;
./sound/isa/msnd/msnd.c:604:	clear_bit(F_AUDIO_READ_INUSE, &chip->flags);
./sound/isa/msnd/msnd.c:616:	chip->captureDMAPos = 0;
./sound/isa/msnd/msnd.c:626:		chip->last_recbank = -1;
./sound/isa/msnd/msnd.c:627:		set_bit(F_READING, &chip->flags);
./sound/isa/msnd/msnd.c:631:		clear_bit(F_READING, &chip->flags);
./sound/isa/msnd/msnd.c:633:		clear_bit(F_READING, &chip->flags);
./sound/isa/msnd/msnd.c:647:	return bytes_to_frames(runtime, chip->captureDMAPos);
./sound/isa/msnd/msnd.c:656:	void		*pDAQ = chip->mappedbase + DARQ_DATA_BUFF;
./sound/isa/msnd/msnd.c:658:	chip->capture_sample_size = snd_pcm_format_width(params_format(params));
./sound/isa/msnd/msnd.c:659:	chip->capture_channels = params_channels(params);
./sound/isa/msnd/msnd.c:660:	chip->capture_sample_rate = params_rate(params);
./sound/isa/msnd/msnd.c:663:		writew(chip->capture_sample_size, pDAQ + DAQDS_wSampleSize);
./sound/isa/msnd/msnd.c:664:		writew(chip->capture_channels, pDAQ + DAQDS_wChannels);
./sound/isa/msnd/msnd.c:665:		writew(chip->capture_sample_rate, pDAQ + DAQDS_wSampleRate);
./sound/isa/msnd/msnd_pinnacle_mixer.c:62:	unsigned items = test_bit(F_HAVEDIGITAL, &chip->flags) ? 3 : 2;
./sound/isa/msnd/msnd_pinnacle_mixer.c:74:	if (chip->recsrc & MSND_MASK_SYNTH) {
./sound/isa/msnd/msnd_pinnacle_mixer.c:76:	} else if ((chip->recsrc & MSND_MASK_DIGITAL) &&
./sound/isa/msnd/msnd_pinnacle_mixer.c:77:		 test_bit(F_HAVEDIGITAL, &chip->flags)) {
./sound/isa/msnd/msnd_pinnacle_mixer.c:107:	change  = newrecsrc != chip->recsrc;
./sound/isa/msnd/msnd_pinnacle_mixer.c:112:				chip->recsrc = newrecsrc;
./sound/isa/msnd/msnd_pinnacle_mixer.c:306:	spin_lock_init(&chip->mixer_lock);
./sound/isa/msnd/msnd_midi.c:173:	chip->msndmidi_mpu = mpu;
./sound/isa/sc6000.c:472:	struct snd_card *card = chip->card;
./sound/isa/cmi8330.c:289:	spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/cmi8330.c:291:	spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/cmi8330.c:295:		spin_lock_irqsave(&chip->mixer_lock, flags);
./sound/isa/cmi8330.c:298:		spin_unlock_irqrestore(&chip->mixer_lock, flags);
./sound/isa/cmi8330.c:427:	substream->private_data = chip->streams[SNDRV_PCM_STREAM_PLAYBACK].private_data;
./sound/isa/cmi8330.c:428:	return chip->streams[SNDRV_PCM_STREAM_PLAYBACK].open(substream);
./sound/isa/cmi8330.c:436:	substream->private_data = chip->streams[SNDRV_PCM_STREAM_CAPTURE].private_data;
./sound/isa/cmi8330.c:437:	return chip->streams[SNDRV_PCM_STREAM_CAPTURE].open(substream);
./sound/isa/cmi8330.c:450:	if ((err = snd_pcm_new(card, (chip->type == CMI8329) ? "CMI8329" : "CMI8330", 0, 1, 1, &pcm)) < 0)
./sound/isa/cmi8330.c:452:	strcpy(pcm->name, (chip->type == CMI8329) ? "CMI8329" : "CMI8330");
./sound/isa/cmi8330.c:457:	chip->streams[CMI_SB_STREAM].ops = *ops;
./sound/isa/cmi8330.c:458:	chip->streams[CMI_SB_STREAM].open = ops->open;
./sound/isa/cmi8330.c:459:	chip->streams[CMI_SB_STREAM].ops.open = cmi_open_callbacks[CMI_SB_STREAM];
./sound/isa/cmi8330.c:460:	chip->streams[CMI_SB_STREAM].private_data = chip->sb;
./sound/isa/cmi8330.c:464:	chip->streams[CMI_AD_STREAM].ops = *ops;
./sound/isa/cmi8330.c:465:	chip->streams[CMI_AD_STREAM].open = ops->open;
./sound/isa/cmi8330.c:466:	chip->streams[CMI_AD_STREAM].ops.open = cmi_open_callbacks[CMI_AD_STREAM];
./sound/isa/cmi8330.c:467:	chip->streams[CMI_AD_STREAM].private_data = chip->wss;
./sound/isa/cmi8330.c:469:	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &chip->streams[SNDRV_PCM_STREAM_PLAYBACK].ops);
./sound/isa/cmi8330.c:470:	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &chip->streams[SNDRV_PCM_STREAM_CAPTURE].ops);
./sound/isa/cmi8330.c:475:	chip->pcm = pcm;
./sound/isa/opti9xx/opti92x-ad1848.c:190:	chip->hardware = hardware;
./sound/isa/opti9xx/opti92x-ad1848.c:191:	strcpy(chip->name, snd_opti9xx_names[hardware]);
./sound/isa/opti9xx/opti92x-ad1848.c:193:	spin_lock_init(&chip->lock);
./sound/isa/opti9xx/opti92x-ad1848.c:195:	chip->irq = -1;
./sound/isa/opti9xx/opti92x-ad1848.c:199:	if (isapnp && chip->mc_base)
./sound/isa/opti9xx/opti92x-ad1848.c:201:		chip->mc_base |= 0xc00;
./sound/isa/opti9xx/opti92x-ad1848.c:205:		chip->mc_base = 0xf8c;
./sound/isa/opti9xx/opti92x-ad1848.c:206:		chip->mc_base_size = opti9xx_mc_size[hardware];
./sound/isa/opti9xx/opti92x-ad1848.c:209:		chip->mc_base_size = opti9xx_mc_size[hardware];
./sound/isa/opti9xx/opti92x-ad1848.c:216:		chip->password = (hardware == OPTi9XX_HW_82C928) ? 0xe2 : 0xe3;
./sound/isa/opti9xx/opti92x-ad1848.c:217:		chip->pwd_reg = 3;
./sound/isa/opti9xx/opti92x-ad1848.c:222:		chip->password = 0xe5;
./sound/isa/opti9xx/opti92x-ad1848.c:223:		chip->pwd_reg = 3;
./sound/isa/opti9xx/opti92x-ad1848.c:230:		chip->mc_base = (hardware == OPTi9XX_HW_82C930) ? 0xf8f : 0xf8d;
./sound/isa/opti9xx/opti92x-ad1848.c:231:		if (!chip->mc_indir_index)
./sound/isa/opti9xx/opti92x-ad1848.c:232:			chip->mc_indir_index = 0xe0e;
./sound/isa/opti9xx/opti92x-ad1848.c:233:		chip->password = 0xe4;
./sound/isa/opti9xx/opti92x-ad1848.c:234:		chip->pwd_reg = 0;
./sound/isa/opti9xx/opti92x-ad1848.c:251:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/opti9xx/opti92x-ad1848.c:252:	outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/opti92x-ad1848.c:254:	switch (chip->hardware) {
./sound/isa/opti9xx/opti92x-ad1848.c:259:			outb(reg, chip->mc_base + 8);
./sound/isa/opti9xx/opti92x-ad1848.c:260:			outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/opti92x-ad1848.c:261:			retval = inb(chip->mc_base + 9);
./sound/isa/opti9xx/opti92x-ad1848.c:267:		retval = inb(chip->mc_base + reg);
./sound/isa/opti9xx/opti92x-ad1848.c:274:		outb(reg, chip->mc_indir_index);
./sound/isa/opti9xx/opti92x-ad1848.c:275:		outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/opti92x-ad1848.c:276:		retval = inb(chip->mc_indir_index + 1);
./sound/isa/opti9xx/opti92x-ad1848.c:281:		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
./sound/isa/opti9xx/opti92x-ad1848.c:284:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/opti9xx/opti92x-ad1848.c:293:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/opti9xx/opti92x-ad1848.c:294:	outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/opti92x-ad1848.c:296:	switch (chip->hardware) {
./sound/isa/opti9xx/opti92x-ad1848.c:301:			outb(reg, chip->mc_base + 8);
./sound/isa/opti9xx/opti92x-ad1848.c:302:			outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/opti92x-ad1848.c:303:			outb(value, chip->mc_base + 9);
./sound/isa/opti9xx/opti92x-ad1848.c:309:		outb(value, chip->mc_base + reg);
./sound/isa/opti9xx/opti92x-ad1848.c:316:		outb(reg, chip->mc_indir_index);
./sound/isa/opti9xx/opti92x-ad1848.c:317:		outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/opti92x-ad1848.c:318:		outb(value, chip->mc_indir_index + 1);
./sound/isa/opti9xx/opti92x-ad1848.c:323:		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
./sound/isa/opti9xx/opti92x-ad1848.c:326:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/opti9xx/opti92x-ad1848.c:346:	switch (chip->hardware) {
./sound/isa/opti9xx/opti92x-ad1848.c:404:			(chip->hardware == OPTi9XX_HW_82C930 ? 0x00 : 0x04),
./sound/isa/opti9xx/opti92x-ad1848.c:411:		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
./sound/isa/opti9xx/opti92x-ad1848.c:418:		chip->wss_base = 0x530;
./sound/isa/opti9xx/opti92x-ad1848.c:422:		chip->wss_base = 0x604;
./sound/isa/opti9xx/opti92x-ad1848.c:426:		chip->wss_base = 0xe80;
./sound/isa/opti9xx/opti92x-ad1848.c:430:		chip->wss_base = 0xf40;
./sound/isa/opti9xx/opti92x-ad1848.c:496:	 outb(irq_bits << 3 | dma_bits, chip->wss_base);
./sound/isa/opti9xx/opti92x-ad1848.c:502:	if (chip->hardware > OPTi9XX_HW_82C928) {
./sound/isa/opti9xx/opti92x-ad1848.c:599:	if (snd_BUG_ON(!chip || !chip->pcm))
./sound/isa/opti9xx/opti92x-ad1848.c:602:	card = chip->card;
./sound/isa/opti9xx/opti92x-ad1848.c:604:	strcpy(card->mixername, chip->pcm->name);
./sound/isa/opti9xx/opti92x-ad1848.c:646:	struct snd_wss *codec = chip->codec;
./sound/isa/opti9xx/opti92x-ad1848.c:672:	chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size,
./sound/isa/opti9xx/opti92x-ad1848.c:674:	if (chip->res_mc_base == NULL)
./sound/isa/opti9xx/opti92x-ad1848.c:678:	if (value != 0xff && value != inb(chip->mc_base + OPTi9XX_MC_REG(1)))
./sound/isa/opti9xx/opti92x-ad1848.c:682:	chip->res_mc_indir = request_region(chip->mc_indir_index, 2,
./sound/isa/opti9xx/opti92x-ad1848.c:684:	if (chip->res_mc_indir == NULL)
./sound/isa/opti9xx/opti92x-ad1848.c:687:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/opti9xx/opti92x-ad1848.c:688:	outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/opti92x-ad1848.c:689:	outb(((chip->mc_indir_index & 0x1f0) >> 4), chip->mc_base);
./sound/isa/opti9xx/opti92x-ad1848.c:690:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/opti9xx/opti92x-ad1848.c:697:	release_and_free_resource(chip->res_mc_indir);
./sound/isa/opti9xx/opti92x-ad1848.c:698:	chip->res_mc_indir = NULL;
./sound/isa/opti9xx/opti92x-ad1848.c:700:	release_and_free_resource(chip->res_mc_base);
./sound/isa/opti9xx/opti92x-ad1848.c:701:	chip->res_mc_base = NULL;
./sound/isa/opti9xx/opti92x-ad1848.c:724:		chip->mc_indir_index = 0;
./sound/isa/opti9xx/opti92x-ad1848.c:757:	chip->mc_indir_index = (pnp_port_start(pdev, 3) & ~0xf) | 0xe;
./sound/isa/opti9xx/opti92x-ad1848.c:775:	chip->mc_base = pnp_port_start(devmc, 0) - 1;
./sound/isa/opti9xx/opti92x-ad1848.c:776:	chip->mc_base_size = pnp_port_len(devmc, 0) + 1;
./sound/isa/opti9xx/opti92x-ad1848.c:806:		if (chip->irq > 0) {
./sound/isa/opti9xx/opti92x-ad1848.c:807:			disable_irq(chip->irq);
./sound/isa/opti9xx/opti92x-ad1848.c:808:			free_irq(chip->irq, chip);
./sound/isa/opti9xx/opti92x-ad1848.c:810:		release_and_free_resource(chip->res_mc_indir);
./sound/isa/opti9xx/opti92x-ad1848.c:812:		release_and_free_resource(chip->res_mc_base);
./sound/isa/opti9xx/opti92x-ad1848.c:844:	error = snd_wss_create(card, chip->wss_base + 4, -1, irq, dma1, xdma2,
./sound/isa/opti9xx/opti92x-ad1848.c:853:	chip->codec = codec;
./sound/isa/opti9xx/opti92x-ad1848.c:878:	chip->irq = irq;
./sound/isa/opti9xx/opti92x-ad1848.c:879:	strcpy(card->driver, chip->name);
./sound/isa/opti9xx/opti92x-ad1848.c:884:		chip->wss_base + 4, irq, dma1, xdma2);
./sound/isa/opti9xx/opti92x-ad1848.c:887:		card->shortname, codec->pcm->name, chip->wss_base + 4, irq,
./sound/isa/opti9xx/opti92x-ad1848.c:904:		if (chip->hardware == OPTi9XX_HW_82C928 ||
./sound/isa/opti9xx/opti92x-ad1848.c:905:		    chip->hardware == OPTi9XX_HW_82C929 ||
./sound/isa/opti9xx/opti92x-ad1848.c:906:		    chip->hardware == OPTi9XX_HW_82C924) {
./sound/isa/opti9xx/opti92x-ad1848.c:1039:	chip->codec->suspend(chip->codec);
./sound/isa/opti9xx/opti92x-ad1848.c:1057:	chip->codec->resume(chip->codec);
./sound/isa/opti9xx/miro.c:779:	chip->hardware = hardware;
./sound/isa/opti9xx/miro.c:780:	strcpy(chip->name, snd_opti9xx_names[hardware]);
./sound/isa/opti9xx/miro.c:782:	chip->mc_base_size = opti9xx_mc_size[hardware];  
./sound/isa/opti9xx/miro.c:784:	spin_lock_init(&chip->lock);
./sound/isa/opti9xx/miro.c:786:	chip->wss_base = -1;
./sound/isa/opti9xx/miro.c:787:	chip->irq = -1;
./sound/isa/opti9xx/miro.c:788:	chip->dma1 = -1;
./sound/isa/opti9xx/miro.c:789:	chip->dma2 = -1;
./sound/isa/opti9xx/miro.c:790:	chip->mpu_port = -1;
./sound/isa/opti9xx/miro.c:791:	chip->mpu_irq = -1;
./sound/isa/opti9xx/miro.c:793:	chip->pwd_reg = 3;
./sound/isa/opti9xx/miro.c:796:	if (isapnp && chip->mc_base)
./sound/isa/opti9xx/miro.c:798:		chip->mc_base |= 0xc00;
./sound/isa/opti9xx/miro.c:801:		chip->mc_base = 0xf8c;
./sound/isa/opti9xx/miro.c:805:		chip->password = 0xe3;
./sound/isa/opti9xx/miro.c:809:		chip->password = 0xe5;
./sound/isa/opti9xx/miro.c:826:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/opti9xx/miro.c:827:	outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/miro.c:829:	switch (chip->hardware) {
./sound/isa/opti9xx/miro.c:832:			outb(reg, chip->mc_base + 8);
./sound/isa/opti9xx/miro.c:833:			outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/miro.c:834:			retval = inb(chip->mc_base + 9);
./sound/isa/opti9xx/miro.c:839:		retval = inb(chip->mc_base + reg);
./sound/isa/opti9xx/miro.c:843:		snd_printk(KERN_ERR "sorry, no support for %d\n", chip->hardware);
./sound/isa/opti9xx/miro.c:846:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/opti9xx/miro.c:855:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/opti9xx/miro.c:856:	outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/miro.c:858:	switch (chip->hardware) {
./sound/isa/opti9xx/miro.c:861:			outb(reg, chip->mc_base + 8);
./sound/isa/opti9xx/miro.c:862:			outb(chip->password, chip->mc_base + chip->pwd_reg);
./sound/isa/opti9xx/miro.c:863:			outb(value, chip->mc_base + 9);
./sound/isa/opti9xx/miro.c:868:		outb(value, chip->mc_base + reg);
./sound/isa/opti9xx/miro.c:872:		snd_printk(KERN_ERR "sorry, no support for %d\n", chip->hardware);
./sound/isa/opti9xx/miro.c:875:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/opti9xx/miro.c:1018:	switch (chip->hardware) {
./sound/isa/opti9xx/miro.c:1028:		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
./sound/isa/opti9xx/miro.c:1033:	switch (chip->wss_base & 0x3ff) {
./sound/isa/opti9xx/miro.c:1035:		chip->wss_base = 0x530;
./sound/isa/opti9xx/miro.c:1039:		chip->wss_base = 0x604;
./sound/isa/opti9xx/miro.c:1043:		chip->wss_base = 0xe80;
./sound/isa/opti9xx/miro.c:1047:		chip->wss_base = 0xf40;
./sound/isa/opti9xx/miro.c:1051:		snd_printk(KERN_ERR "WSS port 0x%lx not valid\n", chip->wss_base);
./sound/isa/opti9xx/miro.c:1057:	switch (chip->irq) {
./sound/isa/opti9xx/miro.c:1074:		snd_printk(KERN_ERR "WSS irq # %d not valid\n", chip->irq);
./sound/isa/opti9xx/miro.c:1078:	switch (chip->dma1) {
./sound/isa/opti9xx/miro.c:1089:		snd_printk(KERN_ERR "WSS dma1 # %d not valid\n", chip->dma1);
./sound/isa/opti9xx/miro.c:1093:	if (chip->dma1 == chip->dma2) {
./sound/isa/opti9xx/miro.c:1098:	switch (chip->dma2) {
./sound/isa/opti9xx/miro.c:1103:		snd_printk(KERN_ERR "WSS dma2 # %d not valid\n", chip->dma2);
./sound/isa/opti9xx/miro.c:1108:	spin_lock_irqsave(&chip->lock, flags);
./sound/isa/opti9xx/miro.c:1109:	outb(irq_bits << 3 | dma_bits, chip->wss_base);
./sound/isa/opti9xx/miro.c:1110:	spin_unlock_irqrestore(&chip->lock, flags);
./sound/isa/opti9xx/miro.c:1113:	if (chip->hardware > OPTi9XX_HW_82C928) {
./sound/isa/opti9xx/miro.c:1114:		switch (chip->mpu_port) {
./sound/isa/opti9xx/miro.c:1132:				   chip->mpu_port);
./sound/isa/opti9xx/miro.c:1136:		switch (chip->mpu_irq) {
./sound/isa/opti9xx/miro.c:1151:				   chip->mpu_irq);
./sound/isa/opti9xx/miro.c:1156:			(chip->mpu_port <= 0) ? 0x00 :
./sound/isa/opti9xx/miro.c:1169:	chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size,
./sound/isa/opti9xx/miro.c:1171:	if (chip->res_mc_base == NULL)
./sound/isa/opti9xx/miro.c:1175:	if (value != 0xff && value != inb(chip->mc_base + OPTi9XX_MC_REG(1)))
./sound/isa/opti9xx/miro.c:1179:	release_and_free_resource(chip->res_mc_base);
./sound/isa/opti9xx/miro.c:1180:	chip->res_mc_base = NULL;
./sound/isa/opti9xx/miro.c:1552:	chip->mc_base = pnp_port_start(devmc, 0) - 1;
./sound/isa/opti9xx/miro.c:1553:	chip->mc_base_size = pnp_port_len(devmc, 0) + 1;
./sound/isa/cmi8328.c:151:	card = chip->card;
./sound/pcmcia/vx/vxp_ops.c:54:	return chip->port + vxp_reg_offset[reg];
./sound/pcmcia/vx/vxp_ops.c:116:	vx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_DSP_RESET_MASK);
./sound/pcmcia/vx/vxp_ops.c:120:	chip->regCDSP &= ~VXP_CDSP_DSP_RESET_MASK;
./sound/pcmcia/vx/vxp_ops.c:121:	vx_outb(chip, CDSP, chip->regCDSP);
./sound/pcmcia/vx/vxp_ops.c:134:	vx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_CODEC_RESET_MASK);
./sound/pcmcia/vx/vxp_ops.c:138:	chip->regCDSP &= ~VXP_CDSP_CODEC_RESET_MASK;
./sound/pcmcia/vx/vxp_ops.c:139:	vx_outb(chip, CDSP, chip->regCDSP);
./sound/pcmcia/vx/vxp_ops.c:158:	chip->regDIALOG |= VXP_DLG_XILINX_REPROG_MASK;
./sound/pcmcia/vx/vxp_ops.c:159:	vx_outb(chip, DIALOG, chip->regDIALOG);
./sound/pcmcia/vx/vxp_ops.c:220:	chip->regDIALOG |= VXP_DLG_XILINX_REPROG_MASK;
./sound/pcmcia/vx/vxp_ops.c:221:	vx_outb(chip, DIALOG, chip->regDIALOG);
./sound/pcmcia/vx/vxp_ops.c:224:	chip->regDIALOG &= ~VXP_DLG_XILINX_REPROG_MASK;
./sound/pcmcia/vx/vxp_ops.c:225:	vx_outb(chip, DIALOG, chip->regDIALOG);
./sound/pcmcia/vx/vxp_ops.c:237:	chip->regDIALOG &= ~VXP_DLG_XILINX_REPROG_MASK;
./sound/pcmcia/vx/vxp_ops.c:238:	vx_outb(chip, DIALOG, chip->regDIALOG);
./sound/pcmcia/vx/vxp_ops.c:286:	if (! (_chip->chip_status & VX_STAT_XILINX_LOADED))
./sound/pcmcia/vx/vxp_ops.c:294:	vx_outb(chip, DIALOG, chip->regDIALOG | VXP_DLG_ACK_MEMIRQ_MASK);
./sound/pcmcia/vx/vxp_ops.c:299:	vx_outb(chip, DIALOG, chip->regDIALOG & ~VXP_DLG_ACK_MEMIRQ_MASK);
./sound/pcmcia/vx/vxp_ops.c:314:		chip->regCDSP |= VXP_CDSP_VALID_IRQ_MASK;
./sound/pcmcia/vx/vxp_ops.c:316:		chip->regCDSP &= ~VXP_CDSP_VALID_IRQ_MASK;
./sound/pcmcia/vx/vxp_ops.c:317:	vx_outb(chip, CDSP, chip->regCDSP);
./sound/pcmcia/vx/vxp_ops.c:335:	chip->regDIALOG |= VXP_DLG_DMA16_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:336:	chip->regDIALOG |= do_write ? VXP_DLG_DMAWRITE_SEL_MASK : VXP_DLG_DMAREAD_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:337:	vx_outb(chip, DIALOG, chip->regDIALOG);
./sound/pcmcia/vx/vxp_ops.c:349:	chip->regDIALOG &= ~(VXP_DLG_DMAWRITE_SEL_MASK|
./sound/pcmcia/vx/vxp_ops.c:352:	vx_outb(chip, DIALOG, chip->regDIALOG);
./sound/pcmcia/vx/vxp_ops.c:430:	pchip->regDIALOG &= ~VXP_DLG_DMAREAD_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:431:	vx_outb(chip, DIALOG, pchip->regDIALOG);
./sound/pcmcia/vx/vxp_ops.c:435:	pchip->regDIALOG &= ~VXP_DLG_DMA16_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:436:	vx_outb(chip, DIALOG, pchip->regDIALOG);
./sound/pcmcia/vx/vxp_ops.c:472:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/pcmcia/vx/vxp_ops.c:475:	mutex_lock(&chip->lock);
./sound/pcmcia/vx/vxp_ops.c:476:	if (pchip->regCDSP & P24_CDSP_MICS_SEL_MASK) {
./sound/pcmcia/vx/vxp_ops.c:479:			pchip->regCDSP &= ~P24_CDSP_MIC20_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:480:			pchip->regCDSP |=  P24_CDSP_MIC38_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:483:			pchip->regCDSP |=  P24_CDSP_MIC20_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:484:			pchip->regCDSP &= ~P24_CDSP_MIC38_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:486:		vx_outb(chip, CDSP, pchip->regCDSP);
./sound/pcmcia/vx/vxp_ops.c:488:	mutex_unlock(&chip->lock);
./sound/pcmcia/vx/vxp_ops.c:514:	if (chip->chip_status & VX_STAT_IS_STALE)
./sound/pcmcia/vx/vxp_ops.c:517:	mutex_lock(&chip->lock);
./sound/pcmcia/vx/vxp_ops.c:518:	if (pchip->regCDSP & VXP_CDSP_MIC_SEL_MASK) {
./sound/pcmcia/vx/vxp_ops.c:522:	mutex_unlock(&chip->lock);
./sound/pcmcia/vx/vxp_ops.c:535:		chip->regCDSP |= VXP_CDSP_DATAIN_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:536:		vx_outb(chip, CDSP, chip->regCDSP);
./sound/pcmcia/vx/vxp_ops.c:539:		chip->regCDSP &= ~VXP_CDSP_DATAIN_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:540:		if (_chip->type == VX_TYPE_VXP440)
./sound/pcmcia/vx/vxp_ops.c:541:			chip->regCDSP &= ~P24_CDSP_MICS_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:543:			chip->regCDSP &= ~VXP_CDSP_MIC_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:544:		vx_outb(chip, CDSP, chip->regCDSP);
./sound/pcmcia/vx/vxp_ops.c:547:		chip->regCDSP &= ~VXP_CDSP_DATAIN_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:549:		if (_chip->type == VX_TYPE_VXP440) {
./sound/pcmcia/vx/vxp_ops.c:550:			chip->regCDSP &= ~P24_CDSP_MICS_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:551:			if (chip->mic_level)
./sound/pcmcia/vx/vxp_ops.c:552:				chip->regCDSP |=  P24_CDSP_MIC38_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:554:				chip->regCDSP |= P24_CDSP_MIC20_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:555:			vx_outb(chip, CDSP, chip->regCDSP);
./sound/pcmcia/vx/vxp_ops.c:557:			chip->regCDSP |= VXP_CDSP_MIC_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:558:			vx_outb(chip, CDSP, chip->regCDSP);
./sound/pcmcia/vx/vxp_ops.c:559:			vx_outb(chip, MICRO, vx_compute_mic_level(chip->mic_level));
./sound/pcmcia/vx/vxp_ops.c:574:		chip->regCDSP &= ~VXP_CDSP_CLOCKIN_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:576:		chip->regCDSP |= VXP_CDSP_CLOCKIN_SEL_MASK;
./sound/pcmcia/vx/vxp_ops.c:577:	vx_outb(chip, CDSP, chip->regCDSP);
./sound/pcmcia/vx/vxp_ops.c:588:	chip->regCDSP = 0;
./sound/pcmcia/vx/vxp_ops.c:589:	chip->regDIALOG = 0;
./sound/pcmcia/vx/vxpocket.c:156:	chip->ibl.size = ibl;
./sound/pcmcia/vx/vxpocket.c:189:	struct snd_card *card = chip->card;
./sound/pcmcia/vx/vxpocket.c:199:	chip->irq = irq;
./sound/pcmcia/vx/vxpocket.c:225:		chip->hw = &vxp440_hw;
./sound/pcmcia/vx/vxpocket.c:226:		chip->type = vxp440_hw.type;
./sound/pcmcia/vx/vxpocket.c:227:		strcpy(chip->card->driver, vxp440_hw.name);
./sound/pcmcia/vx/vxpocket.c:244:	chip->dev = &link->dev;
./sound/pcmcia/vx/vxpocket.c:349:	chip->chip_status |= VX_STAT_IS_STALE; /* to be sure */
./sound/pcmcia/vx/vxpocket.c:350:	snd_card_disconnect(chip->card);
./sound/pcmcia/vx/vxpocket.c:352:	snd_card_free_when_closed(chip->card);
./sound/pcmcia/vx/vxp_mixer.c:47:	ucontrol->value.integer.value[0] = chip->mic_level;
./sound/pcmcia/vx/vxp_mixer.c:59:	mutex_lock(&_chip->mixer_mutex);
./sound/pcmcia/vx/vxp_mixer.c:60:	if (chip->mic_level != ucontrol->value.integer.value[0]) {
./sound/pcmcia/vx/vxp_mixer.c:62:		chip->mic_level = ucontrol->value.integer.value[0];
./sound/pcmcia/vx/vxp_mixer.c:63:		mutex_unlock(&_chip->mixer_mutex);
./sound/pcmcia/vx/vxp_mixer.c:66:	mutex_unlock(&_chip->mixer_mutex);
./sound/pcmcia/vx/vxp_mixer.c:92:	ucontrol->value.integer.value[0] = chip->mic_level;
./sound/pcmcia/vx/vxp_mixer.c:101:	mutex_lock(&_chip->mixer_mutex);
./sound/pcmcia/vx/vxp_mixer.c:102:	if (chip->mic_level != val) {
./sound/pcmcia/vx/vxp_mixer.c:104:		chip->mic_level = val;
./sound/pcmcia/vx/vxp_mixer.c:105:		mutex_unlock(&_chip->mixer_mutex);
./sound/pcmcia/vx/vxp_mixer.c:108:	mutex_unlock(&_chip->mixer_mutex);
./sound/pcmcia/vx/vxp_mixer.c:127:	chip->mic_level = 0;
./sound/pcmcia/vx/vxp_mixer.c:128:	switch (_chip->type) {
./sound/pcmcia/vx/vxp_mixer.c:138:	switch (_chip->type) {
./sound/pcmcia/vx/vxp_mixer.c:140:		if ((err = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_mic_level, chip))) < 0)
./sound/pcmcia/vx/vxp_mixer.c:144:		if ((err = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_mic_boost, chip))) < 0)
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:38:	spin_lock_irqsave(&chip->ak4117_lock, flags);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:43:			spin_unlock_irqrestore(&chip->ak4117_lock, flags);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:53:			spin_unlock_irqrestore(&chip->ak4117_lock, flags);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:59:	spin_unlock_irqrestore(&chip->ak4117_lock, flags);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:69:	spin_lock_irqsave(&chip->ak4117_lock, flags);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:71:	while (inw(chip->port + PDAUDIOCF_REG_SCR) & PDAUDIOCF_AK_SBP) {
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:74:			spin_unlock_irqrestore(&chip->ak4117_lock, flags);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:79:	outw((u16)reg << 8 | val | (1<<13), chip->port + PDAUDIOCF_REG_AK_IFR);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:80:	spin_unlock_irqrestore(&chip->ak4117_lock, flags);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:86:	printk(KERN_DEBUG "PDAUDIOCF DUMP (0x%lx):\n", chip->port);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:88:	       inw(chip->port + PDAUDIOCF_REG_WDP));
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:90:	       inw(chip->port + PDAUDIOCF_REG_RDP));
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:92:	       inw(chip->port + PDAUDIOCF_REG_TCR));
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:94:	       inw(chip->port + PDAUDIOCF_REG_SCR));
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:96:	       inw(chip->port + PDAUDIOCF_REG_ISR));
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:98:	       inw(chip->port + PDAUDIOCF_REG_IER));
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:100:	       inw(chip->port + PDAUDIOCF_REG_AK_IFR));
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:131:		pdacf_reg_write(chip, PDAUDIOCF_REG_SCR, chip->suspend_reg_scr);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:132:	snd_ak4117_reinit(chip->ak4117);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:133:	pdacf_reg_write(chip, PDAUDIOCF_REG_TCR, chip->regmap[PDAUDIOCF_REG_TCR>>1]);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:134:	pdacf_reg_write(chip, PDAUDIOCF_REG_IER, chip->regmap[PDAUDIOCF_REG_IER>>1]);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:153:	if (! snd_card_proc_new(chip->card, "pdaudiocf", &entry))
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:164:	chip->card = card;
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:165:	mutex_init(&chip->reg_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:166:	spin_lock_init(&chip->ak4117_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:180:	mutex_lock(&chip->reg_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:181:	val = chip->regmap[PDAUDIOCF_REG_SCR>>1];
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:187:	mutex_unlock(&chip->reg_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:209:	err = snd_ak4117_create(chip->card, pdacf_ak4117_read, pdacf_ak4117_write, pgm, chip, &chip->ak4117);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:237:	chip->ak4117->change_callback_private = chip;
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:238:	chip->ak4117->change_callback = snd_pdacf_ak4117_change;
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:241:	snd_pdacf_ak4117_change(chip->ak4117, AK4117_UNLCK, 0);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:251:	chip->suspend_reg_scr = val;
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:254:	/* disable interrupts, but use direct write to preserve old register value in chip->regmap */
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:255:	val = inw(chip->port + PDAUDIOCF_REG_IER);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:257:	outw(val, chip->port + PDAUDIOCF_REG_IER);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:267:	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:268:	snd_pcm_suspend_all(chip->pcm);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:269:	/* disable interrupts, but use direct write to preserve old register value in chip->regmap */
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:270:	val = inw(chip->port + PDAUDIOCF_REG_IER);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:272:	outw(val, chip->port + PDAUDIOCF_REG_IER);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:273:	chip->chip_status |= PDAUDIOCF_STAT_IS_SUSPENDED;	/* ignore interrupts from now */
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:280:	return (chip->ak4117->rcs0 & AK4117_UNLCK) == 0;
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:290:	       (snd_ak4117_external_rate(chip->ak4117) <= 0 || !check_signal(chip)))
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:292:	chip->chip_status &= ~PDAUDIOCF_STAT_IS_SUSPENDED;
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:293:	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:35:	if ((chip->chip_status & (PDAUDIOCF_STAT_IS_STALE|
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:40:	stat = inw(chip->port + PDAUDIOCF_REG_ISR);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:44:		if (chip->pcm_substream)
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:50:		snd_ak4117_check_rate_and_errors(chip->ak4117, 0);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:210:	unsigned long rdp_port = chip->port + PDAUDIOCF_REG_MD;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:211:	unsigned int xor = chip->pcm_xor;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:213:	if (chip->pcm_sample == 3) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:214:		if (chip->pcm_little) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:215:			if (chip->pcm_channels == 1) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:216:				pdacf_transfer_mono24le((char *)chip->pcm_area + (off * 3), xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:218:				pdacf_transfer_stereo24le((char *)chip->pcm_area + (off * 6), xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:221:			if (chip->pcm_channels == 1) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:222:				pdacf_transfer_mono24be((char *)chip->pcm_area + (off * 3), xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:224:				pdacf_transfer_stereo24be((char *)chip->pcm_area + (off * 6), xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:229:	if (chip->pcm_swab == 0) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:230:		if (chip->pcm_channels == 1) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:231:			if (chip->pcm_frame == 2) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:232:				pdacf_transfer_mono16((u16 *)chip->pcm_area + off, xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:234:				pdacf_transfer_mono32((u32 *)chip->pcm_area + off, xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:237:			if (chip->pcm_frame == 2) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:238:				pdacf_transfer_stereo16((u16 *)chip->pcm_area + (off * 2), xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:240:				pdacf_transfer_stereo32((u32 *)chip->pcm_area + (off * 2), xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:244:		if (chip->pcm_channels == 1) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:245:			if (chip->pcm_frame == 2) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:246:				pdacf_transfer_mono16sw((u16 *)chip->pcm_area + off, xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:248:				pdacf_transfer_mono32sw((u32 *)chip->pcm_area + off, xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:251:			if (chip->pcm_frame == 2) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:252:				pdacf_transfer_stereo16sw((u16 *)chip->pcm_area + (off * 2), xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:254:				pdacf_transfer_stereo32sw((u32 *)chip->pcm_area + (off * 2), xor, size, rdp_port);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:265:	if ((chip->chip_status & (PDAUDIOCF_STAT_IS_STALE|PDAUDIOCF_STAT_IS_CONFIGURED)) != PDAUDIOCF_STAT_IS_CONFIGURED)
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:268:	if (chip->pcm_substream == NULL || chip->pcm_substream->runtime == NULL || !snd_pcm_running(chip->pcm_substream))
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:271:	rdp = inw(chip->port + PDAUDIOCF_REG_RDP);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:272:	wdp = inw(chip->port + PDAUDIOCF_REG_WDP);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:279:	size /= chip->pcm_frame;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:284:	chip->pcm_hwptr += size;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:285:	chip->pcm_hwptr %= chip->pcm_size;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:286:	chip->pcm_tdone += size;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:287:	if (chip->pcm_frame == 2) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:288:		unsigned long rdp_port = chip->port + PDAUDIOCF_REG_MD;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:294:		unsigned long rdp_port = chip->port + PDAUDIOCF_REG_MD;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:302:	off = chip->pcm_hwptr + chip->pcm_tdone;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:303:	off %= chip->pcm_size;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:304:	chip->pcm_tdone += size;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:306:		cont = chip->pcm_size - off;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:311:		off %= chip->pcm_size;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:315:	mutex_lock(&chip->reg_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:316:	while (chip->pcm_tdone >= chip->pcm_period) {
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:317:		chip->pcm_hwptr += chip->pcm_period;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:318:		chip->pcm_hwptr %= chip->pcm_size;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:319:		chip->pcm_tdone -= chip->pcm_period;
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:320:		mutex_unlock(&chip->reg_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:321:		snd_pcm_period_elapsed(chip->pcm_substream);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:322:		mutex_lock(&chip->reg_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_irq.c:324:	mutex_unlock(&chip->reg_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:36:	while (inw(chip->port + PDAUDIOCF_REG_RDP) != inw(chip->port + PDAUDIOCF_REG_WDP)) {
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:39:		inw(chip->port + PDAUDIOCF_REG_MD);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:54:	if (chip->chip_status & PDAUDIOCF_STAT_IS_STALE)
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:59:		chip->pcm_hwptr = 0;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:60:		chip->pcm_tdone = 0;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:67:		rate = snd_ak4117_check_rate_and_errors(chip->ak4117, AK4117_CHECK_NO_STAT|AK4117_CHECK_NO_RATE);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:80:	mutex_lock(&chip->reg_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:81:	chip->pcm_running += inc;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:83:	if (chip->pcm_running) {
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:84:		if ((chip->ak4117->rcs0 & AK4117_UNLCK) || runtime->rate != rate) {
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:85:			chip->pcm_running -= inc;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:94:	mutex_unlock(&chip->reg_lock);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:95:	snd_ak4117_check_rate_and_errors(chip->ak4117, AK4117_CHECK_NO_RATE);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:126:	if (chip->chip_status & PDAUDIOCF_STAT_IS_STALE)
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:129:	chip->pcm_channels = runtime->channels;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:131:	chip->pcm_little = snd_pcm_format_little_endian(runtime->format) > 0;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:133:	chip->pcm_swab = snd_pcm_format_big_endian(runtime->format) > 0;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:135:	chip->pcm_swab = chip->pcm_little;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:139:		chip->pcm_xor = 0x80008000;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:155:	chip->pcm_sample = 4;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:160:		chip->pcm_frame = 2;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:161:		chip->pcm_sample = 2;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:165:		chip->pcm_sample = 3;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:169:		chip->pcm_frame = 3;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:170:		chip->pcm_xor &= 0xffff0000;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:175:		snd_ak4117_reg_write(chip->ak4117, AK4117_REG_IO, AK4117_DIF2|AK4117_DIF1|AK4117_DIF0, aval);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:184:	chip->pcm_size = runtime->buffer_size;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:185:	chip->pcm_period = runtime->period_size;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:186:	chip->pcm_area = runtime->dma_area;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:232:	if (chip->chip_status & PDAUDIOCF_STAT_IS_STALE)
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:237:	chip->pcm_substream = subs;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:252:	chip->pcm_substream = NULL;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:263:	return chip->pcm_hwptr;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:291:	err = snd_pcm_new(chip->card, "PDAudioCF", 0, 0, 1, &pcm);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:300:	strcpy(pcm->name, chip->card->shortname);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:301:	chip->pcm = pcm;
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:303:	err = snd_ak4117_build(chip->ak4117, pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);
./sound/pcmcia/pdaudiocf/pdaudiocf.c:202:	if (chip->chip_status & PDAUDIOCF_STAT_IS_CONFIGURED)
./sound/pcmcia/pdaudiocf/pdaudiocf.c:204:	chip->chip_status |= PDAUDIOCF_STAT_IS_STALE; /* to be sure */
./sound/pcmcia/pdaudiocf/pdaudiocf.c:205:	snd_card_disconnect(chip->card);
./sound/pcmcia/pdaudiocf/pdaudiocf.c:206:	snd_card_free_when_closed(chip->card);
./sound/i2c/cs8427.c:102:	if (udata != (chip->regmap[CS8427_REG_CSDATABUF] & udata)) {
./sound/i2c/cs8427.c:103:		chip->regmap[CS8427_REG_CSDATABUF] &= ~CS8427_BSEL;
./sound/i2c/cs8427.c:104:		chip->regmap[CS8427_REG_CSDATABUF] |= udata;
./sound/i2c/cs8427.c:106:					   chip->regmap[CS8427_REG_CSDATABUF]);
./sound/i2c/cs8427.c:120:		chip->playback.hw_udata : chip->playback.hw_status;
./sound/i2c/cs8427.c:132:			chip->regmap[CS8427_REG_UDATABUF] &= ~CS8427_UBMMASK;
./sound/i2c/cs8427.c:133:			chip->regmap[CS8427_REG_UDATABUF] |= CS8427_UBMZEROS |
./sound/i2c/cs8427.c:136:						   chip->regmap[CS8427_REG_UDATABUF]);
./sound/i2c/cs8427.c:226:	memcpy(chip->regmap + (initvals1[0] & 0x7f), initvals1 + 1, 6);
./sound/i2c/cs8427.c:238:	memcpy(chip->regmap + (initvals2[0] & 0x7f), initvals2 + 1, 3);
./sound/i2c/cs8427.c:248:	memcpy(chip->playback.def_status, buf, 24);
./sound/i2c/cs8427.c:249:	memcpy(chip->playback.pcm_status, buf, 24);
./sound/i2c/cs8427.c:286:	chip->reset_timeout = reset_timeout;
./sound/i2c/cs8427.c:330:	if ((chip->regmap[CS8427_REG_CLOCKSOURCE] & CS8427_RXDAES3INPUT) ==
./sound/i2c/cs8427.c:333:	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~(CS8427_RUN | CS8427_RXDMASK);
./sound/i2c/cs8427.c:335:			     chip->regmap[CS8427_REG_CLOCKSOURCE]);
./sound/i2c/cs8427.c:337:	chip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RUN | CS8427_RXDILRCK;
./sound/i2c/cs8427.c:339:			     chip->regmap[CS8427_REG_CLOCKSOURCE]);
./sound/i2c/cs8427.c:342:	end_time = jiffies + chip->reset_timeout;
./sound/i2c/cs8427.c:352:	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~CS8427_RXDMASK;
./sound/i2c/cs8427.c:354:		chip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RXDAES3INPUT;
./sound/i2c/cs8427.c:356:			     chip->regmap[CS8427_REG_CLOCKSOURCE]);
./sound/i2c/cs8427.c:433:	memcpy(ucontrol->value.iec958.status, chip->playback.def_status, 24);
./sound/i2c/cs8427.c:444:		chip->playback.pcm_status : chip->playback.def_status;
./sound/i2c/cs8427.c:445:	struct snd_pcm_runtime *runtime = chip->playback.substream ?
./sound/i2c/cs8427.c:446:		chip->playback.substream->runtime : NULL;
./sound/i2c/cs8427.c:552:			chip->playback.pcm_ctl = kctl;
./sound/i2c/cs8427.c:555:	chip->playback.substream = play_substream;
./sound/i2c/cs8427.c:556:	chip->capture.substream = cap_substream;
./sound/i2c/cs8427.c:557:	if (snd_BUG_ON(!chip->playback.pcm_ctl))
./sound/i2c/cs8427.c:572:		memcpy(chip->playback.pcm_status,
./sound/i2c/cs8427.c:573:		       chip->playback.def_status, 24);
./sound/i2c/cs8427.c:574:	chip->playback.pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
./sound/i2c/cs8427.c:577:		       &chip->playback.pcm_ctl->id);
./sound/i2c/cs8427.c:592:	status = chip->playback.pcm_status;
./sound/i2c/cs8427.c:614:			       &chip->playback.pcm_ctl->id);
./sound/i2c/cs8427.c:615:	reset = chip->rate != rate;
./sound/i2c/cs8427.c:616:	chip->rate = rate;
./sound/i2c/other/ak4117.c:65:	del_timer_sync(&chip->timer);
./sound/i2c/other/ak4117.c:89:	spin_lock_init(&chip->lock);
./sound/i2c/other/ak4117.c:90:	chip->card = card;
./sound/i2c/other/ak4117.c:91:	chip->read = read;
./sound/i2c/other/ak4117.c:92:	chip->write = write;
./sound/i2c/other/ak4117.c:93:	chip->private_data = private_data;
./sound/i2c/other/ak4117.c:94:	setup_timer(&chip->timer, snd_ak4117_timer, (unsigned long)chip);
./sound/i2c/other/ak4117.c:97:		chip->regmap[reg] = pgm[reg];
./sound/i2c/other/ak4117.c:100:	chip->rcs0 = reg_read(chip, AK4117_REG_RCS0) & ~(AK4117_QINT | AK4117_CINT | AK4117_STC);
./sound/i2c/other/ak4117.c:101:	chip->rcs1 = reg_read(chip, AK4117_REG_RCS1);
./sound/i2c/other/ak4117.c:102:	chip->rcs2 = reg_read(chip, AK4117_REG_RCS2);
./sound/i2c/other/ak4117.c:120:	reg_write(chip, reg, (chip->regmap[reg] & ~mask) | val);
./sound/i2c/other/ak4117.c:125:	unsigned char old = chip->regmap[AK4117_REG_PWRDN], reg;
./sound/i2c/other/ak4117.c:127:	del_timer(&chip->timer);
./sound/i2c/other/ak4117.c:128:	chip->init = 1;
./sound/i2c/other/ak4117.c:136:		reg_write(chip, reg, chip->regmap[reg]);
./sound/i2c/other/ak4117.c:139:	chip->init = 0;
./sound/i2c/other/ak4117.c:140:	mod_timer(&chip->timer, 1 + jiffies);
./sound/i2c/other/ak4117.c:173:	spin_lock_irq(&chip->lock);
./sound/i2c/other/ak4117.c:177:	spin_unlock_irq(&chip->lock);
./sound/i2c/other/ak4117.c:210:	ucontrol->value.integer.value[0] = (chip->regmap[AK4117_REG_IO] & AK4117_IPS) ? 1 : 0;
./sound/i2c/other/ak4117.c:221:	spin_lock_irq(&chip->lock);
./sound/i2c/other/ak4117.c:222:	old_val = chip->regmap[AK4117_REG_IO];
./sound/i2c/other/ak4117.c:226:	spin_unlock_irq(&chip->lock);
./sound/i2c/other/ak4117.c:537:	if (chip->init)
./sound/i2c/other/ak4117.c:540:	mod_timer(&chip->timer, 1 + jiffies);
./sound/i2c/other/ak4114.c:69:	atomic_inc(&chip->wq_processing);	/* don't schedule new work */
./sound/i2c/other/ak4114.c:70:	cancel_delayed_work_sync(&chip->work);
./sound/i2c/other/ak4114.c:96:	spin_lock_init(&chip->lock);
./sound/i2c/other/ak4114.c:97:	chip->card = card;
./sound/i2c/other/ak4114.c:98:	chip->read = read;
./sound/i2c/other/ak4114.c:99:	chip->write = write;
./sound/i2c/other/ak4114.c:100:	chip->private_data = private_data;
./sound/i2c/other/ak4114.c:101:	INIT_DELAYED_WORK(&chip->work, ak4114_stats);
./sound/i2c/other/ak4114.c:102:	atomic_set(&chip->wq_processing, 0);
./sound/i2c/other/ak4114.c:103:	mutex_init(&chip->reinit_mutex);
./sound/i2c/other/ak4114.c:106:		chip->regmap[reg] = pgm[reg];
./sound/i2c/other/ak4114.c:108:		chip->txcsb[reg] = txcsb[reg];
./sound/i2c/other/ak4114.c:112:	chip->rcs0 = reg_read(chip, AK4114_REG_RCS0) & ~(AK4114_QINT | AK4114_CINT);
./sound/i2c/other/ak4114.c:113:	chip->rcs1 = reg_read(chip, AK4114_REG_RCS1);
./sound/i2c/other/ak4114.c:131:		reg_write(chip, reg, (chip->regmap[reg] & ~mask) | val);
./sound/i2c/other/ak4114.c:134:			  (chip->txcsb[reg-AK4114_REG_TXCSB0] & ~mask) | val);
./sound/i2c/other/ak4114.c:140:	unsigned char old = chip->regmap[AK4114_REG_PWRDN], reg;
./sound/i2c/other/ak4114.c:149:		reg_write(chip, reg, chip->regmap[reg]);
./sound/i2c/other/ak4114.c:151:		reg_write(chip, reg + AK4114_REG_TXCSB0, chip->txcsb[reg]);
./sound/i2c/other/ak4114.c:158:	if (atomic_inc_return(&chip->wq_processing) == 1)
./sound/i2c/other/ak4114.c:159:		cancel_delayed_work_sync(&chip->work);
./sound/i2c/other/ak4114.c:160:	mutex_lock(&chip->reinit_mutex);
./sound/i2c/other/ak4114.c:162:	mutex_unlock(&chip->reinit_mutex);
./sound/i2c/other/ak4114.c:164:	if (atomic_dec_and_test(&chip->wq_processing))
./sound/i2c/other/ak4114.c:165:		schedule_delayed_work(&chip->work, HZ / 10);
./sound/i2c/other/ak4114.c:199:	spin_lock_irq(&chip->lock);
./sound/i2c/other/ak4114.c:203:	spin_unlock_irq(&chip->lock);
./sound/i2c/other/ak4114.c:265:		ucontrol->value.iec958.status[i] = chip->txcsb[i];
./sound/i2c/other/ak4114.c:622:	if (atomic_inc_return(&chip->wq_processing) == 1)
./sound/i2c/other/ak4114.c:623:		snd_ak4114_check_rate_and_errors(chip, chip->check_flags);
./sound/i2c/other/ak4114.c:624:	if (atomic_dec_and_test(&chip->wq_processing))
./sound/i2c/other/ak4114.c:625:		schedule_delayed_work(&chip->work, HZ / 10);
./sound/i2c/other/ak4114.c:631:	atomic_inc(&chip->wq_processing); /* don't schedule new work */
./sound/i2c/other/ak4114.c:632:	cancel_delayed_work_sync(&chip->work);
./sound/i2c/other/ak4114.c:638:	atomic_dec(&chip->wq_processing);
./sound/i2c/other/ak4113.c:59:	atomic_inc(&chip->wq_processing);	/* don't schedule new work */
./sound/i2c/other/ak4113.c:60:	cancel_delayed_work_sync(&chip->work);
./sound/i2c/other/ak4113.c:85:	spin_lock_init(&chip->lock);
./sound/i2c/other/ak4113.c:86:	chip->card = card;
./sound/i2c/other/ak4113.c:87:	chip->read = read;
./sound/i2c/other/ak4113.c:88:	chip->write = write;
./sound/i2c/other/ak4113.c:89:	chip->private_data = private_data;
./sound/i2c/other/ak4113.c:90:	INIT_DELAYED_WORK(&chip->work, ak4113_stats);
./sound/i2c/other/ak4113.c:91:	atomic_set(&chip->wq_processing, 0);
./sound/i2c/other/ak4113.c:92:	mutex_init(&chip->reinit_mutex);
./sound/i2c/other/ak4113.c:95:		chip->regmap[reg] = pgm[reg];
./sound/i2c/other/ak4113.c:98:	chip->rcs0 = reg_read(chip, AK4113_REG_RCS0) & ~(AK4113_QINT |
./sound/i2c/other/ak4113.c:100:	chip->rcs1 = reg_read(chip, AK4113_REG_RCS1);
./sound/i2c/other/ak4113.c:101:	chip->rcs2 = reg_read(chip, AK4113_REG_RCS2);
./sound/i2c/other/ak4113.c:121:	reg_write(chip, reg, (chip->regmap[reg] & ~mask) | val);
./sound/i2c/other/ak4113.c:127:	unsigned char old = chip->regmap[AK4113_REG_PWRDN], reg;
./sound/i2c/other/ak4113.c:136:		reg_write(chip, reg, chip->regmap[reg]);
./sound/i2c/other/ak4113.c:143:	if (atomic_inc_return(&chip->wq_processing) == 1)
./sound/i2c/other/ak4113.c:144:		cancel_delayed_work_sync(&chip->work);
./sound/i2c/other/ak4113.c:145:	mutex_lock(&chip->reinit_mutex);
./sound/i2c/other/ak4113.c:147:	mutex_unlock(&chip->reinit_mutex);
./sound/i2c/other/ak4113.c:149:	if (atomic_dec_and_test(&chip->wq_processing))
./sound/i2c/other/ak4113.c:150:		schedule_delayed_work(&chip->work, HZ / 10);
./sound/i2c/other/ak4113.c:204:	spin_lock_irq(&chip->lock);
./sound/i2c/other/ak4113.c:208:	spin_unlock_irq(&chip->lock);
./sound/i2c/other/ak4113.c:243:		(AK4113_IPS(chip->regmap[AK4113_REG_IO1]));
./sound/i2c/other/ak4113.c:254:	spin_lock_irq(&chip->lock);
./sound/i2c/other/ak4113.c:255:	old_val = chip->regmap[AK4113_REG_IO1];
./sound/i2c/other/ak4113.c:261:	spin_unlock_irq(&chip->lock);
./sound/i2c/other/ak4113.c:636:	if (atomic_inc_return(&chip->wq_processing) == 1)
./sound/i2c/other/ak4113.c:637:		snd_ak4113_check_rate_and_errors(chip, chip->check_flags);
./sound/i2c/other/ak4113.c:639:	if (atomic_dec_and_test(&chip->wq_processing))
./sound/i2c/other/ak4113.c:640:		schedule_delayed_work(&chip->work, HZ / 10);
./sound/i2c/other/ak4113.c:646:	atomic_inc(&chip->wq_processing); /* don't schedule new work */
./sound/i2c/other/ak4113.c:647:	cancel_delayed_work_sync(&chip->work);
./sound/i2c/other/ak4113.c:653:	atomic_dec(&chip->wq_processing);
./kernel/irq/manage.c:121:	    !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)
./kernel/irq/manage.c:189:	ret = chip->irq_set_affinity(data, mask, force);
./kernel/irq/manage.c:209:	if (!chip || !chip->irq_set_affinity)
./kernel/irq/manage.c:417:	if (chip && chip->irq_set_vcpu_affinity)
./kernel/irq/manage.c:418:		ret = chip->irq_set_vcpu_affinity(data, vcpu_info);
./kernel/irq/manage.c:536: *	desc->irq_data.chip->bus_lock and desc->chip->bus_sync_unlock are NULL !
./kernel/irq/manage.c:563:	if (desc->irq_data.chip->irq_set_wake)
./kernel/irq/manage.c:564:		ret = desc->irq_data.chip->irq_set_wake(&desc->irq_data, on);
./kernel/irq/manage.c:645:	if (!chip || !chip->irq_set_type) {
./kernel/irq/manage.c:652:			 chip ? (chip->name ? : "unknown") : "unknown");
./kernel/irq/manage.c:658:	if (chip->flags & IRQCHIP_SET_TYPE_MASKED) {
./kernel/irq/manage.c:666:	ret = chip->irq_set_type(&desc->irq_data, flags);
./kernel/irq/manage.c:688:		       flags, irq_desc_get_irq(desc), chip->irq_set_type);
./kernel/irq/manage.c:1173:	if (desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)
./kernel/irq/manage.c:1251:		   !(desc->irq_data.chip->flags & IRQCHIP_ONESHOT_SAFE)) {
./kernel/irq/manage.c:1277:			       new->name, irq, desc->irq_data.chip->name);
./kernel/irq/manage.c:1975:		if (chip->irq_get_irqchip_state)
./kernel/irq/manage.c:1985:		err = chip->irq_get_irqchip_state(data, which, state);
./kernel/irq/manage.c:2021:		if (chip->irq_set_irqchip_state)
./kernel/irq/manage.c:2031:		err = chip->irq_set_irqchip_state(data, which, val);
./kernel/irq/proc.c:486:		if (desc->irq_data.chip->irq_print_chip)
./kernel/irq/proc.c:487:			desc->irq_data.chip->irq_print_chip(&desc->irq_data, p);
./kernel/irq/proc.c:488:		else if (desc->irq_data.chip->name)
./kernel/irq/proc.c:489:			seq_printf(p, " %8s", desc->irq_data.chip->name);
./kernel/irq/resend.c:74:		if (!desc->irq_data.chip->irq_retrigger ||
./kernel/irq/resend.c:75:		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {
./kernel/irq/irqdomain.c:372:			domain->name = irq_data->chip->name;
./kernel/irq/irqdomain.c:729:			seq_printf(m, "%-15s  ", (chip && chip->name) ? chip->name : "none");
./kernel/irq/irqdomain.c:912:			domain->name = data->chip->name;
./kernel/irq/msi.c:55:	data->chip->irq_write_msi_msg(data, msg);
./kernel/irq/msi.c:74:	ret = parent->chip->irq_set_affinity(parent, mask, force);
./kernel/irq/msi.c:233:	BUG_ON(!chip || !chip->irq_mask || !chip->irq_unmask);
./kernel/irq/msi.c:234:	if (!chip->irq_set_affinity)
./kernel/irq/msi.c:235:		chip->irq_set_affinity = msi_domain_set_affinity;
./kernel/irq/chip.c:197:	if (desc->irq_data.chip->irq_startup) {
./kernel/irq/chip.c:198:		ret = desc->irq_data.chip->irq_startup(&desc->irq_data);
./kernel/irq/chip.c:212:	if (desc->irq_data.chip->irq_shutdown)
./kernel/irq/chip.c:213:		desc->irq_data.chip->irq_shutdown(&desc->irq_data);
./kernel/irq/chip.c:214:	else if (desc->irq_data.chip->irq_disable)
./kernel/irq/chip.c:215:		desc->irq_data.chip->irq_disable(&desc->irq_data);
./kernel/irq/chip.c:217:		desc->irq_data.chip->irq_mask(&desc->irq_data);
./kernel/irq/chip.c:225:	if (desc->irq_data.chip->irq_enable)
./kernel/irq/chip.c:226:		desc->irq_data.chip->irq_enable(&desc->irq_data);
./kernel/irq/chip.c:228:		desc->irq_data.chip->irq_unmask(&desc->irq_data);
./kernel/irq/chip.c:255:	if (desc->irq_data.chip->irq_disable) {
./kernel/irq/chip.c:256:		desc->irq_data.chip->irq_disable(&desc->irq_data);
./kernel/irq/chip.c:265:	if (desc->irq_data.chip->irq_enable)
./kernel/irq/chip.c:266:		desc->irq_data.chip->irq_enable(&desc->irq_data);
./kernel/irq/chip.c:268:		desc->irq_data.chip->irq_unmask(&desc->irq_data);
./kernel/irq/chip.c:274:	if (desc->irq_data.chip->irq_disable)
./kernel/irq/chip.c:275:		desc->irq_data.chip->irq_disable(&desc->irq_data);
./kernel/irq/chip.c:277:		desc->irq_data.chip->irq_mask(&desc->irq_data);
./kernel/irq/chip.c:283:	if (desc->irq_data.chip->irq_mask_ack)
./kernel/irq/chip.c:284:		desc->irq_data.chip->irq_mask_ack(&desc->irq_data);
./kernel/irq/chip.c:286:		desc->irq_data.chip->irq_mask(&desc->irq_data);
./kernel/irq/chip.c:287:		if (desc->irq_data.chip->irq_ack)
./kernel/irq/chip.c:288:			desc->irq_data.chip->irq_ack(&desc->irq_data);
./kernel/irq/chip.c:295:	if (desc->irq_data.chip->irq_mask) {
./kernel/irq/chip.c:296:		desc->irq_data.chip->irq_mask(&desc->irq_data);
./kernel/irq/chip.c:303:	if (desc->irq_data.chip->irq_unmask) {
./kernel/irq/chip.c:304:		desc->irq_data.chip->irq_unmask(&desc->irq_data);
./kernel/irq/chip.c:313:	if (chip->flags & IRQCHIP_EOI_THREADED)
./kernel/irq/chip.c:314:		chip->irq_eoi(&desc->irq_data);
./kernel/irq/chip.c:316:	if (chip->irq_unmask) {
./kernel/irq/chip.c:317:		chip->irq_unmask(&desc->irq_data);
./kernel/irq/chip.c:498:		chip->irq_eoi(&desc->irq_data);
./kernel/irq/chip.c:509:		chip->irq_eoi(&desc->irq_data);
./kernel/irq/chip.c:511:	} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {
./kernel/irq/chip.c:512:		chip->irq_eoi(&desc->irq_data);
./kernel/irq/chip.c:558:	if (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))
./kernel/irq/chip.c:559:		chip->irq_eoi(&desc->irq_data);
./kernel/irq/chip.c:604:	desc->irq_data.chip->irq_ack(&desc->irq_data);
./kernel/irq/chip.c:675:	chip->irq_eoi(&desc->irq_data);
./kernel/irq/chip.c:692:	if (chip->irq_ack)
./kernel/irq/chip.c:693:		chip->irq_ack(&desc->irq_data);
./kernel/irq/chip.c:697:	if (chip->irq_eoi)
./kernel/irq/chip.c:698:		chip->irq_eoi(&desc->irq_data);
./kernel/irq/chip.c:722:	if (chip->irq_ack)
./kernel/irq/chip.c:723:		chip->irq_ack(&desc->irq_data);
./kernel/irq/chip.c:729:	if (chip->irq_eoi)
./kernel/irq/chip.c:730:		chip->irq_eoi(&desc->irq_data);
./kernel/irq/chip.c:876:		if (chip && chip->irq_cpu_online &&
./kernel/irq/chip.c:877:		    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||
./kernel/irq/chip.c:879:			chip->irq_cpu_online(&desc->irq_data);
./kernel/irq/chip.c:906:		if (chip && chip->irq_cpu_offline &&
./kernel/irq/chip.c:907:		    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||
./kernel/irq/chip.c:909:			chip->irq_cpu_offline(&desc->irq_data);
./kernel/irq/chip.c:924:	if (data->chip->irq_enable)
./kernel/irq/chip.c:925:		data->chip->irq_enable(data);
./kernel/irq/chip.c:927:		data->chip->irq_unmask(data);
./kernel/irq/chip.c:938:	if (data->chip->irq_disable)
./kernel/irq/chip.c:939:		data->chip->irq_disable(data);
./kernel/irq/chip.c:941:		data->chip->irq_mask(data);
./kernel/irq/chip.c:951:	data->chip->irq_ack(data);
./kernel/irq/chip.c:962:	data->chip->irq_mask(data);
./kernel/irq/chip.c:973:	data->chip->irq_unmask(data);
./kernel/irq/chip.c:984:	data->chip->irq_eoi(data);
./kernel/irq/chip.c:1000:	if (data->chip->irq_set_affinity)
./kernel/irq/chip.c:1001:		return data->chip->irq_set_affinity(data, dest, force);
./kernel/irq/chip.c:1017:	if (data->chip->irq_set_type)
./kernel/irq/chip.c:1018:		return data->chip->irq_set_type(data, type);
./kernel/irq/chip.c:1034:		if (data->chip && data->chip->irq_retrigger)
./kernel/irq/chip.c:1035:			return data->chip->irq_retrigger(data);
./kernel/irq/chip.c:1048:	if (data->chip->irq_set_vcpu_affinity)
./kernel/irq/chip.c:1049:		return data->chip->irq_set_vcpu_affinity(data, vcpu_info);
./kernel/irq/chip.c:1064:	if (data->chip->irq_set_wake)
./kernel/irq/chip.c:1065:		return data->chip->irq_set_wake(data, on);
./kernel/irq/chip.c:1087:		if (data->chip && data->chip->irq_compose_msi_msg)
./kernel/irq/chip.c:1092:	pos->chip->irq_compose_msi_msg(pos, msg);
./kernel/irq/autoprobe.c:53:			if (desc->irq_data.chip->irq_set_type)
./kernel/irq/autoprobe.c:54:				desc->irq_data.chip->irq_set_type(&desc->irq_data,
./kernel/irq/ipi.c:195:	if (!chip->ipi_send_single && !chip->ipi_send_mask)
./kernel/irq/ipi.c:236:	if (!chip->ipi_send_single) {
./kernel/irq/ipi.c:237:		chip->ipi_send_mask(data, cpumask_of(cpu));
./kernel/irq/ipi.c:249:	chip->ipi_send_single(data, cpu);
./kernel/irq/ipi.c:279:	if (chip->ipi_send_mask) {
./kernel/irq/ipi.c:280:		chip->ipi_send_mask(data, dest);
./kernel/irq/ipi.c:291:			chip->ipi_send_single(data, cpu);
./kernel/irq/ipi.c:295:			chip->ipi_send_single(data, cpu);
./kernel/irq/migration.c:28:	if (!chip->irq_set_affinity)
./kernel/irq/migration.c:75:		idata->chip->irq_mask(idata);
./kernel/irq/migration.c:78:		idata->chip->irq_unmask(idata);
./kernel/irq/generic-chip.c:403:	if (chip->irq_calc_mask)
./kernel/irq/generic-chip.c:404:		chip->irq_calc_mask(data);
./kernel/irq/generic-chip.c:456:			if (chip->irq_calc_mask)
./kernel/irq/generic-chip.c:457:				chip->irq_calc_mask(d);
./kernel/irq/generic-chip.c:474: * Only to be called from chip->irq_set_type() callbacks.
./arch/blackfin/mach-bf538/ext-gpio.c:29:	switch (chip->base) {
./arch/blackfin/mach-bf538/ext-gpio.c:71:	return bfin_special_gpio_request(chip->base + gpio, chip->label);
./arch/blackfin/mach-bf538/ext-gpio.c:76:	return bfin_special_gpio_free(chip->base + gpio);
./arch/blackfin/kernel/bfin_gpio.c:1174:	return bfin_gpio_request(gpio, chip->label);
./arch/blackfin/mach-bf561/smp.c:166:	chip->irq_unmask(data);
./arch/ia64/kernel/iosapic.c:610:			       chip->name, irq_type->name);
./arch/ia64/kernel/irq.c:134:			if (chip && chip->irq_disable &&
./arch/ia64/kernel/irq.c:135:				chip->irq_enable && chip->irq_set_affinity) {
./arch/ia64/kernel/irq.c:136:				chip->irq_disable(data);
./arch/ia64/kernel/irq.c:137:				chip->irq_set_affinity(data,
./arch/ia64/kernel/irq.c:139:				chip->irq_enable(data);
./arch/ia64/kernel/irq.c:141:				WARN_ON((!chip || !chip->irq_disable ||
./arch/ia64/kernel/irq.c:142:					 !chip->irq_enable ||
./arch/ia64/kernel/irq.c:143:					 !chip->irq_set_affinity));
./arch/ia64/kernel/smpboot.c:633:				data->chip->irq_disable(data);
./arch/ia64/kernel/smpboot.c:634:				data->chip->irq_set_affinity(data, mask, false);
./arch/ia64/kernel/smpboot.c:635:				data->chip->irq_enable(data);
./arch/alpha/kernel/core_tsunami.c:185:	csr = &pchip->tlbia.csr;
./arch/alpha/kernel/core_tsunami.c:187:		csr = &pchip->tlbiv.csr;
./arch/alpha/kernel/core_tsunami.c:226:	TSUNAMI_cchip->misc.csr |= (1L << 28); /* clear NXM... */
./arch/alpha/kernel/core_tsunami.c:230:	if (TSUNAMI_cchip->misc.csr & (1L << 28)) {
./arch/alpha/kernel/core_tsunami.c:231:		int source = (TSUNAMI_cchip->misc.csr >> 29) & 7;
./arch/alpha/kernel/core_tsunami.c:232:		TSUNAMI_cchip->misc.csr |= (1L << 28); /* ...and unlock NXS. */
./arch/alpha/kernel/core_tsunami.c:250:	if (tsunami_probe_read(&pchip->pctl.csr) == 0)
./arch/alpha/kernel/core_tsunami.c:293:	saved_config[index].wsba[0] = pchip->wsba[0].csr;
./arch/alpha/kernel/core_tsunami.c:294:	saved_config[index].wsm[0] = pchip->wsm[0].csr;
./arch/alpha/kernel/core_tsunami.c:295:	saved_config[index].tba[0] = pchip->tba[0].csr;
./arch/alpha/kernel/core_tsunami.c:297:	saved_config[index].wsba[1] = pchip->wsba[1].csr;
./arch/alpha/kernel/core_tsunami.c:298:	saved_config[index].wsm[1] = pchip->wsm[1].csr;
./arch/alpha/kernel/core_tsunami.c:299:	saved_config[index].tba[1] = pchip->tba[1].csr;
./arch/alpha/kernel/core_tsunami.c:301:	saved_config[index].wsba[2] = pchip->wsba[2].csr;
./arch/alpha/kernel/core_tsunami.c:302:	saved_config[index].wsm[2] = pchip->wsm[2].csr;
./arch/alpha/kernel/core_tsunami.c:303:	saved_config[index].tba[2] = pchip->tba[2].csr;
./arch/alpha/kernel/core_tsunami.c:305:	saved_config[index].wsba[3] = pchip->wsba[3].csr;
./arch/alpha/kernel/core_tsunami.c:306:	saved_config[index].wsm[3] = pchip->wsm[3].csr;
./arch/alpha/kernel/core_tsunami.c:307:	saved_config[index].tba[3] = pchip->tba[3].csr;
./arch/alpha/kernel/core_tsunami.c:332:	pchip->wsba[0].csr = hose->sg_isa->dma_base | 3;
./arch/alpha/kernel/core_tsunami.c:333:	pchip->wsm[0].csr  = (hose->sg_isa->size - 1) & 0xfff00000;
./arch/alpha/kernel/core_tsunami.c:334:	pchip->tba[0].csr  = virt_to_phys(hose->sg_isa->ptes);
./arch/alpha/kernel/core_tsunami.c:336:	pchip->wsba[1].csr = hose->sg_pci->dma_base | 3;
./arch/alpha/kernel/core_tsunami.c:337:	pchip->wsm[1].csr  = (hose->sg_pci->size - 1) & 0xfff00000;
./arch/alpha/kernel/core_tsunami.c:338:	pchip->tba[1].csr  = virt_to_phys(hose->sg_pci->ptes);
./arch/alpha/kernel/core_tsunami.c:340:	pchip->wsba[2].csr = 0x80000000 | 1;
./arch/alpha/kernel/core_tsunami.c:341:	pchip->wsm[2].csr  = (0x80000000 - 1) & 0xfff00000;
./arch/alpha/kernel/core_tsunami.c:342:	pchip->tba[2].csr  = 0;
./arch/alpha/kernel/core_tsunami.c:344:	pchip->wsba[3].csr = 0;
./arch/alpha/kernel/core_tsunami.c:347:	pchip->pctl.csr |= pctl_m_mwin;
./arch/alpha/kernel/core_tsunami.c:393:	printk("%s: CSR_CSC 0x%lx\n", __func__, TSUNAMI_cchip->csc.csr);
./arch/alpha/kernel/core_tsunami.c:395:	printk("%s: CSR_MISC 0x%lx\n", __func__, TSUNAMI_cchip->misc.csr);
./arch/alpha/kernel/core_tsunami.c:396:	printk("%s: CSR_DIM0 0x%lx\n", __func__, TSUNAMI_cchip->dim0.csr);
./arch/alpha/kernel/core_tsunami.c:397:	printk("%s: CSR_DIM1 0x%lx\n", __func__, TSUNAMI_cchip->dim1.csr);
./arch/alpha/kernel/core_tsunami.c:398:	printk("%s: CSR_DIR0 0x%lx\n", __func__, TSUNAMI_cchip->dir0.csr);
./arch/alpha/kernel/core_tsunami.c:399:	printk("%s: CSR_DIR1 0x%lx\n", __func__, TSUNAMI_cchip->dir1.csr);
./arch/alpha/kernel/core_tsunami.c:400:	printk("%s: CSR_DRIR 0x%lx\n", __func__, TSUNAMI_cchip->drir.csr);
./arch/alpha/kernel/core_tsunami.c:403:	printk("%s: CSR_DSC 0x%lx\n", __func__, TSUNAMI_dchip->dsc.csr);
./arch/alpha/kernel/core_tsunami.c:404:	printk("%s: CSR_STR 0x%lx\n", __func__, TSUNAMI_dchip->str.csr);
./arch/alpha/kernel/core_tsunami.c:405:	printk("%s: CSR_DREV 0x%lx\n", __func__, TSUNAMI_dchip->drev.csr);
./arch/alpha/kernel/core_tsunami.c:414:	if (TSUNAMI_cchip->csc.csr & 1L<<14)
./arch/alpha/kernel/core_tsunami.c:424:	pchip->wsba[0].csr = saved_config[index].wsba[0];
./arch/alpha/kernel/core_tsunami.c:425:	pchip->wsm[0].csr = saved_config[index].wsm[0];
./arch/alpha/kernel/core_tsunami.c:426:	pchip->tba[0].csr = saved_config[index].tba[0];
./arch/alpha/kernel/core_tsunami.c:428:	pchip->wsba[1].csr = saved_config[index].wsba[1];
./arch/alpha/kernel/core_tsunami.c:429:	pchip->wsm[1].csr = saved_config[index].wsm[1];
./arch/alpha/kernel/core_tsunami.c:430:	pchip->tba[1].csr = saved_config[index].tba[1];
./arch/alpha/kernel/core_tsunami.c:432:	pchip->wsba[2].csr = saved_config[index].wsba[2];
./arch/alpha/kernel/core_tsunami.c:433:	pchip->wsm[2].csr = saved_config[index].wsm[2];
./arch/alpha/kernel/core_tsunami.c:434:	pchip->tba[2].csr = saved_config[index].tba[2];
./arch/alpha/kernel/core_tsunami.c:436:	pchip->wsba[3].csr = saved_config[index].wsba[3];
./arch/alpha/kernel/core_tsunami.c:437:	pchip->wsm[3].csr = saved_config[index].wsm[3];
./arch/alpha/kernel/core_tsunami.c:438:	pchip->tba[3].csr = saved_config[index].tba[3];
./arch/alpha/kernel/core_tsunami.c:445:	if (TSUNAMI_cchip->csc.csr & 1L<<14)
./arch/alpha/kernel/core_tsunami.c:452:	pchip->perror.csr;
./arch/alpha/kernel/core_tsunami.c:453:	pchip->perror.csr = 0x040;
./arch/alpha/kernel/core_tsunami.c:455:	pchip->perror.csr;
./arch/alpha/kernel/core_tsunami.c:464:	if (TSUNAMI_cchip->csc.csr & 1L<<14)
./arch/alpha/kernel/sys_titan.c:83:	dim0 = &cchip->dim0.csr;
./arch/alpha/kernel/sys_titan.c:84:	dim1 = &cchip->dim1.csr;
./arch/alpha/kernel/sys_titan.c:85:	dim2 = &cchip->dim2.csr;
./arch/alpha/kernel/sys_titan.c:86:	dim3 = &cchip->dim3.csr;
./arch/alpha/kernel/sys_titan.c:103:	dimB = &cchip->dim0.csr;
./arch/alpha/kernel/sys_titan.c:104:	if (bcpu == 1) dimB = &cchip->dim1.csr;
./arch/alpha/kernel/sys_titan.c:105:	else if (bcpu == 2) dimB = &cchip->dim2.csr;
./arch/alpha/kernel/sys_titan.c:106:	else if (bcpu == 3) dimB = &cchip->dim3.csr;
./arch/alpha/kernel/core_titan.c:211:	port = &pachip->g_port;
./arch/alpha/kernel/core_titan.c:213:		port = &pachip->a_port;
./arch/alpha/kernel/core_titan.c:353:	titan_pchip1_present = TITAN_cchip->csc.csr & 1L<<14;
./arch/alpha/kernel/core_titan.c:370:	printk("%s: CSR_CSC 0x%lx\n", __func__, TITAN_cchip->csc.csr);
./arch/alpha/kernel/core_titan.c:371:	printk("%s: CSR_MTR 0x%lx\n", __func__, TITAN_cchip->mtr.csr);
./arch/alpha/kernel/core_titan.c:372:	printk("%s: CSR_MISC 0x%lx\n", __func__, TITAN_cchip->misc.csr);
./arch/alpha/kernel/core_titan.c:373:	printk("%s: CSR_DIM0 0x%lx\n", __func__, TITAN_cchip->dim0.csr);
./arch/alpha/kernel/core_titan.c:374:	printk("%s: CSR_DIM1 0x%lx\n", __func__, TITAN_cchip->dim1.csr);
./arch/alpha/kernel/core_titan.c:375:	printk("%s: CSR_DIR0 0x%lx\n", __func__, TITAN_cchip->dir0.csr);
./arch/alpha/kernel/core_titan.c:376:	printk("%s: CSR_DIR1 0x%lx\n", __func__, TITAN_cchip->dir1.csr);
./arch/alpha/kernel/core_titan.c:377:	printk("%s: CSR_DRIR 0x%lx\n", __func__, TITAN_cchip->drir.csr);
./arch/alpha/kernel/core_titan.c:380:	printk("%s: CSR_DSC 0x%lx\n", __func__, TITAN_dchip->dsc.csr);
./arch/alpha/kernel/core_titan.c:381:	printk("%s: CSR_STR 0x%lx\n", __func__, TITAN_dchip->str.csr);
./arch/alpha/kernel/core_titan.c:382:	printk("%s: CSR_DREV 0x%lx\n", __func__, TITAN_dchip->drev.csr);
./arch/alpha/kernel/irq.c:54:	if (!chip->irq_set_affinity || irq_user_affinity[irq])
./arch/alpha/kernel/irq.c:63:	chip->irq_set_affinity(data, cpumask_of(cpu), false);
./arch/alpha/kernel/sys_dp264.c:68:	dim0 = &cchip->dim0.csr;
./arch/alpha/kernel/sys_dp264.c:69:	dim1 = &cchip->dim1.csr;
./arch/alpha/kernel/sys_dp264.c:70:	dim2 = &cchip->dim2.csr;
./arch/alpha/kernel/sys_dp264.c:71:	dim3 = &cchip->dim3.csr;
./arch/alpha/kernel/sys_dp264.c:88:	if (bcpu == 0) dimB = &cchip->dim0.csr;
./arch/alpha/kernel/sys_dp264.c:89:	else if (bcpu == 1) dimB = &cchip->dim1.csr;
./arch/alpha/kernel/sys_dp264.c:90:	else if (bcpu == 2) dimB = &cchip->dim2.csr;
./arch/alpha/kernel/sys_dp264.c:91:	else dimB = &cchip->dim3.csr;
./arch/alpha/kernel/sys_dp264.c:197:	pld = TSUNAMI_cchip->dir0.csr;
./arch/alpha/kernel/core_polaris.c:4: * POLARIS chip-specific code
./arch/microblaze/mm/init.c:298: * MMU_init_hw does the chip-specific initialization of the MMU hardware.
./arch/powerpc/kernel/machine_kexec.c:36:		if (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))
./arch/powerpc/kernel/machine_kexec.c:37:			chip->irq_eoi(&desc->irq_data);
./arch/powerpc/kernel/machine_kexec.c:39:		if (chip->irq_mask)
./arch/powerpc/kernel/machine_kexec.c:40:			chip->irq_mask(&desc->irq_data);
./arch/powerpc/kernel/machine_kexec.c:42:		if (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))
./arch/powerpc/kernel/machine_kexec.c:43:			chip->irq_disable(&desc->irq_data);
./arch/powerpc/kernel/irq.c:450:		if (chip->irq_set_affinity)
./arch/powerpc/kernel/irq.c:451:			chip->irq_set_affinity(data, mask, true);
./arch/powerpc/kernel/prom.c:782: * of_get_ibm_chip_id - Returns the IBM "chip-id" of a device
./arch/powerpc/kernel/prom.c:785: * This looks for a property "ibm,chip-id" in the node or any
./arch/powerpc/kernel/prom.c:797:		 * cell in chip-id, we only read the first one here.
./arch/powerpc/kernel/prom.c:799:		if (!of_property_read_u32(np, "ibm,chip-id", &chip_id)) {
./arch/powerpc/kernel/prom.c:811: * cpu_to_chip_id - Return the cpus chip-id
./arch/powerpc/kernel/prom.c:814: * Return the value of the ibm,chip-id property corresponding to the given
./arch/powerpc/kernel/prom.c:815: * logical cpu number. If the chip-id can not be found, returns -1.
./arch/powerpc/kernel/smp.c:622:		prop = of_get_property(np, "ibm,chip-id", &plen);
./arch/powerpc/kernel/smp.c:666:	/* First see if we have ibm,chip-id properties in cpu nodes */
./arch/powerpc/kernel/smp.c:670:		prop = of_get_property(np, "ibm,chip-id", &plen);
./arch/powerpc/platforms/8xx/m8xx_setup.c:225:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/chrp/setup.c:374:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/86xx/pic.c:28:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/embedded6xx/mvme5100.c:53:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/embedded6xx/hlwd-pic.c:130:	chip->irq_mask(&desc->irq_data); /* IRQ_LEVEL */
./arch/powerpc/platforms/embedded6xx/hlwd-pic.c:140:	chip->irq_ack(&desc->irq_data); /* IRQ_LEVEL */
./arch/powerpc/platforms/embedded6xx/hlwd-pic.c:141:	if (!irqd_irq_disabled(&desc->irq_data) && chip->irq_unmask)
./arch/powerpc/platforms/embedded6xx/hlwd-pic.c:142:		chip->irq_unmask(&desc->irq_data);
./arch/powerpc/platforms/cell/interrupt.c:134:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/cell/axon_msi.c:151:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/cell/spider-pic.c:217:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/85xx/common.c:63:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/85xx/socrates_fpga_pic.c:108:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/85xx/mpc85xx_ds.c:57:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/platforms/powernv/opal-xscom.c:43:	gcid = of_get_property(dev, "ibm,chip-id", NULL);
./arch/powerpc/platforms/powernv/opal-xscom.c:45:		pr_err("%s: device %s has no ibm,chip-id\n",
./arch/powerpc/platforms/powernv/rng.c:91:		pr_warn("No ibm,chip-id found for %s.\n", dn->full_name);
./arch/powerpc/platforms/52xx/media5200.c:91:	chip->irq_mask(&desc->irq_data);
./arch/powerpc/platforms/52xx/media5200.c:109:	chip->irq_ack(&desc->irq_data);
./arch/powerpc/platforms/52xx/media5200.c:111:		chip->irq_unmask(&desc->irq_data);
./arch/powerpc/platforms/pseries/setup.c:123:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/sysdev/xilinx_intc.c:234:	chip->irq_unmask(&desc->irq_data);
./arch/powerpc/sysdev/ge/ge_pic.c:108:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/sysdev/tsi108_pci.c:439:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/sysdev/xics/xics-common.c:223:		if (!chip || !chip->irq_set_affinity)
./arch/powerpc/sysdev/mpic.c:1179:	chip->irq_eoi(&desc->irq_data);
./arch/powerpc/sysdev/ppc4xx_gpio.c:96:	spin_lock_irqsave(&chip->lock, flags);
./arch/powerpc/sysdev/ppc4xx_gpio.c:100:	spin_unlock_irqrestore(&chip->lock, flags);
./arch/powerpc/sysdev/ppc4xx_gpio.c:112:	spin_lock_irqsave(&chip->lock, flags);
./arch/powerpc/sysdev/ppc4xx_gpio.c:129:	spin_unlock_irqrestore(&chip->lock, flags);
./arch/powerpc/sysdev/ppc4xx_gpio.c:142:	spin_lock_irqsave(&chip->lock, flags);
./arch/powerpc/sysdev/ppc4xx_gpio.c:162:	spin_unlock_irqrestore(&chip->lock, flags);
./arch/powerpc/sysdev/uic.c:208:		chip->irq_mask(idata);
./arch/powerpc/sysdev/uic.c:210:		chip->irq_mask_ack(idata);
./arch/powerpc/sysdev/uic.c:225:		chip->irq_ack(idata);
./arch/powerpc/sysdev/uic.c:226:	if (!irqd_irq_disabled(idata) && chip->irq_unmask)
./arch/powerpc/sysdev/uic.c:227:		chip->irq_unmask(idata);
./arch/powerpc/mm/8xx_mmu.c:21: * MMU_init_hw does the chip-specific initialization of the MMU hardware.
./arch/powerpc/mm/40x_mmu.c:56: * MMU_init_hw does the chip-specific initialization of the MMU hardware.
./arch/powerpc/mm/fsl_booke_mmu.c:230: * MMU_init_hw does the chip-specific initialization of the MMU hardware.
./arch/arm/mach-u300/dummyspichip.c:43:	 * WARNING! Do not dereference the chip-specific data in any normal
./arch/arm/mach-u300/core.c:284:	for ( ; chip->chipid; chip++) {
./arch/arm/mach-u300/core.c:285:		if (chip->chipid == (val & 0xFF00U)) {
./arch/arm/mach-u300/core.c:286:			chipname = chip->name;
./arch/arm/mach-omap1/usb.c:35:/* These routines should handle the standard chip-specific modes
./arch/arm/mach-omap1/ams-delta-fiq.c:70:				if (irq_chip && irq_chip->irq_unmask)
./arch/arm/mach-omap1/ams-delta-fiq.c:71:					irq_chip->irq_unmask(d);
./arch/arm/mach-orion5x/ts78xx-setup.c:204:	void __iomem *io_base = chip->IO_ADDR_W;
./arch/arm/mach-orion5x/ts78xx-setup.c:231:	void __iomem *io_base = chip->IO_ADDR_R;
./arch/arm/mach-ep93xx/ts72xx.c:80:		void __iomem *addr = chip->IO_ADDR_R;
./arch/arm/mach-ep93xx/ts72xx.c:94:		__raw_writeb(cmd, chip->IO_ADDR_W);
./arch/arm/mach-ep93xx/ts72xx.c:100:	void __iomem *addr = chip->IO_ADDR_R;
./arch/arm/mach-ep93xx/snappercl15.c:47:#define NAND_CTRL_ADDR(chip) 	(chip->IO_ADDR_W + 0x40)
./arch/arm/mach-ep93xx/snappercl15.c:74:		__raw_writew((cmd & 0xff) | nand_state, chip->IO_ADDR_W);
./arch/arm/kernel/machine_kexec.c:106:		if (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))
./arch/arm/kernel/machine_kexec.c:107:			chip->irq_eoi(&desc->irq_data);
./arch/arm/kernel/machine_kexec.c:109:		if (chip->irq_mask)
./arch/arm/kernel/machine_kexec.c:110:			chip->irq_mask(&desc->irq_data);
./arch/arm/kernel/machine_kexec.c:112:		if (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))
./arch/arm/kernel/machine_kexec.c:113:			chip->irq_disable(&desc->irq_data);
./arch/arm/plat-samsung/pm-gpio.c:35:	chip->pm_save[0] = __raw_readl(chip->base + OFFS_CON);
./arch/arm/plat-samsung/pm-gpio.c:36:	chip->pm_save[1] = __raw_readl(chip->base + OFFS_DAT);
./arch/arm/plat-samsung/pm-gpio.c:41:	void __iomem *base = chip->base;
./arch/arm/plat-samsung/pm-gpio.c:44:	u32 gps_gpcon = chip->pm_save[0];
./arch/arm/plat-samsung/pm-gpio.c:45:	u32 gps_gpdat = chip->pm_save[1];
./arch/arm/plat-samsung/pm-gpio.c:62:		  chip->chip.label, old_gpcon, gps_gpcon, old_gpdat, gps_gpdat);
./arch/arm/plat-samsung/pm-gpio.c:72:	chip->pm_save[0] = __raw_readl(chip->base + OFFS_CON);
./arch/arm/plat-samsung/pm-gpio.c:73:	chip->pm_save[1] = __raw_readl(chip->base + OFFS_DAT);
./arch/arm/plat-samsung/pm-gpio.c:74:	chip->pm_save[2] = __raw_readl(chip->base + OFFS_UP);
./arch/arm/plat-samsung/pm-gpio.c:128:	void __iomem *base = chip->base;
./arch/arm/plat-samsung/pm-gpio.c:131:	u32 gps_gpcon = chip->pm_save[0];
./arch/arm/plat-samsung/pm-gpio.c:132:	u32 gps_gpdat = chip->pm_save[1];
./arch/arm/plat-samsung/pm-gpio.c:138:	__raw_writel(chip->pm_save[2], base + OFFS_UP);
./arch/arm/plat-samsung/pm-gpio.c:189:		  chip->chip.label, old_gpcon, gps_gpcon, old_gpdat, gps_gpdat);
./arch/arm/plat-samsung/pm-gpio.c:200:	chip->pm_save[1] = __raw_readl(chip->base + OFFS_CON);
./arch/arm/plat-samsung/pm-gpio.c:201:	chip->pm_save[2] = __raw_readl(chip->base + OFFS_DAT);
./arch/arm/plat-samsung/pm-gpio.c:202:	chip->pm_save[3] = __raw_readl(chip->base + OFFS_UP);
./arch/arm/plat-samsung/pm-gpio.c:204:	if (chip->chip.ngpio > 8)
./arch/arm/plat-samsung/pm-gpio.c:205:		chip->pm_save[0] = __raw_readl(chip->base - 4);
./arch/arm/plat-samsung/pm-gpio.c:249:	void __iomem *con = chip->base + (index * 4);
./arch/arm/plat-samsung/pm-gpio.c:251:	u32 gps_gpcon = chip->pm_save[index + 1];
./arch/arm/plat-samsung/pm-gpio.c:264:	void __iomem *base = chip->base;
./arch/arm/plat-samsung/pm-gpio.c:267:	u32 gps_gpdat = chip->pm_save[2];
./arch/arm/plat-samsung/pm-gpio.c:275:	if (chip->chip.ngpio > 8) {
./arch/arm/plat-samsung/pm-gpio.c:282:	__raw_writel(chip->pm_save[2], base + OFFS_DAT);
./arch/arm/plat-samsung/pm-gpio.c:283:	__raw_writel(chip->pm_save[1], base + OFFS_CON);
./arch/arm/plat-samsung/pm-gpio.c:284:	if (chip->chip.ngpio > 8)
./arch/arm/plat-samsung/pm-gpio.c:285:		__raw_writel(chip->pm_save[0], base - 4);
./arch/arm/plat-samsung/pm-gpio.c:287:	__raw_writel(chip->pm_save[2], base + OFFS_DAT);
./arch/arm/plat-samsung/pm-gpio.c:288:	__raw_writel(chip->pm_save[3], base + OFFS_UP);
./arch/arm/plat-samsung/pm-gpio.c:290:	if (chip->chip.ngpio > 8) {
./arch/arm/plat-samsung/pm-gpio.c:292:			  chip->chip.label, old_gpcon[0], old_gpcon[1],
./arch/arm/plat-samsung/pm-gpio.c:298:			  chip->chip.label, old_gpcon[1],
./arch/arm/plat-samsung/pm-gpio.c:315:	struct samsung_gpio_pm *pm = ourchip->pm;
./arch/arm/plat-samsung/pm-gpio.c:318:		S3C_PMDBG("%s: no pm for %s\n", __func__, ourchip->chip.label);
./arch/arm/plat-samsung/pm-gpio.c:344:			  ourchip->chip.label,
./arch/arm/plat-samsung/pm-gpio.c:345:			  ourchip->pm_save[0],
./arch/arm/plat-samsung/pm-gpio.c:346:			  ourchip->pm_save[1],
./arch/arm/plat-samsung/pm-gpio.c:347:			  ourchip->pm_save[2],
./arch/arm/plat-samsung/pm-gpio.c:348:			  ourchip->pm_save[3]);
./arch/arm/plat-samsung/pm-gpio.c:350:		gpio_nr += ourchip->chip.ngpio;
./arch/arm/plat-samsung/pm-gpio.c:361:	struct samsung_gpio_pm *pm = ourchip->pm;
./arch/arm/plat-samsung/pm-gpio.c:364:		S3C_PMDBG("%s: no pm for %s\n", __func__, ourchip->chip.label);
./arch/arm/plat-samsung/pm-gpio.c:383:		gpio_nr += ourchip->chip.ngpio;
./arch/arm/plat-samsung/gpio-samsung.c:47:	void __iomem *reg = chip->base + 0x08;
./arch/arm/plat-samsung/gpio-samsung.c:62:	void __iomem *reg = chip->base + 0x08;
./arch/arm/plat-samsung/gpio-samsung.c:116:	void __iomem *reg = chip->base + 0x08;
./arch/arm/plat-samsung/gpio-samsung.c:134:	void __iomem *reg = chip->base + 0x08;
./arch/arm/plat-samsung/gpio-samsung.c:182:	void __iomem *reg = chip->base;
./arch/arm/plat-samsung/gpio-samsung.c:217:	con = __raw_readl(chip->base);
./arch/arm/plat-samsung/gpio-samsung.c:245:	void __iomem *reg = chip->base;
./arch/arm/plat-samsung/gpio-samsung.c:249:	if (off < 8 && chip->chip.ngpio > 8)
./arch/arm/plat-samsung/gpio-samsung.c:280:	void __iomem *reg = chip->base;
./arch/arm/plat-samsung/gpio-samsung.c:284:	if (off < 8 && chip->chip.ngpio > 8)
./arch/arm/plat-samsung/gpio-samsung.c:310:	void __iomem *reg = chip->base;
./arch/arm/plat-samsung/gpio-samsung.c:350:	con = __raw_readl(chip->base);
./arch/arm/plat-samsung/gpio-samsung.c:435:	void __iomem *base = ourchip->base;
./arch/arm/plat-samsung/gpio-samsung.c:454:	void __iomem *base = ourchip->base;
./arch/arm/plat-samsung/gpio-samsung.c:498:	void __iomem *base = ourchip->base;
./arch/arm/plat-samsung/gpio-samsung.c:502:	if (ourchip->bitmap_gpio_int & BIT(offset))
./arch/arm/plat-samsung/gpio-samsung.c:517:	void __iomem *base = ourchip->base;
./arch/arm/plat-samsung/gpio-samsung.c:560: * the data register at ourchip->base + 0x04.
./arch/arm/plat-samsung/gpio-samsung.c:567:	void __iomem *base = ourchip->base;
./arch/arm/plat-samsung/gpio-samsung.c:589:	void __iomem *base = ourchip->base;
./arch/arm/plat-samsung/gpio-samsung.c:632:	void __iomem *base = ourchip->base;
./arch/arm/plat-samsung/gpio-samsung.c:662:	void __iomem *base = ourchip->base;
./arch/arm/plat-samsung/gpio-samsung.c:682:	val = __raw_readl(ourchip->base + 0x04);
./arch/arm/plat-samsung/gpio-samsung.c:709:	gpn = chip->chip.base;
./arch/arm/plat-samsung/gpio-samsung.c:710:	for (i = 0; i < chip->chip.ngpio; i++, gpn++) {
./arch/arm/plat-samsung/gpio-samsung.c:729:	struct gpio_chip *gc = &chip->chip;
./arch/arm/plat-samsung/gpio-samsung.c:732:	BUG_ON(!chip->base);
./arch/arm/plat-samsung/gpio-samsung.c:736:	spin_lock_init(&chip->lock);
./arch/arm/plat-samsung/gpio-samsung.c:748:	if (chip->pm != NULL) {
./arch/arm/plat-samsung/gpio-samsung.c:749:		if (!chip->pm->save || !chip->pm->resume)
./arch/arm/plat-samsung/gpio-samsung.c:766:	struct gpio_chip *gc = &chip->chip;
./arch/arm/plat-samsung/gpio-samsung.c:770:		if (chip->chip.base >= S3C_GPIO_END)
./arch/arm/plat-samsung/gpio-samsung.c:773:		if (!chip->config)
./arch/arm/plat-samsung/gpio-samsung.c:774:			chip->config = &s3c24xx_gpiocfg_default;
./arch/arm/plat-samsung/gpio-samsung.c:775:		if (!chip->pm)
./arch/arm/plat-samsung/gpio-samsung.c:776:			chip->pm = __gpio_pm(&samsung_gpio_pm_2bit);
./arch/arm/plat-samsung/gpio-samsung.c:777:		if ((base != NULL) && (chip->base == NULL))
./arch/arm/plat-samsung/gpio-samsung.c:778:			chip->base = base + ((i) * 0x10);
./arch/arm/plat-samsung/gpio-samsung.c:796:		chip->chip.direction_input = samsung_gpiolib_2bit_input;
./arch/arm/plat-samsung/gpio-samsung.c:797:		chip->chip.direction_output = samsung_gpiolib_2bit_output;
./arch/arm/plat-samsung/gpio-samsung.c:799:		if (!chip->config)
./arch/arm/plat-samsung/gpio-samsung.c:800:			chip->config = &samsung_gpio_cfgs[7];
./arch/arm/plat-samsung/gpio-samsung.c:801:		if (!chip->pm)
./arch/arm/plat-samsung/gpio-samsung.c:802:			chip->pm = __gpio_pm(&samsung_gpio_pm_2bit);
./arch/arm/plat-samsung/gpio-samsung.c:803:		if ((base != NULL) && (chip->base == NULL))
./arch/arm/plat-samsung/gpio-samsung.c:804:			chip->base = base + ((i) * offset);
./arch/arm/plat-samsung/gpio-samsung.c:832:		chip->chip.direction_input = samsung_gpiolib_4bit_input;
./arch/arm/plat-samsung/gpio-samsung.c:833:		chip->chip.direction_output = samsung_gpiolib_4bit_output;
./arch/arm/plat-samsung/gpio-samsung.c:835:		if (!chip->config)
./arch/arm/plat-samsung/gpio-samsung.c:836:			chip->config = &samsung_gpio_cfgs[2];
./arch/arm/plat-samsung/gpio-samsung.c:837:		if (!chip->pm)
./arch/arm/plat-samsung/gpio-samsung.c:838:			chip->pm = __gpio_pm(&samsung_gpio_pm_4bit);
./arch/arm/plat-samsung/gpio-samsung.c:839:		if ((base != NULL) && (chip->base == NULL))
./arch/arm/plat-samsung/gpio-samsung.c:840:			chip->base = base + ((i) * 0x20);
./arch/arm/plat-samsung/gpio-samsung.c:842:		chip->bitmap_gpio_int = 0;
./arch/arm/plat-samsung/gpio-samsung.c:852:		chip->chip.direction_input = samsung_gpiolib_4bit2_input;
./arch/arm/plat-samsung/gpio-samsung.c:853:		chip->chip.direction_output = samsung_gpiolib_4bit2_output;
./arch/arm/plat-samsung/gpio-samsung.c:855:		if (!chip->config)
./arch/arm/plat-samsung/gpio-samsung.c:856:			chip->config = &samsung_gpio_cfgs[2];
./arch/arm/plat-samsung/gpio-samsung.c:857:		if (!chip->pm)
./arch/arm/plat-samsung/gpio-samsung.c:858:			chip->pm = __gpio_pm(&samsung_gpio_pm_4bit);
./arch/arm/plat-samsung/gpio-samsung.c:868:	return samsung_chip->irq_base + offset;
./arch/arm/plat-samsung/gpio-samsung.c:1214:	offset = pin - chip->chip.base;
./arch/arm/plat-samsung/gpio-samsung.c:1263:		offset = pin - chip->chip.base;
./arch/arm/plat-samsung/gpio-samsung.c:1283:	offset = pin - chip->chip.base;
./arch/arm/plat-samsung/gpio-samsung.c:1301:		offset = pin - chip->chip.base;
./arch/arm/mach-pxa/zeus.c:117:		desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-pxa/cm-x2xx-pci.c:35:	desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-pxa/balloon3.c:509:		if (chip->irq_ack)
./arch/arm/mach-pxa/balloon3.c:510:			chip->irq_ack(d);
./arch/arm/mach-pxa/littleton.c:84:	GPIO17_GPIO,	/* SFRM as chip-select */
./arch/arm/mach-pxa/lpd270.c:132:		desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-pxa/viper.c:289:		desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-pxa/pcm990-baseboard.c:301:		desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-davinci/aemif.c:90: * @cs: chip-select to program the timing values for
./arch/arm/mach-davinci/aemif.c:98: * chip-select.
./arch/arm/mach-davinci/aemif.c:146: * chip-select.
./arch/arm/mach-rpc/ecard.c:537:			desc->irq_data.chip->irq_mask(&desc->irq_data);
./arch/arm/mach-rpc/ecard.c:559:	desc->irq_data.chip->irq_mask(&desc->irq_data);
./arch/arm/mach-rpc/ecard.c:576:	desc->irq_data.chip->irq_unmask(&desc->irq_data);
./arch/arm/mach-w90x900/gpio.c:149:		spin_lock_init(&gpio_chip->gpio_lock);
./arch/arm/mach-w90x900/gpio.c:150:		gpio_chip->regbase = GPIO_BASE + i * GROUPINERV;
./arch/arm/mach-w90x900/gpio.c:151:		gpiochip_add_data(&gpio_chip->chip, gpio_chip);
./arch/arm/mach-omap2/prm_common.c:154:	if (chip->irq_ack)
./arch/arm/mach-omap2/prm_common.c:155:		chip->irq_ack(&desc->irq_data);
./arch/arm/mach-omap2/prm_common.c:156:	if (chip->irq_eoi)
./arch/arm/mach-omap2/prm_common.c:157:		chip->irq_eoi(&desc->irq_data);
./arch/arm/mach-omap2/prm_common.c:158:	chip->irq_unmask(&desc->irq_data);
./arch/arm/common/locomo.c:147:	desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/common/locomo.c:150:	req = locomo_readl(lchip->base + LOCOMO_ICR) & 0x0f00;
./arch/arm/common/locomo.c:156:		irq = lchip->irq_base;
./arch/arm/common/locomo.c:174:	r = locomo_readl(lchip->base + LOCOMO_ICR);
./arch/arm/common/locomo.c:175:	r &= ~(0x0010 << (d->irq - lchip->irq_base));
./arch/arm/common/locomo.c:176:	locomo_writel(r, lchip->base + LOCOMO_ICR);
./arch/arm/common/locomo.c:183:	r = locomo_readl(lchip->base + LOCOMO_ICR);
./arch/arm/common/locomo.c:184:	r |= (0x0010 << (d->irq - lchip->irq_base));
./arch/arm/common/locomo.c:185:	locomo_writel(r, lchip->base + LOCOMO_ICR);
./arch/arm/common/locomo.c:197:	int irq = lchip->irq_base;
./arch/arm/common/locomo.c:202:	irq_set_irq_type(lchip->irq, IRQ_TYPE_EDGE_FALLING);
./arch/arm/common/locomo.c:203:	irq_set_chip_data(lchip->irq, lchip);
./arch/arm/common/locomo.c:204:	irq_set_chained_handler(lchip->irq, locomo_handler);
./arch/arm/common/locomo.c:207:	for ( ; irq <= lchip->irq_base + 3; irq++) {
./arch/arm/common/locomo.c:238:	if (lchip->dev->dma_mask) {
./arch/arm/common/locomo.c:239:		dev->dma_mask = *lchip->dev->dma_mask;
./arch/arm/common/locomo.c:245:	dev->dev.parent  = lchip->dev;
./arch/arm/common/locomo.c:248:	dev->dev.coherent_dma_mask = lchip->dev->coherent_dma_mask;
./arch/arm/common/locomo.c:251:		dev->mapbase = lchip->base + info->offset;
./arch/arm/common/locomo.c:256:	dev->irq[0] = (lchip->irq_base == NO_IRQ) ?
./arch/arm/common/locomo.c:257:			NO_IRQ : lchip->irq_base + info->irq[0];
./arch/arm/common/locomo.c:287:	lchip->saved_state = save;
./arch/arm/common/locomo.c:289:	spin_lock_irqsave(&lchip->lock, flags);
./arch/arm/common/locomo.c:291:	save->LCM_GPO     = locomo_readl(lchip->base + LOCOMO_GPO);	/* GPIO */
./arch/arm/common/locomo.c:292:	locomo_writel(0x00, lchip->base + LOCOMO_GPO);
./arch/arm/common/locomo.c:293:	save->LCM_SPICT   = locomo_readl(lchip->base + LOCOMO_SPI + LOCOMO_SPICT);	/* SPI */
./arch/arm/common/locomo.c:294:	locomo_writel(0x40, lchip->base + LOCOMO_SPI + LOCOMO_SPICT);
./arch/arm/common/locomo.c:295:	save->LCM_GPE     = locomo_readl(lchip->base + LOCOMO_GPE);	/* GPIO */
./arch/arm/common/locomo.c:296:	locomo_writel(0x00, lchip->base + LOCOMO_GPE);
./arch/arm/common/locomo.c:297:	save->LCM_ASD     = locomo_readl(lchip->base + LOCOMO_ASD);	/* ADSTART */
./arch/arm/common/locomo.c:298:	locomo_writel(0x00, lchip->base + LOCOMO_ASD);
./arch/arm/common/locomo.c:299:	save->LCM_SPIMD   = locomo_readl(lchip->base + LOCOMO_SPI + LOCOMO_SPIMD);	/* SPI */
./arch/arm/common/locomo.c:300:	locomo_writel(0x3C14, lchip->base + LOCOMO_SPI + LOCOMO_SPIMD);
./arch/arm/common/locomo.c:302:	locomo_writel(0x00, lchip->base + LOCOMO_PAIF);
./arch/arm/common/locomo.c:303:	locomo_writel(0x00, lchip->base + LOCOMO_DAC);
./arch/arm/common/locomo.c:304:	locomo_writel(0x00, lchip->base + LOCOMO_BACKLIGHT + LOCOMO_TC);
./arch/arm/common/locomo.c:306:	if ((locomo_readl(lchip->base + LOCOMO_LED + LOCOMO_LPT0) & 0x88) && (locomo_readl(lchip->base + LOCOMO_LED + LOCOMO_LPT1) & 0x88))
./arch/arm/common/locomo.c:307:		locomo_writel(0x00, lchip->base + LOCOMO_C32K); 	/* CLK32 off */
./arch/arm/common/locomo.c:310:		locomo_writel(0xc1, lchip->base + LOCOMO_C32K); 	/* CLK32 on */
./arch/arm/common/locomo.c:312:	locomo_writel(0x00, lchip->base + LOCOMO_TADC);		/* 18MHz clock off*/
./arch/arm/common/locomo.c:313:	locomo_writel(0x00, lchip->base + LOCOMO_AUDIO + LOCOMO_ACC);			/* 22MHz/24MHz clock off */
./arch/arm/common/locomo.c:314:	locomo_writel(0x00, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALS);			/* FL */
./arch/arm/common/locomo.c:316:	spin_unlock_irqrestore(&lchip->lock, flags);
./arch/arm/common/locomo.c:328:	save = lchip->saved_state;
./arch/arm/common/locomo.c:332:	spin_lock_irqsave(&lchip->lock, flags);
./arch/arm/common/locomo.c:334:	locomo_writel(save->LCM_GPO, lchip->base + LOCOMO_GPO);
./arch/arm/common/locomo.c:335:	locomo_writel(save->LCM_SPICT, lchip->base + LOCOMO_SPI + LOCOMO_SPICT);
./arch/arm/common/locomo.c:336:	locomo_writel(save->LCM_GPE, lchip->base + LOCOMO_GPE);
./arch/arm/common/locomo.c:337:	locomo_writel(save->LCM_ASD, lchip->base + LOCOMO_ASD);
./arch/arm/common/locomo.c:338:	locomo_writel(save->LCM_SPIMD, lchip->base + LOCOMO_SPI + LOCOMO_SPIMD);
./arch/arm/common/locomo.c:340:	locomo_writel(0x00, lchip->base + LOCOMO_C32K);
./arch/arm/common/locomo.c:341:	locomo_writel(0x90, lchip->base + LOCOMO_TADC);
./arch/arm/common/locomo.c:343:	locomo_writel(0, lchip->base + LOCOMO_KEYBOARD + LOCOMO_KSC);
./arch/arm/common/locomo.c:344:	r = locomo_readl(lchip->base + LOCOMO_KEYBOARD + LOCOMO_KIC);
./arch/arm/common/locomo.c:346:	locomo_writel(r, lchip->base + LOCOMO_KEYBOARD + LOCOMO_KIC);
./arch/arm/common/locomo.c:347:	locomo_writel(0x1, lchip->base + LOCOMO_KEYBOARD + LOCOMO_KCMD);
./arch/arm/common/locomo.c:349:	spin_unlock_irqrestore(&lchip->lock, flags);
./arch/arm/common/locomo.c:351:	lchip->saved_state = NULL;
./arch/arm/common/locomo.c:383:	spin_lock_init(&lchip->lock);
./arch/arm/common/locomo.c:385:	lchip->dev = me;
./arch/arm/common/locomo.c:386:	dev_set_drvdata(lchip->dev, lchip);
./arch/arm/common/locomo.c:388:	lchip->phys = mem->start;
./arch/arm/common/locomo.c:389:	lchip->irq = irq;
./arch/arm/common/locomo.c:390:	lchip->irq_base = (pdata) ? pdata->irq_base : NO_IRQ;
./arch/arm/common/locomo.c:396:	lchip->base = ioremap(mem->start, PAGE_SIZE);
./arch/arm/common/locomo.c:397:	if (!lchip->base) {
./arch/arm/common/locomo.c:403:	locomo_writel(0, lchip->base + LOCOMO_ICR);
./arch/arm/common/locomo.c:405:	locomo_writel(0, lchip->base + LOCOMO_KEYBOARD + LOCOMO_KIC);
./arch/arm/common/locomo.c:408:	locomo_writel(0, lchip->base + LOCOMO_GPO);
./arch/arm/common/locomo.c:410:			, lchip->base + LOCOMO_GPE);
./arch/arm/common/locomo.c:412:			, lchip->base + LOCOMO_GPD);
./arch/arm/common/locomo.c:413:	locomo_writel(0, lchip->base + LOCOMO_GIE);
./arch/arm/common/locomo.c:416:	locomo_writel(0, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALS);
./arch/arm/common/locomo.c:417:	locomo_writel(0, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALD);
./arch/arm/common/locomo.c:420:	locomo_writel(0, lchip->base + LOCOMO_LTINT);
./arch/arm/common/locomo.c:422:	locomo_writel(0, lchip->base + LOCOMO_SPI + LOCOMO_SPIIE);
./arch/arm/common/locomo.c:424:	locomo_writel(6 + 8 + 320 + 30 - 10, lchip->base + LOCOMO_ASD);
./arch/arm/common/locomo.c:425:	r = locomo_readl(lchip->base + LOCOMO_ASD);
./arch/arm/common/locomo.c:427:	locomo_writel(r, lchip->base + LOCOMO_ASD);
./arch/arm/common/locomo.c:429:	locomo_writel(6 + 8 + 320 + 30 - 10 - 128 + 4, lchip->base + LOCOMO_HSD);
./arch/arm/common/locomo.c:430:	r = locomo_readl(lchip->base + LOCOMO_HSD);
./arch/arm/common/locomo.c:432:	locomo_writel(r, lchip->base + LOCOMO_HSD);
./arch/arm/common/locomo.c:434:	locomo_writel(128 / 8, lchip->base + LOCOMO_HSC);
./arch/arm/common/locomo.c:437:	locomo_writel(0x80, lchip->base + LOCOMO_TADC);
./arch/arm/common/locomo.c:440:	r = locomo_readl(lchip->base + LOCOMO_TADC);
./arch/arm/common/locomo.c:442:	locomo_writel(r, lchip->base + LOCOMO_TADC);
./arch/arm/common/locomo.c:446:	r = locomo_readl(lchip->base + LOCOMO_DAC);
./arch/arm/common/locomo.c:448:	locomo_writel(r, lchip->base + LOCOMO_DAC);
./arch/arm/common/locomo.c:450:	r = locomo_readl(lchip->base + LOCOMO_VER);
./arch/arm/common/locomo.c:457:	if (lchip->irq != NO_IRQ && lchip->irq_base != NO_IRQ)
./arch/arm/common/locomo.c:477:	device_for_each_child(lchip->dev, NULL, locomo_remove_child);
./arch/arm/common/locomo.c:479:	if (lchip->irq != NO_IRQ) {
./arch/arm/common/locomo.c:480:		irq_set_chained_handler_and_data(lchip->irq, NULL, NULL);
./arch/arm/common/locomo.c:483:	iounmap(lchip->base);
./arch/arm/common/locomo.c:550:	spin_lock_irqsave(&lchip->lock, flags);
./arch/arm/common/locomo.c:552:	r = locomo_readl(lchip->base + LOCOMO_GPD);
./arch/arm/common/locomo.c:557:	locomo_writel(r, lchip->base + LOCOMO_GPD);
./arch/arm/common/locomo.c:559:	r = locomo_readl(lchip->base + LOCOMO_GPE);
./arch/arm/common/locomo.c:564:	locomo_writel(r, lchip->base + LOCOMO_GPE);
./arch/arm/common/locomo.c:566:	spin_unlock_irqrestore(&lchip->lock, flags);
./arch/arm/common/locomo.c:579:	spin_lock_irqsave(&lchip->lock, flags);
./arch/arm/common/locomo.c:580:	ret = locomo_readl(lchip->base + LOCOMO_GPL);
./arch/arm/common/locomo.c:581:	spin_unlock_irqrestore(&lchip->lock, flags);
./arch/arm/common/locomo.c:597:	spin_lock_irqsave(&lchip->lock, flags);
./arch/arm/common/locomo.c:598:	ret = locomo_readl(lchip->base + LOCOMO_GPO);
./arch/arm/common/locomo.c:599:	spin_unlock_irqrestore(&lchip->lock, flags);
./arch/arm/common/locomo.c:615:	spin_lock_irqsave(&lchip->lock, flags);
./arch/arm/common/locomo.c:617:	r = locomo_readl(lchip->base + LOCOMO_GPO);
./arch/arm/common/locomo.c:622:	locomo_writel(r, lchip->base + LOCOMO_GPO);
./arch/arm/common/locomo.c:624:	spin_unlock_irqrestore(&lchip->lock, flags);
./arch/arm/common/locomo.c:669:	void *mapbase = lchip->base;
./arch/arm/common/locomo.c:672:	spin_lock_irqsave(&lchip->lock, flags);
./arch/arm/common/locomo.c:789:	spin_unlock_irqrestore(&lchip->lock, flags);
./arch/arm/common/locomo.c:807:	spin_lock_irqsave(&lchip->lock, flags);
./arch/arm/common/locomo.c:808:	locomo_writel(bpwf, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALS);
./arch/arm/common/locomo.c:810:	locomo_writel(duty, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALD);
./arch/arm/common/locomo.c:811:	locomo_writel(bpwf | LOCOMO_ALC_EN, lchip->base + LOCOMO_FRONTLIGHT + LOCOMO_ALS);
./arch/arm/common/locomo.c:812:	spin_unlock_irqrestore(&lchip->lock, flags);
./arch/arm/common/sa1111.c:203:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:210:	desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/common/sa1111.c:221:			generic_handle_irq(i + sachip->irq_base);
./arch/arm/common/sa1111.c:225:			generic_handle_irq(i + sachip->irq_base);
./arch/arm/common/sa1111.c:228:	desc->irq_data.chip->irq_unmask(&desc->irq_data);
./arch/arm/common/sa1111.c:231:#define SA1111_IRQMASK_LO(x)	(1 << (x - sachip->irq_base))
./arch/arm/common/sa1111.c:232:#define SA1111_IRQMASK_HI(x)	(1 << (x - sachip->irq_base - 32))
./arch/arm/common/sa1111.c:241:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:252:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:270:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:292:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:316:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:343:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:354:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:372:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:394:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:418:	void __iomem *mapbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:444:	void __iomem *irqbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:451:	request_mem_region(sachip->phys + SA1111_INTC, 512, "irq");
./arch/arm/common/sa1111.c:455:		dev_err(sachip->dev, "unable to allocate %u irqs: %d\n",
./arch/arm/common/sa1111.c:462:	sachip->irq_base = ret;
./arch/arm/common/sa1111.c:484:		irq = sachip->irq_base + i;
./arch/arm/common/sa1111.c:492:		irq = sachip->irq_base + i;
./arch/arm/common/sa1111.c:502:	irq_set_irq_type(sachip->irq, IRQ_TYPE_EDGE_RISING);
./arch/arm/common/sa1111.c:503:	irq_set_chained_handler_and_data(sachip->irq, sa1111_irq_handler,
./arch/arm/common/sa1111.c:506:	dev_info(sachip->dev, "Providing IRQ%u-%u\n",
./arch/arm/common/sa1111.c:507:		sachip->irq_base, sachip->irq_base + SA1111_IRQ_NR - 1);
./arch/arm/common/sa1111.c:530:	spin_lock_irqsave(&sachip->lock, flags);
./arch/arm/common/sa1111.c:532:	clk_enable(sachip->clk);
./arch/arm/common/sa1111.c:537:	r = sa1111_readl(sachip->base + SA1111_SKCR);
./arch/arm/common/sa1111.c:539:	sa1111_writel(r, sachip->base + SA1111_SKCR);
./arch/arm/common/sa1111.c:541:	sa1111_writel(r, sachip->base + SA1111_SKCR);
./arch/arm/common/sa1111.c:553:	sa1111_writel(r, sachip->base + SA1111_SKCR);
./arch/arm/common/sa1111.c:564:	sa1111_writel(0, sachip->base + SA1111_SKPCR);
./arch/arm/common/sa1111.c:566:	spin_unlock_irqrestore(&sachip->lock, flags);
./arch/arm/common/sa1111.c:594:	sa1111_writel(smcr, sachip->base + SA1111_SMCR);
./arch/arm/common/sa1111.c:601:	if (sachip->dev->dma_mask)
./arch/arm/common/sa1111.c:602:		*sachip->dev->dma_mask &= sa1111_dma_mask[drac >> 2];
./arch/arm/common/sa1111.c:604:	sachip->dev->coherent_dma_mask &= sa1111_dma_mask[drac >> 2];
./arch/arm/common/sa1111.c:632:	dev->dev.parent  = sachip->dev;
./arch/arm/common/sa1111.c:635:	dev->res.start   = sachip->phys + info->offset;
./arch/arm/common/sa1111.c:639:	dev->mapbase     = sachip->base + info->offset;
./arch/arm/common/sa1111.c:643:		dev->irq[i] = sachip->irq_base + info->irq[i];
./arch/arm/common/sa1111.c:649:	if (info->dma && sachip->dev->dma_mask) {
./arch/arm/common/sa1111.c:650:		dev->dma_mask = *sachip->dev->dma_mask;
./arch/arm/common/sa1111.c:652:		dev->dev.coherent_dma_mask = sachip->dev->coherent_dma_mask;
./arch/arm/common/sa1111.c:657:		dev_err(sachip->dev, "failed to allocate resource for %s\n",
./arch/arm/common/sa1111.c:703:	sachip->clk = clk_get(me, "SA1111_CLK");
./arch/arm/common/sa1111.c:704:	if (IS_ERR(sachip->clk)) {
./arch/arm/common/sa1111.c:705:		ret = PTR_ERR(sachip->clk);
./arch/arm/common/sa1111.c:709:	ret = clk_prepare(sachip->clk);
./arch/arm/common/sa1111.c:713:	spin_lock_init(&sachip->lock);
./arch/arm/common/sa1111.c:715:	sachip->dev = me;
./arch/arm/common/sa1111.c:716:	dev_set_drvdata(sachip->dev, sachip);
./arch/arm/common/sa1111.c:718:	sachip->pdata = pd;
./arch/arm/common/sa1111.c:719:	sachip->phys = mem->start;
./arch/arm/common/sa1111.c:720:	sachip->irq = irq;
./arch/arm/common/sa1111.c:726:	sachip->base = ioremap(mem->start, PAGE_SIZE * 2);
./arch/arm/common/sa1111.c:727:	if (!sachip->base) {
./arch/arm/common/sa1111.c:735:	id = sa1111_readl(sachip->base + SA1111_SKID);
./arch/arm/common/sa1111.c:754:	if (sachip->irq != NO_IRQ) {
./arch/arm/common/sa1111.c:780:	val = sa1111_readl(sachip->base + SA1111_SKPCR);
./arch/arm/common/sa1111.c:781:	sa1111_writel(val | SKPCR_DCLKEN, sachip->base + SA1111_SKPCR);
./arch/arm/common/sa1111.c:803:	iounmap(sachip->base);
./arch/arm/common/sa1111.c:805:	clk_unprepare(sachip->clk);
./arch/arm/common/sa1111.c:807:	clk_put(sachip->clk);
./arch/arm/common/sa1111.c:824:	void __iomem *irqbase = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:826:	device_for_each_child(sachip->dev, NULL, sa1111_remove_one);
./arch/arm/common/sa1111.c:834:	clk_disable(sachip->clk);
./arch/arm/common/sa1111.c:835:	clk_unprepare(sachip->clk);
./arch/arm/common/sa1111.c:837:	if (sachip->irq != NO_IRQ) {
./arch/arm/common/sa1111.c:838:		irq_set_chained_handler_and_data(sachip->irq, NULL, NULL);
./arch/arm/common/sa1111.c:839:		irq_free_descs(sachip->irq_base, SA1111_IRQ_NR);
./arch/arm/common/sa1111.c:841:		release_mem_region(sachip->phys + SA1111_INTC, 512);
./arch/arm/common/sa1111.c:844:	iounmap(sachip->base);
./arch/arm/common/sa1111.c:845:	clk_put(sachip->clk);
./arch/arm/common/sa1111.c:883:	sachip->saved_state = save;
./arch/arm/common/sa1111.c:885:	spin_lock_irqsave(&sachip->lock, flags);
./arch/arm/common/sa1111.c:890:	base = sachip->base;
./arch/arm/common/sa1111.c:898:	sa1111_writel(0, sachip->base + SA1111_SKPWM0);
./arch/arm/common/sa1111.c:899:	sa1111_writel(0, sachip->base + SA1111_SKPWM1);
./arch/arm/common/sa1111.c:901:	base = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:914:	val = sa1111_readl(sachip->base + SA1111_SKCR);
./arch/arm/common/sa1111.c:915:	sa1111_writel(val | SKCR_SLEEP, sachip->base + SA1111_SKCR);
./arch/arm/common/sa1111.c:917:	clk_disable(sachip->clk);
./arch/arm/common/sa1111.c:919:	spin_unlock_irqrestore(&sachip->lock, flags);
./arch/arm/common/sa1111.c:944:	save = sachip->saved_state;
./arch/arm/common/sa1111.c:952:	id = sa1111_readl(sachip->base + SA1111_SKID);
./arch/arm/common/sa1111.c:974:	spin_lock_irqsave(&sachip->lock, flags);
./arch/arm/common/sa1111.c:976:	sa1111_writel(0, sachip->base + SA1111_INTC + SA1111_INTEN0);
./arch/arm/common/sa1111.c:977:	sa1111_writel(0, sachip->base + SA1111_INTC + SA1111_INTEN1);
./arch/arm/common/sa1111.c:979:	base = sachip->base;
./arch/arm/common/sa1111.c:987:	base = sachip->base + SA1111_INTC;
./arch/arm/common/sa1111.c:997:	spin_unlock_irqrestore(&sachip->lock, flags);
./arch/arm/common/sa1111.c:999:	sachip->saved_state = NULL;
./arch/arm/common/sa1111.c:1031:		kfree(sachip->saved_state);
./arch/arm/common/sa1111.c:1032:		sachip->saved_state = NULL;
./arch/arm/common/sa1111.c:1078:	skcdr = sa1111_readl(sachip->base + SA1111_SKCDR);
./arch/arm/common/sa1111.c:1118:	spin_lock_irqsave(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1120:	val = sa1111_readl(sachip->base + SA1111_SKCR);
./arch/arm/common/sa1111.c:1126:	sa1111_writel(val, sachip->base + SA1111_SKCR);
./arch/arm/common/sa1111.c:1128:	spin_unlock_irqrestore(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1151:	sa1111_writel(div - 1, sachip->base + SA1111_SKAUD);
./arch/arm/common/sa1111.c:1169:	div = sa1111_readl(sachip->base + SA1111_SKAUD) + 1;
./arch/arm/common/sa1111.c:1182:	void __iomem *gpio = sachip->base + SA1111_GPIO;
./arch/arm/common/sa1111.c:1192:	spin_lock_irqsave(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1200:	spin_unlock_irqrestore(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1209:	void __iomem *gpio = sachip->base + SA1111_GPIO;
./arch/arm/common/sa1111.c:1211:	spin_lock_irqsave(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1215:	spin_unlock_irqrestore(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1224:	void __iomem *gpio = sachip->base + SA1111_GPIO;
./arch/arm/common/sa1111.c:1226:	spin_lock_irqsave(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1230:	spin_unlock_irqrestore(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1249:	if (sachip->pdata && sachip->pdata->enable)
./arch/arm/common/sa1111.c:1250:		ret = sachip->pdata->enable(sachip->pdata->data, sadev->devid);
./arch/arm/common/sa1111.c:1253:		spin_lock_irqsave(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1254:		val = sa1111_readl(sachip->base + SA1111_SKPCR);
./arch/arm/common/sa1111.c:1255:		sa1111_writel(val | sadev->skpcr_mask, sachip->base + SA1111_SKPCR);
./arch/arm/common/sa1111.c:1256:		spin_unlock_irqrestore(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1272:	spin_lock_irqsave(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1273:	val = sa1111_readl(sachip->base + SA1111_SKPCR);
./arch/arm/common/sa1111.c:1274:	sa1111_writel(val & ~sadev->skpcr_mask, sachip->base + SA1111_SKPCR);
./arch/arm/common/sa1111.c:1275:	spin_unlock_irqrestore(&sachip->lock, flags);
./arch/arm/common/sa1111.c:1277:	if (sachip->pdata && sachip->pdata->disable)
./arch/arm/common/sa1111.c:1278:		sachip->pdata->disable(sachip->pdata->data, sadev->devid);
./arch/arm/mach-s3c24xx/bast-irq.c:84:	desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-s3c24xx/bast-irq.c:115:		desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-s3c24xx/iotiming-s3c2410.c:72: * is actually being handled as a chip-select.
./arch/arm/plat-orion/gpio.c:53:	return ochip->base + GPIO_OUT_OFF;
./arch/arm/plat-orion/gpio.c:58:	return ochip->base + GPIO_IO_CONF_OFF;
./arch/arm/plat-orion/gpio.c:63:	return ochip->base + GPIO_BLINK_EN_OFF;
./arch/arm/plat-orion/gpio.c:68:	return ochip->base + GPIO_IN_POL_OFF;
./arch/arm/plat-orion/gpio.c:73:	return ochip->base + GPIO_DATA_IN_OFF;
./arch/arm/plat-orion/gpio.c:78:	return ochip->base + GPIO_EDGE_CAUSE_OFF;
./arch/arm/plat-orion/gpio.c:83:	return ochip->base + ochip->mask_offset + GPIO_EDGE_MASK_OFF;
./arch/arm/plat-orion/gpio.c:88:	return ochip->base + ochip->mask_offset + GPIO_LEVEL_MASK_OFF;
./arch/arm/plat-orion/gpio.c:136:	if (pin >= ochip->chip.ngpio)
./arch/arm/plat-orion/gpio.c:139:	if ((mode & GPIO_INPUT_OK) && !test_bit(pin, &ochip->valid_input))
./arch/arm/plat-orion/gpio.c:142:	if ((mode & GPIO_OUTPUT_OK) && !test_bit(pin, &ochip->valid_output))
./arch/arm/plat-orion/gpio.c:174:	spin_lock_irqsave(&ochip->lock, flags);
./arch/arm/plat-orion/gpio.c:176:	spin_unlock_irqrestore(&ochip->lock, flags);
./arch/arm/plat-orion/gpio.c:204:	spin_lock_irqsave(&ochip->lock, flags);
./arch/arm/plat-orion/gpio.c:208:	spin_unlock_irqrestore(&ochip->lock, flags);
./arch/arm/plat-orion/gpio.c:218:	spin_lock_irqsave(&ochip->lock, flags);
./arch/arm/plat-orion/gpio.c:220:	spin_unlock_irqrestore(&ochip->lock, flags);
./arch/arm/plat-orion/gpio.c:227:	return irq_create_mapping(ochip->domain,
./arch/arm/plat-orion/gpio.c:228:				  ochip->secondary_irq_base + pin);
./arch/arm/plat-orion/gpio.c:240:		struct gpio_chip *chip = &ochip->chip;
./arch/arm/plat-orion/gpio.c:242:		if (pin >= chip->base && pin < chip->base + chip->ngpio)
./arch/arm/plat-orion/gpio.c:256:	pin -= ochip->chip.base;
./arch/arm/plat-orion/gpio.c:270:	pin -= ochip->chip.base;
./arch/arm/plat-orion/gpio.c:276:		__set_bit(pin, &ochip->valid_input);
./arch/arm/plat-orion/gpio.c:278:		__clear_bit(pin, &ochip->valid_input);
./arch/arm/plat-orion/gpio.c:281:		__set_bit(pin, &ochip->valid_output);
./arch/arm/plat-orion/gpio.c:283:		__clear_bit(pin, &ochip->valid_output);
./arch/arm/plat-orion/gpio.c:294:	spin_lock_irqsave(&ochip->lock, flags);
./arch/arm/plat-orion/gpio.c:297:	spin_unlock_irqrestore(&ochip->lock, flags);
./arch/arm/plat-orion/gpio.c:359:	pin = d->hwirq - ochip->secondary_irq_base;
./arch/arm/plat-orion/gpio.c:416:	for (i = 0; i < ochip->chip.ngpio; i++) {
./arch/arm/plat-orion/gpio.c:419:		irq = ochip->secondary_irq_base + i;
./arch/arm/plat-orion/gpio.c:456:	for (i = 0; i < chip->ngpio; i++) {
./arch/arm/plat-orion/gpio.c:468:		seq_printf(s, " gpio-%-3d (%-20.20s)", chip->base + i, label);
./arch/arm/plat-orion/gpio.c:542:	ochip->chip.label = kstrdup(gc_label, GFP_KERNEL);
./arch/arm/plat-orion/gpio.c:543:	ochip->chip.request = orion_gpio_request;
./arch/arm/plat-orion/gpio.c:544:	ochip->chip.direction_input = orion_gpio_direction_input;
./arch/arm/plat-orion/gpio.c:545:	ochip->chip.get = orion_gpio_get;
./arch/arm/plat-orion/gpio.c:546:	ochip->chip.direction_output = orion_gpio_direction_output;
./arch/arm/plat-orion/gpio.c:547:	ochip->chip.set = orion_gpio_set;
./arch/arm/plat-orion/gpio.c:548:	ochip->chip.to_irq = orion_gpio_to_irq;
./arch/arm/plat-orion/gpio.c:549:	ochip->chip.base = gpio_base;
./arch/arm/plat-orion/gpio.c:550:	ochip->chip.ngpio = ngpio;
./arch/arm/plat-orion/gpio.c:551:	ochip->chip.can_sleep = 0;
./arch/arm/plat-orion/gpio.c:553:	ochip->chip.of_node = np;
./arch/arm/plat-orion/gpio.c:555:	ochip->chip.dbg_show = orion_gpio_dbg_show;
./arch/arm/plat-orion/gpio.c:557:	spin_lock_init(&ochip->lock);
./arch/arm/plat-orion/gpio.c:558:	ochip->base = (void __iomem *)base;
./arch/arm/plat-orion/gpio.c:559:	ochip->valid_input = 0;
./arch/arm/plat-orion/gpio.c:560:	ochip->valid_output = 0;
./arch/arm/plat-orion/gpio.c:561:	ochip->mask_offset = mask_offset;
./arch/arm/plat-orion/gpio.c:562:	ochip->secondary_irq_base = secondary_irq_base;
./arch/arm/plat-orion/gpio.c:564:	gpiochip_add_data(&ochip->chip, ochip);
./arch/arm/plat-orion/gpio.c:587:				    ochip->base, handle_level_irq);
./arch/arm/plat-orion/gpio.c:590:	ct->regs.mask = ochip->mask_offset + GPIO_LEVEL_MASK_OFF;
./arch/arm/plat-orion/gpio.c:595:	ct->chip.name = ochip->chip.label;
./arch/arm/plat-orion/gpio.c:598:	ct->regs.mask = ochip->mask_offset + GPIO_EDGE_MASK_OFF;
./arch/arm/plat-orion/gpio.c:606:	ct->chip.name = ochip->chip.label;
./arch/arm/plat-orion/gpio.c:612:	ochip->domain = irq_domain_add_legacy(np,
./arch/arm/plat-orion/gpio.c:613:					      ochip->chip.ngpio,
./arch/arm/plat-orion/gpio.c:614:					      ochip->secondary_irq_base,
./arch/arm/plat-orion/gpio.c:615:					      ochip->secondary_irq_base,
./arch/arm/plat-orion/gpio.c:618:	if (!ochip->domain)
./arch/arm/plat-orion/gpio.c:620:		      ochip->chip.label);
./arch/arm/mach-imx/mach-mx35_3ds.c:99:	return !strcmp(chip->label, data);
./arch/arm/mach-imx/mach-mx35_3ds.c:112:				chip->base + GPIO_MC9S08DZ60_LCD_ENABLE;
./arch/arm/mach-imx/3ds_debugboard.c:95:	desc->irq_data.chip->irq_mask(&desc->irq_data);
./arch/arm/mach-imx/3ds_debugboard.c:107:	desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-imx/3ds_debugboard.c:108:	desc->irq_data.chip->irq_unmask(&desc->irq_data);
./arch/arm/mach-imx/mach-mx27ads.c:242:	vchip->owner		= THIS_MODULE;
./arch/arm/mach-imx/mach-mx27ads.c:243:	vchip->label		= "LCD";
./arch/arm/mach-imx/mach-mx27ads.c:244:	vchip->base		= MX27ADS_LCD_GPIO;
./arch/arm/mach-imx/mach-mx27ads.c:245:	vchip->ngpio		= 1;
./arch/arm/mach-imx/mach-mx27ads.c:246:	vchip->direction_output	= vgpio_dir_out;
./arch/arm/mach-imx/mach-mx27ads.c:247:	vchip->set		= vgpio_set;
./arch/arm/mach-imx/mach-qong.c:140:		writeb(cmd, nand_chip->IO_ADDR_W + (1 << 24));
./arch/arm/mach-imx/mach-qong.c:142:		writeb(cmd, nand_chip->IO_ADDR_W + (1 << 23));
./arch/arm/mach-sa1100/neponset.c:178:		desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-sa1100/neponset.c:197:			desc->irq_data.chip->irq_mask(&desc->irq_data);
./arch/arm/mach-sa1100/neponset.c:205:			desc->irq_data.chip->irq_ack(&desc->irq_data);
./arch/arm/mach-sa1100/neponset.c:213:			desc->irq_data.chip->irq_unmask(&desc->irq_data);
./arch/sparc/kernel/leon_pci_grpci2.c:543:		desc->irq_data.chip->irq_eoi(&desc->irq_data);
./arch/sparc/kernel/leon_pci_grpci1.c:391:		desc->irq_data.chip->irq_eoi(&desc->irq_data);
./arch/sparc/kernel/irq_64.c:887:			if (data->chip->irq_set_affinity)
./arch/sparc/kernel/irq_64.c:888:				data->chip->irq_set_affinity(data,
./arch/sparc/kernel/irq_32.c:106: * up via the irq_chip->startup() method which gets invoked by
./arch/sh/boards/mach-x3proto/gpio.c:55:	if (gpio < chip->ngpio)
./arch/sh/boards/mach-x3proto/gpio.c:70:	chip->irq_mask_ack(data);
./arch/sh/boards/mach-x3proto/gpio.c:76:	chip->irq_unmask(data);
./arch/sh/boards/mach-se/7343/irq.c:39:	chip->irq_mask_ack(data);
./arch/sh/boards/mach-se/7343/irq.c:46:	chip->irq_unmask(data);
./arch/sh/boards/mach-se/7722/irq.c:38:	chip->irq_mask_ack(data);
./arch/sh/boards/mach-se/7722/irq.c:45:	chip->irq_unmask(data);
./arch/sh/boards/mach-migor/setup.c:175:		writeb(cmd, chip->IO_ADDR_W + 0x00400000);
./arch/sh/boards/mach-migor/setup.c:177:		writeb(cmd, chip->IO_ADDR_W + 0x00800000);
./arch/sh/boards/mach-migor/setup.c:179:		writeb(cmd, chip->IO_ADDR_W);
./arch/x86/kernel/apic/io_apic.c:1855:	ret = parent->chip->irq_set_affinity(parent, mask, force);
./arch/x86/kernel/apic/io_apic.c:2554:		if (chip->irq_set_affinity)
./arch/x86/kernel/apic/io_apic.c:2555:			chip->irq_set_affinity(idata, mask, false);
./arch/x86/kernel/apic/htirq.c:35:	ret = parent->chip->irq_set_affinity(parent, mask, force);
./arch/x86/kernel/irq.c:482:		if (!irqd_can_move_in_process_context(data) && chip->irq_mask)
./arch/x86/kernel/irq.c:483:			chip->irq_mask(data);
./arch/x86/kernel/irq.c:485:		if (chip->irq_set_affinity) {
./arch/x86/kernel/irq.c:486:			ret = chip->irq_set_affinity(data, affinity, true);
./arch/x86/kernel/irq.c:500:		    !irqd_irq_masked(data) && chip->irq_unmask)
./arch/x86/kernel/irq.c:501:			chip->irq_unmask(data);
./arch/x86/kernel/irq.c:540:			if (chip->irq_retrigger) {
./arch/x86/kernel/irq.c:541:				chip->irq_retrigger(data);
./arch/x86/pci/vmd.c:127:	data->chip->irq_unmask(data);
./arch/x86/pci/vmd.c:134:	data->chip->irq_mask(data);
./arch/x86/platform/uv/uv_irq.c:63:	ret = parent->chip->irq_set_affinity(parent, mask, force);
./arch/x86/kvm/x86.c:3563:	switch (chip->chip_id) {
./arch/x86/kvm/x86.c:3565:		memcpy(&chip->chip.pic,
./arch/x86/kvm/x86.c:3570:		memcpy(&chip->chip.pic,
./arch/x86/kvm/x86.c:3575:		r = kvm_get_ioapic(kvm, &chip->chip.ioapic);
./arch/x86/kvm/x86.c:3589:	switch (chip->chip_id) {
./arch/x86/kvm/x86.c:3593:			&chip->chip.pic,
./arch/x86/kvm/x86.c:3600:			&chip->chip.pic,
./arch/x86/kvm/x86.c:3605:		r = kvm_set_ioapic(kvm, &chip->chip.ioapic);
./arch/mips/rb532/gpio.c:168:	rb532_set_bit(bit, gpio, rb532_gpio_chip->regbase + GPIOILEVEL);
./arch/mips/rb532/gpio.c:177:	rb532_set_bit(bit, gpio, rb532_gpio_chip->regbase + GPIOISTAT);
./arch/mips/rb532/gpio.c:186:       rb532_set_bit(1, gpio, rb532_gpio_chip->regbase + GPIOFUNC);
./arch/mips/rb532/gpio.c:195:	rb532_gpio_chip->regbase = ioremap_nocache(r->start, resource_size(r));
./arch/mips/rb532/gpio.c:197:	if (!rb532_gpio_chip->regbase) {
./arch/mips/rb532/gpio.c:203:	gpiochip_add_data(&rb532_gpio_chip->chip, rb532_gpio_chip);
./arch/mips/rb532/devices.c:164:		writeb(cmd, chip->IO_ADDR_W);
./arch/mips/vr41xx/common/irq.c:78:		if (chip->irq_mask_ack)
./arch/mips/vr41xx/common/irq.c:79:			chip->irq_mask_ack(idata);
./arch/mips/vr41xx/common/irq.c:81:			chip->irq_mask(idata);
./arch/mips/vr41xx/common/irq.c:82:			chip->irq_ack(idata);
./arch/mips/vr41xx/common/irq.c:90:		if (!irqd_irq_disabled(idata) && chip->irq_unmask)
./arch/mips/vr41xx/common/irq.c:91:			chip->irq_unmask(idata);
./arch/mips/pmcs-msp71xx/msp_setup.c:118:	/* No chip-specific reset code, just jump to the ROM reset vector */
./arch/mips/cavium-octeon/octeon-irq.c:921:	data->chip->irq_ack(data);
./arch/mips/cavium-octeon/octeon-irq.c:922:	data->chip->irq_enable(data);
./arch/mips/bcm63xx/gpio.c:46:	if (gpio >= chip->ngpio)
./arch/mips/bcm63xx/gpio.c:73:	if (gpio >= chip->ngpio)
./arch/mips/bcm63xx/gpio.c:95:	if (gpio >= chip->ngpio)
./arch/mips/jz4740/gpio.c:283:	if (!(chip->edge_trigger_both & mask))
./arch/mips/jz4740/gpio.c:286:	reg = chip->base;
./arch/mips/jz4740/gpio.c:288:	value = readl(chip->base + JZ_REG_GPIO_PIN);
./arch/mips/jz4740/gpio.c:303:	flag = readl(chip->base + JZ_REG_GPIO_FLAG);
./arch/mips/jz4740/gpio.c:307:	gpio_irq = chip->irq_base + __fls(flag);
./arch/mips/jz4740/gpio.c:317:	writel(IRQ_TO_BIT(data->irq), chip->base + reg);
./arch/mips/jz4740/gpio.c:351:		uint32_t value = readl(chip->base + JZ_REG_GPIO_PIN);
./arch/mips/jz4740/gpio.c:356:		chip->edge_trigger_both |= IRQ_TO_BIT(irq);
./arch/mips/jz4740/gpio.c:358:		chip->edge_trigger_both &= ~IRQ_TO_BIT(irq);
./arch/mips/jz4740/gpio.c:390:	irq_set_irq_wake(chip->irq, on);
./arch/mips/jz4740/gpio.c:422:	chip->base = ioremap(JZ4740_GPIO_BASE_ADDR + (id * 0x100), 0x100);
./arch/mips/jz4740/gpio.c:424:	chip->irq = JZ4740_IRQ_INTC_GPIO(id);
./arch/mips/jz4740/gpio.c:425:	irq_set_chained_handler_and_data(chip->irq,
./arch/mips/jz4740/gpio.c:428:	gc = irq_alloc_generic_chip(chip->gpio_chip.label, 1, chip->irq_base,
./arch/mips/jz4740/gpio.c:429:		chip->base, handle_level_irq);
./arch/mips/jz4740/gpio.c:431:	gc->wake_enabled = IRQ_MSK(chip->gpio_chip.ngpio);
./arch/mips/jz4740/gpio.c:451:	irq_setup_generic_chip(gc, IRQ_MSK(chip->gpio_chip.ngpio),
./arch/mips/jz4740/gpio.c:454:	gpiochip_add_data(&chip->gpio_chip, chip);
./arch/mips/jz4740/gpio.c:475:	seq_printf(s, "\t%s: %08x\n", name, readl(chip->base + reg));
./arch/mips/jz4740/board-qi_lb60.c:143:	if (chip->page_shift == 12) {
./arch/avr32/mach-at32ap/pio.c:364:			chip->base + i, bank, i,
./arch/avr32/mach-at32ap/pio.c:375:				gpio_to_irq(chip->base + i));
./arch/cris/arch-v10/kernel/shadows.c:20: * to the corresponding external chip-select pin.
./drivers/input/misc/88pm860x_onkey.c:77:	info->i2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;
./drivers/input/misc/88pm860x_onkey.c:83:		dev_err(chip->dev, "Failed to allocate input dev\n");
./drivers/input/misc/88pm860x_onkey.c:96:		dev_err(chip->dev, "Can't register input device: %d\n", ret);
./drivers/input/misc/88pm860x_onkey.c:104:		dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
./drivers/input/misc/88pm860x_onkey.c:121:		chip->wakeup_flag |= 1 << PM8607_IRQ_ONKEY;
./drivers/input/misc/88pm860x_onkey.c:130:		chip->wakeup_flag &= ~(1 << PM8607_IRQ_ONKEY);
./drivers/input/misc/max8925_onkey.c:95:	info->i2c = chip->i2c;
./drivers/input/misc/max8925_onkey.c:110:		dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
./drivers/input/misc/max8925_onkey.c:119:		dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
./drivers/input/misc/max8925_onkey.c:126:		dev_err(chip->dev, "Can't register input device: %d\n", error);
./drivers/input/misc/max8925_onkey.c:143:		chip->wakeup_flag |= 1 << info->irq[0];
./drivers/input/misc/max8925_onkey.c:144:		chip->wakeup_flag |= 1 << info->irq[1];
./drivers/input/misc/max8925_onkey.c:157:		chip->wakeup_flag &= ~(1 << info->irq[0]);
./drivers/input/misc/max8925_onkey.c:158:		chip->wakeup_flag &= ~(1 << info->irq[1]);
./drivers/input/misc/ad714x-spi.c:34:	struct spi_device *spi = to_spi_device(chip->dev);
./drivers/input/misc/ad714x-spi.c:43:	chip->xfer_buf[0] = cpu_to_be16(AD714x_SPI_CMD_PREFIX |
./drivers/input/misc/ad714x-spi.c:45:	xfer[0].tx_buf = &chip->xfer_buf[0];
./drivers/input/misc/ad714x-spi.c:46:	xfer[0].len = sizeof(chip->xfer_buf[0]);
./drivers/input/misc/ad714x-spi.c:49:	xfer[1].rx_buf = &chip->xfer_buf[1];
./drivers/input/misc/ad714x-spi.c:50:	xfer[1].len = sizeof(chip->xfer_buf[1]) * len;
./drivers/input/misc/ad714x-spi.c:55:		dev_err(chip->dev, "SPI read error: %d\n", error);
./drivers/input/misc/ad714x-spi.c:60:		data[i] = be16_to_cpu(chip->xfer_buf[i + 1]);
./drivers/input/misc/ad714x-spi.c:68:	struct spi_device *spi = to_spi_device(chip->dev);
./drivers/input/misc/ad714x-spi.c:71:	chip->xfer_buf[0] = cpu_to_be16(AD714x_SPI_CMD_PREFIX | reg);
./drivers/input/misc/ad714x-spi.c:72:	chip->xfer_buf[1] = cpu_to_be16(data);
./drivers/input/misc/ad714x-spi.c:74:	error = spi_write(spi, (u8 *)chip->xfer_buf,
./drivers/input/misc/ad714x-spi.c:75:			  2 * sizeof(*chip->xfer_buf));
./drivers/input/misc/ad714x-spi.c:77:		dev_err(chip->dev, "SPI write error: %d\n", error);
./drivers/input/misc/max8997_haptic.c:74:	if (chip->mode == MAX8997_EXTERNAL_MODE) {
./drivers/input/misc/max8997_haptic.c:75:		unsigned int duty = chip->pwm_period * chip->level / 100;
./drivers/input/misc/max8997_haptic.c:76:		ret = pwm_config(chip->pwm, duty, chip->pwm_period);
./drivers/input/misc/max8997_haptic.c:82:			if (chip->level <= i * 100 / 64) {
./drivers/input/misc/max8997_haptic.c:87:		switch (chip->internal_mode_pattern) {
./drivers/input/misc/max8997_haptic.c:89:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:93:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:97:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:101:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:115:	value = chip->type << MAX8997_MOTOR_TYPE_SHIFT |
./drivers/input/misc/max8997_haptic.c:116:		chip->enabled << MAX8997_ENABLE_SHIFT |
./drivers/input/misc/max8997_haptic.c:117:		chip->mode << MAX8997_MODE_SHIFT | chip->pwm_divisor;
./drivers/input/misc/max8997_haptic.c:118:	max8997_write_reg(chip->client, MAX8997_HAPTIC_REG_CONF2, value);
./drivers/input/misc/max8997_haptic.c:120:	if (chip->mode == MAX8997_INTERNAL_MODE && chip->enabled) {
./drivers/input/misc/max8997_haptic.c:121:		value = chip->internal_mode_pattern << MAX8997_CYCLE_SHIFT |
./drivers/input/misc/max8997_haptic.c:122:			chip->internal_mode_pattern << MAX8997_SIG_PERIOD_SHIFT |
./drivers/input/misc/max8997_haptic.c:123:			chip->internal_mode_pattern << MAX8997_SIG_DUTY_SHIFT |
./drivers/input/misc/max8997_haptic.c:124:			chip->internal_mode_pattern << MAX8997_PWM_DUTY_SHIFT;
./drivers/input/misc/max8997_haptic.c:125:		max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:128:		switch (chip->internal_mode_pattern) {
./drivers/input/misc/max8997_haptic.c:130:			value = chip->pattern_cycle << 4;
./drivers/input/misc/max8997_haptic.c:131:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:133:			value = chip->pattern_signal_period;
./drivers/input/misc/max8997_haptic.c:134:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:139:			value = chip->pattern_cycle;
./drivers/input/misc/max8997_haptic.c:140:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:142:			value = chip->pattern_signal_period;
./drivers/input/misc/max8997_haptic.c:143:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:148:			value = chip->pattern_cycle << 4;
./drivers/input/misc/max8997_haptic.c:149:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:151:			value = chip->pattern_signal_period;
./drivers/input/misc/max8997_haptic.c:152:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:157:			value = chip->pattern_cycle;
./drivers/input/misc/max8997_haptic.c:158:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:160:			value = chip->pattern_signal_period;
./drivers/input/misc/max8997_haptic.c:161:			max8997_write_reg(chip->client,
./drivers/input/misc/max8997_haptic.c:175:	mutex_lock(&chip->mutex);
./drivers/input/misc/max8997_haptic.c:179:		dev_err(chip->dev, "set_pwm_cycle failed, error: %d\n", error);
./drivers/input/misc/max8997_haptic.c:183:	if (!chip->enabled) {
./drivers/input/misc/max8997_haptic.c:184:		error = regulator_enable(chip->regulator);
./drivers/input/misc/max8997_haptic.c:186:			dev_err(chip->dev, "Failed to enable regulator\n");
./drivers/input/misc/max8997_haptic.c:190:		if (chip->mode == MAX8997_EXTERNAL_MODE) {
./drivers/input/misc/max8997_haptic.c:191:			error = pwm_enable(chip->pwm);
./drivers/input/misc/max8997_haptic.c:193:				dev_err(chip->dev, "Failed to enable PWM\n");
./drivers/input/misc/max8997_haptic.c:194:				regulator_disable(chip->regulator);
./drivers/input/misc/max8997_haptic.c:198:		chip->enabled = true;
./drivers/input/misc/max8997_haptic.c:202:	mutex_unlock(&chip->mutex);
./drivers/input/misc/max8997_haptic.c:207:	mutex_lock(&chip->mutex);
./drivers/input/misc/max8997_haptic.c:209:	if (chip->enabled) {
./drivers/input/misc/max8997_haptic.c:210:		chip->enabled = false;
./drivers/input/misc/max8997_haptic.c:212:		if (chip->mode == MAX8997_EXTERNAL_MODE)
./drivers/input/misc/max8997_haptic.c:213:			pwm_disable(chip->pwm);
./drivers/input/misc/max8997_haptic.c:214:		regulator_disable(chip->regulator);
./drivers/input/misc/max8997_haptic.c:217:	mutex_unlock(&chip->mutex);
./drivers/input/misc/max8997_haptic.c:225:	if (chip->level)
./drivers/input/misc/max8997_haptic.c:236:	chip->level = effect->u.rumble.strong_magnitude;
./drivers/input/misc/max8997_haptic.c:237:	if (!chip->level)
./drivers/input/misc/max8997_haptic.c:238:		chip->level = effect->u.rumble.weak_magnitude;
./drivers/input/misc/max8997_haptic.c:240:	schedule_work(&chip->work);
./drivers/input/misc/max8997_haptic.c:249:	cancel_work_sync(&chip->work);
./drivers/input/misc/max8997_haptic.c:279:	INIT_WORK(&chip->work, max8997_haptic_play_effect_work);
./drivers/input/misc/max8997_haptic.c:280:	mutex_init(&chip->mutex);
./drivers/input/misc/max8997_haptic.c:282:	chip->client = iodev->haptic;
./drivers/input/misc/max8997_haptic.c:283:	chip->dev = &pdev->dev;
./drivers/input/misc/max8997_haptic.c:284:	chip->input_dev = input_dev;
./drivers/input/misc/max8997_haptic.c:285:	chip->pwm_period = haptic_pdata->pwm_period;
./drivers/input/misc/max8997_haptic.c:286:	chip->type = haptic_pdata->type;
./drivers/input/misc/max8997_haptic.c:287:	chip->mode = haptic_pdata->mode;
./drivers/input/misc/max8997_haptic.c:288:	chip->pwm_divisor = haptic_pdata->pwm_divisor;
./drivers/input/misc/max8997_haptic.c:290:	switch (chip->mode) {
./drivers/input/misc/max8997_haptic.c:292:		chip->internal_mode_pattern =
./drivers/input/misc/max8997_haptic.c:294:		chip->pattern_cycle = haptic_pdata->pattern_cycle;
./drivers/input/misc/max8997_haptic.c:295:		chip->pattern_signal_period =
./drivers/input/misc/max8997_haptic.c:300:		chip->pwm = pwm_request(haptic_pdata->pwm_channel_id,
./drivers/input/misc/max8997_haptic.c:302:		if (IS_ERR(chip->pwm)) {
./drivers/input/misc/max8997_haptic.c:303:			error = PTR_ERR(chip->pwm);
./drivers/input/misc/max8997_haptic.c:314:		pwm_apply_args(chip->pwm);
./drivers/input/misc/max8997_haptic.c:319:			"Invalid chip mode specified (%d)\n", chip->mode);
./drivers/input/misc/max8997_haptic.c:324:	chip->regulator = regulator_get(&pdev->dev, "inmotor");
./drivers/input/misc/max8997_haptic.c:325:	if (IS_ERR(chip->regulator)) {
./drivers/input/misc/max8997_haptic.c:326:		error = PTR_ERR(chip->regulator);
./drivers/input/misc/max8997_haptic.c:363:	regulator_put(chip->regulator);
./drivers/input/misc/max8997_haptic.c:365:	if (chip->mode == MAX8997_EXTERNAL_MODE)
./drivers/input/misc/max8997_haptic.c:366:		pwm_free(chip->pwm);
./drivers/input/misc/max8997_haptic.c:378:	input_unregister_device(chip->input_dev);
./drivers/input/misc/max8997_haptic.c:379:	regulator_put(chip->regulator);
./drivers/input/misc/max8997_haptic.c:381:	if (chip->mode == MAX8997_EXTERNAL_MODE)
./drivers/input/misc/max8997_haptic.c:382:		pwm_free(chip->pwm);
./drivers/input/misc/ad714x-i2c.c:31:	struct i2c_client *client = to_i2c_client(chip->dev);
./drivers/input/misc/ad714x-i2c.c:34:	chip->xfer_buf[0] = cpu_to_be16(reg);
./drivers/input/misc/ad714x-i2c.c:35:	chip->xfer_buf[1] = cpu_to_be16(data);
./drivers/input/misc/ad714x-i2c.c:37:	error = i2c_master_send(client, (u8 *)chip->xfer_buf,
./drivers/input/misc/ad714x-i2c.c:38:				2 * sizeof(*chip->xfer_buf));
./drivers/input/misc/ad714x-i2c.c:50:	struct i2c_client *client = to_i2c_client(chip->dev);
./drivers/input/misc/ad714x-i2c.c:54:	chip->xfer_buf[0] = cpu_to_be16(reg);
./drivers/input/misc/ad714x-i2c.c:56:	error = i2c_master_send(client, (u8 *)chip->xfer_buf,
./drivers/input/misc/ad714x-i2c.c:57:				sizeof(*chip->xfer_buf));
./drivers/input/misc/ad714x-i2c.c:59:		error = i2c_master_recv(client, (u8 *)chip->xfer_buf,
./drivers/input/misc/ad714x-i2c.c:60:					len * sizeof(*chip->xfer_buf));
./drivers/input/misc/ad714x-i2c.c:68:		data[i] = be16_to_cpu(chip->xfer_buf[i]);
./drivers/input/keyboard/mcs_touchkey.c:68:	val = i2c_smbus_read_byte_data(client, chip->status_reg);
./drivers/input/keyboard/mcs_touchkey.c:74:	pressed = (val & (1 << chip->pressbit)) >> chip->pressbit;
./drivers/input/keyboard/mcs_touchkey.c:75:	if (chip->press_invert)
./drivers/input/keyboard/mcs_touchkey.c:76:		pressed ^= chip->press_invert;
./drivers/input/keyboard/mcs_touchkey.c:80:		key_val = val & (0xff >> (8 - chip->pressbit));
./drivers/input/keyboard/mcs_touchkey.c:83:		key_val -= chip->baseval;
./drivers/input/keyboard/tca6416-keypad.c:61:	error = chip->io_size > 8 ?
./drivers/input/keyboard/tca6416-keypad.c:62:		i2c_smbus_write_word_data(chip->client, reg << 1, val) :
./drivers/input/keyboard/tca6416-keypad.c:63:		i2c_smbus_write_byte_data(chip->client, reg, val);
./drivers/input/keyboard/tca6416-keypad.c:65:		dev_err(&chip->client->dev,
./drivers/input/keyboard/tca6416-keypad.c:78:	retval = chip->io_size > 8 ?
./drivers/input/keyboard/tca6416-keypad.c:79:		 i2c_smbus_read_word_data(chip->client, reg << 1) :
./drivers/input/keyboard/tca6416-keypad.c:80:		 i2c_smbus_read_byte_data(chip->client, reg);
./drivers/input/keyboard/tca6416-keypad.c:82:		dev_err(&chip->client->dev, "%s failed, reg: %d, error: %d\n",
./drivers/input/keyboard/tca6416-keypad.c:93:	struct input_dev *input = chip->input;
./drivers/input/keyboard/tca6416-keypad.c:101:	reg_val &= chip->pinmask;
./drivers/input/keyboard/tca6416-keypad.c:104:	val = reg_val ^ chip->reg_input;
./drivers/input/keyboard/tca6416-keypad.c:105:	chip->reg_input = reg_val;
./drivers/input/keyboard/tca6416-keypad.c:109:			struct tca6416_button *button = &chip->buttons[pin_index];
./drivers/input/keyboard/tca6416-keypad.c:118:		if (chip->pinmask & (1 << i))
./drivers/input/keyboard/tca6416-keypad.c:141:	schedule_delayed_work(&chip->dwork, msecs_to_jiffies(100));
./drivers/input/keyboard/tca6416-keypad.c:151:	if (chip->use_polling)
./drivers/input/keyboard/tca6416-keypad.c:152:		schedule_delayed_work(&chip->dwork, msecs_to_jiffies(100));
./drivers/input/keyboard/tca6416-keypad.c:154:		enable_irq(chip->irqnum);
./drivers/input/keyboard/tca6416-keypad.c:163:	if (chip->use_polling)
./drivers/input/keyboard/tca6416-keypad.c:164:		cancel_delayed_work_sync(&chip->dwork);
./drivers/input/keyboard/tca6416-keypad.c:166:		disable_irq(chip->irqnum);
./drivers/input/keyboard/tca6416-keypad.c:173:	error = tca6416_read_reg(chip, TCA6416_OUTPUT, &chip->reg_output);
./drivers/input/keyboard/tca6416-keypad.c:177:	error = tca6416_read_reg(chip, TCA6416_DIRECTION, &chip->reg_direction);
./drivers/input/keyboard/tca6416-keypad.c:183:				  chip->reg_direction | chip->pinmask);
./drivers/input/keyboard/tca6416-keypad.c:187:	error = tca6416_read_reg(chip, TCA6416_DIRECTION, &chip->reg_direction);
./drivers/input/keyboard/tca6416-keypad.c:191:	error = tca6416_read_reg(chip, TCA6416_INPUT, &chip->reg_input);
./drivers/input/keyboard/tca6416-keypad.c:195:	chip->reg_input &= chip->pinmask;
./drivers/input/keyboard/tca6416-keypad.c:231:	chip->client = client;
./drivers/input/keyboard/tca6416-keypad.c:232:	chip->input = input;
./drivers/input/keyboard/tca6416-keypad.c:233:	chip->io_size = id->driver_data;
./drivers/input/keyboard/tca6416-keypad.c:234:	chip->pinmask = pdata->pinmask;
./drivers/input/keyboard/tca6416-keypad.c:235:	chip->use_polling = pdata->use_polling;
./drivers/input/keyboard/tca6416-keypad.c:237:	INIT_DELAYED_WORK(&chip->dwork, tca6416_keys_work_func);
./drivers/input/keyboard/tca6416-keypad.c:258:		chip->buttons[i] = pdata->buttons[i];
./drivers/input/keyboard/tca6416-keypad.c:273:	if (!chip->use_polling) {
./drivers/input/keyboard/tca6416-keypad.c:275:			chip->irqnum = gpio_to_irq(client->irq);
./drivers/input/keyboard/tca6416-keypad.c:277:			chip->irqnum = client->irq;
./drivers/input/keyboard/tca6416-keypad.c:279:		error = request_threaded_irq(chip->irqnum, NULL,
./drivers/input/keyboard/tca6416-keypad.c:287:				chip->irqnum, error);
./drivers/input/keyboard/tca6416-keypad.c:290:		disable_irq(chip->irqnum);
./drivers/input/keyboard/tca6416-keypad.c:306:	if (!chip->use_polling) {
./drivers/input/keyboard/tca6416-keypad.c:307:		free_irq(chip->irqnum, chip);
./drivers/input/keyboard/tca6416-keypad.c:308:		enable_irq(chip->irqnum);
./drivers/input/keyboard/tca6416-keypad.c:320:	if (!chip->use_polling) {
./drivers/input/keyboard/tca6416-keypad.c:321:		free_irq(chip->irqnum, chip);
./drivers/input/keyboard/tca6416-keypad.c:322:		enable_irq(chip->irqnum);
./drivers/input/keyboard/tca6416-keypad.c:325:	input_unregister_device(chip->input);
./drivers/input/keyboard/tca6416-keypad.c:338:		enable_irq_wake(chip->irqnum);
./drivers/input/keyboard/tca6416-keypad.c:349:		disable_irq_wake(chip->irqnum);
./drivers/input/touchscreen/bu21013_ts.c:230:			if (data->chip->x_flip)
./drivers/input/touchscreen/bu21013_ts.c:231:				pos_x[i] = data->chip->touch_x_max - pos_x[i];
./drivers/input/touchscreen/bu21013_ts.c:232:			if (data->chip->y_flip)
./drivers/input/touchscreen/bu21013_ts.c:233:				pos_y[i] = data->chip->touch_y_max - pos_y[i];
./drivers/input/touchscreen/bu21013_ts.c:269:		data->intr_pin = gpio_get_value(data->chip->touch_pin);
./drivers/input/touchscreen/bu21013_ts.c:335:	if (data->chip->ext_clk)
./drivers/input/touchscreen/bu21013_ts.c:439:	error = gpio_direction_output(bu21013_data->chip->cs_pin, 0);
./drivers/input/touchscreen/bu21013_ts.c:445:		gpio_set_value(bu21013_data->chip->cs_pin, 0);
./drivers/input/touchscreen/bu21013_ts.c:447:	gpio_free(bu21013_data->chip->cs_pin);
./drivers/input/touchscreen/pixcir_i2c_ts.c:72:	i = chip->has_hw_ids ? 1 : 0;
./drivers/input/touchscreen/pixcir_i2c_ts.c:104:		if (chip->has_hw_ids) {
./drivers/input/touchscreen/pixcir_i2c_ts.c:127:	if (!ts->chip->has_hw_ids) {
./drivers/input/touchscreen/pixcir_i2c_ts.c:140:		if (chip->has_hw_ids) {
./drivers/input/touchscreen/pixcir_i2c_ts.c:492:	if (!tsdata->chip->max_fingers) {
./drivers/input/touchscreen/pixcir_i2c_ts.c:526:	tsdata->max_fingers = tsdata->chip->max_fingers;
./drivers/input/touchscreen/88pm860x-ts.c:74:			dev_dbg(chip->dev, "z1:%d, z2:%d, rt:%d\n",
./drivers/input/touchscreen/88pm860x-ts.c:81:		dev_dbg(chip->dev, "pen down at [%d, %d].\n", x, y);
./drivers/input/touchscreen/88pm860x-ts.c:85:		dev_dbg(chip->dev, "pen release\n");
./drivers/input/touchscreen/88pm860x-ts.c:124:	struct i2c_client *i2c = (chip->id == CHIP_PM8607) ? chip->client \
./drivers/input/touchscreen/88pm860x-ts.c:125:				 : chip->companion;
./drivers/input/touchscreen/88pm860x-ts.c:178:	struct i2c_client *i2c = (chip->id == CHIP_PM8607) ? chip->client \
./drivers/input/touchscreen/88pm860x-ts.c:179:				 : chip->companion;
./drivers/input/touchscreen/88pm860x-ts.c:284:		dev_err(chip->dev, "Failed to register touch!\n");
./drivers/macintosh/macio_asic.c:254:	if (dev->bus->chip->type != macio_gatwick)
./drivers/macintosh/macio_asic.c:373:	dev->bus = &chip->lbus;
./drivers/macintosh/macio_asic.c:394:	dev->ofdev.dev.archdata = chip->lbus.pdev->dev.archdata;
./drivers/macintosh/macio_asic.c:403:	if (np == chip->of_node) {
./drivers/macintosh/macio_asic.c:405:			     chip->lbus.index,
./drivers/macintosh/macio_asic.c:407:			(unsigned int)pci_resource_start(chip->lbus.pdev, 0),
./drivers/macintosh/macio_asic.c:415:			     chip->lbus.index,
./drivers/macintosh/macio_asic.c:464:	if (chip->lbus.pdev) {
./drivers/macintosh/macio_asic.c:465:		parent = &chip->lbus.pdev->dev;
./drivers/macintosh/macio_asic.c:466:		root_res = &chip->lbus.pdev->resource[0];
./drivers/macintosh/macio_asic.c:469:	pnode = of_node_get(chip->of_node);
./drivers/macintosh/macio_asic.c:712:	if (chip->lbus.pdev == NULL) {
./drivers/macintosh/macio_asic.c:713:		chip->lbus.pdev = pdev;
./drivers/macintosh/macio_asic.c:714:		chip->lbus.chip = chip;
./drivers/macintosh/macio_asic.c:715:		pci_set_drvdata(pdev, &chip->lbus);
./drivers/macintosh/macio_asic.c:720:		chip->name);
./drivers/macintosh/macio_asic.c:728:	if (chip->type == macio_gatwick || chip->type == macio_ohareII)
./drivers/iio/accel/mma8452.c:489:	val = i2c_smbus_read_byte_data(data->client, chip->ev_cfg);
./drivers/iio/accel/mma8452.c:505:	val = i2c_smbus_read_byte_data(data->client, chip->ev_cfg);
./drivers/iio/accel/mma8452.c:510:		val |= BIT(idx_x + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:511:		val |= BIT(idx_y + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:512:		val |= BIT(idx_z + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:515:		val &= ~BIT(idx_x + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:516:		val &= ~BIT(idx_y + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:517:		val &= ~BIT(idx_z + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:521:	val = mma8452_change_config(data, chip->ev_cfg, val);
./drivers/iio/accel/mma8452.c:734:				    chip->ev_cfg_chan_shift));
./drivers/iio/accel/mma8452.c:758:		val = i2c_smbus_read_byte_data(data->client, chip->ev_cfg);
./drivers/iio/accel/mma8452.c:764:				val &= ~BIT(idx_x + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:765:				val &= ~BIT(idx_y + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:766:				val &= ~BIT(idx_z + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:769:			val |= BIT(chan->scan_index + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:774:			val &= ~BIT(chan->scan_index + chip->ev_cfg_chan_shift);
./drivers/iio/accel/mma8452.c:777:		val |= chip->ev_cfg_ele;
./drivers/iio/accel/mma8452.c:779:		return mma8452_change_config(data, chip->ev_cfg, val);
./drivers/iio/accel/mma8452.c:845:	     chip->ev_src == MMA8452_TRANSIENT_SRC) ||
./drivers/iio/accel/mma8452.c:847:	     chip->ev_src == MMA8452_FF_MT_SRC)) {
./drivers/iio/light/cm3232.c:89:	struct i2c_client *client = chip->client;
./drivers/iio/light/cm3232.c:92:	chip->als_info = &cm3232_als_info_default;
./drivers/iio/light/cm3232.c:97:		dev_err(&chip->client->dev, "Error reading addr_id\n");
./drivers/iio/light/cm3232.c:101:	if ((ret & 0xFF) != chip->als_info->hw_id)
./drivers/iio/light/cm3232.c:105:	chip->regs_cmd = CM3232_CMD_ALS_DISABLE | CM3232_CMD_ALS_RESET;
./drivers/iio/light/cm3232.c:107:					chip->regs_cmd);
./drivers/iio/light/cm3232.c:109:		dev_err(&chip->client->dev, "Error writing reg_cmd\n");
./drivers/iio/light/cm3232.c:114:	chip->regs_cmd = chip->als_info->regs_cmd_default;
./drivers/iio/light/cm3232.c:118:					chip->regs_cmd);
./drivers/iio/light/cm3232.c:120:		dev_err(&chip->client->dev, "Error writing reg_cmd\n");
./drivers/iio/light/cm3232.c:140:	als_it = chip->regs_cmd;
./drivers/iio/light/cm3232.c:166:	struct i2c_client *client = chip->client;
./drivers/iio/light/cm3232.c:178:			cmd = chip->regs_cmd & ~CM3232_CMD_ALS_IT_MASK;
./drivers/iio/light/cm3232.c:185:			chip->regs_cmd = cmd;
./drivers/iio/light/cm3232.c:203:	struct i2c_client *client = chip->client;
./drivers/iio/light/cm3232.c:204:	struct cm3232_als_info *als_info = chip->als_info;
./drivers/iio/light/cm3232.c:225:	chip->regs_als = (u16)ret;
./drivers/iio/light/cm3232.c:226:	lux *= chip->regs_als;
./drivers/iio/light/cm3232.c:242:	struct cm3232_als_info *als_info = chip->als_info;
./drivers/iio/light/cm3232.c:267:	struct cm3232_als_info *als_info = chip->als_info;
./drivers/iio/light/cm3232.c:344:	chip->client = client;
./drivers/iio/light/cm3232.c:386:	struct i2c_client *client = chip->client;
./drivers/iio/light/cm3232.c:389:	chip->regs_cmd |= CM3232_CMD_ALS_DISABLE;
./drivers/iio/light/cm3232.c:391:					chip->regs_cmd);
./drivers/iio/light/cm3232.c:400:	struct i2c_client *client = chip->client;
./drivers/iio/light/cm3232.c:403:	chip->regs_cmd &= ~CM3232_CMD_ALS_DISABLE;
./drivers/iio/light/cm3232.c:405:					chip->regs_cmd | CM3232_CMD_ALS_RESET);
./drivers/iio/light/tsl2563.c:142:	struct i2c_client *client = chip->client;
./drivers/iio/light/tsl2563.c:156:	struct i2c_client *client = chip->client;
./drivers/iio/light/tsl2563.c:170:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/iio/light/tsl2563.c:172:			chip->gainlevel->gaintime);
./drivers/iio/light/tsl2563.c:175:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/iio/light/tsl2563.c:177:			chip->high_thres & 0xFF);
./drivers/iio/light/tsl2563.c:180:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/iio/light/tsl2563.c:182:			(chip->high_thres >> 8) & 0xFF);
./drivers/iio/light/tsl2563.c:185:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/iio/light/tsl2563.c:187:			chip->low_thres & 0xFF);
./drivers/iio/light/tsl2563.c:190:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/iio/light/tsl2563.c:192:			(chip->low_thres >> 8) & 0xFF);
./drivers/iio/light/tsl2563.c:225:	struct i2c_client *client = chip->client;
./drivers/iio/light/tsl2563.c:275:	switch (chip->gainlevel->gaintime & TSL2563_TIMING_MASK) {
./drivers/iio/light/tsl2563.c:294:	struct i2c_client *client = chip->client;
./drivers/iio/light/tsl2563.c:296:	if (adc > chip->gainlevel->max || adc < chip->gainlevel->min) {
./drivers/iio/light/tsl2563.c:298:		(adc > chip->gainlevel->max) ?
./drivers/iio/light/tsl2563.c:299:			chip->gainlevel++ : chip->gainlevel--;
./drivers/iio/light/tsl2563.c:303:					  chip->gainlevel->gaintime);
./drivers/iio/light/tsl2563.c:315:	struct i2c_client *client = chip->client;
./drivers/iio/light/tsl2563.c:320:	if (chip->suspended)
./drivers/iio/light/tsl2563.c:323:	if (!chip->int_enabled) {
./drivers/iio/light/tsl2563.c:324:		cancel_delayed_work(&chip->poweroff_work);
./drivers/iio/light/tsl2563.c:353:	chip->data0 = tsl2563_normalize_adc(adc0, chip->gainlevel->gaintime);
./drivers/iio/light/tsl2563.c:354:	chip->data1 = tsl2563_normalize_adc(adc1, chip->gainlevel->gaintime);
./drivers/iio/light/tsl2563.c:356:	if (!chip->int_enabled)
./drivers/iio/light/tsl2563.c:357:		schedule_delayed_work(&chip->poweroff_work, 5 * HZ);
./drivers/iio/light/tsl2563.c:466:		chip->calib0 = tsl2563_calib_from_sysfs(val);
./drivers/iio/light/tsl2563.c:468:		chip->calib1 = tsl2563_calib_from_sysfs(val);
./drivers/iio/light/tsl2563.c:485:	mutex_lock(&chip->lock);
./drivers/iio/light/tsl2563.c:494:			calib0 = tsl2563_calib_adc(chip->data0, chip->calib0) *
./drivers/iio/light/tsl2563.c:495:				chip->cover_comp_gain;
./drivers/iio/light/tsl2563.c:496:			calib1 = tsl2563_calib_adc(chip->data1, chip->calib1) *
./drivers/iio/light/tsl2563.c:497:				chip->cover_comp_gain;
./drivers/iio/light/tsl2563.c:506:				*val = chip->data0;
./drivers/iio/light/tsl2563.c:508:				*val = chip->data1;
./drivers/iio/light/tsl2563.c:518:			*val = tsl2563_calib_to_sysfs(chip->calib0);
./drivers/iio/light/tsl2563.c:520:			*val = tsl2563_calib_to_sysfs(chip->calib1);
./drivers/iio/light/tsl2563.c:529:	mutex_unlock(&chip->lock);
./drivers/iio/light/tsl2563.c:579:		*val = chip->high_thres;
./drivers/iio/light/tsl2563.c:582:		*val = chip->low_thres;
./drivers/iio/light/tsl2563.c:604:	mutex_lock(&chip->lock);
./drivers/iio/light/tsl2563.c:605:	ret = i2c_smbus_write_byte_data(chip->client, TSL2563_CMD | address,
./drivers/iio/light/tsl2563.c:609:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/iio/light/tsl2563.c:613:		chip->high_thres = val;
./drivers/iio/light/tsl2563.c:615:		chip->low_thres = val;
./drivers/iio/light/tsl2563.c:618:	mutex_unlock(&chip->lock);
./drivers/iio/light/tsl2563.c:636:	i2c_smbus_write_byte(chip->client, TSL2563_CMD | TSL2563_CLEARINT);
./drivers/iio/light/tsl2563.c:647:	mutex_lock(&chip->lock);
./drivers/iio/light/tsl2563.c:648:	if (state && !(chip->intr & 0x30)) {
./drivers/iio/light/tsl2563.c:649:		chip->intr &= ~0x30;
./drivers/iio/light/tsl2563.c:650:		chip->intr |= 0x10;
./drivers/iio/light/tsl2563.c:652:		cancel_delayed_work(&chip->poweroff_work);
./drivers/iio/light/tsl2563.c:661:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/iio/light/tsl2563.c:663:						chip->intr);
./drivers/iio/light/tsl2563.c:664:		chip->int_enabled = true;
./drivers/iio/light/tsl2563.c:667:	if (!state && (chip->intr & 0x30)) {
./drivers/iio/light/tsl2563.c:668:		chip->intr &= ~0x30;
./drivers/iio/light/tsl2563.c:669:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/iio/light/tsl2563.c:671:						chip->intr);
./drivers/iio/light/tsl2563.c:672:		chip->int_enabled = false;
./drivers/iio/light/tsl2563.c:674:		schedule_delayed_work(&chip->poweroff_work, 5 * HZ);
./drivers/iio/light/tsl2563.c:677:	mutex_unlock(&chip->lock);
./drivers/iio/light/tsl2563.c:689:	mutex_lock(&chip->lock);
./drivers/iio/light/tsl2563.c:690:	ret = i2c_smbus_read_byte_data(chip->client,
./drivers/iio/light/tsl2563.c:692:	mutex_unlock(&chip->lock);
./drivers/iio/light/tsl2563.c:732:	chip->client = client;
./drivers/iio/light/tsl2563.c:746:	mutex_init(&chip->lock);
./drivers/iio/light/tsl2563.c:749:	chip->low_thres = 0x0;
./drivers/iio/light/tsl2563.c:750:	chip->high_thres = 0xffff;
./drivers/iio/light/tsl2563.c:751:	chip->gainlevel = tsl2563_gainlevel_table;
./drivers/iio/light/tsl2563.c:752:	chip->intr = TSL2563_INT_PERSIST(4);
./drivers/iio/light/tsl2563.c:753:	chip->calib0 = tsl2563_calib_from_sysfs(CALIB_BASE_SYSFS);
./drivers/iio/light/tsl2563.c:754:	chip->calib1 = tsl2563_calib_from_sysfs(CALIB_BASE_SYSFS);
./drivers/iio/light/tsl2563.c:757:		chip->cover_comp_gain = pdata->cover_comp_gain;
./drivers/iio/light/tsl2563.c:760:				     &chip->cover_comp_gain);
./drivers/iio/light/tsl2563.c:762:		chip->cover_comp_gain = 1;
./drivers/iio/light/tsl2563.c:795:	INIT_DELAYED_WORK(&chip->poweroff_work, tsl2563_poweroff_work);
./drivers/iio/light/tsl2563.c:798:	schedule_delayed_work(&chip->poweroff_work, 5 * HZ);
./drivers/iio/light/tsl2563.c:809:	cancel_delayed_work_sync(&chip->poweroff_work);
./drivers/iio/light/tsl2563.c:819:	if (!chip->int_enabled)
./drivers/iio/light/tsl2563.c:820:		cancel_delayed_work(&chip->poweroff_work);
./drivers/iio/light/tsl2563.c:822:	chip->intr &= ~0x30;
./drivers/iio/light/tsl2563.c:823:	i2c_smbus_write_byte_data(chip->client, TSL2563_CMD | TSL2563_REG_INT,
./drivers/iio/light/tsl2563.c:824:				  chip->intr);
./drivers/iio/light/tsl2563.c:837:	mutex_lock(&chip->lock);
./drivers/iio/light/tsl2563.c:843:	chip->suspended = true;
./drivers/iio/light/tsl2563.c:846:	mutex_unlock(&chip->lock);
./drivers/iio/light/tsl2563.c:855:	mutex_lock(&chip->lock);
./drivers/iio/light/tsl2563.c:865:	chip->suspended = false;
./drivers/iio/light/tsl2563.c:868:	mutex_unlock(&chip->lock);
./drivers/iio/adc/rockchip_saradc.c:364:		.name	= "rockchip-saradc",
./drivers/iio/adc/ina2xx-adc.c:152:		ret = regmap_read(chip->regmap, chan->address, &regval);
./drivers/iio/adc/ina2xx-adc.c:164:		*val = chip->avg;
./drivers/iio/adc/ina2xx-adc.c:170:			*val2 = chip->int_time_vshunt;
./drivers/iio/adc/ina2xx-adc.c:172:			*val2 = chip->int_time_vbus;
./drivers/iio/adc/ina2xx-adc.c:189:			*val2 = chip->config->shunt_div;
./drivers/iio/adc/ina2xx-adc.c:195:			*val = chip->config->bus_voltage_lsb;
./drivers/iio/adc/ina2xx-adc.c:196:			*val2 = 1000 << chip->config->bus_voltage_shift;
./drivers/iio/adc/ina2xx-adc.c:201:			*val = chip->config->power_lsb;
./drivers/iio/adc/ina2xx-adc.c:234:	chip->avg = ina226_avg_tab[bits];
./drivers/iio/adc/ina2xx-adc.c:257:	chip->int_time_vbus = ina226_conv_time_tab[bits];
./drivers/iio/adc/ina2xx-adc.c:276:	chip->int_time_vshunt = ina226_conv_time_tab[bits];
./drivers/iio/adc/ina2xx-adc.c:295:	mutex_lock(&chip->state_lock);
./drivers/iio/adc/ina2xx-adc.c:297:	ret = regmap_read(chip->regmap, INA2XX_CONFIG, &config);
./drivers/iio/adc/ina2xx-adc.c:320:		ret = regmap_write(chip->regmap, INA2XX_CONFIG, tmp);
./drivers/iio/adc/ina2xx-adc.c:322:	mutex_unlock(&chip->state_lock);
./drivers/iio/adc/ina2xx-adc.c:333:	return sprintf(buf, "%d\n", chip->allow_async_readout);
./drivers/iio/adc/ina2xx-adc.c:348:	chip->allow_async_readout = val;
./drivers/iio/adc/ina2xx-adc.c:364:	u16 regval = DIV_ROUND_CLOSEST(chip->config->calibration_factor,
./drivers/iio/adc/ina2xx-adc.c:365:				   chip->shunt_resistor);
./drivers/iio/adc/ina2xx-adc.c:367:	return regmap_write(chip->regmap, INA2XX_CALIBRATION, regval);
./drivers/iio/adc/ina2xx-adc.c:372:	if (val <= 0 || val > chip->config->calibration_factor)
./drivers/iio/adc/ina2xx-adc.c:375:	chip->shunt_resistor = val;
./drivers/iio/adc/ina2xx-adc.c:386:	return sprintf(buf, "%d\n", chip->shunt_resistor);
./drivers/iio/adc/ina2xx-adc.c:480:	if (!chip->allow_async_readout)
./drivers/iio/adc/ina2xx-adc.c:482:			ret = regmap_read(chip->regmap, INA226_ALERT_MASK,
./drivers/iio/adc/ina2xx-adc.c:499:		ret = regmap_read(chip->regmap,
./drivers/iio/adc/ina2xx-adc.c:512:	chip->prev_ns = time_a;
./drivers/iio/adc/ina2xx-adc.c:528:	if (!chip->allow_async_readout)
./drivers/iio/adc/ina2xx-adc.c:551:		1000000 / sampling_us, chip->avg);
./drivers/iio/adc/ina2xx-adc.c:555:		chip->allow_async_readout);
./drivers/iio/adc/ina2xx-adc.c:557:	chip->prev_ns = iio_get_time_ns();
./drivers/iio/adc/ina2xx-adc.c:559:	chip->task = kthread_run(ina2xx_capture_thread, (void *)indio_dev,
./drivers/iio/adc/ina2xx-adc.c:563:	return PTR_ERR_OR_ZERO(chip->task);
./drivers/iio/adc/ina2xx-adc.c:570:	if (chip->task) {
./drivers/iio/adc/ina2xx-adc.c:571:		kthread_stop(chip->task);
./drivers/iio/adc/ina2xx-adc.c:572:		chip->task = NULL;
./drivers/iio/adc/ina2xx-adc.c:589:		return regmap_write(chip->regmap, reg, writeval);
./drivers/iio/adc/ina2xx-adc.c:591:	return regmap_read(chip->regmap, reg, readval);
./drivers/iio/adc/ina2xx-adc.c:627:	int ret = regmap_write(chip->regmap, INA2XX_CONFIG, config);
./drivers/iio/adc/ina2xx-adc.c:652:	chip->regmap = devm_regmap_init_i2c(client, &ina2xx_regmap_config);
./drivers/iio/adc/ina2xx-adc.c:653:	if (IS_ERR(chip->regmap)) {
./drivers/iio/adc/ina2xx-adc.c:655:		return PTR_ERR(chip->regmap);
./drivers/iio/adc/ina2xx-adc.c:658:	chip->config = &ina2xx_config[id->driver_data];
./drivers/iio/adc/ina2xx-adc.c:660:	mutex_init(&chip->state_lock);
./drivers/iio/adc/ina2xx-adc.c:678:	val = chip->config->config_default;
./drivers/iio/adc/ina2xx-adc.c:717:	return regmap_update_bits(chip->regmap, INA2XX_CONFIG,
./drivers/iio/adc/ad7291.c:92:	struct i2c_client *client = chip->client;
./drivers/iio/adc/ad7291.c:108:	return i2c_smbus_write_word_swapped(chip->client, reg, data);
./drivers/iio/adc/ad7291.c:129:	command = chip->command | AD7291_ALERT_CLEAR;
./drivers/iio/adc/ad7291.c:132:	command = chip->command & ~AD7291_ALERT_CLEAR;
./drivers/iio/adc/ad7291.c:261:		return !!(chip->c_mask & BIT(15 - chan->channel));
./drivers/iio/adc/ad7291.c:282:	mutex_lock(&chip->state_lock);
./drivers/iio/adc/ad7291.c:283:	regval = chip->command;
./drivers/iio/adc/ad7291.c:294:		if ((!state) && (chip->c_mask & mask))
./drivers/iio/adc/ad7291.c:295:			chip->c_mask &= ~mask;
./drivers/iio/adc/ad7291.c:296:		else if (state && (!(chip->c_mask & mask)))
./drivers/iio/adc/ad7291.c:297:			chip->c_mask |= mask;
./drivers/iio/adc/ad7291.c:302:		regval |= chip->c_mask;
./drivers/iio/adc/ad7291.c:303:		if (chip->c_mask) /* Enable autocycle? */
./drivers/iio/adc/ad7291.c:310:		chip->command = regval;
./drivers/iio/adc/ad7291.c:317:	mutex_unlock(&chip->state_lock);
./drivers/iio/adc/ad7291.c:335:			mutex_lock(&chip->state_lock);
./drivers/iio/adc/ad7291.c:337:			if (chip->command & AD7291_AUTOCYCLE) {
./drivers/iio/adc/ad7291.c:338:				mutex_unlock(&chip->state_lock);
./drivers/iio/adc/ad7291.c:342:			regval = chip->command & (~AD7291_VOLTAGE_MASK);
./drivers/iio/adc/ad7291.c:346:				mutex_unlock(&chip->state_lock);
./drivers/iio/adc/ad7291.c:350:			ret = i2c_smbus_read_word_swapped(chip->client,
./drivers/iio/adc/ad7291.c:353:				mutex_unlock(&chip->state_lock);
./drivers/iio/adc/ad7291.c:357:			mutex_unlock(&chip->state_lock);
./drivers/iio/adc/ad7291.c:361:			ret = i2c_smbus_read_word_swapped(chip->client,
./drivers/iio/adc/ad7291.c:371:		ret = i2c_smbus_read_word_swapped(chip->client,
./drivers/iio/adc/ad7291.c:380:			if (chip->reg) {
./drivers/iio/adc/ad7291.c:383:				vref = regulator_get_voltage(chip->reg);
./drivers/iio/adc/ad7291.c:481:		chip->reg = devm_regulator_get(&client->dev, "vref");
./drivers/iio/adc/ad7291.c:482:		if (IS_ERR(chip->reg))
./drivers/iio/adc/ad7291.c:483:			return PTR_ERR(chip->reg);
./drivers/iio/adc/ad7291.c:485:		ret = regulator_enable(chip->reg);
./drivers/iio/adc/ad7291.c:490:	mutex_init(&chip->state_lock);
./drivers/iio/adc/ad7291.c:494:	chip->client = client;
./drivers/iio/adc/ad7291.c:496:	chip->command = AD7291_NOISE_DELAY |
./drivers/iio/adc/ad7291.c:501:		chip->command |= AD7291_EXT_REF;
./drivers/iio/adc/ad7291.c:517:	ret = ad7291_i2c_write(chip, AD7291_COMMAND, chip->command);
./drivers/iio/adc/ad7291.c:544:	if (chip->reg)
./drivers/iio/adc/ad7291.c:545:		regulator_disable(chip->reg);
./drivers/iio/adc/ad7291.c:560:	if (chip->reg)
./drivers/iio/adc/ad7291.c:561:		regulator_disable(chip->reg);
./drivers/remoteproc/da8xx_remoteproc.c:45: * @ack_fxn: chip-specific ack function for ack'ing irq
./drivers/remoteproc/da8xx_remoteproc.c:250:	drproc->ack_fxn = irq_data->chip->irq_ack;
./drivers/clk/clk-cdce925.c:211:		regmap_update_bits(data->chip->regmap,
./drivers/clk/clk-cdce925.c:240:			regmap_write(data->chip->regmap,
./drivers/clk/clk-cdce925.c:243:		regmap_update_bits(data->chip->regmap,
./drivers/clk/clk-cdce925.c:255:	regmap_update_bits(data->chip->regmap,
./drivers/clk/clk-cdce925.c:272:		regmap_update_bits(data->chip->regmap,
./drivers/clk/clk-cdce925.c:275:		regmap_write(data->chip->regmap, 0x03, pdiv & 0xFF);
./drivers/clk/clk-cdce925.c:278:		regmap_update_bits(data->chip->regmap, 0x16, 0x7F, pdiv);
./drivers/clk/clk-cdce925.c:281:		regmap_update_bits(data->chip->regmap, 0x17, 0x7F, pdiv);
./drivers/clk/clk-cdce925.c:284:		regmap_update_bits(data->chip->regmap, 0x26, 0x7F, pdiv);
./drivers/clk/clk-cdce925.c:287:		regmap_update_bits(data->chip->regmap, 0x27, 0x7F, pdiv);
./drivers/clk/clk-cdce925.c:296:		regmap_update_bits(data->chip->regmap,
./drivers/clk/clk-cdce925.c:301:		regmap_update_bits(data->chip->regmap, 0x14, 0x03, 0x03);
./drivers/clk/clk-cdce925.c:305:		regmap_update_bits(data->chip->regmap, 0x24, 0x03, 0x03);
./drivers/mmc/host/cb710-mmc.c:701:	pci_read_config_dword(chip->pdev, 0x48, &val);
./drivers/mmc/host/sdhci-pci-o2micro.c:27:	pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:33:	pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:43:	ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:49:	pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:52:	ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:58:	pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:68:	ret = pci_read_config_dword(chip->pdev, O2_SD_DEV_CTRL, &scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:72:	pci_write_config_dword(chip->pdev, O2_SD_DEV_CTRL, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:75:	ret = pci_read_config_dword(chip->pdev, O2_SD_MISC_REG5, &scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:80:	pci_write_config_dword(chip->pdev, O2_SD_MISC_REG5, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:83:	ret = pci_read_config_dword(chip->pdev, O2_SD_TEST_REG, &scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:87:	pci_write_config_dword(chip->pdev, O2_SD_TEST_REG, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:90:	pci_write_config_dword(chip->pdev, O2_SD_DELAY_CTRL, 0x00002492);
./drivers/mmc/host/sdhci-pci-o2micro.c:93:	ret = pci_read_config_dword(chip->pdev, O2_SD_LD0_CTRL, &scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:97:	pci_write_config_dword(chip->pdev, O2_SD_LD0_CTRL, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:100:	ret = pci_read_config_dword(chip->pdev, O2_SD_CAP_REG0, &scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:105:	pci_write_config_dword(chip->pdev, O2_SD_CAP_REG0, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:107:	ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:113:	pci_write_config_dword(chip->pdev, O2_SD_TUNING_CTRL, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:116:	ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:122:	pci_write_config_dword(chip->pdev, O2_SD_UHS2_L1_CTRL, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:125:	ret = pci_read_config_dword(chip->pdev, O2_SD_FUNC_REG3, &scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:130:	pci_write_config_dword(chip->pdev, O2_SD_FUNC_REG3, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:133:	ret = pci_read_config_dword(chip->pdev, O2_SD_CAPS, &scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:138:	pci_write_config_dword(chip->pdev, O2_SD_CAPS, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:140:	ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:146:	pci_write_config_dword(chip->pdev, O2_SD_MISC_CTRL4, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:157:	switch (chip->pdev->device) {
./drivers/mmc/host/sdhci-pci-o2micro.c:167:		if (chip->pdev->device != PCI_DEVICE_ID_O2_FUJIN2)
./drivers/mmc/host/sdhci-pci-o2micro.c:188:	switch (chip->pdev->device) {
./drivers/mmc/host/sdhci-pci-o2micro.c:194:		ret = pci_read_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:199:		pci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);
./drivers/mmc/host/sdhci-pci-o2micro.c:202:		pci_write_config_byte(chip->pdev, O2_SD_MULTI_VCC3V, 0x08);
./drivers/mmc/host/sdhci-pci-o2micro.c:205:		ret = pci_read_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:210:		pci_write_config_byte(chip->pdev, O2_SD_CLKREQ, scratch);
./drivers/mmc/host/sdhci-pci-o2micro.c:215:		ret = pci_read_config_byte(chip->pdev, O2_SD_CAPS, &scratch);
./drivers/mmc/host/sdhci-pci-o2micro.c:219:		pci_write_config_byte(chip->pdev, O2_SD_CAPS, scratch);
./drivers/mmc/host/sdhci-pci-o2micro.c:220:		pci_write_config_byte(chip->pdev, O2_SD_CAPS, 0x73);
./drivers/mmc/host/sdhci-pci-o2micro.c:223:		pci_write_config_byte(chip->pdev, O2_SD_ADMA1, 0x39);
./drivers/mmc/host/sdhci-pci-o2micro.c:224:		pci_write_config_byte(chip->pdev, O2_SD_ADMA2, 0x08);
./drivers/mmc/host/sdhci-pci-o2micro.c:227:		ret = pci_read_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:232:		pci_write_config_byte(chip->pdev, O2_SD_INF_MOD, scratch);
./drivers/mmc/host/sdhci-pci-o2micro.c:235:		ret = pci_read_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:240:		pci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);
./drivers/mmc/host/sdhci-pci-o2micro.c:246:		ret = pci_read_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:252:		pci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);
./drivers/mmc/host/sdhci-pci-o2micro.c:255:		if (chip->pdev->device == PCI_DEVICE_ID_O2_FUJIN2) {
./drivers/mmc/host/sdhci-pci-o2micro.c:256:			ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:267:				ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:273:				pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:278:				pci_write_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:289:		ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:296:		pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:299:		ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:304:		pci_write_config_dword(chip->pdev, O2_SD_CLKREQ, scratch_32);
./drivers/mmc/host/sdhci-pci-o2micro.c:306:		ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:313:		pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:317:		ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:322:		pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:325:		if (chip->pdev->device == PCI_DEVICE_ID_O2_FUJIN2)
./drivers/mmc/host/sdhci-pci-o2micro.c:329:		ret = pci_read_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:334:		pci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);
./drivers/mmc/host/sdhci-pci-o2micro.c:339:		ret = pci_read_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:345:		pci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);
./drivers/mmc/host/sdhci-pci-o2micro.c:347:		ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:354:			pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:360:			pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:363:			ret = pci_read_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:367:			pci_write_config_dword(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:372:		pci_write_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:375:		ret = pci_read_config_byte(chip->pdev,
./drivers/mmc/host/sdhci-pci-o2micro.c:380:		pci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);
./drivers/mmc/host/mmc_spi.c:1161:				"can't change chip-select polarity\n");
./drivers/mmc/host/mmc_spi.c:1170:					"can't restore chip-select polarity\n");
./drivers/mmc/host/sdhci-acpi.c:448:			host->ops            = c->slot->chip->ops;
./drivers/mmc/host/sdhci-acpi.c:449:			host->quirks        |= c->slot->chip->quirks;
./drivers/mmc/host/sdhci-acpi.c:450:			host->quirks2       |= c->slot->chip->quirks2;
./drivers/mmc/host/sdhci-acpi.c:451:			host->mmc->caps     |= c->slot->chip->caps;
./drivers/mmc/host/sdhci-acpi.c:452:			host->mmc->caps2    |= c->slot->chip->caps2;
./drivers/mmc/host/sdhci-acpi.c:453:			host->mmc->pm_caps  |= c->slot->chip->pm_caps;
./drivers/mmc/host/sdhci-pci-core.c:43:	if (chip->pdev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG ||
./drivers/mmc/host/sdhci-pci-core.c:44:	    chip->pdev->subsystem_vendor == PCI_VENDOR_ID_SONY)
./drivers/mmc/host/sdhci-pci-core.c:45:		chip->quirks |= SDHCI_QUIRK_NO_CARD_NO_RESET;
./drivers/mmc/host/sdhci-pci-core.c:128:	chip->num_slots = 1;
./drivers/mmc/host/sdhci-pci-core.c:184:	dev_warn(&slot->chip->pdev->dev, "failed to setup card detect wake up\n");
./drivers/mmc/host/sdhci-pci-core.c:362:	if (slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BSW_EMMC)
./drivers/mmc/host/sdhci-pci-core.c:364:	if (slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_SPT_EMMC) {
./drivers/mmc/host/sdhci-pci-core.c:384:	if (slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BXT_SD ||
./drivers/mmc/host/sdhci-pci-core.c:385:	    slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BXTM_SD ||
./drivers/mmc/host/sdhci-pci-core.c:386:	    slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_APL_SD) {
./drivers/mmc/host/sdhci-pci-core.c:427:	if ((PCI_FUNC(slot->chip->pdev->devfn) != INTEL_MRFL_EMMC_0) &&
./drivers/mmc/host/sdhci-pci-core.c:428:	    (PCI_FUNC(slot->chip->pdev->devfn) != INTEL_MRFL_EMMC_1))
./drivers/mmc/host/sdhci-pci-core.c:460:	ret = pci_read_config_byte(chip->pdev, 0xAE, &scratch);
./drivers/mmc/host/sdhci-pci-core.c:473:	return pci_write_config_byte(chip->pdev, 0xAE, scratch);
./drivers/mmc/host/sdhci-pci-core.c:481:	if (chip->pdev->revision == 0) {
./drivers/mmc/host/sdhci-pci-core.c:482:		chip->quirks |= SDHCI_QUIRK_32BIT_DMA_ADDR |
./drivers/mmc/host/sdhci-pci-core.c:501:	if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_SD)
./drivers/mmc/host/sdhci-pci-core.c:503:	else if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_SD)
./drivers/mmc/host/sdhci-pci-core.c:512:			if ((PCI_SLOT(chip->pdev->devfn) ==
./drivers/mmc/host/sdhci-pci-core.c:514:				(chip->pdev->bus == sd_dev->bus))
./drivers/mmc/host/sdhci-pci-core.c:520:			dev_info(&chip->pdev->dev, "Refusing to bind to "
./drivers/mmc/host/sdhci-pci-core.c:532:		dev_err(&chip->pdev->dev, "Failure enabling card power\n");
./drivers/mmc/host/sdhci-pci-core.c:537:	if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_SD ||
./drivers/mmc/host/sdhci-pci-core.c:538:	    chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)
./drivers/mmc/host/sdhci-pci-core.c:539:		chip->quirks |= SDHCI_QUIRK_UNSTABLE_RO_DETECT;
./drivers/mmc/host/sdhci-pci-core.c:560:	if (slot->chip->pdev->revision == 0) {
./drivers/mmc/host/sdhci-pci-core.c:577:	if (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {
./drivers/mmc/host/sdhci-pci-core.c:589:	if (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||
./drivers/mmc/host/sdhci-pci-core.c:590:	    slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)
./drivers/mmc/host/sdhci-pci-core.c:603:	if (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||
./drivers/mmc/host/sdhci-pci-core.c:604:	    slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)
./drivers/mmc/host/sdhci-pci-core.c:612:	if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||
./drivers/mmc/host/sdhci-pci-core.c:613:	    chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {
./drivers/mmc/host/sdhci-pci-core.c:614:		for (i = 0; i < chip->num_slots; i++)
./drivers/mmc/host/sdhci-pci-core.c:615:			jmicron_enable_mmc(chip->slots[i]->host, 0);
./drivers/mmc/host/sdhci-pci-core.c:625:	if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||
./drivers/mmc/host/sdhci-pci-core.c:626:	    chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {
./drivers/mmc/host/sdhci-pci-core.c:627:		for (i = 0; i < chip->num_slots; i++)
./drivers/mmc/host/sdhci-pci-core.c:628:			jmicron_enable_mmc(chip->slots[i]->host, 1);
./drivers/mmc/host/sdhci-pci-core.c:633:		dev_err(&chip->pdev->dev, "Failure enabling card power\n");
./drivers/mmc/host/sdhci-pci-core.c:679:	if ((chip->pdev->class & 0x0000FF) == PCI_SDHCI_IFVENDOR) {
./drivers/mmc/host/sdhci-pci-core.c:680:		chip->pdev->class &= ~0x0000FF;
./drivers/mmc/host/sdhci-pci-core.c:681:		chip->pdev->class |= PCI_SDHCI_IFDMA;
./drivers/mmc/host/sdhci-pci-core.c:692:	dev_info(&slot->chip->pdev->dev, "SysKonnect CardBus2SDIO, "
./drivers/mmc/host/sdhci-pci-core.c:710:		dev_err(&slot->chip->pdev->dev,
./drivers/mmc/host/sdhci-pci-core.c:727:	if (chip->pdev->revision == 0x10)
./drivers/mmc/host/sdhci-pci-core.c:728:		chip->quirks |= SDHCI_QUIRK_DELAY_AFTER_POWER;
./drivers/mmc/host/sdhci-pci-core.c:781:		chip->quirks2 |= SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD;
./drivers/mmc/host/sdhci-pci-core.c:782:		chip->quirks2 |= SDHCI_QUIRK2_BROKEN_HS200;
./drivers/mmc/host/sdhci-pci-core.c:1326:	pdev = slot->chip->pdev;
./drivers/mmc/host/sdhci-pci-core.c:1431:	for (i = 0; i < chip->num_slots; i++) {
./drivers/mmc/host/sdhci-pci-core.c:1432:		slot = chip->slots[i];
./drivers/mmc/host/sdhci-pci-core.c:1448:	if (chip->fixes && chip->fixes->suspend) {
./drivers/mmc/host/sdhci-pci-core.c:1449:		ret = chip->fixes->suspend(chip);
./drivers/mmc/host/sdhci-pci-core.c:1466:		sdhci_resume_host(chip->slots[i]->host);
./drivers/mmc/host/sdhci-pci-core.c:1481:	if (chip->fixes && chip->fixes->resume) {
./drivers/mmc/host/sdhci-pci-core.c:1482:		ret = chip->fixes->resume(chip);
./drivers/mmc/host/sdhci-pci-core.c:1487:	for (i = 0; i < chip->num_slots; i++) {
./drivers/mmc/host/sdhci-pci-core.c:1488:		slot = chip->slots[i];
./drivers/mmc/host/sdhci-pci-core.c:1511:	for (i = 0; i < chip->num_slots; i++) {
./drivers/mmc/host/sdhci-pci-core.c:1512:		slot = chip->slots[i];
./drivers/mmc/host/sdhci-pci-core.c:1522:	if (chip->fixes && chip->fixes->suspend) {
./drivers/mmc/host/sdhci-pci-core.c:1523:		ret = chip->fixes->suspend(chip);
./drivers/mmc/host/sdhci-pci-core.c:1532:		sdhci_runtime_resume_host(chip->slots[i]->host);
./drivers/mmc/host/sdhci-pci-core.c:1547:	if (chip->fixes && chip->fixes->resume) {
./drivers/mmc/host/sdhci-pci-core.c:1548:		ret = chip->fixes->resume(chip);
./drivers/mmc/host/sdhci-pci-core.c:1553:	for (i = 0; i < chip->num_slots; i++) {
./drivers/mmc/host/sdhci-pci-core.c:1554:		slot = chip->slots[i];
./drivers/mmc/host/sdhci-pci-core.c:1647:	host->quirks = chip->quirks;
./drivers/mmc/host/sdhci-pci-core.c:1648:	host->quirks2 = chip->quirks2;
./drivers/mmc/host/sdhci-pci-core.c:1665:	if (chip->fixes && chip->fixes->probe_slot) {
./drivers/mmc/host/sdhci-pci-core.c:1666:		ret = chip->fixes->probe_slot(slot);
./drivers/mmc/host/sdhci-pci-core.c:1704:	if (chip->fixes && chip->fixes->own_cd_for_runtime_pm &&
./drivers/mmc/host/sdhci-pci-core.c:1706:		chip->allow_runtime_pm = false;
./drivers/mmc/host/sdhci-pci-core.c:1714:	if (chip->fixes && chip->fixes->remove_slot)
./drivers/mmc/host/sdhci-pci-core.c:1715:		chip->fixes->remove_slot(slot, 0);
./drivers/mmc/host/sdhci-pci-core.c:1750:	if (slot->chip->fixes && slot->chip->fixes->remove_slot)
./drivers/mmc/host/sdhci-pci-core.c:1751:		slot->chip->fixes->remove_slot(slot, dead);
./drivers/mmc/host/sdhci-pci-core.c:1756:	pci_release_region(slot->chip->pdev, slot->pci_bar);
./drivers/mmc/host/sdhci-pci-core.c:1823:	chip->pdev = pdev;
./drivers/mmc/host/sdhci-pci-core.c:1824:	chip->fixes = (const struct sdhci_pci_fixes *)ent->driver_data;
./drivers/mmc/host/sdhci-pci-core.c:1825:	if (chip->fixes) {
./drivers/mmc/host/sdhci-pci-core.c:1826:		chip->quirks = chip->fixes->quirks;
./drivers/mmc/host/sdhci-pci-core.c:1827:		chip->quirks2 = chip->fixes->quirks2;
./drivers/mmc/host/sdhci-pci-core.c:1828:		chip->allow_runtime_pm = chip->fixes->allow_runtime_pm;
./drivers/mmc/host/sdhci-pci-core.c:1830:	chip->num_slots = slots;
./drivers/mmc/host/sdhci-pci-core.c:1834:	if (chip->fixes && chip->fixes->probe) {
./drivers/mmc/host/sdhci-pci-core.c:1835:		ret = chip->fixes->probe(chip);
./drivers/mmc/host/sdhci-pci-core.c:1840:	slots = chip->num_slots;	/* Quirk may have changed this */
./drivers/mmc/host/sdhci-pci-core.c:1846:				sdhci_pci_remove_slot(chip->slots[i]);
./drivers/mmc/host/sdhci-pci-core.c:1851:		chip->slots[i] = slot;
./drivers/mmc/host/sdhci-pci-core.c:1854:	if (chip->allow_runtime_pm)
./drivers/mmc/host/sdhci-pci-core.c:1876:		if (chip->allow_runtime_pm)
./drivers/mmc/host/sdhci-pci-core.c:1879:		for (i = 0; i < chip->num_slots; i++)
./drivers/mmc/host/sdhci-pci-core.c:1880:			sdhci_pci_remove_slot(chip->slots[i]);
./drivers/base/platform-msi.c:105:	if (!chip->irq_mask)
./drivers/base/platform-msi.c:106:		chip->irq_mask = irq_chip_mask_parent;
./drivers/base/platform-msi.c:107:	if (!chip->irq_unmask)
./drivers/base/platform-msi.c:108:		chip->irq_unmask = irq_chip_unmask_parent;
./drivers/base/platform-msi.c:109:	if (!chip->irq_eoi)
./drivers/base/platform-msi.c:110:		chip->irq_eoi = irq_chip_eoi_parent;
./drivers/base/platform-msi.c:111:	if (!chip->irq_set_affinity)
./drivers/base/platform-msi.c:112:		chip->irq_set_affinity = msi_domain_set_affinity;
./drivers/base/platform-msi.c:113:	if (!chip->irq_write_msi_msg)
./drivers/base/platform-msi.c:114:		chip->irq_write_msi_msg = platform_msi_write_msg;
./drivers/base/regmap/regmap-irq.c:53:	return &data->chip->irqs[irq];
./drivers/base/regmap/regmap-irq.c:71:	if (d->chip->runtime_pm) {
./drivers/base/regmap/regmap-irq.c:83:	for (i = 0; i < d->chip->num_regs; i++) {
./drivers/base/regmap/regmap-irq.c:84:		reg = d->chip->mask_base +
./drivers/base/regmap/regmap-irq.c:86:		if (d->chip->mask_invert) {
./drivers/base/regmap/regmap-irq.c:89:		} else if (d->chip->unmask_base) {
./drivers/base/regmap/regmap-irq.c:97:			unmask_offset = d->chip->unmask_base -
./drivers/base/regmap/regmap-irq.c:98:							d->chip->mask_base;
./drivers/base/regmap/regmap-irq.c:112:		reg = d->chip->wake_base +
./drivers/base/regmap/regmap-irq.c:115:			if (d->chip->wake_invert)
./drivers/base/regmap/regmap-irq.c:129:		if (!d->chip->init_ack_masked)
./drivers/base/regmap/regmap-irq.c:136:		if (d->mask_buf[i] && (d->chip->ack_base || d->chip->use_ack)) {
./drivers/base/regmap/regmap-irq.c:137:			reg = d->chip->ack_base +
./drivers/base/regmap/regmap-irq.c:140:			if (d->chip->ack_invert)
./drivers/base/regmap/regmap-irq.c:150:	for (i = 0; i < d->chip->num_type_reg; i++) {
./drivers/base/regmap/regmap-irq.c:153:		reg = d->chip->type_base +
./drivers/base/regmap/regmap-irq.c:155:		if (d->chip->type_invert)
./drivers/base/regmap/regmap-irq.c:166:	if (d->chip->runtime_pm)
./drivers/base/regmap/regmap-irq.c:271:	if (chip->runtime_pm) {
./drivers/base/regmap/regmap-irq.c:293:		ret = regmap_bulk_read(map, chip->status_base,
./drivers/base/regmap/regmap-irq.c:295:				       chip->num_regs);
./drivers/base/regmap/regmap-irq.c:302:		for (i = 0; i < data->chip->num_regs; i++) {
./drivers/base/regmap/regmap-irq.c:320:		for (i = 0; i < data->chip->num_regs; i++) {
./drivers/base/regmap/regmap-irq.c:321:			ret = regmap_read(map, chip->status_base +
./drivers/base/regmap/regmap-irq.c:330:				if (chip->runtime_pm)
./drivers/base/regmap/regmap-irq.c:344:	for (i = 0; i < data->chip->num_regs; i++) {
./drivers/base/regmap/regmap-irq.c:347:		if (data->status_buf[i] && (chip->ack_base || chip->use_ack)) {
./drivers/base/regmap/regmap-irq.c:348:			reg = chip->ack_base +
./drivers/base/regmap/regmap-irq.c:357:	for (i = 0; i < chip->num_irqs; i++) {
./drivers/base/regmap/regmap-irq.c:358:		if (data->status_buf[chip->irqs[i].reg_offset /
./drivers/base/regmap/regmap-irq.c:359:				     map->reg_stride] & chip->irqs[i].mask) {
./drivers/base/regmap/regmap-irq.c:365:	if (chip->runtime_pm)
./drivers/base/regmap/regmap-irq.c:418:	if (chip->num_regs <= 0)
./drivers/base/regmap/regmap-irq.c:421:	for (i = 0; i < chip->num_irqs; i++) {
./drivers/base/regmap/regmap-irq.c:422:		if (chip->irqs[i].reg_offset % map->reg_stride)
./drivers/base/regmap/regmap-irq.c:424:		if (chip->irqs[i].reg_offset / map->reg_stride >=
./drivers/base/regmap/regmap-irq.c:425:		    chip->num_regs)
./drivers/base/regmap/regmap-irq.c:430:		irq_base = irq_alloc_descs(irq_base, 0, chip->num_irqs, 0);
./drivers/base/regmap/regmap-irq.c:442:	d->status_buf = kcalloc(chip->num_regs, sizeof(unsigned int),
./drivers/base/regmap/regmap-irq.c:447:	d->mask_buf = kcalloc(chip->num_regs, sizeof(unsigned int),
./drivers/base/regmap/regmap-irq.c:452:	d->mask_buf_def = kcalloc(chip->num_regs, sizeof(unsigned int),
./drivers/base/regmap/regmap-irq.c:457:	if (chip->wake_base) {
./drivers/base/regmap/regmap-irq.c:458:		d->wake_buf = kcalloc(chip->num_regs, sizeof(unsigned int),
./drivers/base/regmap/regmap-irq.c:464:	if (chip->num_type_reg) {
./drivers/base/regmap/regmap-irq.c:465:		d->type_buf_def = kcalloc(chip->num_type_reg,
./drivers/base/regmap/regmap-irq.c:470:		d->type_buf = kcalloc(chip->num_type_reg, sizeof(unsigned int),
./drivers/base/regmap/regmap-irq.c:477:	d->irq_chip.name = chip->name;
./drivers/base/regmap/regmap-irq.c:483:	if (chip->irq_reg_stride)
./drivers/base/regmap/regmap-irq.c:484:		d->irq_reg_stride = chip->irq_reg_stride;
./drivers/base/regmap/regmap-irq.c:488:	if (chip->type_reg_stride)
./drivers/base/regmap/regmap-irq.c:489:		d->type_reg_stride = chip->type_reg_stride;
./drivers/base/regmap/regmap-irq.c:495:		d->status_reg_buf = kmalloc_array(chip->num_regs,
./drivers/base/regmap/regmap-irq.c:504:	for (i = 0; i < chip->num_irqs; i++)
./drivers/base/regmap/regmap-irq.c:505:		d->mask_buf_def[chip->irqs[i].reg_offset / map->reg_stride]
./drivers/base/regmap/regmap-irq.c:506:			|= chip->irqs[i].mask;
./drivers/base/regmap/regmap-irq.c:509:	for (i = 0; i < chip->num_regs; i++) {
./drivers/base/regmap/regmap-irq.c:511:		reg = chip->mask_base +
./drivers/base/regmap/regmap-irq.c:513:		if (chip->mask_invert)
./drivers/base/regmap/regmap-irq.c:516:		else if (d->chip->unmask_base) {
./drivers/base/regmap/regmap-irq.c:517:			unmask_offset = d->chip->unmask_base -
./drivers/base/regmap/regmap-irq.c:518:					d->chip->mask_base;
./drivers/base/regmap/regmap-irq.c:532:		if (!chip->init_ack_masked)
./drivers/base/regmap/regmap-irq.c:536:		reg = chip->status_base +
./drivers/base/regmap/regmap-irq.c:545:		if (d->status_buf[i] && (chip->ack_base || chip->use_ack)) {
./drivers/base/regmap/regmap-irq.c:546:			reg = chip->ack_base +
./drivers/base/regmap/regmap-irq.c:548:			if (chip->ack_invert)
./drivers/base/regmap/regmap-irq.c:564:		for (i = 0; i < chip->num_regs; i++) {
./drivers/base/regmap/regmap-irq.c:566:			reg = chip->wake_base +
./drivers/base/regmap/regmap-irq.c:569:			if (chip->wake_invert)
./drivers/base/regmap/regmap-irq.c:585:	if (chip->num_type_reg) {
./drivers/base/regmap/regmap-irq.c:586:		for (i = 0; i < chip->num_irqs; i++) {
./drivers/base/regmap/regmap-irq.c:587:			reg = chip->irqs[i].type_reg_offset / map->reg_stride;
./drivers/base/regmap/regmap-irq.c:588:			d->type_buf_def[reg] |= chip->irqs[i].type_rising_mask |
./drivers/base/regmap/regmap-irq.c:589:					chip->irqs[i].type_falling_mask;
./drivers/base/regmap/regmap-irq.c:591:		for (i = 0; i < chip->num_type_reg; ++i) {
./drivers/base/regmap/regmap-irq.c:595:			reg = chip->type_base +
./drivers/base/regmap/regmap-irq.c:597:			if (chip->type_invert)
./drivers/base/regmap/regmap-irq.c:614:						  chip->num_irqs, irq_base, 0,
./drivers/base/regmap/regmap-irq.c:618:						  chip->num_irqs,
./drivers/base/regmap/regmap-irq.c:628:				   chip->name, d);
./drivers/base/regmap/regmap-irq.c:631:			irq, chip->name, ret);
./drivers/base/regmap/regmap-irq.c:673:	for (hwirq = 0; hwirq < d->chip->num_irqs; hwirq++) {
./drivers/base/regmap/regmap-irq.c:675:		if (!d->chip->irqs[hwirq].mask)
./drivers/base/regmap/regmap-irq.c:806:	if (!data->chip->irqs[irq].mask)
./drivers/of/of_pci.c:272:	if (!of_property_read_bool(chip->of_node, "msi-controller"))
./drivers/of/of_pci.c:276:	list_add(&chip->list, &of_pci_msi_chip_list);
./drivers/of/of_pci.c:286:	list_del(&chip->list);
./drivers/ata/sata_mv.c:2877:	 * Handle chip-reported errors, or continue on to handle PIO.
./drivers/hwmon/tmp401.c:555: * temperature measured since power-on, chip-reset, or
./drivers/hwmon/jc42.c:439:		if (manid == chip->manid &&
./drivers/hwmon/jc42.c:440:		    (devid & chip->devid_mask) == chip->devid) {
./drivers/hwmon/dme1737.c:198:/* chip-dependent features */
./drivers/hwmon/dme1737.c:2127:	/* Create chip-dependent sysfs attributes */
./drivers/hwmon/dme1737.c:2193:		/* Change permissions of chip-dependent sysfs attributes */
./drivers/hwmon/ibmpowernv.c:161:	if (!of_property_read_u32(np, "ibm,chip-id", &id))
./drivers/hwmon/w83627hf.c:1466:	/* Register chip-specific device attributes */
./drivers/hwmon/max6697.c:198:	for (i = 0; i < data->chip->channels; i++) {
./drivers/hwmon/max6697.c:199:		if (data->chip->have_ext & (1 << i)) {
./drivers/hwmon/max6697.c:223:		if (data->chip->have_crit & (1 << i)) {
./drivers/hwmon/max6697.c:294:	if (data->chip->alarm_map)
./drivers/hwmon/max6697.c:295:		index = data->chip->alarm_map[index];
./drivers/hwmon/max6697.c:412:	if (channel >= chip->channels)
./drivers/hwmon/max6697.c:415:	if ((nr == 3 || nr == 4) && !(chip->have_crit & (1 << channel)))
./drivers/hwmon/max6697.c:417:	if (nr == 5 && !(chip->have_fault & (1 << channel)))
./drivers/hwmon/max6697.c:531:	int factor = chip->channels;
./drivers/hwmon/max6697.c:566:	    (chip->valid_conf & MAX6697_CONF_TIMEOUT)) {
./drivers/hwmon/max6697.c:570:	    (chip->valid_conf & MAX6581_CONF_EXTENDED)) {
./drivers/hwmon/max6697.c:575:	    (chip->valid_conf & MAX6697_CONF_RESISTANCE)) {
./drivers/hwmon/max6697.c:580:	    (chip->valid_conf & MAX6693_CONF_BETA)) {
./drivers/hwmon/ad7314.c:48:	ret = spi_read(chip->spi_dev, (u8 *)&chip->rx, sizeof(chip->rx));
./drivers/hwmon/ad7314.c:50:		dev_err(&chip->spi_dev->dev, "SPI read error\n");
./drivers/hwmon/ad7314.c:54:	return be16_to_cpu(chip->rx);
./drivers/hwmon/ad7314.c:68:	switch (spi_get_device_id(chip->spi_dev)->driver_data) {
./drivers/hwmon/ad7314.c:126:	chip->hwmon_dev = hwmon_device_register(&spi_dev->dev);
./drivers/hwmon/ad7314.c:127:	if (IS_ERR(chip->hwmon_dev)) {
./drivers/hwmon/ad7314.c:128:		ret = PTR_ERR(chip->hwmon_dev);
./drivers/hwmon/ad7314.c:131:	chip->spi_dev = spi_dev;
./drivers/hwmon/ad7314.c:143:	hwmon_device_unregister(chip->hwmon_dev);
./drivers/memstick/host/jmb38x_ms.c:422:		if (1 != dma_map_sg(&host->chip->pdev->dev, &host->req->sg, 1,
./drivers/memstick/host/jmb38x_ms.c:490:		dma_unmap_sg(&host->chip->pdev->dev, &host->req->sg, 1,
./drivers/memstick/host/jmb38x_ms.c:528:	dev_dbg(&host->chip->pdev->dev, "irq_status = %08x\n", irq_status);
./drivers/memstick/host/jmb38x_ms.c:539:				dev_dbg(&host->chip->pdev->dev, "TPC_ERR\n");
./drivers/memstick/host/jmb38x_ms.c:579:		dev_dbg(&host->chip->pdev->dev, "media changed\n");
./drivers/memstick/host/jmb38x_ms.c:601:	dev_dbg(&host->chip->pdev->dev, "abort\n");
./drivers/memstick/host/jmb38x_ms.c:621:			dev_dbg(&host->chip->pdev->dev, "tasklet req %d\n", rc);
./drivers/memstick/host/jmb38x_ms.c:655:	dev_dbg(&host->chip->pdev->dev, "reset_req timeout\n");
./drivers/memstick/host/jmb38x_ms.c:670:	dev_dbg(&host->chip->pdev->dev, "reset timeout\n");
./drivers/memstick/host/jmb38x_ms.c:709:			dev_dbg(&host->chip->pdev->dev, "power on\n");
./drivers/memstick/host/jmb38x_ms.c:716:			dev_dbg(&host->chip->pdev->dev, "power off\n");
./drivers/memstick/host/jmb38x_ms.c:721:		dev_dbg(&host->chip->pdev->dev,
./drivers/memstick/host/jmb38x_ms.c:753:		pci_write_config_byte(host->chip->pdev,
./drivers/memory/omap-gpmc.c:247:/* Define chip-selects as reserved by default until probe completes */
./drivers/memory/omap-gpmc.c:942: * gpmc_cs_remap - remaps a chip-select physical base address
./drivers/memory/omap-gpmc.c:943: * @cs:		chip-select to remap
./drivers/memory/omap-gpmc.c:944: * @base:	physical base address to re-map chip-select to
./drivers/memory/omap-gpmc.c:946: * Re-maps a chip-select to a new physical base address specified by
./drivers/memory/omap-gpmc.c:956:		pr_err("%s: requested chip-select is disabled\n", __func__);
./drivers/memory/omap-gpmc.c:991:		pr_err("%s: requested chip-select is disabled\n", __func__);
./drivers/memory/omap-gpmc.c:1720: * @cs:		GPMC chip-select to program
./drivers/memory/omap-gpmc.c:1723: * Programs non-timing related settings for a GPMC chip-select, such as
./drivers/memory/omap-gpmc.c:1725: * for each chip-select that is being used and must be called before
./drivers/memory/omap-gpmc.c:1969: * Allocates and configures a GPMC chip-select for a child device.
./drivers/memory/omap-gpmc.c:2232:		pr_err("%s: number of chip-selects not defined\n", __func__);
./drivers/memory/omap-gpmc.c:2235:		pr_err("%s: all chip-selects are disabled\n", __func__);
./drivers/memory/omap-gpmc.c:2238:		pr_err("%s: number of supported chip-selects cannot be > %d\n",
./drivers/memory/ti-aemif.c:87: * @cs: chip-select number
./drivers/memory/ti-aemif.c:118: * @num_cs: number of assigned chip-selects
./drivers/memory/ti-aemif.c:120: * @cs_data: array of chip-select settings
./drivers/memory/ti-aemif.c:172: * chip-select.
./drivers/uio/uio_fsl_elbc_gpcm.c:8:   using the general purpose chip-select mode (GPCM).
./drivers/tty/serial/8250/8250_mid.c:120:	chip->dev = &pdev->dev;
./drivers/tty/serial/8250/8250_mid.c:121:	chip->irq = pdev->irq;
./drivers/tty/serial/8250/8250_mid.c:122:	chip->regs = p->membase;
./drivers/tty/serial/8250/8250_mid.c:123:	chip->length = pci_resource_len(pdev, bar);
./drivers/tty/serial/8250/8250_mid.c:124:	chip->offset = DNV_DMA_CHAN_OFFSET;
./drivers/tty/serial/sccnxp.c:293:		if (baud_std[i].mr0 && !(chip->flags & SCCNXP_HAVE_MR0))
./drivers/tty/serial/sccnxp.c:295:		div_std = DIV_ROUND_CLOSEST(chip->freq_std, baud_std[i].baud);
./drivers/tty/serial/sccnxp.c:305:	if (chip->flags & SCCNXP_HAVE_MR0) {
./drivers/tty/serial/sccnxp.c:428:			if (s->chip->flags & SCCNXP_HAVE_IO)
./drivers/tty/serial/sccnxp.c:500:	if (s->chip->flags & SCCNXP_HAVE_IO)
./drivers/tty/serial/sccnxp.c:541:	if (!(s->chip->flags & SCCNXP_HAVE_IO))
./drivers/tty/serial/sccnxp.c:559:	if (!(s->chip->flags & SCCNXP_HAVE_IO))
./drivers/tty/serial/sccnxp.c:677:				  (s->chip->flags & SCCNXP_HAVE_MR0) ?
./drivers/tty/serial/sccnxp.c:701:	if (s->chip->flags & SCCNXP_HAVE_IO) {
./drivers/tty/serial/sccnxp.c:741:	if (s->chip->flags & SCCNXP_HAVE_IO)
./drivers/tty/serial/sccnxp.c:751:	return (port->type == PORT_SC26XX) ? s->chip->name : NULL;
./drivers/tty/serial/sccnxp.c:892:		uartclk = s->chip->freq_std;
./drivers/tty/serial/sccnxp.c:897:	if ((uartclk < s->chip->freq_min) || (uartclk > s->chip->freq_max)) {
./drivers/tty/serial/sccnxp.c:925:	s->uart.nr		= s->chip->nr;
./drivers/tty/serial/sccnxp.c:947:		s->port[i].fifosize	= s->chip->fifosize;
./drivers/tty/serial/sccnxp.c:957:		if (s->chip->flags & SCCNXP_HAVE_IO)
./drivers/mtd/chips/cfi_cmdset_0002.c:786:	switch (chip->state) {
./drivers/mtd/chips/cfi_cmdset_0002.c:797:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:799:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:822:		map_write(map, CMD(0xB0), chip->in_progress_block_addr);
./drivers/mtd/chips/cfi_cmdset_0002.c:823:		chip->oldstate = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0002.c:824:		chip->state = FL_ERASE_SUSPENDING;
./drivers/mtd/chips/cfi_cmdset_0002.c:825:		chip->erase_suspended = 1;
./drivers/mtd/chips/cfi_cmdset_0002.c:841:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:843:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:847:		chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:854:		chip->oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0002.c:855:		chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:864:		if (mode == FL_READY && chip->oldstate == FL_READY)
./drivers/mtd/chips/cfi_cmdset_0002.c:870:		add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:871:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:873:		remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:874:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:884:	switch(chip->oldstate) {
./drivers/mtd/chips/cfi_cmdset_0002.c:887:			chip->in_progress_block_addr);
./drivers/mtd/chips/cfi_cmdset_0002.c:888:		map_write(map, cfi->sector_erase_cmd, chip->in_progress_block_addr);
./drivers/mtd/chips/cfi_cmdset_0002.c:890:		chip->oldstate = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:891:		chip->state = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0002.c:895:		chip->state = chip->oldstate;
./drivers/mtd/chips/cfi_cmdset_0002.c:896:		chip->oldstate = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:903:		printk(KERN_ERR "MTD: put_chip() called with oldstate %d!!\n", chip->oldstate);
./drivers/mtd/chips/cfi_cmdset_0002.c:905:	wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0002.c:934:	if (chip->state != FL_POINT && chip->state != FL_READY) {
./drivers/mtd/chips/cfi_cmdset_0002.c:936:		chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:968:		    ((chip->state == FL_ERASING && (extp->EraseSuspend & 2))) &&
./drivers/mtd/chips/cfi_cmdset_0002.c:969:		    (cfi_interleave_is_1(cfi) || chip->oldstate == FL_READY)) {
./drivers/mtd/chips/cfi_cmdset_0002.c:997:			oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0002.c:1000:			chip->state = FL_XIP_WHILE_ERASING;
./drivers/mtd/chips/cfi_cmdset_0002.c:1001:			chip->erase_suspended = 1;
./drivers/mtd/chips/cfi_cmdset_0002.c:1006:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1016:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1017:			while (chip->state != FL_XIP_WHILE_ERASING) {
./drivers/mtd/chips/cfi_cmdset_0002.c:1020:				add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:1021:				mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1023:				remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:1024:				mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1033:			chip->state = oldstate;
./drivers/mtd/chips/cfi_cmdset_0002.c:1075: * with chip->state set to FL_READY (or FL_XIP_WHILE_*) where flash state
./drivers/mtd/chips/cfi_cmdset_0002.c:1088:	mutex_unlock(&chip->mutex);  \
./drivers/mtd/chips/cfi_cmdset_0002.c:1090:	mutex_lock(&chip->mutex);  \
./drivers/mtd/chips/cfi_cmdset_0002.c:1095:	mutex_unlock(&chip->mutex);  \
./drivers/mtd/chips/cfi_cmdset_0002.c:1098:	mutex_lock(&chip->mutex);  \
./drivers/mtd/chips/cfi_cmdset_0002.c:1109:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0002.c:1114:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1117:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1121:	if (chip->state != FL_POINT && chip->state != FL_READY) {
./drivers/mtd/chips/cfi_cmdset_0002.c:1123:		chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:1130:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1180:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1182:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1184:	cfi_send_gen_cmd(0x88, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1187:	INVALIDATE_CACHED_RANGE(map, chip->start + adr, len);
./drivers/mtd/chips/cfi_cmdset_0002.c:1195:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1197:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1199:	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1201:	cfi_send_gen_cmd(0x00, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1204:	INVALIDATE_CACHED_RANGE(map, chip->start + adr, len);
./drivers/mtd/chips/cfi_cmdset_0002.c:1216:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1218:	if (chip->state != FL_READY){
./drivers/mtd/chips/cfi_cmdset_0002.c:1220:		add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:1222:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1225:		remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:1231:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0002.c:1233:	chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:1239:	wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0002.c:1240:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1330:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1331:	ret = get_chip(map, chip, chip->start, FL_LOCKING);
./drivers/mtd/chips/cfi_cmdset_0002.c:1333:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1336:	chip->state = FL_LOCKING;
./drivers/mtd/chips/cfi_cmdset_0002.c:1339:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1341:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1343:	cfi_send_gen_cmd(0x40, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1354:	map_write(map, CMD(0xA0), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:1355:	map_write(map, CMD(lockreg), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:1372:	map_write(map, CMD(0x90), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:1373:	map_write(map, CMD(0x00), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:1375:	chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:1376:	put_chip(map, chip, chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:1377:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1408:			base = chip->start;
./drivers/mtd/chips/cfi_cmdset_0002.c:1412:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1415:				mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1422:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1433:				mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1436:					mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1442:						 chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1445:						 chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1448:						 chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1453:				map_write(map, CMD(0x90), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:1454:				map_write(map, CMD(0x00), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:1455:				put_chip(map, chip, chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:1456:				mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1566:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0002.c:1568:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1571:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1599:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:1600:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:1601:	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:1603:	chip->state = mode;
./drivers/mtd/chips/cfi_cmdset_0002.c:1607:				chip->word_write_time);
./drivers/mtd/chips/cfi_cmdset_0002.c:1612:		if (chip->state != mode) {
./drivers/mtd/chips/cfi_cmdset_0002.c:1617:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:1618:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1620:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:1622:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1642:		map_write( map, CMD(0xF0), chip->start );
./drivers/mtd/chips/cfi_cmdset_0002.c:1654:	chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:1657:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1801:				usecs_to_jiffies(chip->buffer_write_time_max);
./drivers/mtd/chips/cfi_cmdset_0002.c:1807:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0002.c:1810:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1813:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1826:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:1827:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:1832:	chip->state = FL_WRITING_TO_BUFFER;
./drivers/mtd/chips/cfi_cmdset_0002.c:1852:	chip->state = FL_WRITING;
./drivers/mtd/chips/cfi_cmdset_0002.c:1856:				chip->word_write_time);
./drivers/mtd/chips/cfi_cmdset_0002.c:1861:		if (chip->state != FL_WRITING) {
./drivers/mtd/chips/cfi_cmdset_0002.c:1866:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:1867:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1869:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:1871:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:1895:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1897:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1899:	cfi_send_gen_cmd(0xF0, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:1909:	chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:1912:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2012:	if (chip->state == FL_READY && chip_ready(map, adr))
./drivers/mtd/chips/cfi_cmdset_0002.c:2025:		map_write(map, CMD(0xF0), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2063:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0002.c:2087:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2088:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2089:	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2101:		map_write(map, CMD(0xF0), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2242:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2245:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2250:	       __func__, chip->start );
./drivers/mtd/chips/cfi_cmdset_0002.c:2256:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2257:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2258:	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2259:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2260:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2261:	cfi_send_gen_cmd(0x10, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2263:	chip->state = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0002.c:2264:	chip->erase_suspended = 0;
./drivers/mtd/chips/cfi_cmdset_0002.c:2265:	chip->in_progress_block_addr = adr;
./drivers/mtd/chips/cfi_cmdset_0002.c:2269:				chip->erase_time*500);
./drivers/mtd/chips/cfi_cmdset_0002.c:2274:		if (chip->state != FL_ERASING) {
./drivers/mtd/chips/cfi_cmdset_0002.c:2277:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:2278:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2280:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:2281:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2284:		if (chip->erase_suspended) {
./drivers/mtd/chips/cfi_cmdset_0002.c:2288:			chip->erase_suspended = 0;
./drivers/mtd/chips/cfi_cmdset_0002.c:2306:		map_write( map, CMD(0xF0), chip->start );
./drivers/mtd/chips/cfi_cmdset_0002.c:2312:	chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:2316:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2329:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0002.c:2331:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2334:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2345:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2346:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2347:	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2348:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2349:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
./drivers/mtd/chips/cfi_cmdset_0002.c:2352:	chip->state = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0002.c:2353:	chip->erase_suspended = 0;
./drivers/mtd/chips/cfi_cmdset_0002.c:2354:	chip->in_progress_block_addr = adr;
./drivers/mtd/chips/cfi_cmdset_0002.c:2358:				chip->erase_time*500);
./drivers/mtd/chips/cfi_cmdset_0002.c:2363:		if (chip->state != FL_ERASING) {
./drivers/mtd/chips/cfi_cmdset_0002.c:2366:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:2367:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2369:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:2370:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2373:		if (chip->erase_suspended) {
./drivers/mtd/chips/cfi_cmdset_0002.c:2377:			chip->erase_suspended = 0;
./drivers/mtd/chips/cfi_cmdset_0002.c:2398:		map_write( map, CMD(0xF0), chip->start );
./drivers/mtd/chips/cfi_cmdset_0002.c:2404:	chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:2407:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2459:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2460:	ret = get_chip(map, chip, adr + chip->start, FL_LOCKING);
./drivers/mtd/chips/cfi_cmdset_0002.c:2463:	chip->state = FL_LOCKING;
./drivers/mtd/chips/cfi_cmdset_0002.c:2467:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:2469:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:2471:	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:2473:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:2475:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:2477:	map_write(map, CMD(0x40), chip->start + adr);
./drivers/mtd/chips/cfi_cmdset_0002.c:2479:	chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:2480:	put_chip(map, chip, adr + chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2484:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2494:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2495:	ret = get_chip(map, chip, adr + chip->start, FL_UNLOCKING);
./drivers/mtd/chips/cfi_cmdset_0002.c:2498:	chip->state = FL_UNLOCKING;
./drivers/mtd/chips/cfi_cmdset_0002.c:2502:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:2506:	chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:2507:	put_chip(map, chip, adr + chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2511:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2549:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2550:	ret = get_chip(map, chip, adr + chip->start, FL_LOCKING);
./drivers/mtd/chips/cfi_cmdset_0002.c:2552:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2558:	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:2560:	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:2563:	cfi_send_gen_cmd(0xC0, cfi->addr_unlock1, chip->start, map, cfi,
./drivers/mtd/chips/cfi_cmdset_0002.c:2567:		chip->state = FL_LOCKING;
./drivers/mtd/chips/cfi_cmdset_0002.c:2568:		map_write(map, CMD(0xA0), chip->start + adr);
./drivers/mtd/chips/cfi_cmdset_0002.c:2569:		map_write(map, CMD(0x00), chip->start + adr);
./drivers/mtd/chips/cfi_cmdset_0002.c:2575:		chip->state = FL_UNLOCKING;
./drivers/mtd/chips/cfi_cmdset_0002.c:2576:		map_write(map, CMD(0x80), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2577:		map_write(map, CMD(0x30), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2579:		chip->state = FL_JEDEC_QUERY;
./drivers/mtd/chips/cfi_cmdset_0002.c:2603:	map_write(map, CMD(0x90), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2604:	map_write(map, CMD(0x00), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2606:	chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:2607:	put_chip(map, chip, adr + chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2608:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2738:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2740:		switch(chip->state) {
./drivers/mtd/chips/cfi_cmdset_0002.c:2745:			chip->oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0002.c:2746:			chip->state = FL_SYNCING;
./drivers/mtd/chips/cfi_cmdset_0002.c:2752:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2758:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:2760:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2764:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0002.c:2775:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2777:		if (chip->state == FL_SYNCING) {
./drivers/mtd/chips/cfi_cmdset_0002.c:2778:			chip->state = chip->oldstate;
./drivers/mtd/chips/cfi_cmdset_0002.c:2779:			wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0002.c:2781:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2797:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2799:		switch(chip->state) {
./drivers/mtd/chips/cfi_cmdset_0002.c:2804:			chip->oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0002.c:2805:			chip->state = FL_PM_SUSPENDED;
./drivers/mtd/chips/cfi_cmdset_0002.c:2817:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2826:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2828:			if (chip->state == FL_PM_SUSPENDED) {
./drivers/mtd/chips/cfi_cmdset_0002.c:2829:				chip->state = chip->oldstate;
./drivers/mtd/chips/cfi_cmdset_0002.c:2830:				wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0002.c:2832:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2851:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2853:		if (chip->state == FL_PM_SUSPENDED) {
./drivers/mtd/chips/cfi_cmdset_0002.c:2854:			chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0002.c:2855:			map_write(map, CMD(0xF0), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2856:			wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0002.c:2861:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2883:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0002.c:2885:		ret = get_chip(map, chip, chip->start, FL_SHUTDOWN);
./drivers/mtd/chips/cfi_cmdset_0002.c:2887:			map_write(map, CMD(0xF0), chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2888:			chip->state = FL_SHUTDOWN;
./drivers/mtd/chips/cfi_cmdset_0002.c:2889:			put_chip(map, chip, chip->start);
./drivers/mtd/chips/cfi_cmdset_0002.c:2892:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:256:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0020.c:266:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:271:	switch (chip->state) {
./drivers/mtd/chips/cfi_cmdset_0020.c:283:		chip->oldstate = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0020.c:284:		chip->state = FL_ERASE_SUSPENDING;
./drivers/mtd/chips/cfi_cmdset_0020.c:296:				chip->state = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0020.c:297:				wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:298:				mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:304:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:306:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:311:		chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0020.c:325:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:331:			chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0020.c:337:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:343:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:352:		add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:353:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:355:		remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:363:		chip->state = chip->oldstate;
./drivers/mtd/chips/cfi_cmdset_0020.c:377:	wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:378:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:433:        adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0020.c:443:       printk("%s: chip->state[%d]\n", __func__, chip->state);
./drivers/mtd/chips/cfi_cmdset_0020.c:445:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:452:	switch (chip->state) {
./drivers/mtd/chips/cfi_cmdset_0020.c:459:                chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:470:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:477:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:485:		add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:486:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:488:		remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:495:	chip->state = FL_WRITING_TO_BUFFER;
./drivers/mtd/chips/cfi_cmdset_0020.c:503:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:505:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:511:			chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:512:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:530:	chip->state = FL_WRITING;
./drivers/mtd/chips/cfi_cmdset_0020.c:532:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:533:	cfi_udelay(chip->buffer_write_time);
./drivers/mtd/chips/cfi_cmdset_0020.c:534:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:539:		if (chip->state != FL_WRITING) {
./drivers/mtd/chips/cfi_cmdset_0020.c:542:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:543:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:545:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:547:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:561:			chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:563:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:569:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:572:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:575:		chip->buffer_write_time--;
./drivers/mtd/chips/cfi_cmdset_0020.c:576:		if (!chip->buffer_write_time)
./drivers/mtd/chips/cfi_cmdset_0020.c:577:			chip->buffer_write_time++;
./drivers/mtd/chips/cfi_cmdset_0020.c:580:		chip->buffer_write_time++;
./drivers/mtd/chips/cfi_cmdset_0020.c:584:	chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:595:		wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:596:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:599:	wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:600:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:740:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0020.c:747:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:750:	switch (chip->state) {
./drivers/mtd/chips/cfi_cmdset_0020.c:755:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:764:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:770:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:778:		add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:779:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:781:		remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:793:	chip->state = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0020.c:795:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:797:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:804:		if (chip->state != FL_ERASING) {
./drivers/mtd/chips/cfi_cmdset_0020.c:807:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:808:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:810:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:812:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:823:			chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:826:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:831:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:833:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:841:	chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:875:				chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:876:				mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:884:	wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:885:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:987:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:989:		switch(chip->state) {
./drivers/mtd/chips/cfi_cmdset_0020.c:994:			chip->oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0020.c:995:			chip->state = FL_SYNCING;
./drivers/mtd/chips/cfi_cmdset_0020.c:1001:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1007:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:1009:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1011:		        remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:1022:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1024:		if (chip->state == FL_SYNCING) {
./drivers/mtd/chips/cfi_cmdset_0020.c:1025:			chip->state = chip->oldstate;
./drivers/mtd/chips/cfi_cmdset_0020.c:1026:			wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:1028:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1039:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0020.c:1046:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1049:	switch (chip->state) {
./drivers/mtd/chips/cfi_cmdset_0020.c:1054:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:1063:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1069:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1077:		add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:1078:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1080:		remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:1088:	chip->state = FL_LOCKING;
./drivers/mtd/chips/cfi_cmdset_0020.c:1090:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1092:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1107:			chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:1110:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1115:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1117:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1121:	chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:1123:	wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:1124:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1185:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0020.c:1192:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1195:	switch (chip->state) {
./drivers/mtd/chips/cfi_cmdset_0020.c:1200:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:1209:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1215:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1223:		add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:1224:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1226:		remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0020.c:1234:	chip->state = FL_UNLOCKING;
./drivers/mtd/chips/cfi_cmdset_0020.c:1236:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1238:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1253:			chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:1256:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1261:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1263:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1267:	chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0020.c:1269:	wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:1270:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1323:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1325:		switch(chip->state) {
./drivers/mtd/chips/cfi_cmdset_0020.c:1330:			chip->oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0020.c:1331:			chip->state = FL_PM_SUSPENDED;
./drivers/mtd/chips/cfi_cmdset_0020.c:1343:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1352:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1354:			if (chip->state == FL_PM_SUSPENDED) {
./drivers/mtd/chips/cfi_cmdset_0020.c:1358:				chip->state = chip->oldstate;
./drivers/mtd/chips/cfi_cmdset_0020.c:1359:				wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:1361:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1379:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0020.c:1382:		if (chip->state == FL_PM_SUSPENDED) {
./drivers/mtd/chips/cfi_cmdset_0020.c:1384:			chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0020.c:1385:			wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0020.c:1388:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/gen_probe.c:153:			pchip->start = (i << cfi.chipshift);
./drivers/mtd/chips/gen_probe.c:154:			pchip->state = FL_READY;
./drivers/mtd/chips/gen_probe.c:155:			init_waitqueue_head(&pchip->wq);
./drivers/mtd/chips/gen_probe.c:156:			mutex_init(&pchip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:764:				chip->start += j << partshift;
./drivers/mtd/chips/cfi_cmdset_0001.c:765:				chip->priv = &shared[i];
./drivers/mtd/chips/cfi_cmdset_0001.c:768:				init_waitqueue_head(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0001.c:769:				mutex_init(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:799:	if (mode == FL_SYNCING && chip->oldstate != FL_READY)
./drivers/mtd/chips/cfi_cmdset_0001.c:802:	switch (chip->state) {
./drivers/mtd/chips/cfi_cmdset_0001.c:812:			if (chip->priv && map_word_andequal(map, status, status_PWS, status_PWS))
./drivers/mtd/chips/cfi_cmdset_0001.c:815:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:817:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:844:		chip->oldstate = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0001.c:845:		chip->state = FL_ERASE_SUSPENDING;
./drivers/mtd/chips/cfi_cmdset_0001.c:846:		chip->erase_suspended = 1;
./drivers/mtd/chips/cfi_cmdset_0001.c:861:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:863:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:867:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0001.c:874:		chip->oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0001.c:875:		chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0001.c:883:		if (mode == FL_READY && chip->oldstate == FL_READY)
./drivers/mtd/chips/cfi_cmdset_0001.c:889:		add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0001.c:890:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:892:		remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0001.c:893:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:904:	if (chip->priv &&
./drivers/mtd/chips/cfi_cmdset_0001.c:906:	    || mode == FL_SHUTDOWN) && chip->state != FL_SYNCING) {
./drivers/mtd/chips/cfi_cmdset_0001.c:925:		struct flchip_shared *shared = chip->priv;
./drivers/mtd/chips/cfi_cmdset_0001.c:943:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:945:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:959:			if (chip->state == FL_SYNCING) {
./drivers/mtd/chips/cfi_cmdset_0001.c:973:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0001.c:974:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:976:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0001.c:977:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:998:	if (chip->priv) {
./drivers/mtd/chips/cfi_cmdset_0001.c:999:		struct flchip_shared *shared = chip->priv;
./drivers/mtd/chips/cfi_cmdset_0001.c:1001:		if (shared->writing == chip && chip->oldstate == FL_READY) {
./drivers/mtd/chips/cfi_cmdset_0001.c:1009:				mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1011:				mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1013:				wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0001.c:1027:			wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0001.c:1033:	switch(chip->oldstate) {
./drivers/mtd/chips/cfi_cmdset_0001.c:1046:		chip->oldstate = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0001.c:1047:		chip->state = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0001.c:1051:		chip->state = chip->oldstate;
./drivers/mtd/chips/cfi_cmdset_0001.c:1052:		chip->oldstate = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0001.c:1060:		printk(KERN_ERR "%s: put_chip() called with oldstate %d!!\n", map->name, chip->oldstate);
./drivers/mtd/chips/cfi_cmdset_0001.c:1062:	wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0001.c:1090:	if (chip->state != FL_POINT && chip->state != FL_READY) {
./drivers/mtd/chips/cfi_cmdset_0001.c:1092:		chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0001.c:1131:		    ((chip->state == FL_ERASING && (cfip->FeatureSupport&2)) ||
./drivers/mtd/chips/cfi_cmdset_0001.c:1132:		     (chip->state == FL_WRITING && (cfip->FeatureSupport&4))) &&
./drivers/mtd/chips/cfi_cmdset_0001.c:1133:		    (cfi_interleave_is_1(cfi) || chip->oldstate == FL_READY)) {
./drivers/mtd/chips/cfi_cmdset_0001.c:1162:			oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0001.c:1167:				chip->erase_suspended = 1;
./drivers/mtd/chips/cfi_cmdset_0001.c:1172:				chip->write_suspended = 1;
./drivers/mtd/chips/cfi_cmdset_0001.c:1174:			chip->state = newstate;
./drivers/mtd/chips/cfi_cmdset_0001.c:1179:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1189:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1190:			while (chip->state != newstate) {
./drivers/mtd/chips/cfi_cmdset_0001.c:1193:				add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0001.c:1194:				mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1196:				remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0001.c:1197:				mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1205:			chip->state = oldstate;
./drivers/mtd/chips/cfi_cmdset_0001.c:1250:	int chip_state = chip->state;
./drivers/mtd/chips/cfi_cmdset_0001.c:1253:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1256:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1265:		if (chip->state != chip_state) {
./drivers/mtd/chips/cfi_cmdset_0001.c:1269:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0001.c:1270:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1272:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/chips/cfi_cmdset_0001.c:1273:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1281:		if (chip->erase_suspended && chip_state == FL_ERASING)  {
./drivers/mtd/chips/cfi_cmdset_0001.c:1284:			chip->erase_suspended = 0;
./drivers/mtd/chips/cfi_cmdset_0001.c:1286:		if (chip->write_suspended && chip_state == FL_WRITING)  {
./drivers/mtd/chips/cfi_cmdset_0001.c:1289:			chip->write_suspended = 0;
./drivers/mtd/chips/cfi_cmdset_0001.c:1293:			chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0001.c:1298:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1313:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1317: 	chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0001.c:1333:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0001.c:1338:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1343:		if (chip->state != FL_POINT && chip->state != FL_READY)
./drivers/mtd/chips/cfi_cmdset_0001.c:1346:		chip->state = FL_POINT;
./drivers/mtd/chips/cfi_cmdset_0001.c:1347:		chip->ref_point_counter++;
./drivers/mtd/chips/cfi_cmdset_0001.c:1349:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1433:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1434:		if (chip->state == FL_POINT) {
./drivers/mtd/chips/cfi_cmdset_0001.c:1435:			chip->ref_point_counter--;
./drivers/mtd/chips/cfi_cmdset_0001.c:1436:			if(chip->ref_point_counter == 0)
./drivers/mtd/chips/cfi_cmdset_0001.c:1437:				chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0001.c:1443:		put_chip(map, chip, chip->start);
./drivers/mtd/chips/cfi_cmdset_0001.c:1444:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1460:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0001.c:1465:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1468:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1472:	if (chip->state != FL_POINT && chip->state != FL_READY) {
./drivers/mtd/chips/cfi_cmdset_0001.c:1475:		chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0001.c:1482:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1530:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0001.c:1543:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1546:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1555:	chip->state = mode;
./drivers/mtd/chips/cfi_cmdset_0001.c:1559:				   chip->word_write_time,
./drivers/mtd/chips/cfi_cmdset_0001.c:1560:				   chip->word_write_time_max);
./drivers/mtd/chips/cfi_cmdset_0001.c:1593:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1691:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0001.c:1704:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1707:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1719:	if (chip->state != FL_STATUS) {
./drivers/mtd/chips/cfi_cmdset_0001.c:1721:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0001.c:1732:	chip->state = FL_WRITING_TO_BUFFER;
./drivers/mtd/chips/cfi_cmdset_0001.c:1739:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0001.c:1799:	chip->state = FL_WRITING;
./drivers/mtd/chips/cfi_cmdset_0001.c:1803:				   chip->buffer_write_time,
./drivers/mtd/chips/cfi_cmdset_0001.c:1804:				   chip->buffer_write_time_max);
./drivers/mtd/chips/cfi_cmdset_0001.c:1807:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0001.c:1839:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1914:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0001.c:1917:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1920:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1934:	chip->state = FL_ERASING;
./drivers/mtd/chips/cfi_cmdset_0001.c:1935:	chip->erase_suspended = 0;
./drivers/mtd/chips/cfi_cmdset_0001.c:1939:				   chip->erase_time,
./drivers/mtd/chips/cfi_cmdset_0001.c:1940:				   chip->erase_time_max);
./drivers/mtd/chips/cfi_cmdset_0001.c:1943:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0001.c:1951:	chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0001.c:1977:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:1990:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2023:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2024:		ret = get_chip(map, chip, chip->start, FL_SYNCING);
./drivers/mtd/chips/cfi_cmdset_0001.c:2027:			chip->oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0001.c:2028:			chip->state = FL_SYNCING;
./drivers/mtd/chips/cfi_cmdset_0001.c:2034:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2042:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2044:		if (chip->state == FL_SYNCING) {
./drivers/mtd/chips/cfi_cmdset_0001.c:2045:			chip->state = chip->oldstate;
./drivers/mtd/chips/cfi_cmdset_0001.c:2046:			chip->oldstate = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0001.c:2047:			wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0001.c:2049:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2061:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0001.c:2064:	chip->state = FL_JEDEC_QUERY;
./drivers/mtd/chips/cfi_cmdset_0001.c:2093:	adr += chip->start;
./drivers/mtd/chips/cfi_cmdset_0001.c:2095:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2098:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2108:		chip->state = FL_LOCKING;
./drivers/mtd/chips/cfi_cmdset_0001.c:2111:		chip->state = FL_UNLOCKING;
./drivers/mtd/chips/cfi_cmdset_0001.c:2132:		chip->state = FL_STATUS;
./drivers/mtd/chips/cfi_cmdset_0001.c:2141:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2213:	mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2214:	ret = get_chip(map, chip, chip->start, FL_JEDEC_QUERY);
./drivers/mtd/chips/cfi_cmdset_0001.c:2216:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2221:	INVALIDATE_CACHED_RANGE(map, chip->start + offset, size);
./drivers/mtd/chips/cfi_cmdset_0001.c:2223:	xip_disable(map, chip, chip->start);
./drivers/mtd/chips/cfi_cmdset_0001.c:2224:	if (chip->state != FL_JEDEC_QUERY) {
./drivers/mtd/chips/cfi_cmdset_0001.c:2225:		map_write(map, CMD(0x90), chip->start);
./drivers/mtd/chips/cfi_cmdset_0001.c:2226:		chip->state = FL_JEDEC_QUERY;
./drivers/mtd/chips/cfi_cmdset_0001.c:2228:	map_copy_from(map, buf, chip->start + offset, size);
./drivers/mtd/chips/cfi_cmdset_0001.c:2229:	xip_enable(map, chip, chip->start);
./drivers/mtd/chips/cfi_cmdset_0001.c:2232:	INVALIDATE_CACHED_RANGE(map, chip->start + offset, size);
./drivers/mtd/chips/cfi_cmdset_0001.c:2234:	put_chip(map, chip, chip->start);
./drivers/mtd/chips/cfi_cmdset_0001.c:2235:	mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2505:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2507:		switch (chip->state) {
./drivers/mtd/chips/cfi_cmdset_0001.c:2512:			if (chip->oldstate == FL_READY) {
./drivers/mtd/chips/cfi_cmdset_0001.c:2515:				chip->oldstate = chip->state;
./drivers/mtd/chips/cfi_cmdset_0001.c:2516:				chip->state = FL_PM_SUSPENDED;
./drivers/mtd/chips/cfi_cmdset_0001.c:2523:				printk(KERN_NOTICE "Flash device refused suspend due to pending operation (oldstate %d)\n", chip->oldstate);
./drivers/mtd/chips/cfi_cmdset_0001.c:2532:			printk(KERN_NOTICE "Flash device refused suspend due to active operation (state %d)\n", chip->state);
./drivers/mtd/chips/cfi_cmdset_0001.c:2537:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2546:			mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2548:			if (chip->state == FL_PM_SUSPENDED) {
./drivers/mtd/chips/cfi_cmdset_0001.c:2552:				chip->state = chip->oldstate;
./drivers/mtd/chips/cfi_cmdset_0001.c:2553:				chip->oldstate = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0001.c:2554:				wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0001.c:2556:			mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2595:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2598:		if (chip->state == FL_PM_SUSPENDED) {
./drivers/mtd/chips/cfi_cmdset_0001.c:2602:			chip->oldstate = chip->state = FL_READY;
./drivers/mtd/chips/cfi_cmdset_0001.c:2603:			wake_up(&chip->wq);
./drivers/mtd/chips/cfi_cmdset_0001.c:2606:		mutex_unlock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2626:		mutex_lock(&chip->mutex);
./drivers/mtd/chips/cfi_cmdset_0001.c:2627:		ret = get_chip(map, chip, chip->start, FL_SHUTDOWN);
./drivers/mtd/chips/cfi_cmdset_0001.c:2629:			map_write(map, CMD(0xff), chip->start);
./drivers/mtd/chips/cfi_cmdset_0001.c:2630:			chip->state = FL_SHUTDOWN;
./drivers/mtd/chips/cfi_cmdset_0001.c:2631:			put_chip(map, chip, chip->start);
./drivers/mtd/chips/cfi_cmdset_0001.c:2633:		mutex_unlock(&chip->mutex);
./drivers/mtd/devices/spear_smi.c:361:	/* Matches chip-id to entire list of 'serial-nor flash' ids */
./drivers/mtd/devices/docg3.c:2162:	{ .compatible = "m-systems,diskonchip-g3" },
./drivers/mtd/nand/txx9ndfmc.c:184:	for (eccbytes = chip->ecc.bytes; eccbytes > 0; eccbytes -= 3) {
./drivers/mtd/nand/txx9ndfmc.c:202:	for (eccsize = chip->ecc.size; eccsize > 0; eccsize -= 256) {
./drivers/mtd/nand/txx9ndfmc.c:266:			chip->ecc.size = 512;
./drivers/mtd/nand/txx9ndfmc.c:267:			chip->ecc.bytes = 6;
./drivers/mtd/nand/txx9ndfmc.c:327:		chip->read_byte = txx9ndfmc_read_byte;
./drivers/mtd/nand/txx9ndfmc.c:328:		chip->read_buf = txx9ndfmc_read_buf;
./drivers/mtd/nand/txx9ndfmc.c:329:		chip->write_buf = txx9ndfmc_write_buf;
./drivers/mtd/nand/txx9ndfmc.c:330:		chip->cmd_ctrl = txx9ndfmc_cmd_ctrl;
./drivers/mtd/nand/txx9ndfmc.c:331:		chip->dev_ready = txx9ndfmc_dev_ready;
./drivers/mtd/nand/txx9ndfmc.c:332:		chip->ecc.calculate = txx9ndfmc_calculate_ecc;
./drivers/mtd/nand/txx9ndfmc.c:333:		chip->ecc.correct = txx9ndfmc_correct_data;
./drivers/mtd/nand/txx9ndfmc.c:334:		chip->ecc.hwctl = txx9ndfmc_enable_hwecc;
./drivers/mtd/nand/txx9ndfmc.c:335:		chip->ecc.mode = NAND_ECC_HW;
./drivers/mtd/nand/txx9ndfmc.c:337:		chip->ecc.size = 256;
./drivers/mtd/nand/txx9ndfmc.c:338:		chip->ecc.bytes = 3;
./drivers/mtd/nand/txx9ndfmc.c:339:		chip->ecc.strength = 1;
./drivers/mtd/nand/txx9ndfmc.c:340:		chip->chip_delay = 100;
./drivers/mtd/nand/txx9ndfmc.c:341:		chip->controller = &drvdata->hw_control;
./drivers/mtd/nand/txx9ndfmc.c:361:			chip->options |= NAND_BUSWIDTH_16;
./drivers/mtd/nand/nandsim.c:681:	chip->chip_delay = 0;
./drivers/mtd/nand/nandsim.c:684:	ns->busw = chip->options & NAND_BUSWIDTH_16 ? 16 : 8;
./drivers/mtd/nand/nandsim.c:693:	ns->geom.pgshift  = chip->page_shift;
./drivers/mtd/nand/nandsim.c:2151:	return chip->read_byte(mtd) | (chip->read_byte(mtd) << 8);
./drivers/mtd/nand/nandsim.c:2257:	chip->cmd_ctrl	 = ns_hwcontrol;
./drivers/mtd/nand/nandsim.c:2258:	chip->read_byte  = ns_nand_read_byte;
./drivers/mtd/nand/nandsim.c:2259:	chip->dev_ready  = ns_device_ready;
./drivers/mtd/nand/nandsim.c:2260:	chip->write_buf  = ns_nand_write_buf;
./drivers/mtd/nand/nandsim.c:2261:	chip->read_buf   = ns_nand_read_buf;
./drivers/mtd/nand/nandsim.c:2262:	chip->read_word  = ns_nand_read_word;
./drivers/mtd/nand/nandsim.c:2263:	chip->ecc.mode   = NAND_ECC_SOFT;
./drivers/mtd/nand/nandsim.c:2264:	chip->ecc.algo   = NAND_ECC_HAMMING;
./drivers/mtd/nand/nandsim.c:2267:	chip->options   |= NAND_SKIP_BBTSCAN;
./drivers/mtd/nand/nandsim.c:2271:		 chip->bbt_options |= NAND_BBT_NO_OOB;
./drivers/mtd/nand/nandsim.c:2273:		 chip->bbt_options |= NAND_BBT_USE_FLASH;
./drivers/mtd/nand/nandsim.c:2299:		chip->options |= NAND_BUSWIDTH_16;
./drivers/mtd/nand/nandsim.c:2342:		chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/nandsim.c:2343:		chip->ecc.algo = NAND_ECC_BCH;
./drivers/mtd/nand/nandsim.c:2344:		chip->ecc.size = 512;
./drivers/mtd/nand/nandsim.c:2345:		chip->ecc.strength = bch;
./drivers/mtd/nand/nandsim.c:2346:		chip->ecc.bytes = eccbytes;
./drivers/mtd/nand/nandsim.c:2347:		NS_INFO("using %u-bit/%u bytes BCH ECC\n", bch, chip->ecc.size);
./drivers/mtd/nand/nandsim.c:2367:		chip->chipsize = new_size;
./drivers/mtd/nand/nandsim.c:2368:		chip->chip_shift = ffs(nsmtd->erasesize) + overridesize - 1;
./drivers/mtd/nand/nandsim.c:2369:		chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;
./drivers/mtd/nand/nandsim.c:2381:	if ((retval = chip->scan_bbt(nsmtd)) != 0)
./drivers/mtd/nand/fsmc_nand.c:47:	if (section >= chip->ecc.steps)
./drivers/mtd/nand/fsmc_nand.c:61:	if (section >= chip->ecc.steps)
./drivers/mtd/nand/fsmc_nand.c:66:	if (section < chip->ecc.steps - 1)
./drivers/mtd/nand/fsmc_nand.c:90:	if (section >= chip->ecc.steps)
./drivers/mtd/nand/fsmc_nand.c:93:	oobregion->length = chip->ecc.bytes;
./drivers/mtd/nand/fsmc_nand.c:108:	if (section >= chip->ecc.steps)
./drivers/mtd/nand/fsmc_nand.c:113:	if (section < chip->ecc.steps - 1)
./drivers/mtd/nand/fsmc_nand.c:190:		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
./drivers/mtd/nand/fsmc_nand.c:198:					chip->options & NAND_BUSWIDTH_16);
./drivers/mtd/nand/fsmc_nand.c:202:		dev_err(host->dev, "unsupported chip-select %d\n", chipnr);
./drivers/mtd/nand/fsmc_nand.c:486:			writel_relaxed(p[i], chip->IO_ADDR_W);
./drivers/mtd/nand/fsmc_nand.c:489:			writeb_relaxed(buf[i], chip->IO_ADDR_W);
./drivers/mtd/nand/fsmc_nand.c:509:			p[i] = readl_relaxed(chip->IO_ADDR_R);
./drivers/mtd/nand/fsmc_nand.c:512:			buf[i] = readb_relaxed(chip->IO_ADDR_R);
./drivers/mtd/nand/fsmc_nand.c:548: * @oob_required:	caller expects OOB data read to chip->oob_poi
./drivers/mtd/nand/fsmc_nand.c:560:	int i, j, s, stat, eccsize = chip->ecc.size;
./drivers/mtd/nand/fsmc_nand.c:561:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/fsmc_nand.c:562:	int eccsteps = chip->ecc.steps;
./drivers/mtd/nand/fsmc_nand.c:564:	uint8_t *ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/fsmc_nand.c:565:	uint8_t *ecc_code = chip->buffers->ecccode;
./drivers/mtd/nand/fsmc_nand.c:577:		chip->cmdfunc(mtd, NAND_CMD_READ0, s * eccsize, page);
./drivers/mtd/nand/fsmc_nand.c:578:		chip->ecc.hwctl(mtd, NAND_ECC_READ);
./drivers/mtd/nand/fsmc_nand.c:579:		chip->read_buf(mtd, p, eccsize);
./drivers/mtd/nand/fsmc_nand.c:597:			if (chip->options & NAND_BUSWIDTH_16)
./drivers/mtd/nand/fsmc_nand.c:600:			chip->cmdfunc(mtd, NAND_CMD_READOOB, off, page);
./drivers/mtd/nand/fsmc_nand.c:601:			chip->read_buf(mtd, oob + j, len);
./drivers/mtd/nand/fsmc_nand.c:605:		memcpy(&ecc_code[i], oob, chip->ecc.bytes);
./drivers/mtd/nand/fsmc_nand.c:606:		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
./drivers/mtd/nand/fsmc_nand.c:608:		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
./drivers/mtd/nand/fsmc_nand.c:663:		int bits_ecc = count_written_bits(read_ecc, chip->ecc.bytes, 8);
./drivers/mtd/nand/fsmc_nand.c:664:		int bits_data = count_written_bits(dat, chip->ecc.size, 8);
./drivers/mtd/nand/fsmc_nand.c:668:				memset(dat, 0xff, chip->ecc.size);
./drivers/mtd/nand/fsmc_nand.c:703:		if (err_idx[i] < chip->ecc.size * 8) {
./drivers/mtd/nand/sunxi_nand.c:1036:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/sunxi_nand.c:1047:		u8 *oob = chip->oob_poi + oob_off;
./drivers/mtd/nand/sunxi_nand.c:1060:		sunxi_nfc_hw_ecc_read_extra_oob(mtd, chip->oob_poi, &cur_off,
./drivers/mtd/nand/sunxi_nand.c:1073:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/sunxi_nand.c:1079:	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
./drivers/mtd/nand/sunxi_nand.c:1085:		u8 *oob = chip->oob_poi + oob_off;
./drivers/mtd/nand/sunxi_nand.c:1106:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/sunxi_nand.c:1115:		const u8 *oob = chip->oob_poi + oob_off;
./drivers/mtd/nand/sunxi_nand.c:1124:	if (oob_required || (chip->options & NAND_NEED_SCRAMBLING))
./drivers/mtd/nand/sunxi_nand.c:1125:		sunxi_nfc_hw_ecc_write_extra_oob(mtd, chip->oob_poi,
./drivers/mtd/nand/sunxi_nand.c:1138:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/sunxi_nand.c:1149:		u8 *oob = chip->oob_poi + (i * (ecc->bytes + 4));
./drivers/mtd/nand/sunxi_nand.c:1163:		sunxi_nfc_hw_ecc_read_extra_oob(mtd, chip->oob_poi, &cur_off,
./drivers/mtd/nand/sunxi_nand.c:1176:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/sunxi_nand.c:1185:		const u8 *oob = chip->oob_poi + (i * (ecc->bytes + 4));
./drivers/mtd/nand/sunxi_nand.c:1194:	if (oob_required || (chip->options & NAND_NEED_SCRAMBLING))
./drivers/mtd/nand/sunxi_nand.c:1195:		sunxi_nfc_hw_ecc_write_extra_oob(mtd, chip->oob_poi,
./drivers/mtd/nand/sunxi_nand.c:1207:	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
./drivers/mtd/nand/sunxi_nand.c:1209:	chip->pagebuf = -1;
./drivers/mtd/nand/sunxi_nand.c:1211:	return chip->ecc.read_page(mtd, chip, chip->buffers->databuf, 1, page);
./drivers/mtd/nand/sunxi_nand.c:1220:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);
./drivers/mtd/nand/sunxi_nand.c:1222:	chip->pagebuf = -1;
./drivers/mtd/nand/sunxi_nand.c:1224:	memset(chip->buffers->databuf, 0xff, mtd->writesize);
./drivers/mtd/nand/sunxi_nand.c:1225:	ret = chip->ecc.write_page(mtd, chip, chip->buffers->databuf, 1, page);
./drivers/mtd/nand/sunxi_nand.c:1230:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/sunxi_nand.c:1232:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/sunxi_nand.c:1261:	struct sunxi_nfc *nfc = to_sunxi_nfc(chip->nand.controller);
./drivers/mtd/nand/sunxi_nand.c:1372:	chip->timing_cfg = NFC_TIMING_CFG(tWB, tADL, tWHR, tRHW, tCAD);
./drivers/mtd/nand/sunxi_nand.c:1383:	chip->clk_rate = NSEC_PER_SEC / min_clk_period;
./drivers/mtd/nand/sunxi_nand.c:1384:	real_clk_rate = clk_round_rate(nfc->mod_clk, chip->clk_rate);
./drivers/mtd/nand/sunxi_nand.c:1392:	chip->timing_ctl = ((min_clk_period * 2) < 30) ?
./drivers/mtd/nand/sunxi_nand.c:1401:	struct mtd_info *mtd = nand_to_mtd(&chip->nand);
./drivers/mtd/nand/sunxi_nand.c:1406:	mode = onfi_get_async_timing_mode(&chip->nand);
./drivers/mtd/nand/sunxi_nand.c:1408:		mode = chip->nand.onfi_timing_mode_default;
./drivers/mtd/nand/sunxi_nand.c:1418:		for (i = 0; i < chip->nsels; i++) {
./drivers/mtd/nand/sunxi_nand.c:1419:			chip->nand.select_chip(mtd, i);
./drivers/mtd/nand/sunxi_nand.c:1420:			ret = chip->nand.onfi_set_features(mtd,	&chip->nand,
./drivers/mtd/nand/sunxi_nand.c:1423:			chip->nand.select_chip(mtd, -1);
./drivers/mtd/nand/sunxi_nand.c:1665:	chip->nsels = nsels;
./drivers/mtd/nand/sunxi_nand.c:1666:	chip->selected = -1;
./drivers/mtd/nand/sunxi_nand.c:1688:		chip->sels[i].cs = tmp;
./drivers/mtd/nand/sunxi_nand.c:1692:			chip->sels[i].rb.type = RB_NATIVE;
./drivers/mtd/nand/sunxi_nand.c:1693:			chip->sels[i].rb.info.nativeid = tmp;
./drivers/mtd/nand/sunxi_nand.c:1698:				chip->sels[i].rb.type = RB_GPIO;
./drivers/mtd/nand/sunxi_nand.c:1699:				chip->sels[i].rb.info.gpio = tmp;
./drivers/mtd/nand/sunxi_nand.c:1708:				chip->sels[i].rb.type = RB_NONE;
./drivers/mtd/nand/sunxi_nand.c:1713:	nand = &chip->nand;
./drivers/mtd/nand/sunxi_nand.c:1784:	list_add_tail(&chip->node, &nfc->chips);
./drivers/mtd/nand/sunxi_nand.c:1819:		nand_release(nand_to_mtd(&chip->nand));
./drivers/mtd/nand/sunxi_nand.c:1820:		sunxi_nand_ecc_cleanup(&chip->nand.ecc);
./drivers/mtd/nand/sunxi_nand.c:1821:		list_del(&chip->node);
./drivers/mtd/nand/sharpsl.c:84:		writeb(cmd, chip->IO_ADDR_W);
./drivers/mtd/nand/qcom_nandc.c:227: * @buf_size/count/start:	markers for chip->read_buf/write_buf functions
./drivers/mtd/nand/qcom_nandc.c:327:	return container_of(chip->controller, struct qcom_nand_controller,
./drivers/mtd/nand/qcom_nandc.c:398:	if (chip->options & NAND_BUSWIDTH_16)
./drivers/mtd/nand/qcom_nandc.c:642: * the following functions are used within chip->cmdfunc() to perform different
./drivers/mtd/nand/qcom_nandc.c:829:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:868: * Implements chip->cmdfunc. It's  only used for a limited set of commands.
./drivers/mtd/nand/qcom_nandc.c:878:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1012:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1102:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1164:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1201:	oob_buf = oob_required ? chip->oob_poi : NULL;
./drivers/mtd/nand/qcom_nandc.c:1220:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1224:	oob_buf = chip->oob_poi;
./drivers/mtd/nand/qcom_nandc.c:1279:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1288:	ret = read_page_ecc(host, NULL, chip->oob_poi);
./drivers/mtd/nand/qcom_nandc.c:1301:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1308:	oob_buf = chip->oob_poi;
./drivers/mtd/nand/qcom_nandc.c:1365:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1372:	oob_buf = chip->oob_poi;
./drivers/mtd/nand/qcom_nandc.c:1429: * with the new one in chip->oob_poi, and then write the entire codeword.
./drivers/mtd/nand/qcom_nandc.c:1437:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1438:	u8 *oob = chip->oob_poi;
./drivers/mtd/nand/qcom_nandc.c:1475:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/qcom_nandc.c:1477:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/qcom_nandc.c:1487:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1491:	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
./drivers/mtd/nand/qcom_nandc.c:1516:	if (chip->options & NAND_BUSWIDTH_16)
./drivers/mtd/nand/qcom_nandc.c:1527:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1539:	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
./drivers/mtd/nand/qcom_nandc.c:1559:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/qcom_nandc.c:1561:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/qcom_nandc.c:1567: * the three functions below implement chip->read_byte(), chip->read_buf()
./drivers/mtd/nand/qcom_nandc.c:1568: * and chip->write_buf() respectively. these aren't used for
./drivers/mtd/nand/qcom_nandc.c:1718:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1740:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1760:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/qcom_nandc.c:1775:	wide_bus = chip->options & NAND_BUSWIDTH_16 ? true : false;
./drivers/mtd/nand/qcom_nandc.c:1998:		dev_err(dev, "can't get chip-select\n");
./drivers/mtd/nand/qcom_nandc.c:2007:	chip->cmdfunc		= qcom_nandc_command;
./drivers/mtd/nand/qcom_nandc.c:2008:	chip->select_chip	= qcom_nandc_select_chip;
./drivers/mtd/nand/qcom_nandc.c:2009:	chip->read_byte		= qcom_nandc_read_byte;
./drivers/mtd/nand/qcom_nandc.c:2010:	chip->read_buf		= qcom_nandc_read_buf;
./drivers/mtd/nand/qcom_nandc.c:2011:	chip->write_buf		= qcom_nandc_write_buf;
./drivers/mtd/nand/qcom_nandc.c:2021:	chip->block_bad		= qcom_nandc_block_bad;
./drivers/mtd/nand/qcom_nandc.c:2022:	chip->block_markbad	= qcom_nandc_block_markbad;
./drivers/mtd/nand/qcom_nandc.c:2024:	chip->controller = &nandc->controller;
./drivers/mtd/nand/qcom_nandc.c:2025:	chip->options |= NAND_NO_SUBPAGE_WRITE | NAND_USE_BOUNCE_BUFFER |
./drivers/mtd/nand/r852.c:369:	timeout = jiffies + (chip->state == FL_ERASING ?
./drivers/mtd/nand/r852.c:373:		if (chip->dev_ready(mtd))
./drivers/mtd/nand/r852.c:376:	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
./drivers/mtd/nand/r852.c:377:	status = (int)chip->read_byte(mtd);
./drivers/mtd/nand/r852.c:525:	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
./drivers/mtd/nand/r852.c:526:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/r852.c:644:		dev->chip->options |= NAND_ROM;
./drivers/mtd/nand/r852.c:855:	chip->cmd_ctrl = r852_cmdctl;
./drivers/mtd/nand/r852.c:856:	chip->waitfunc = r852_wait;
./drivers/mtd/nand/r852.c:857:	chip->dev_ready = r852_ready;
./drivers/mtd/nand/r852.c:860:	chip->read_byte = r852_read_byte;
./drivers/mtd/nand/r852.c:861:	chip->read_buf = r852_read_buf;
./drivers/mtd/nand/r852.c:862:	chip->write_buf = r852_write_buf;
./drivers/mtd/nand/r852.c:865:	chip->ecc.mode = NAND_ECC_HW_SYNDROME;
./drivers/mtd/nand/r852.c:866:	chip->ecc.size = R852_DMA_LEN;
./drivers/mtd/nand/r852.c:867:	chip->ecc.bytes = SM_OOB_SIZE;
./drivers/mtd/nand/r852.c:868:	chip->ecc.strength = 2;
./drivers/mtd/nand/r852.c:869:	chip->ecc.hwctl = r852_ecc_hwctl;
./drivers/mtd/nand/r852.c:870:	chip->ecc.calculate = r852_ecc_calculate;
./drivers/mtd/nand/r852.c:871:	chip->ecc.correct = r852_ecc_correct;
./drivers/mtd/nand/r852.c:874:	chip->ecc.read_oob = r852_read_oob;
./drivers/mtd/nand/r852.c:1048:		dev->chip->select_chip(mtd, 0);
./drivers/mtd/nand/r852.c:1049:		dev->chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
./drivers/mtd/nand/r852.c:1050:		dev->chip->select_chip(mtd, -1);
./drivers/mtd/nand/socrates_nand.c:172:	nand_chip->IO_ADDR_R = (void *)0xdeadbeef;
./drivers/mtd/nand/socrates_nand.c:173:	nand_chip->IO_ADDR_W = (void *)0xdeadbeef;
./drivers/mtd/nand/socrates_nand.c:175:	nand_chip->cmd_ctrl = socrates_nand_cmd_ctrl;
./drivers/mtd/nand/socrates_nand.c:176:	nand_chip->read_byte = socrates_nand_read_byte;
./drivers/mtd/nand/socrates_nand.c:177:	nand_chip->read_word = socrates_nand_read_word;
./drivers/mtd/nand/socrates_nand.c:178:	nand_chip->write_buf = socrates_nand_write_buf;
./drivers/mtd/nand/socrates_nand.c:179:	nand_chip->read_buf = socrates_nand_read_buf;
./drivers/mtd/nand/socrates_nand.c:180:	nand_chip->dev_ready = socrates_nand_device_ready;
./drivers/mtd/nand/socrates_nand.c:182:	nand_chip->ecc.mode = NAND_ECC_SOFT;	/* enable ECC */
./drivers/mtd/nand/socrates_nand.c:183:	nand_chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/socrates_nand.c:186:	nand_chip->chip_delay = 20;		/* 20us command delay time */
./drivers/mtd/nand/fsl_ifc_nand.c:105:	oobregion->length = chip->ecc.total;
./drivers/mtd/nand/fsl_ifc_nand.c:119:	    !(chip->options & NAND_BUSWIDTH_16)) {
./drivers/mtd/nand/fsl_ifc_nand.c:135:		oobregion->offset = chip->ecc.total + 8;
./drivers/mtd/nand/fsl_ifc_nand.c:259:		int sector = bufnum * chip->ecc.steps;
./drivers/mtd/nand/fsl_ifc_nand.c:260:		int sector_end = sector + chip->ecc.steps - 1;
./drivers/mtd/nand/fsl_ifc_nand.c:355:		if (chip->ecc.mode == NAND_ECC_HW)
./drivers/mtd/nand/fsl_ifc_nand.c:518:		if (chip->options & NAND_BUSWIDTH_16)
./drivers/mtd/nand/fsl_ifc_nand.c:684:		fsl_ifc_read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/fsl_ifc_nand.c:702:	fsl_ifc_write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/fsl_ifc_nand.c:713:							chip->numchips);
./drivers/mtd/nand/fsl_ifc_nand.c:715:							chip->chipsize);
./drivers/mtd/nand/fsl_ifc_nand.c:717:							chip->pagemask);
./drivers/mtd/nand/fsl_ifc_nand.c:719:							chip->chip_delay);
./drivers/mtd/nand/fsl_ifc_nand.c:721:							chip->badblockpos);
./drivers/mtd/nand/fsl_ifc_nand.c:723:							chip->chip_shift);
./drivers/mtd/nand/fsl_ifc_nand.c:725:							chip->page_shift);
./drivers/mtd/nand/fsl_ifc_nand.c:727:							chip->phys_erase_shift);
./drivers/mtd/nand/fsl_ifc_nand.c:729:							chip->ecc.mode);
./drivers/mtd/nand/fsl_ifc_nand.c:731:							chip->ecc.steps);
./drivers/mtd/nand/fsl_ifc_nand.c:733:							chip->ecc.bytes);
./drivers/mtd/nand/fsl_ifc_nand.c:735:							chip->ecc.total);
./drivers/mtd/nand/fsl_ifc_nand.c:819:		chip->read_byte = fsl_ifc_read_byte16;
./drivers/mtd/nand/fsl_ifc_nand.c:821:		chip->read_byte = fsl_ifc_read_byte;
./drivers/mtd/nand/fsl_ifc_nand.c:823:	chip->write_buf = fsl_ifc_write_buf;
./drivers/mtd/nand/fsl_ifc_nand.c:824:	chip->read_buf = fsl_ifc_read_buf;
./drivers/mtd/nand/fsl_ifc_nand.c:825:	chip->select_chip = fsl_ifc_select_chip;
./drivers/mtd/nand/fsl_ifc_nand.c:826:	chip->cmdfunc = fsl_ifc_cmdfunc;
./drivers/mtd/nand/fsl_ifc_nand.c:827:	chip->waitfunc = fsl_ifc_wait;
./drivers/mtd/nand/fsl_ifc_nand.c:829:	chip->bbt_td = &bbt_main_descr;
./drivers/mtd/nand/fsl_ifc_nand.c:830:	chip->bbt_md = &bbt_mirror_descr;
./drivers/mtd/nand/fsl_ifc_nand.c:835:	chip->bbt_options = NAND_BBT_USE_FLASH;
./drivers/mtd/nand/fsl_ifc_nand.c:836:	chip->options = NAND_NO_SUBPAGE_WRITE;
./drivers/mtd/nand/fsl_ifc_nand.c:840:		chip->read_byte = fsl_ifc_read_byte16;
./drivers/mtd/nand/fsl_ifc_nand.c:841:		chip->options |= NAND_BUSWIDTH_16;
./drivers/mtd/nand/fsl_ifc_nand.c:843:		chip->read_byte = fsl_ifc_read_byte;
./drivers/mtd/nand/fsl_ifc_nand.c:846:	chip->controller = &ifc_nand_ctrl->controller;
./drivers/mtd/nand/fsl_ifc_nand.c:849:	chip->ecc.read_page = fsl_ifc_read_page;
./drivers/mtd/nand/fsl_ifc_nand.c:850:	chip->ecc.write_page = fsl_ifc_write_page;
./drivers/mtd/nand/fsl_ifc_nand.c:856:		if (!(chip->options & NAND_BUSWIDTH_16)) {
./drivers/mtd/nand/fsl_ifc_nand.c:884:		chip->ecc.mode = NAND_ECC_HW;
./drivers/mtd/nand/fsl_ifc_nand.c:888:		chip->ecc.size = 512;
./drivers/mtd/nand/fsl_ifc_nand.c:890:			chip->ecc.bytes = 8;
./drivers/mtd/nand/fsl_ifc_nand.c:891:			chip->ecc.strength = 4;
./drivers/mtd/nand/fsl_ifc_nand.c:893:			chip->ecc.bytes = 16;
./drivers/mtd/nand/fsl_ifc_nand.c:894:			chip->ecc.strength = 8;
./drivers/mtd/nand/fsl_ifc_nand.c:897:		chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/fsl_ifc_nand.c:898:		chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:179:	if (!(chip->ecc_strength_ds > 0 && chip->ecc_step_ds > 0))
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:182:	switch (chip->ecc_step_ds) {
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:192:			chip->ecc_strength_ds, chip->ecc_step_ds);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:195:	geo->ecc_chunk_size = chip->ecc_step_ds;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:196:	geo->ecc_strength = round_up(chip->ecc_strength_ds, 2);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:204:			chip->ecc_step_ds, mtd->oobsize);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1091:			chip->cmdfunc(mtd, NAND_CMD_RNDOUT, offset, -1);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1092:			chip->read_buf(mtd, eccbuf, eccbytes);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1163:		memset(chip->oob_poi, ~0, mtd->oobsize);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1164:		chip->oob_poi[0] = ((uint8_t *) auxiliary_virt)[0];
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1178:	int size = chip->ecc.size; /* ECC chunk size */
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1214:		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1281:		memcpy(this->auxiliary_virt, chip->oob_poi,
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1305:				chip->oob_poi, mtd->oobsize,
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1321:		send_page_end(this, chip->oob_poi, mtd->oobsize,
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1402:	memset(chip->oob_poi, ~0, mtd->oobsize);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1405:	chip->cmdfunc(mtd, NAND_CMD_READ0, mtd->writesize, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1406:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1415:		chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1416:		chip->oob_poi[0] = chip->read_byte(mtd);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1436:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize + of.offset, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1437:	chip->write_buf(mtd, chip->oob_poi + of.offset, of.length);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1438:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1440:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1468:	uint8_t *oob = chip->oob_poi;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1471:	chip->read_buf(mtd, tmp_buf,
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1554:	uint8_t *oob = chip->oob_poi;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1616:	chip->write_buf(mtd, tmp_buf, mtd->writesize + mtd->oobsize);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1624:	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1632:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1645:	chipnr = (int)(ofs >> chip->chip_shift);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1646:	chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1655:	page = (int)(ofs >> chip->page_shift);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1657:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, column, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1658:	chip->write_buf(mtd, block_mark, 1);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1659:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1661:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1665:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1706:	uint8_t *buffer = chip->buffers->databuf;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1714:	chip->select_chip(mtd, 0);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1731:		chip->cmdfunc(mtd, NAND_CMD_READ0, 12, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1732:		chip->read_buf(mtd, buffer, strlen(fingerprint));
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1742:	chip->select_chip(mtd, saved_chip_number);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1765:	uint8_t      *buffer = chip->buffers->databuf;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1785:	chip->select_chip(mtd, 0);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1796:		chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1797:		chip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1800:		status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1817:		chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1818:		chip->ecc.write_page_raw(mtd, chip, buffer, 0, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1819:		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1822:		status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1828:	chip->select_chip(mtd, saved_chip_number);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1861:	block_count = chip->chipsize >> chip->phys_erase_shift;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1872:		chipnr = block >> (chip->chip_shift - chip->phys_erase_shift);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1873:		page = block << (chip->phys_erase_shift - chip->page_shift);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1874:		byte = block <<  chip->phys_erase_shift;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1877:		chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1878:		chip->cmdfunc(mtd, NAND_CMD_READ0, mtd->writesize, page);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1879:		block_mark = chip->read_byte(mtd);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1880:		chip->select_chip(mtd, -1);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1889:			ret = chip->block_markbad(mtd, byte);
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1940:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:1971:		chip->options |= NAND_SUBPAGE_READ;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2001:	chip->select_chip	= gpmi_select_chip;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2002:	chip->cmd_ctrl		= gpmi_cmd_ctrl;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2003:	chip->dev_ready		= gpmi_dev_ready;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2004:	chip->read_byte		= gpmi_read_byte;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2005:	chip->read_buf		= gpmi_read_buf;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2006:	chip->write_buf		= gpmi_write_buf;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2007:	chip->badblock_pattern	= &gpmi_bbt_descr;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2008:	chip->block_markbad	= gpmi_block_markbad;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2009:	chip->options		|= NAND_NO_SUBPAGE_WRITE;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2028:	if (chip->bbt_options & NAND_BBT_USE_FLASH) {
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2029:		chip->bbt_options |= NAND_BBT_NO_OOB;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2042:	chip->options |= NAND_SKIP_BBTSCAN;
./drivers/mtd/nand/gpmi-nand/gpmi-nand.c:2050:	ret = chip->scan_bbt(mtd);
./drivers/mtd/nand/gpmi-nand/gpmi-lib.c:974:	if (GPMI_IS_MX6(this) && chip->onfi_version) {
./drivers/mtd/nand/xway_nand.c:59:	unsigned long nandaddr = (unsigned long) chip->IO_ADDR_W;
./drivers/mtd/nand/nand_bch.c:54:	struct nand_bch_control *nbc = chip->ecc.priv;
./drivers/mtd/nand/nand_bch.c:57:	memset(code, 0, chip->ecc.bytes);
./drivers/mtd/nand/nand_bch.c:58:	encode_bch(nbc->bch, buf, chip->ecc.size, code);
./drivers/mtd/nand/nand_bch.c:61:	for (i = 0; i < chip->ecc.bytes; i++)
./drivers/mtd/nand/nand_bch.c:81:	struct nand_bch_control *nbc = chip->ecc.priv;
./drivers/mtd/nand/nand_bch.c:85:	count = decode_bch(nbc->bch, NULL, chip->ecc.size, read_ecc, calc_ecc,
./drivers/mtd/nand/nand_bch.c:89:			if (errloc[i] < (chip->ecc.size*8))
./drivers/mtd/nand/mpc5121_nfc.c:249:	u32 pagemask = chip->pagemask;
./drivers/mtd/nand/mpc5121_nfc.c:396:		if (chip->options & NAND_BUSWIDTH_16)
./drivers/mtd/nand/mpc5121_nfc.c:601:		chip->options |= NAND_BUSWIDTH_16;
./drivers/mtd/nand/mpc5121_nfc.c:704:	chip->dev_ready = mpc5121_nfc_dev_ready;
./drivers/mtd/nand/mpc5121_nfc.c:705:	chip->cmdfunc = mpc5121_nfc_command;
./drivers/mtd/nand/mpc5121_nfc.c:706:	chip->read_byte = mpc5121_nfc_read_byte;
./drivers/mtd/nand/mpc5121_nfc.c:707:	chip->read_word = mpc5121_nfc_read_word;
./drivers/mtd/nand/mpc5121_nfc.c:708:	chip->read_buf = mpc5121_nfc_read_buf;
./drivers/mtd/nand/mpc5121_nfc.c:709:	chip->write_buf = mpc5121_nfc_write_buf;
./drivers/mtd/nand/mpc5121_nfc.c:710:	chip->select_chip = mpc5121_nfc_select_chip;
./drivers/mtd/nand/mpc5121_nfc.c:711:	chip->bbt_options = NAND_BBT_USE_FLASH;
./drivers/mtd/nand/mpc5121_nfc.c:712:	chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/mpc5121_nfc.c:713:	chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/mpc5121_nfc.c:715:	/* Support external chip-select logic on ADS5121 board */
./drivers/mtd/nand/mpc5121_nfc.c:723:		chip->select_chip = ads5121_select_chip;
./drivers/mtd/nand/s3c2410.c:816:	chip->write_buf    = s3c2410_nand_write_buf;
./drivers/mtd/nand/s3c2410.c:817:	chip->read_buf     = s3c2410_nand_read_buf;
./drivers/mtd/nand/s3c2410.c:818:	chip->select_chip  = s3c2410_nand_select_chip;
./drivers/mtd/nand/s3c2410.c:819:	chip->chip_delay   = 50;
./drivers/mtd/nand/s3c2410.c:821:	chip->options	   = set->options;
./drivers/mtd/nand/s3c2410.c:822:	chip->controller   = &info->controller;
./drivers/mtd/nand/s3c2410.c:826:		chip->IO_ADDR_W = regs + S3C2410_NFDATA;
./drivers/mtd/nand/s3c2410.c:829:		chip->cmd_ctrl  = s3c2410_nand_hwcontrol;
./drivers/mtd/nand/s3c2410.c:830:		chip->dev_ready = s3c2410_nand_devready;
./drivers/mtd/nand/s3c2410.c:834:		chip->IO_ADDR_W = regs + S3C2440_NFDATA;
./drivers/mtd/nand/s3c2410.c:837:		chip->cmd_ctrl  = s3c2440_nand_hwcontrol;
./drivers/mtd/nand/s3c2410.c:838:		chip->dev_ready = s3c2440_nand_devready;
./drivers/mtd/nand/s3c2410.c:839:		chip->read_buf  = s3c2440_nand_read_buf;
./drivers/mtd/nand/s3c2410.c:840:		chip->write_buf	= s3c2440_nand_write_buf;
./drivers/mtd/nand/s3c2410.c:844:		chip->IO_ADDR_W = regs + S3C2440_NFDATA;
./drivers/mtd/nand/s3c2410.c:847:		chip->cmd_ctrl  = s3c2440_nand_hwcontrol;
./drivers/mtd/nand/s3c2410.c:848:		chip->dev_ready = s3c2412_nand_devready;
./drivers/mtd/nand/s3c2410.c:856:	chip->IO_ADDR_R = chip->IO_ADDR_W;
./drivers/mtd/nand/s3c2410.c:862:	chip->ecc.calculate = s3c2410_nand_calculate_ecc;
./drivers/mtd/nand/s3c2410.c:863:	chip->ecc.correct   = s3c2410_nand_correct_data;
./drivers/mtd/nand/s3c2410.c:864:	chip->ecc.mode	    = NAND_ECC_NONE;//NAND_ECC_HW;
./drivers/mtd/nand/s3c2410.c:865:	chip->ecc.strength  = 1;
./drivers/mtd/nand/s3c2410.c:869:		chip->ecc.hwctl	    = s3c2410_nand_enable_hwecc;
./drivers/mtd/nand/s3c2410.c:870:		chip->ecc.calculate = s3c2410_nand_calculate_ecc;
./drivers/mtd/nand/s3c2410.c:874:		chip->ecc.hwctl     = s3c2412_nand_enable_hwecc;
./drivers/mtd/nand/s3c2410.c:875:		chip->ecc.calculate = s3c2412_nand_calculate_ecc;
./drivers/mtd/nand/s3c2410.c:879:		chip->ecc.hwctl     = s3c2440_nand_enable_hwecc;
./drivers/mtd/nand/s3c2410.c:880:		chip->ecc.calculate = s3c2440_nand_calculate_ecc;
./drivers/mtd/nand/s3c2410.c:884:	chip->ecc.mode	    = NAND_ECC_NONE;//NAND_ECC_SOFT;
./drivers/mtd/nand/s3c2410.c:885:	chip->ecc.algo	= NAND_ECC_HAMMING;
./drivers/mtd/nand/s3c2410.c:889:		chip->ecc.mode	= NAND_ECC_NONE;
./drivers/mtd/nand/s3c2410.c:891:	switch (chip->ecc.mode) {
./drivers/mtd/nand/s3c2410.c:910:		chip->bbt_options |= NAND_BBT_USE_FLASH;
./drivers/mtd/nand/s3c2410.c:911:		chip->options |= NAND_SKIP_BBTSCAN;
./drivers/mtd/nand/s3c2410.c:932:		chip, chip->page_shift);
./drivers/mtd/nand/s3c2410.c:934:	if (chip->ecc.mode != NAND_ECC_HW)
./drivers/mtd/nand/s3c2410.c:940:	if (chip->page_shift > 10) {
./drivers/mtd/nand/s3c2410.c:941:		chip->ecc.size	    = 256;
./drivers/mtd/nand/s3c2410.c:942:		chip->ecc.bytes	    = 3;
./drivers/mtd/nand/s3c2410.c:944:		chip->ecc.size	    = 512;
./drivers/mtd/nand/s3c2410.c:945:		chip->ecc.bytes	    = 3;
./drivers/mtd/nand/hisi504_nand.c:198:	if (chip->ecc.mode == NAND_ECC_NONE) {
./drivers/mtd/nand/hisi504_nand.c:424:		if (chip->options & NAND_BUSWIDTH_16 &&
./drivers/mtd/nand/hisi504_nand.c:436:		if (chip->chipsize > (128 << 20)) {
./drivers/mtd/nand/hisi504_nand.c:494:		if (chip->ecc.mode == NAND_ECC_HW)
./drivers/mtd/nand/hisi504_nand.c:548:	chip->read_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/hisi504_nand.c:549:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/hisi504_nand.c:556:		switch (chip->ecc.strength) {
./drivers/mtd/nand/hisi504_nand.c:578:	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
./drivers/mtd/nand/hisi504_nand.c:579:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/hisi504_nand.c:594:	chip->write_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/hisi504_nand.c:596:		chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/hisi504_nand.c:620:		| ((chip->options & NAND_BUSWIDTH_16) ?
./drivers/mtd/nand/hisi504_nand.c:665:	size = chip->ecc.size;
./drivers/mtd/nand/hisi504_nand.c:666:	strength = chip->ecc.strength;
./drivers/mtd/nand/hisi504_nand.c:678:	chip->ecc.size = size;
./drivers/mtd/nand/hisi504_nand.c:679:	chip->ecc.strength = strength;
./drivers/mtd/nand/hisi504_nand.c:681:	chip->ecc.read_page = hisi_nand_read_page_hwecc;
./drivers/mtd/nand/hisi504_nand.c:682:	chip->ecc.read_oob = hisi_nand_read_oob;
./drivers/mtd/nand/hisi504_nand.c:683:	chip->ecc.write_page = hisi_nand_write_page_hwecc;
./drivers/mtd/nand/hisi504_nand.c:685:	switch (chip->ecc.strength) {
./drivers/mtd/nand/hisi504_nand.c:696:		dev_err(dev, "not support strength: %d\n", chip->ecc.strength);
./drivers/mtd/nand/hisi504_nand.c:760:	chip->cmdfunc		= hisi_nfc_cmdfunc;
./drivers/mtd/nand/hisi504_nand.c:761:	chip->select_chip	= hisi_nfc_select_chip;
./drivers/mtd/nand/hisi504_nand.c:762:	chip->read_byte		= hisi_nfc_read_byte;
./drivers/mtd/nand/hisi504_nand.c:763:	chip->read_word		= hisi_nfc_read_word;
./drivers/mtd/nand/hisi504_nand.c:764:	chip->write_buf		= hisi_nfc_write_buf;
./drivers/mtd/nand/hisi504_nand.c:765:	chip->read_buf		= hisi_nfc_read_buf;
./drivers/mtd/nand/hisi504_nand.c:766:	chip->chip_delay	= HINFC504_CHIP_DELAY;
./drivers/mtd/nand/hisi504_nand.c:808:	if (chip->ecc.mode == NAND_ECC_HW)
./drivers/mtd/nand/hisi504_nand.c:867:	for (cs = 0; cs < chip->numchips; cs++)
./drivers/mtd/nand/pasemi_nand.c:51:		memcpy_fromio(buf, chip->IO_ADDR_R, 0x800);
./drivers/mtd/nand/pasemi_nand.c:55:	memcpy_fromio(buf, chip->IO_ADDR_R, len);
./drivers/mtd/nand/pasemi_nand.c:63:		memcpy_toio(chip->IO_ADDR_R, buf, 0x800);
./drivers/mtd/nand/pasemi_nand.c:67:	memcpy_toio(chip->IO_ADDR_R, buf, len);
./drivers/mtd/nand/pasemi_nand.c:79:		out_8(chip->IO_ADDR_W + (1 << CLE_PIN_CTL), cmd);
./drivers/mtd/nand/pasemi_nand.c:81:		out_8(chip->IO_ADDR_W + (1 << ALE_PIN_CTL), cmd);
./drivers/mtd/nand/pasemi_nand.c:125:	chip->IO_ADDR_R = of_iomap(np, 0);
./drivers/mtd/nand/pasemi_nand.c:126:	chip->IO_ADDR_W = chip->IO_ADDR_R;
./drivers/mtd/nand/pasemi_nand.c:128:	if (!chip->IO_ADDR_R) {
./drivers/mtd/nand/pasemi_nand.c:147:	chip->cmd_ctrl = pasemi_hwcontrol;
./drivers/mtd/nand/pasemi_nand.c:148:	chip->dev_ready = pasemi_device_ready;
./drivers/mtd/nand/pasemi_nand.c:149:	chip->read_buf = pasemi_read_buf;
./drivers/mtd/nand/pasemi_nand.c:150:	chip->write_buf = pasemi_write_buf;
./drivers/mtd/nand/pasemi_nand.c:151:	chip->chip_delay = 0;
./drivers/mtd/nand/pasemi_nand.c:152:	chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/pasemi_nand.c:153:	chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/pasemi_nand.c:156:	chip->bbt_options = NAND_BBT_USE_FLASH;
./drivers/mtd/nand/pasemi_nand.c:178:	iounmap(chip->IO_ADDR_R);
./drivers/mtd/nand/pasemi_nand.c:199:	iounmap(chip->IO_ADDR_R);
./drivers/mtd/nand/atmel_nand.c:252:		chip->dev_ready = atmel_nand_device_ready;
./drivers/mtd/nand/atmel_nand.c:289:		__raw_readsb(nand_chip->IO_ADDR_R, buf, len);
./drivers/mtd/nand/atmel_nand.c:302:		__raw_readsw(nand_chip->IO_ADDR_R, buf, len / 2);
./drivers/mtd/nand/atmel_nand.c:310:	__raw_writesb(nand_chip->IO_ADDR_W, buf, len);
./drivers/mtd/nand/atmel_nand.c:317:	__raw_writesw(nand_chip->IO_ADDR_W, buf, len / 2);
./drivers/mtd/nand/atmel_nand.c:449:	if (chip->options & NAND_BUSWIDTH_16)
./drivers/mtd/nand/atmel_nand.c:464:	if (chip->options & NAND_BUSWIDTH_16)
./drivers/mtd/nand/atmel_nand.c:830:			tmp = sector_num * nand_chip->ecc.bytes
./drivers/mtd/nand/atmel_nand.c:857:	for (i = 0; i < nand_chip->ecc.steps; i++) {
./drivers/mtd/nand/atmel_nand.c:869:						   nand_chip->ecc.bytes,
./drivers/mtd/nand/atmel_nand.c:872:				u8 *ecc_pos = ecc + (i * nand_chip->ecc.bytes);
./drivers/mtd/nand/atmel_nand.c:878:							nand_chip->ecc.bytes,
./drivers/mtd/nand/atmel_nand.c:880:							nand_chip->ecc.strength);
./drivers/mtd/nand/atmel_nand.c:926:	int eccsize = chip->ecc.size * chip->ecc.steps;
./drivers/mtd/nand/atmel_nand.c:927:	uint8_t *oob = chip->oob_poi;
./drivers/mtd/nand/atmel_nand.c:935:	chip->read_buf(mtd, buf, eccsize);
./drivers/mtd/nand/atmel_nand.c:936:	chip->read_buf(mtd, oob, mtd->oobsize);
./drivers/mtd/nand/atmel_nand.c:973:		chip->write_buf(mtd, (u8 *)buf, mtd->writesize);
./drivers/mtd/nand/atmel_nand.c:985:	for (i = 0; i < chip->ecc.steps; i++) {
./drivers/mtd/nand/atmel_nand.c:986:		for (j = 0; j < chip->ecc.bytes; j++) {
./drivers/mtd/nand/atmel_nand.c:990:			chip->oob_poi[oobregion.offset] =
./drivers/mtd/nand/atmel_nand.c:997:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/atmel_nand.c:1039:	switch (nand_chip->ecc.steps) {
./drivers/mtd/nand/atmel_nand.c:1209:		nand_chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/atmel_nand.c:1210:		nand_chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/atmel_nand.c:1252:	nand_chip->ecc.size = sector_size;
./drivers/mtd/nand/atmel_nand.c:1274:		nand_chip->ecc.strength = cap;
./drivers/mtd/nand/atmel_nand.c:1275:		nand_chip->ecc.bytes = pmecc_get_ecc_bytes(cap, sector_size);
./drivers/mtd/nand/atmel_nand.c:1276:		nand_chip->ecc.steps = mtd->writesize / sector_size;
./drivers/mtd/nand/atmel_nand.c:1277:		nand_chip->ecc.total = nand_chip->ecc.bytes *
./drivers/mtd/nand/atmel_nand.c:1278:			nand_chip->ecc.steps;
./drivers/mtd/nand/atmel_nand.c:1279:		if (nand_chip->ecc.total >
./drivers/mtd/nand/atmel_nand.c:1293:		nand_chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/atmel_nand.c:1294:		nand_chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/atmel_nand.c:1306:	nand_chip->options |= NAND_NO_SUBPAGE_WRITE;
./drivers/mtd/nand/atmel_nand.c:1307:	nand_chip->ecc.read_page = atmel_nand_pmecc_read_page;
./drivers/mtd/nand/atmel_nand.c:1308:	nand_chip->ecc.write_page = atmel_nand_pmecc_write_page;
./drivers/mtd/nand/atmel_nand.c:1355: * oob_required:    caller expects OOB data read to chip->oob_poi
./drivers/mtd/nand/atmel_nand.c:1360:	int eccsize = chip->ecc.size;
./drivers/mtd/nand/atmel_nand.c:1361:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/atmel_nand.c:1363:	uint8_t *oob = chip->oob_poi;
./drivers/mtd/nand/atmel_nand.c:1382:	chip->read_buf(mtd, p, eccsize);
./drivers/mtd/nand/atmel_nand.c:1393:		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
./drivers/mtd/nand/atmel_nand.c:1399:	chip->read_buf(mtd, ecc_pos, eccbytes);
./drivers/mtd/nand/atmel_nand.c:1402:	stat = chip->ecc.correct(mtd, p, oob, NULL);
./drivers/mtd/nand/atmel_nand.c:1412:	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);
./drivers/mtd/nand/atmel_nand.c:1415:	chip->read_buf(mtd, oob, mtd->oobsize);
./drivers/mtd/nand/atmel_nand.c:1485:	if (nand_chip->options & NAND_BUSWIDTH_16) {
./drivers/mtd/nand/atmel_nand.c:1629:		nand_chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/atmel_nand.c:1630:		nand_chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/atmel_nand.c:1639:	nand_chip->ecc.size = mtd->writesize;
./drivers/mtd/nand/atmel_nand.c:1662:		nand_chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/atmel_nand.c:1663:		nand_chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/atmel_nand.c:1668:	nand_chip->ecc.calculate = atmel_nand_calculate;
./drivers/mtd/nand/atmel_nand.c:1669:	nand_chip->ecc.correct = atmel_nand_correct;
./drivers/mtd/nand/atmel_nand.c:1670:	nand_chip->ecc.hwctl = atmel_nand_hwctl;
./drivers/mtd/nand/atmel_nand.c:1671:	nand_chip->ecc.read_page = atmel_nand_read_page;
./drivers/mtd/nand/atmel_nand.c:1672:	nand_chip->ecc.bytes = 4;
./drivers/mtd/nand/atmel_nand.c:1673:	nand_chip->ecc.strength = 1;
./drivers/mtd/nand/atmel_nand.c:1848:		if (chip->options & NAND_BUSWIDTH_16 &&
./drivers/mtd/nand/atmel_nand.c:1859:		if (chip->chipsize > (128 << 20))
./drivers/mtd/nand/atmel_nand.c:1902:		udelay(chip->chip_delay);
./drivers/mtd/nand/atmel_nand.c:1906:		while (!(chip->read_byte(mtd) & NAND_STATUS_READY)) {
./drivers/mtd/nand/atmel_nand.c:1942:			if (chip->ecc.mode == NAND_ECC_HW && host->has_pmecc)
./drivers/mtd/nand/atmel_nand.c:2022:		memcpy(sram + len, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/atmel_nand.c:2029:	if (chip->ecc.mode == NAND_ECC_HW && host->has_pmecc)
./drivers/mtd/nand/atmel_nand.c:2038:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
./drivers/mtd/nand/atmel_nand.c:2043:		status = chip->ecc.write_page(mtd, chip, buf, oob_required,
./drivers/mtd/nand/atmel_nand.c:2049:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/atmel_nand.c:2050:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/atmel_nand.c:2052:	if ((status & NAND_STATUS_FAIL) && (chip->errstat))
./drivers/mtd/nand/atmel_nand.c:2053:		status = chip->errstat(mtd, chip, FL_WRITING, status, page);
./drivers/mtd/nand/atmel_nand.c:2108:		if ((chip->ecc.mode == NAND_ECC_HW && host->has_pmecc) ||
./drivers/mtd/nand/atmel_nand.c:2109:				chip->ecc.mode == NAND_ECC_NONE)
./drivers/mtd/nand/atmel_nand.c:2110:			chip->write_page = nfc_sram_write_page;
./drivers/mtd/nand/atmel_nand.c:2161:		nand_chip->ecc.mode = host->board.ecc_mode;
./drivers/mtd/nand/atmel_nand.c:2168:		if (nand_chip->ecc.mode == NAND_ECC_SOFT)
./drivers/mtd/nand/atmel_nand.c:2169:			nand_chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/atmel_nand.c:2173:			nand_chip->options |= NAND_BUSWIDTH_16;
./drivers/mtd/nand/atmel_nand.c:2181:	nand_chip->IO_ADDR_R = host->io_base;
./drivers/mtd/nand/atmel_nand.c:2182:	nand_chip->IO_ADDR_W = host->io_base;
./drivers/mtd/nand/atmel_nand.c:2188:		nand_chip->select_chip = nfc_select_chip;
./drivers/mtd/nand/atmel_nand.c:2189:		nand_chip->dev_ready = nfc_device_ready;
./drivers/mtd/nand/atmel_nand.c:2190:		nand_chip->cmdfunc = nfc_nand_command;
./drivers/mtd/nand/atmel_nand.c:2212:		nand_chip->cmd_ctrl = atmel_nand_cmd_ctrl;
./drivers/mtd/nand/atmel_nand.c:2215:	nand_chip->chip_delay = 40;		/* 40us command delay time */
./drivers/mtd/nand/atmel_nand.c:2218:	nand_chip->read_buf = atmel_read_buf;
./drivers/mtd/nand/atmel_nand.c:2219:	nand_chip->write_buf = atmel_write_buf;
./drivers/mtd/nand/atmel_nand.c:2276:		nand_chip->bbt_options |= NAND_BBT_USE_FLASH;
./drivers/mtd/nand/atmel_nand.c:2278:	if (nand_chip->bbt_options & NAND_BBT_USE_FLASH)
./drivers/mtd/nand/atmel_nand.c:2287:	if (nand_chip->ecc.mode == NAND_ECC_HW) {
./drivers/mtd/nand/ndfc.c:152:	chip->IO_ADDR_R = ndfc->ndfcbase + NDFC_DATA;
./drivers/mtd/nand/ndfc.c:153:	chip->IO_ADDR_W = ndfc->ndfcbase + NDFC_DATA;
./drivers/mtd/nand/ndfc.c:154:	chip->cmd_ctrl = ndfc_hwcontrol;
./drivers/mtd/nand/ndfc.c:155:	chip->dev_ready = ndfc_ready;
./drivers/mtd/nand/ndfc.c:156:	chip->select_chip = ndfc_select_chip;
./drivers/mtd/nand/ndfc.c:157:	chip->chip_delay = 50;
./drivers/mtd/nand/ndfc.c:158:	chip->controller = &ndfc->ndfc_control;
./drivers/mtd/nand/ndfc.c:159:	chip->read_buf = ndfc_read_buf;
./drivers/mtd/nand/ndfc.c:160:	chip->write_buf = ndfc_write_buf;
./drivers/mtd/nand/ndfc.c:161:	chip->ecc.correct = nand_correct_data;
./drivers/mtd/nand/ndfc.c:162:	chip->ecc.hwctl = ndfc_enable_hwecc;
./drivers/mtd/nand/ndfc.c:163:	chip->ecc.calculate = ndfc_calculate_ecc;
./drivers/mtd/nand/ndfc.c:164:	chip->ecc.mode = NAND_ECC_HW;
./drivers/mtd/nand/ndfc.c:165:	chip->ecc.size = 256;
./drivers/mtd/nand/ndfc.c:166:	chip->ecc.bytes = 3;
./drivers/mtd/nand/ndfc.c:167:	chip->ecc.strength = 1;
./drivers/mtd/nand/nand_bbt.c:83:	uint8_t entry = chip->bbt[block >> BBT_ENTRY_SHIFT];
./drivers/mtd/nand/nand_bbt.c:92:	chip->bbt[block >> BBT_ENTRY_SHIFT] |= msk;
./drivers/mtd/nand/gpio.c:130:	if (!of_property_read_u32(dev->of_node, "chip-delay", &val))
./drivers/mtd/nand/gpio.c:227:	chip->IO_ADDR_R = devm_ioremap_resource(&pdev->dev, res);
./drivers/mtd/nand/gpio.c:228:	if (IS_ERR(chip->IO_ADDR_R))
./drivers/mtd/nand/gpio.c:229:		return PTR_ERR(chip->IO_ADDR_R);
./drivers/mtd/nand/gpio.c:270:		chip->dev_ready = gpio_nand_devready;
./drivers/mtd/nand/gpio.c:274:	chip->IO_ADDR_W		= chip->IO_ADDR_R;
./drivers/mtd/nand/gpio.c:275:	chip->ecc.mode		= NAND_ECC_SOFT;
./drivers/mtd/nand/gpio.c:276:	chip->ecc.algo		= NAND_ECC_HAMMING;
./drivers/mtd/nand/gpio.c:277:	chip->options		= gpiomtd->plat.options;
./drivers/mtd/nand/gpio.c:278:	chip->chip_delay	= gpiomtd->plat.chip_delay;
./drivers/mtd/nand/gpio.c:279:	chip->cmd_ctrl		= gpio_nand_cmd_ctrl;
./drivers/mtd/nand/orion_nand.c:51:	void __iomem *io_base = chip->IO_ADDR_R;
./drivers/mtd/nand/orion_nand.c:119:						"chip-delay", &val))
./drivers/mtd/nand/bf5xx_nand.c:322:	if (chip->ecc.size == 512) {
./drivers/mtd/nand/bf5xx_nand.c:362:	if (chip->ecc.size == 512) {
./drivers/mtd/nand/bf5xx_nand.c:496:				(unsigned int)(buf + chip->ecc.size));
./drivers/mtd/nand/bf5xx_nand.c:499:				(unsigned int)(buf + chip->ecc.size));
./drivers/mtd/nand/bf5xx_nand.c:520:	set_dma_x_count(CH_NFC, (chip->ecc.size >> 1));
./drivers/mtd/nand/bf5xx_nand.c:526:	set_dma_x_count(CH_NFC, (chip->ecc.size >> 2));
./drivers/mtd/nand/bf5xx_nand.c:552:	if (len == chip->ecc.size)
./drivers/mtd/nand/bf5xx_nand.c:566:	if (len == chip->ecc.size)
./drivers/mtd/nand/bf5xx_nand.c:576:	bf5xx_nand_read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/bf5xx_nand.c:586:	bf5xx_nand_write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/bf5xx_nand.c:713:			chip->ecc.size = 512;
./drivers/mtd/nand/bf5xx_nand.c:714:			chip->ecc.bytes = 6;
./drivers/mtd/nand/bf5xx_nand.c:715:			chip->ecc.strength = 2;
./drivers/mtd/nand/bf5xx_nand.c:717:			chip->ecc.size = 256;
./drivers/mtd/nand/bf5xx_nand.c:718:			chip->ecc.bytes = 3;
./drivers/mtd/nand/bf5xx_nand.c:719:			chip->ecc.strength = 1;
./drivers/mtd/nand/bf5xx_nand.c:775:		chip->options |= NAND_BUSWIDTH_16;
./drivers/mtd/nand/bf5xx_nand.c:777:	chip->options |= NAND_CACHEPRG | NAND_SKIP_BBTSCAN;
./drivers/mtd/nand/bf5xx_nand.c:779:	chip->read_buf = (plat->data_width) ?
./drivers/mtd/nand/bf5xx_nand.c:781:	chip->write_buf = (plat->data_width) ?
./drivers/mtd/nand/bf5xx_nand.c:784:	chip->read_byte    = bf5xx_nand_read_byte;
./drivers/mtd/nand/bf5xx_nand.c:786:	chip->cmd_ctrl     = bf5xx_nand_hwcontrol;
./drivers/mtd/nand/bf5xx_nand.c:787:	chip->dev_ready    = bf5xx_nand_devready;
./drivers/mtd/nand/bf5xx_nand.c:790:	chip->controller   = &info->controller;
./drivers/mtd/nand/bf5xx_nand.c:792:	chip->IO_ADDR_R    = (void __iomem *) NFC_READ;
./drivers/mtd/nand/bf5xx_nand.c:793:	chip->IO_ADDR_W    = (void __iomem *) NFC_DATA_WR;
./drivers/mtd/nand/bf5xx_nand.c:795:	chip->chip_delay   = 0;
./drivers/mtd/nand/bf5xx_nand.c:810:		chip->read_buf      = bf5xx_nand_dma_read_buf;
./drivers/mtd/nand/bf5xx_nand.c:811:		chip->write_buf     = bf5xx_nand_dma_write_buf;
./drivers/mtd/nand/bf5xx_nand.c:812:		chip->ecc.calculate = bf5xx_nand_calculate_ecc;
./drivers/mtd/nand/bf5xx_nand.c:813:		chip->ecc.correct   = bf5xx_nand_correct_data;
./drivers/mtd/nand/bf5xx_nand.c:814:		chip->ecc.mode	    = NAND_ECC_HW;
./drivers/mtd/nand/bf5xx_nand.c:815:		chip->ecc.hwctl	    = bf5xx_nand_enable_hwecc;
./drivers/mtd/nand/bf5xx_nand.c:816:		chip->ecc.read_page_raw = bf5xx_nand_read_page_raw;
./drivers/mtd/nand/bf5xx_nand.c:817:		chip->ecc.write_page_raw = bf5xx_nand_write_page_raw;
./drivers/mtd/nand/bf5xx_nand.c:819:		chip->ecc.mode	    = NAND_ECC_SOFT;
./drivers/mtd/nand/bf5xx_nand.c:820:		chip->ecc.algo	= NAND_ECC_HAMMING;
./drivers/mtd/nand/bf5xx_nand.c:830:	chip->badblockpos = 63;
./drivers/mtd/nand/bcm47xxnflash/ops_bcm4706.c:100:	BUG_ON(b47n->curr_page_addr & ~nand_chip->pagemask);
./drivers/mtd/nand/bcm47xxnflash/ops_bcm4706.c:101:	/* Don't validate column using nand_chip->page_shift, it may be bigger
./drivers/mtd/nand/bcm47xxnflash/ops_bcm4706.c:150:	BUG_ON(b47n->curr_page_addr & ~nand_chip->pagemask);
./drivers/mtd/nand/bcm47xxnflash/ops_bcm4706.c:151:	/* Don't validate column using nand_chip->page_shift, it may be bigger
./drivers/mtd/nand/bcm47xxnflash/ops_bcm4706.c:232:		nand_chip->cmd_ctrl(mtd, command, NAND_CTRL_CLE);
./drivers/mtd/nand/bcm47xxnflash/ops_bcm4706.c:389:	nand_chip->cmd_ctrl = bcm47xxnflash_ops_bcm4706_cmd_ctrl;
./drivers/mtd/nand/bcm47xxnflash/ops_bcm4706.c:390:	nand_chip->dev_ready = bcm47xxnflash_ops_bcm4706_dev_ready;
./drivers/mtd/nand/bcm47xxnflash/ops_bcm4706.c:396:	nand_chip->chip_delay = 50;
./drivers/mtd/nand/denali.c:1088:			chip->oob_poi,
./drivers/mtd/nand/denali.c:1150:	return write_oob_data(mtd, chip->oob_poi, page);
./drivers/mtd/nand/denali.c:1156:	read_oob_data(mtd, chip->oob_poi, page);
./drivers/mtd/nand/denali.c:1201:		read_oob_data(mtd, chip->oob_poi, denali->page);
./drivers/mtd/nand/denali.c:1245:	memcpy(chip->oob_poi, denali->buf.buf + mtd->writesize, mtd->oobsize);
./drivers/mtd/nand/denali.c:1389:	oobregion->length = chip->ecc.total;
./drivers/mtd/nand/denali.c:1403:	oobregion->offset = chip->ecc.total + denali->bbtskipbytes;
./drivers/mtd/nand/nand_base.c:60:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/nand_base.c:109:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/nand_base.c:124:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/nand_base.c:148:	if (ofs & ((1ULL << chip->phys_erase_shift) - 1)) {
./drivers/mtd/nand/nand_base.c:154:	if (len & ((1ULL << chip->phys_erase_shift) - 1)) {
./drivers/mtd/nand/nand_base.c:173:	spin_lock(&chip->controller->lock);
./drivers/mtd/nand/nand_base.c:174:	chip->controller->active = NULL;
./drivers/mtd/nand/nand_base.c:175:	chip->state = FL_READY;
./drivers/mtd/nand/nand_base.c:176:	wake_up(&chip->controller->wq);
./drivers/mtd/nand/nand_base.c:177:	spin_unlock(&chip->controller->lock);
./drivers/mtd/nand/nand_base.c:189:	return readb(chip->IO_ADDR_R);
./drivers/mtd/nand/nand_base.c:202:	return (uint8_t) cpu_to_le16(readw(chip->IO_ADDR_R));
./drivers/mtd/nand/nand_base.c:214:	return readw(chip->IO_ADDR_R);
./drivers/mtd/nand/nand_base.c:230:		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
./drivers/mtd/nand/nand_base.c:251:	chip->write_buf(mtd, &byte, 1);
./drivers/mtd/nand/nand_base.c:282:	chip->write_buf(mtd, (uint8_t *)&word, 2);
./drivers/mtd/nand/nand_base.c:297:	iowrite8_rep(chip->IO_ADDR_W, buf, len);
./drivers/mtd/nand/nand_base.c:312:	ioread8_rep(chip->IO_ADDR_R, buf, len);
./drivers/mtd/nand/nand_base.c:328:	iowrite16_rep(chip->IO_ADDR_W, p, len >> 1);
./drivers/mtd/nand/nand_base.c:344:	ioread16_rep(chip->IO_ADDR_R, p, len >> 1);
./drivers/mtd/nand/nand_base.c:360:	if (chip->bbt_options & NAND_BBT_SCANLASTPAGE)
./drivers/mtd/nand/nand_base.c:363:	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
./drivers/mtd/nand/nand_base.c:366:		if (chip->options & NAND_BUSWIDTH_16) {
./drivers/mtd/nand/nand_base.c:367:			chip->cmdfunc(mtd, NAND_CMD_READOOB,
./drivers/mtd/nand/nand_base.c:368:					chip->badblockpos & 0xFE, page);
./drivers/mtd/nand/nand_base.c:369:			bad = cpu_to_le16(chip->read_word(mtd));
./drivers/mtd/nand/nand_base.c:370:			if (chip->badblockpos & 0x1)
./drivers/mtd/nand/nand_base.c:375:			chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos,
./drivers/mtd/nand/nand_base.c:377:			bad = chip->read_byte(mtd);
./drivers/mtd/nand/nand_base.c:380:		if (likely(chip->badblockbits == 8))
./drivers/mtd/nand/nand_base.c:383:			res = hweight8(bad) < chip->badblockbits;
./drivers/mtd/nand/nand_base.c:385:		page = (int)(ofs >> chip->page_shift) & chip->pagemask;
./drivers/mtd/nand/nand_base.c:387:	} while (!res && i < 2 && (chip->bbt_options & NAND_BBT_SCAN2NDPAGE));
./drivers/mtd/nand/nand_base.c:410:	ops.ooboffs = chip->badblockpos;
./drivers/mtd/nand/nand_base.c:411:	if (chip->options & NAND_BUSWIDTH_16) {
./drivers/mtd/nand/nand_base.c:420:	if (chip->bbt_options & NAND_BBT_SCANLASTPAGE)
./drivers/mtd/nand/nand_base.c:429:	} while ((chip->bbt_options & NAND_BBT_SCAN2NDPAGE) && i < 2);
./drivers/mtd/nand/nand_base.c:441: * specify how to write bad block markers to OOB (chip->block_markbad).
./drivers/mtd/nand/nand_base.c:456:	if (!(chip->bbt_options & NAND_BBT_NO_OOB_BBM)) {
./drivers/mtd/nand/nand_base.c:463:		einfo.len = 1ULL << chip->phys_erase_shift;
./drivers/mtd/nand/nand_base.c:468:		ret = chip->block_markbad(mtd, ofs);
./drivers/mtd/nand/nand_base.c:473:	if (chip->bbt) {
./drivers/mtd/nand/nand_base.c:497:	if (chip->options & NAND_BROKEN_XD)
./drivers/mtd/nand/nand_base.c:501:	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
./drivers/mtd/nand/nand_base.c:502:	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
./drivers/mtd/nand/nand_base.c:516:	if (!chip->bbt)
./drivers/mtd/nand/nand_base.c:535:	if (!chip->bbt)
./drivers/mtd/nand/nand_base.c:536:		return chip->block_bad(mtd, ofs);
./drivers/mtd/nand/nand_base.c:557:		if (chip->dev_ready(mtd))
./drivers/mtd/nand/nand_base.c:581:		if (chip->dev_ready(mtd))
./drivers/mtd/nand/nand_base.c:586:	if (!chip->dev_ready(mtd))
./drivers/mtd/nand/nand_base.c:604:		if ((chip->read_byte(mtd) & NAND_STATUS_READY))
./drivers/mtd/nand/nand_base.c:641:		chip->cmd_ctrl(mtd, readcmd, ctrl);
./drivers/mtd/nand/nand_base.c:644:	chip->cmd_ctrl(mtd, command, ctrl);
./drivers/mtd/nand/nand_base.c:651:		if (chip->options & NAND_BUSWIDTH_16 &&
./drivers/mtd/nand/nand_base.c:654:		chip->cmd_ctrl(mtd, column, ctrl);
./drivers/mtd/nand/nand_base.c:658:		chip->cmd_ctrl(mtd, page_addr, ctrl);
./drivers/mtd/nand/nand_base.c:660:		chip->cmd_ctrl(mtd, page_addr >> 8, ctrl);
./drivers/mtd/nand/nand_base.c:662:		if (chip->chipsize > (32 << 20))
./drivers/mtd/nand/nand_base.c:663:			chip->cmd_ctrl(mtd, page_addr >> 16, ctrl);
./drivers/mtd/nand/nand_base.c:665:	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
./drivers/mtd/nand/nand_base.c:681:		if (chip->dev_ready)
./drivers/mtd/nand/nand_base.c:683:		udelay(chip->chip_delay);
./drivers/mtd/nand/nand_base.c:684:		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
./drivers/mtd/nand/nand_base.c:686:		chip->cmd_ctrl(mtd,
./drivers/mtd/nand/nand_base.c:698:		if (!chip->dev_ready) {
./drivers/mtd/nand/nand_base.c:699:			udelay(chip->chip_delay);
./drivers/mtd/nand/nand_base.c:735:	chip->cmd_ctrl(mtd, command, NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
./drivers/mtd/nand/nand_base.c:743:			if (chip->options & NAND_BUSWIDTH_16 &&
./drivers/mtd/nand/nand_base.c:746:			chip->cmd_ctrl(mtd, column, ctrl);
./drivers/mtd/nand/nand_base.c:748:			chip->cmd_ctrl(mtd, column >> 8, ctrl);
./drivers/mtd/nand/nand_base.c:751:			chip->cmd_ctrl(mtd, page_addr, ctrl);
./drivers/mtd/nand/nand_base.c:752:			chip->cmd_ctrl(mtd, page_addr >> 8,
./drivers/mtd/nand/nand_base.c:755:			if (chip->chipsize > (128 << 20))
./drivers/mtd/nand/nand_base.c:756:				chip->cmd_ctrl(mtd, page_addr >> 16,
./drivers/mtd/nand/nand_base.c:760:	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
./drivers/mtd/nand/nand_base.c:778:		if (chip->dev_ready)
./drivers/mtd/nand/nand_base.c:780:		udelay(chip->chip_delay);
./drivers/mtd/nand/nand_base.c:781:		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
./drivers/mtd/nand/nand_base.c:783:		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
./drivers/mtd/nand/nand_base.c:791:		chip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,
./drivers/mtd/nand/nand_base.c:793:		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
./drivers/mtd/nand/nand_base.c:798:		chip->cmd_ctrl(mtd, NAND_CMD_READSTART,
./drivers/mtd/nand/nand_base.c:800:		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
./drivers/mtd/nand/nand_base.c:809:		if (!chip->dev_ready) {
./drivers/mtd/nand/nand_base.c:810:			udelay(chip->chip_delay);
./drivers/mtd/nand/nand_base.c:836:	chip->controller->active = chip;
./drivers/mtd/nand/nand_base.c:837:	chip->state = new_state;
./drivers/mtd/nand/nand_base.c:851:	spinlock_t *lock = &chip->controller->lock;
./drivers/mtd/nand/nand_base.c:852:	wait_queue_head_t *wq = &chip->controller->wq;
./drivers/mtd/nand/nand_base.c:858:	if (!chip->controller->active)
./drivers/mtd/nand/nand_base.c:859:		chip->controller->active = chip;
./drivers/mtd/nand/nand_base.c:861:	if (chip->controller->active == chip && chip->state == FL_READY) {
./drivers/mtd/nand/nand_base.c:862:		chip->state = new_state;
./drivers/mtd/nand/nand_base.c:867:		if (chip->controller->active->state == FL_PM_SUSPENDED) {
./drivers/mtd/nand/nand_base.c:868:			chip->state = FL_PM_SUSPENDED;
./drivers/mtd/nand/nand_base.c:896:		if (chip->dev_ready) {
./drivers/mtd/nand/nand_base.c:897:			if (chip->dev_ready(mtd))
./drivers/mtd/nand/nand_base.c:900:			if (chip->read_byte(mtd) & NAND_STATUS_READY)
./drivers/mtd/nand/nand_base.c:926:	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
./drivers/mtd/nand/nand_base.c:933:			if (chip->dev_ready) {
./drivers/mtd/nand/nand_base.c:934:				if (chip->dev_ready(mtd))
./drivers/mtd/nand/nand_base.c:937:				if (chip->read_byte(mtd) & NAND_STATUS_READY)
./drivers/mtd/nand/nand_base.c:944:	status = (int)chip->read_byte(mtd);
./drivers/mtd/nand/nand_base.c:970:	page = ofs >> chip->page_shift;
./drivers/mtd/nand/nand_base.c:971:	chip->cmdfunc(mtd, NAND_CMD_UNLOCK1, -1, page & chip->pagemask);
./drivers/mtd/nand/nand_base.c:974:	page = (ofs + len) >> chip->page_shift;
./drivers/mtd/nand/nand_base.c:975:	chip->cmdfunc(mtd, NAND_CMD_UNLOCK2, -1,
./drivers/mtd/nand/nand_base.c:976:				(page | invert) & chip->pagemask);
./drivers/mtd/nand/nand_base.c:979:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/nand_base.c:1017:	chipnr = ofs >> chip->chip_shift;
./drivers/mtd/nand/nand_base.c:1019:	chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:1028:	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
./drivers/mtd/nand/nand_base.c:1041:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:1076:	chipnr = ofs >> chip->chip_shift;
./drivers/mtd/nand/nand_base.c:1078:	chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:1087:	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
./drivers/mtd/nand/nand_base.c:1099:	page = ofs >> chip->page_shift;
./drivers/mtd/nand/nand_base.c:1100:	chip->cmdfunc(mtd, NAND_CMD_LOCK, -1, page & chip->pagemask);
./drivers/mtd/nand/nand_base.c:1103:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/nand_base.c:1115:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:1255: * @oob_required: caller requires OOB data read to chip->oob_poi
./drivers/mtd/nand/nand_base.c:1263:	chip->read_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/nand_base.c:1265:		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:1274: * @oob_required: caller requires OOB data read to chip->oob_poi
./drivers/mtd/nand/nand_base.c:1283:	int eccsize = chip->ecc.size;
./drivers/mtd/nand/nand_base.c:1284:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:1285:	uint8_t *oob = chip->oob_poi;
./drivers/mtd/nand/nand_base.c:1288:	for (steps = chip->ecc.steps; steps > 0; steps--) {
./drivers/mtd/nand/nand_base.c:1289:		chip->read_buf(mtd, buf, eccsize);
./drivers/mtd/nand/nand_base.c:1292:		if (chip->ecc.prepad) {
./drivers/mtd/nand/nand_base.c:1293:			chip->read_buf(mtd, oob, chip->ecc.prepad);
./drivers/mtd/nand/nand_base.c:1294:			oob += chip->ecc.prepad;
./drivers/mtd/nand/nand_base.c:1297:		chip->read_buf(mtd, oob, eccbytes);
./drivers/mtd/nand/nand_base.c:1300:		if (chip->ecc.postpad) {
./drivers/mtd/nand/nand_base.c:1301:			chip->read_buf(mtd, oob, chip->ecc.postpad);
./drivers/mtd/nand/nand_base.c:1302:			oob += chip->ecc.postpad;
./drivers/mtd/nand/nand_base.c:1306:	size = mtd->oobsize - (oob - chip->oob_poi);
./drivers/mtd/nand/nand_base.c:1308:		chip->read_buf(mtd, oob, size);
./drivers/mtd/nand/nand_base.c:1318: * @oob_required: caller requires OOB data read to chip->oob_poi
./drivers/mtd/nand/nand_base.c:1324:	int i, eccsize = chip->ecc.size, ret;
./drivers/mtd/nand/nand_base.c:1325:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:1326:	int eccsteps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:1328:	uint8_t *ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/nand_base.c:1329:	uint8_t *ecc_code = chip->buffers->ecccode;
./drivers/mtd/nand/nand_base.c:1332:	chip->ecc.read_page_raw(mtd, chip, buf, 1, page);
./drivers/mtd/nand/nand_base.c:1335:		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
./drivers/mtd/nand/nand_base.c:1337:	ret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,
./drivers/mtd/nand/nand_base.c:1338:					 chip->ecc.total);
./drivers/mtd/nand/nand_base.c:1342:	eccsteps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:1348:		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
./drivers/mtd/nand/nand_base.c:1376:	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
./drivers/mtd/nand/nand_base.c:1382:	start_step = data_offs / chip->ecc.size;
./drivers/mtd/nand/nand_base.c:1383:	end_step = (data_offs + readlen - 1) / chip->ecc.size;
./drivers/mtd/nand/nand_base.c:1385:	index = start_step * chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:1388:	datafrag_len = num_steps * chip->ecc.size;
./drivers/mtd/nand/nand_base.c:1389:	eccfrag_len = num_steps * chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:1391:	data_col_addr = start_step * chip->ecc.size;
./drivers/mtd/nand/nand_base.c:1394:		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);
./drivers/mtd/nand/nand_base.c:1397:	chip->read_buf(mtd, p, datafrag_len);
./drivers/mtd/nand/nand_base.c:1400:	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)
./drivers/mtd/nand/nand_base.c:1401:		chip->ecc.calculate(mtd, p, &chip->buffers->ecccalc[i]);
./drivers/mtd/nand/nand_base.c:1415:		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);
./drivers/mtd/nand/nand_base.c:1416:		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:1426:		if ((oobregion.offset + (num_steps * chip->ecc.bytes)) &
./drivers/mtd/nand/nand_base.c:1430:		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
./drivers/mtd/nand/nand_base.c:1432:		chip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);
./drivers/mtd/nand/nand_base.c:1435:	ret = mtd_ooblayout_get_eccbytes(mtd, chip->buffers->ecccode,
./drivers/mtd/nand/nand_base.c:1436:					 chip->oob_poi, index, eccfrag_len);
./drivers/mtd/nand/nand_base.c:1441:	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
./drivers/mtd/nand/nand_base.c:1444:		stat = chip->ecc.correct(mtd, p,
./drivers/mtd/nand/nand_base.c:1445:			&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
./drivers/mtd/nand/nand_base.c:1447:		    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {
./drivers/mtd/nand/nand_base.c:1449:			stat = nand_check_erased_ecc_chunk(p, chip->ecc.size,
./drivers/mtd/nand/nand_base.c:1450:						&chip->buffers->ecccode[i],
./drivers/mtd/nand/nand_base.c:1451:						chip->ecc.bytes,
./drivers/mtd/nand/nand_base.c:1453:						chip->ecc.strength);
./drivers/mtd/nand/nand_base.c:1471: * @oob_required: caller requires OOB data read to chip->oob_poi
./drivers/mtd/nand/nand_base.c:1479:	int i, eccsize = chip->ecc.size, ret;
./drivers/mtd/nand/nand_base.c:1480:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:1481:	int eccsteps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:1483:	uint8_t *ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/nand_base.c:1484:	uint8_t *ecc_code = chip->buffers->ecccode;
./drivers/mtd/nand/nand_base.c:1488:		chip->ecc.hwctl(mtd, NAND_ECC_READ);
./drivers/mtd/nand/nand_base.c:1489:		chip->read_buf(mtd, p, eccsize);
./drivers/mtd/nand/nand_base.c:1490:		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
./drivers/mtd/nand/nand_base.c:1492:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:1494:	ret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,
./drivers/mtd/nand/nand_base.c:1495:					 chip->ecc.total);
./drivers/mtd/nand/nand_base.c:1499:	eccsteps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:1505:		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
./drivers/mtd/nand/nand_base.c:1507:		    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {
./drivers/mtd/nand/nand_base.c:1512:						chip->ecc.strength);
./drivers/mtd/nand/nand_base.c:1530: * @oob_required: caller requires OOB data read to chip->oob_poi
./drivers/mtd/nand/nand_base.c:1542:	int i, eccsize = chip->ecc.size, ret;
./drivers/mtd/nand/nand_base.c:1543:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:1544:	int eccsteps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:1546:	uint8_t *ecc_code = chip->buffers->ecccode;
./drivers/mtd/nand/nand_base.c:1547:	uint8_t *ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/nand_base.c:1551:	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
./drivers/mtd/nand/nand_base.c:1552:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:1553:	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
./drivers/mtd/nand/nand_base.c:1555:	ret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,
./drivers/mtd/nand/nand_base.c:1556:					 chip->ecc.total);
./drivers/mtd/nand/nand_base.c:1563:		chip->ecc.hwctl(mtd, NAND_ECC_READ);
./drivers/mtd/nand/nand_base.c:1564:		chip->read_buf(mtd, p, eccsize);
./drivers/mtd/nand/nand_base.c:1565:		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
./drivers/mtd/nand/nand_base.c:1567:		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
./drivers/mtd/nand/nand_base.c:1569:		    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {
./drivers/mtd/nand/nand_base.c:1574:						chip->ecc.strength);
./drivers/mtd/nand/nand_base.c:1592: * @oob_required: caller requires OOB data read to chip->oob_poi
./drivers/mtd/nand/nand_base.c:1601:	int i, eccsize = chip->ecc.size;
./drivers/mtd/nand/nand_base.c:1602:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:1603:	int eccsteps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:1604:	int eccpadbytes = eccbytes + chip->ecc.prepad + chip->ecc.postpad;
./drivers/mtd/nand/nand_base.c:1606:	uint8_t *oob = chip->oob_poi;
./drivers/mtd/nand/nand_base.c:1612:		chip->ecc.hwctl(mtd, NAND_ECC_READ);
./drivers/mtd/nand/nand_base.c:1613:		chip->read_buf(mtd, p, eccsize);
./drivers/mtd/nand/nand_base.c:1615:		if (chip->ecc.prepad) {
./drivers/mtd/nand/nand_base.c:1616:			chip->read_buf(mtd, oob, chip->ecc.prepad);
./drivers/mtd/nand/nand_base.c:1617:			oob += chip->ecc.prepad;
./drivers/mtd/nand/nand_base.c:1620:		chip->ecc.hwctl(mtd, NAND_ECC_READSYN);
./drivers/mtd/nand/nand_base.c:1621:		chip->read_buf(mtd, oob, eccbytes);
./drivers/mtd/nand/nand_base.c:1622:		stat = chip->ecc.correct(mtd, p, oob, NULL);
./drivers/mtd/nand/nand_base.c:1626:		if (chip->ecc.postpad) {
./drivers/mtd/nand/nand_base.c:1627:			chip->read_buf(mtd, oob, chip->ecc.postpad);
./drivers/mtd/nand/nand_base.c:1628:			oob += chip->ecc.postpad;
./drivers/mtd/nand/nand_base.c:1632:		    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {
./drivers/mtd/nand/nand_base.c:1634:			stat = nand_check_erased_ecc_chunk(p, chip->ecc.size,
./drivers/mtd/nand/nand_base.c:1638:							   chip->ecc.strength);
./drivers/mtd/nand/nand_base.c:1650:	i = mtd->oobsize - (oob - chip->oob_poi);
./drivers/mtd/nand/nand_base.c:1652:		chip->read_buf(mtd, oob, i);
./drivers/mtd/nand/nand_base.c:1674:		memcpy(oob, chip->oob_poi + ops->ooboffs, len);
./drivers/mtd/nand/nand_base.c:1678:		ret = mtd_ooblayout_get_databytes(mtd, oob, chip->oob_poi,
./drivers/mtd/nand/nand_base.c:1704:	if (retry_mode >= chip->read_retries)
./drivers/mtd/nand/nand_base.c:1707:	if (!chip->setup_read_retry)
./drivers/mtd/nand/nand_base.c:1710:	return chip->setup_read_retry(mtd, retry_mode);
./drivers/mtd/nand/nand_base.c:1737:	chipnr = (int)(from >> chip->chip_shift);
./drivers/mtd/nand/nand_base.c:1738:	chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:1740:	realpage = (int)(from >> chip->page_shift);
./drivers/mtd/nand/nand_base.c:1741:	page = realpage & chip->pagemask;
./drivers/mtd/nand/nand_base.c:1757:		else if (chip->options & NAND_USE_BOUNCE_BUFFER)
./drivers/mtd/nand/nand_base.c:1763:		if (realpage != chip->pagebuf || oob) {
./drivers/mtd/nand/nand_base.c:1764:			bufpoi = use_bufpoi ? chip->buffers->databuf : buf;
./drivers/mtd/nand/nand_base.c:1771:			chip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
./drivers/mtd/nand/nand_base.c:1778:				ret = chip->ecc.read_page_raw(mtd, chip, bufpoi,
./drivers/mtd/nand/nand_base.c:1783:				ret = chip->ecc.read_subpage(mtd, chip,
./drivers/mtd/nand/nand_base.c:1787:				ret = chip->ecc.read_page(mtd, chip, bufpoi,
./drivers/mtd/nand/nand_base.c:1792:					chip->pagebuf = -1;
./drivers/mtd/nand/nand_base.c:1803:					chip->pagebuf = realpage;
./drivers/mtd/nand/nand_base.c:1804:					chip->pagebuf_bitflips = ret;
./drivers/mtd/nand/nand_base.c:1807:					chip->pagebuf = -1;
./drivers/mtd/nand/nand_base.c:1809:				memcpy(buf, chip->buffers->databuf + col, bytes);
./drivers/mtd/nand/nand_base.c:1822:			if (chip->options & NAND_NEED_READRDY) {
./drivers/mtd/nand/nand_base.c:1824:				if (!chip->dev_ready)
./drivers/mtd/nand/nand_base.c:1825:					udelay(chip->chip_delay);
./drivers/mtd/nand/nand_base.c:1831:				if (retry_mode + 1 < chip->read_retries) {
./drivers/mtd/nand/nand_base.c:1849:			memcpy(buf, chip->buffers->databuf + col, bytes);
./drivers/mtd/nand/nand_base.c:1852:					     chip->pagebuf_bitflips);
./drivers/mtd/nand/nand_base.c:1873:		page = realpage & chip->pagemask;
./drivers/mtd/nand/nand_base.c:1877:			chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:1878:			chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:1881:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:1931:	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
./drivers/mtd/nand/nand_base.c:1932:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:1948:	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
./drivers/mtd/nand/nand_base.c:1949:	int eccsize = chip->ecc.size;
./drivers/mtd/nand/nand_base.c:1950:	uint8_t *bufpoi = chip->oob_poi;
./drivers/mtd/nand/nand_base.c:1953:	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
./drivers/mtd/nand/nand_base.c:1954:	for (i = 0; i < chip->ecc.steps; i++) {
./drivers/mtd/nand/nand_base.c:1958:				chip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);
./drivers/mtd/nand/nand_base.c:1960:				chip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);
./drivers/mtd/nand/nand_base.c:1964:		chip->read_buf(mtd, bufpoi, toread);
./drivers/mtd/nand/nand_base.c:1969:		chip->read_buf(mtd, bufpoi, length);
./drivers/mtd/nand/nand_base.c:1984:	const uint8_t *buf = chip->oob_poi;
./drivers/mtd/nand/nand_base.c:1987:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
./drivers/mtd/nand/nand_base.c:1988:	chip->write_buf(mtd, buf, length);
./drivers/mtd/nand/nand_base.c:1990:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/nand_base.c:1992:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/nand_base.c:2008:	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
./drivers/mtd/nand/nand_base.c:2009:	int eccsize = chip->ecc.size, length = mtd->oobsize;
./drivers/mtd/nand/nand_base.c:2010:	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:2011:	const uint8_t *bufpoi = chip->oob_poi;
./drivers/mtd/nand/nand_base.c:2018:	if (!chip->ecc.prepad && !chip->ecc.postpad) {
./drivers/mtd/nand/nand_base.c:2024:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
./drivers/mtd/nand/nand_base.c:2033:					chip->write_buf(mtd, (uint8_t *)&fill,
./drivers/mtd/nand/nand_base.c:2039:				chip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);
./drivers/mtd/nand/nand_base.c:2044:		chip->write_buf(mtd, bufpoi, len);
./drivers/mtd/nand/nand_base.c:2049:		chip->write_buf(mtd, bufpoi, length);
./drivers/mtd/nand/nand_base.c:2051:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/nand_base.c:2052:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/nand_base.c:2092:		     ops->ooboffs + readlen > ((mtd->size >> chip->page_shift) -
./drivers/mtd/nand/nand_base.c:2093:					(from >> chip->page_shift)) * len)) {
./drivers/mtd/nand/nand_base.c:2099:	chipnr = (int)(from >> chip->chip_shift);
./drivers/mtd/nand/nand_base.c:2100:	chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:2103:	realpage = (int)(from >> chip->page_shift);
./drivers/mtd/nand/nand_base.c:2104:	page = realpage & chip->pagemask;
./drivers/mtd/nand/nand_base.c:2108:			ret = chip->ecc.read_oob_raw(mtd, chip, page);
./drivers/mtd/nand/nand_base.c:2110:			ret = chip->ecc.read_oob(mtd, chip, page);
./drivers/mtd/nand/nand_base.c:2118:		if (chip->options & NAND_NEED_READRDY) {
./drivers/mtd/nand/nand_base.c:2120:			if (!chip->dev_ready)
./drivers/mtd/nand/nand_base.c:2121:				udelay(chip->chip_delay);
./drivers/mtd/nand/nand_base.c:2133:		page = realpage & chip->pagemask;
./drivers/mtd/nand/nand_base.c:2137:			chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:2138:			chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:2141:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:2204: * @oob_required: must write chip->oob_poi to OOB
./drivers/mtd/nand/nand_base.c:2212:	chip->write_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/nand_base.c:2214:		chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:2224: * @oob_required: must write chip->oob_poi to OOB
./drivers/mtd/nand/nand_base.c:2234:	int eccsize = chip->ecc.size;
./drivers/mtd/nand/nand_base.c:2235:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:2236:	uint8_t *oob = chip->oob_poi;
./drivers/mtd/nand/nand_base.c:2239:	for (steps = chip->ecc.steps; steps > 0; steps--) {
./drivers/mtd/nand/nand_base.c:2240:		chip->write_buf(mtd, buf, eccsize);
./drivers/mtd/nand/nand_base.c:2243:		if (chip->ecc.prepad) {
./drivers/mtd/nand/nand_base.c:2244:			chip->write_buf(mtd, oob, chip->ecc.prepad);
./drivers/mtd/nand/nand_base.c:2245:			oob += chip->ecc.prepad;
./drivers/mtd/nand/nand_base.c:2248:		chip->write_buf(mtd, oob, eccbytes);
./drivers/mtd/nand/nand_base.c:2251:		if (chip->ecc.postpad) {
./drivers/mtd/nand/nand_base.c:2252:			chip->write_buf(mtd, oob, chip->ecc.postpad);
./drivers/mtd/nand/nand_base.c:2253:			oob += chip->ecc.postpad;
./drivers/mtd/nand/nand_base.c:2257:	size = mtd->oobsize - (oob - chip->oob_poi);
./drivers/mtd/nand/nand_base.c:2259:		chip->write_buf(mtd, oob, size);
./drivers/mtd/nand/nand_base.c:2268: * @oob_required: must write chip->oob_poi to OOB
./drivers/mtd/nand/nand_base.c:2275:	int i, eccsize = chip->ecc.size, ret;
./drivers/mtd/nand/nand_base.c:2276:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:2277:	int eccsteps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:2278:	uint8_t *ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/nand_base.c:2283:		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
./drivers/mtd/nand/nand_base.c:2285:	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,
./drivers/mtd/nand/nand_base.c:2286:					 chip->ecc.total);
./drivers/mtd/nand/nand_base.c:2290:	return chip->ecc.write_page_raw(mtd, chip, buf, 1, page);
./drivers/mtd/nand/nand_base.c:2298: * @oob_required: must write chip->oob_poi to OOB
./drivers/mtd/nand/nand_base.c:2305:	int i, eccsize = chip->ecc.size, ret;
./drivers/mtd/nand/nand_base.c:2306:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:2307:	int eccsteps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:2308:	uint8_t *ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/nand_base.c:2312:		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
./drivers/mtd/nand/nand_base.c:2313:		chip->write_buf(mtd, p, eccsize);
./drivers/mtd/nand/nand_base.c:2314:		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
./drivers/mtd/nand/nand_base.c:2317:	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,
./drivers/mtd/nand/nand_base.c:2318:					 chip->ecc.total);
./drivers/mtd/nand/nand_base.c:2322:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:2335: * @oob_required: must write chip->oob_poi to OOB
./drivers/mtd/nand/nand_base.c:2343:	uint8_t *oob_buf  = chip->oob_poi;
./drivers/mtd/nand/nand_base.c:2344:	uint8_t *ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/nand_base.c:2345:	int ecc_size      = chip->ecc.size;
./drivers/mtd/nand/nand_base.c:2346:	int ecc_bytes     = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:2347:	int ecc_steps     = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:2355:		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
./drivers/mtd/nand/nand_base.c:2358:		chip->write_buf(mtd, buf, ecc_size);
./drivers/mtd/nand/nand_base.c:2364:			chip->ecc.calculate(mtd, buf, ecc_calc);
./drivers/mtd/nand/nand_base.c:2376:	/* copy calculated ECC for whole page to chip->buffer->oob */
./drivers/mtd/nand/nand_base.c:2378:	ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/nand_base.c:2379:	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,
./drivers/mtd/nand/nand_base.c:2380:					 chip->ecc.total);
./drivers/mtd/nand/nand_base.c:2385:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:2396: * @oob_required: must write chip->oob_poi to OOB
./drivers/mtd/nand/nand_base.c:2407:	int i, eccsize = chip->ecc.size;
./drivers/mtd/nand/nand_base.c:2408:	int eccbytes = chip->ecc.bytes;
./drivers/mtd/nand/nand_base.c:2409:	int eccsteps = chip->ecc.steps;
./drivers/mtd/nand/nand_base.c:2411:	uint8_t *oob = chip->oob_poi;
./drivers/mtd/nand/nand_base.c:2415:		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
./drivers/mtd/nand/nand_base.c:2416:		chip->write_buf(mtd, p, eccsize);
./drivers/mtd/nand/nand_base.c:2418:		if (chip->ecc.prepad) {
./drivers/mtd/nand/nand_base.c:2419:			chip->write_buf(mtd, oob, chip->ecc.prepad);
./drivers/mtd/nand/nand_base.c:2420:			oob += chip->ecc.prepad;
./drivers/mtd/nand/nand_base.c:2423:		chip->ecc.calculate(mtd, p, oob);
./drivers/mtd/nand/nand_base.c:2424:		chip->write_buf(mtd, oob, eccbytes);
./drivers/mtd/nand/nand_base.c:2427:		if (chip->ecc.postpad) {
./drivers/mtd/nand/nand_base.c:2428:			chip->write_buf(mtd, oob, chip->ecc.postpad);
./drivers/mtd/nand/nand_base.c:2429:			oob += chip->ecc.postpad;
./drivers/mtd/nand/nand_base.c:2434:	i = mtd->oobsize - (oob - chip->oob_poi);
./drivers/mtd/nand/nand_base.c:2436:		chip->write_buf(mtd, oob, i);
./drivers/mtd/nand/nand_base.c:2448: * @oob_required: must write chip->oob_poi to OOB
./drivers/mtd/nand/nand_base.c:2459:	if (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&
./drivers/mtd/nand/nand_base.c:2460:		chip->ecc.write_subpage)
./drivers/mtd/nand/nand_base.c:2465:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
./drivers/mtd/nand/nand_base.c:2468:		status = chip->ecc.write_page_raw(mtd, chip, buf,
./drivers/mtd/nand/nand_base.c:2471:		status = chip->ecc.write_subpage(mtd, chip, offset, data_len,
./drivers/mtd/nand/nand_base.c:2474:		status = chip->ecc.write_page(mtd, chip, buf, oob_required,
./drivers/mtd/nand/nand_base.c:2488:		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/nand_base.c:2489:		status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/nand_base.c:2494:		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
./drivers/mtd/nand/nand_base.c:2495:			status = chip->errstat(mtd, chip, FL_WRITING, status,
./drivers/mtd/nand/nand_base.c:2501:		chip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);
./drivers/mtd/nand/nand_base.c:2502:		status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/nand_base.c:2525:	memset(chip->oob_poi, 0xff, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:2531:		memcpy(chip->oob_poi + ops->ooboffs, oob, len);
./drivers/mtd/nand/nand_base.c:2535:		ret = mtd_ooblayout_set_databytes(mtd, oob, chip->oob_poi,
./drivers/mtd/nand/nand_base.c:2546:#define NOTALIGNED(x)	((x & (chip->subpagesize - 1)) != 0)
./drivers/mtd/nand/nand_base.c:2584:	chipnr = (int)(to >> chip->chip_shift);
./drivers/mtd/nand/nand_base.c:2585:	chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:2593:	realpage = (int)(to >> chip->page_shift);
./drivers/mtd/nand/nand_base.c:2594:	page = realpage & chip->pagemask;
./drivers/mtd/nand/nand_base.c:2595:	blockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
./drivers/mtd/nand/nand_base.c:2598:	if (to <= ((loff_t)chip->pagebuf << chip->page_shift) &&
./drivers/mtd/nand/nand_base.c:2599:	    ((loff_t)chip->pagebuf << chip->page_shift) < (to + ops->len))
./drivers/mtd/nand/nand_base.c:2600:		chip->pagebuf = -1;
./drivers/mtd/nand/nand_base.c:2617:		else if (chip->options & NAND_USE_BOUNCE_BUFFER)
./drivers/mtd/nand/nand_base.c:2629:			chip->pagebuf = -1;
./drivers/mtd/nand/nand_base.c:2630:			memset(chip->buffers->databuf, 0xff, mtd->writesize);
./drivers/mtd/nand/nand_base.c:2631:			memcpy(&chip->buffers->databuf[column], buf, bytes);
./drivers/mtd/nand/nand_base.c:2632:			wbuf = chip->buffers->databuf;
./drivers/mtd/nand/nand_base.c:2641:			memset(chip->oob_poi, 0xff, mtd->oobsize);
./drivers/mtd/nand/nand_base.c:2643:		ret = chip->write_page(mtd, chip, column, bytes, wbuf,
./drivers/mtd/nand/nand_base.c:2657:		page = realpage & chip->pagemask;
./drivers/mtd/nand/nand_base.c:2661:			chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:2662:			chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:2671:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:2772:			((mtd->size >> chip->page_shift) -
./drivers/mtd/nand/nand_base.c:2773:			 (to >> chip->page_shift)) * len)) {
./drivers/mtd/nand/nand_base.c:2779:	chipnr = (int)(to >> chip->chip_shift);
./drivers/mtd/nand/nand_base.c:2780:	chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:2783:	page = (int)(to >> chip->page_shift);
./drivers/mtd/nand/nand_base.c:2791:	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
./drivers/mtd/nand/nand_base.c:2795:		chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:2800:	if (page == chip->pagebuf)
./drivers/mtd/nand/nand_base.c:2801:		chip->pagebuf = -1;
./drivers/mtd/nand/nand_base.c:2806:		status = chip->ecc.write_oob_raw(mtd, chip, page & chip->pagemask);
./drivers/mtd/nand/nand_base.c:2808:		status = chip->ecc.write_oob(mtd, chip, page & chip->pagemask);
./drivers/mtd/nand/nand_base.c:2810:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:2873:	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
./drivers/mtd/nand/nand_base.c:2874:	chip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);
./drivers/mtd/nand/nand_base.c:2876:	return chip->waitfunc(mtd, chip);
./drivers/mtd/nand/nand_base.c:2917:	page = (int)(instr->addr >> chip->page_shift);
./drivers/mtd/nand/nand_base.c:2918:	chipnr = (int)(instr->addr >> chip->chip_shift);
./drivers/mtd/nand/nand_base.c:2921:	pages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);
./drivers/mtd/nand/nand_base.c:2924:	chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:2942:					chip->page_shift, allowbbt)) {
./drivers/mtd/nand/nand_base.c:2953:		if (page <= chip->pagebuf && chip->pagebuf <
./drivers/mtd/nand/nand_base.c:2955:			chip->pagebuf = -1;
./drivers/mtd/nand/nand_base.c:2957:		status = chip->erase(mtd, page & chip->pagemask);
./drivers/mtd/nand/nand_base.c:2963:		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
./drivers/mtd/nand/nand_base.c:2964:			status = chip->errstat(mtd, chip, FL_ERASING,
./drivers/mtd/nand/nand_base.c:2973:				((loff_t)page << chip->page_shift);
./drivers/mtd/nand/nand_base.c:2978:		len -= (1ULL << chip->phys_erase_shift);
./drivers/mtd/nand/nand_base.c:2982:		if (len && !(page & chip->pagemask)) {
./drivers/mtd/nand/nand_base.c:2984:			chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:2985:			chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:2995:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:3030:	int chipnr = (int)(offs >> chip->chip_shift);
./drivers/mtd/nand/nand_base.c:3035:	chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/nand_base.c:3039:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:3078:	if (!chip->onfi_version ||
./drivers/mtd/nand/nand_base.c:3079:	    !(le16_to_cpu(chip->onfi_params.opt_cmd)
./drivers/mtd/nand/nand_base.c:3083:	chip->cmdfunc(mtd, NAND_CMD_SET_FEATURES, addr, -1);
./drivers/mtd/nand/nand_base.c:3085:		chip->write_byte(mtd, subfeature_param[i]);
./drivers/mtd/nand/nand_base.c:3087:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/nand_base.c:3105:	if (!chip->onfi_version ||
./drivers/mtd/nand/nand_base.c:3106:	    !(le16_to_cpu(chip->onfi_params.opt_cmd)
./drivers/mtd/nand/nand_base.c:3110:	chip->cmdfunc(mtd, NAND_CMD_GET_FEATURES, addr, -1);
./drivers/mtd/nand/nand_base.c:3112:		*subfeature_param++ = chip->read_byte(mtd);
./drivers/mtd/nand/nand_base.c:3133:	if (chip->state == FL_PM_SUSPENDED)
./drivers/mtd/nand/nand_base.c:3154:	if (!chip->chip_delay)
./drivers/mtd/nand/nand_base.c:3155:		chip->chip_delay = 20;
./drivers/mtd/nand/nand_base.c:3158:	if (chip->cmdfunc == NULL)
./drivers/mtd/nand/nand_base.c:3159:		chip->cmdfunc = nand_command;
./drivers/mtd/nand/nand_base.c:3162:	if (chip->waitfunc == NULL)
./drivers/mtd/nand/nand_base.c:3163:		chip->waitfunc = nand_wait;
./drivers/mtd/nand/nand_base.c:3165:	if (!chip->select_chip)
./drivers/mtd/nand/nand_base.c:3166:		chip->select_chip = nand_select_chip;
./drivers/mtd/nand/nand_base.c:3169:	if (!chip->onfi_set_features)
./drivers/mtd/nand/nand_base.c:3170:		chip->onfi_set_features = nand_onfi_set_features;
./drivers/mtd/nand/nand_base.c:3171:	if (!chip->onfi_get_features)
./drivers/mtd/nand/nand_base.c:3172:		chip->onfi_get_features = nand_onfi_get_features;
./drivers/mtd/nand/nand_base.c:3175:	if (!chip->read_byte || chip->read_byte == nand_read_byte)
./drivers/mtd/nand/nand_base.c:3176:		chip->read_byte = busw ? nand_read_byte16 : nand_read_byte;
./drivers/mtd/nand/nand_base.c:3177:	if (!chip->read_word)
./drivers/mtd/nand/nand_base.c:3178:		chip->read_word = nand_read_word;
./drivers/mtd/nand/nand_base.c:3179:	if (!chip->block_bad)
./drivers/mtd/nand/nand_base.c:3180:		chip->block_bad = nand_block_bad;
./drivers/mtd/nand/nand_base.c:3181:	if (!chip->block_markbad)
./drivers/mtd/nand/nand_base.c:3182:		chip->block_markbad = nand_default_block_markbad;
./drivers/mtd/nand/nand_base.c:3183:	if (!chip->write_buf || chip->write_buf == nand_write_buf)
./drivers/mtd/nand/nand_base.c:3184:		chip->write_buf = busw ? nand_write_buf16 : nand_write_buf;
./drivers/mtd/nand/nand_base.c:3185:	if (!chip->write_byte || chip->write_byte == nand_write_byte)
./drivers/mtd/nand/nand_base.c:3186:		chip->write_byte = busw ? nand_write_byte16 : nand_write_byte;
./drivers/mtd/nand/nand_base.c:3187:	if (!chip->read_buf || chip->read_buf == nand_read_buf)
./drivers/mtd/nand/nand_base.c:3188:		chip->read_buf = busw ? nand_read_buf16 : nand_read_buf;
./drivers/mtd/nand/nand_base.c:3189:	if (!chip->scan_bbt)
./drivers/mtd/nand/nand_base.c:3190:		chip->scan_bbt = nand_default_bbt;
./drivers/mtd/nand/nand_base.c:3192:	if (!chip->controller) {
./drivers/mtd/nand/nand_base.c:3193:		chip->controller = &chip->hwcontrol;
./drivers/mtd/nand/nand_base.c:3194:		spin_lock_init(&chip->controller->lock);
./drivers/mtd/nand/nand_base.c:3195:		init_waitqueue_head(&chip->controller->wq);
./drivers/mtd/nand/nand_base.c:3248:	chip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);
./drivers/mtd/nand/nand_base.c:3251:	chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
./drivers/mtd/nand/nand_base.c:3255:	chip->read_buf(mtd, (uint8_t *)ep, len);
./drivers/mtd/nand/nand_base.c:3292:	chip->ecc_strength_ds = ecc->ecc_bits;
./drivers/mtd/nand/nand_base.c:3293:	chip->ecc_step_ds = 1 << ecc->codeword_size;
./drivers/mtd/nand/nand_base.c:3306:	return chip->onfi_set_features(mtd, chip, ONFI_FEATURE_ADDR_READ_RETRY,
./drivers/mtd/nand/nand_base.c:3321:	chip->read_retries = micron->read_retry_options;
./drivers/mtd/nand/nand_base.c:3322:	chip->setup_read_retry = nand_setup_read_retry_micron;
./drivers/mtd/nand/nand_base.c:3331:	struct nand_onfi_params *p = &chip->onfi_params;
./drivers/mtd/nand/nand_base.c:3336:	chip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);
./drivers/mtd/nand/nand_base.c:3337:	if (chip->read_byte(mtd) != 'O' || chip->read_byte(mtd) != 'N' ||
./drivers/mtd/nand/nand_base.c:3338:		chip->read_byte(mtd) != 'F' || chip->read_byte(mtd) != 'I')
./drivers/mtd/nand/nand_base.c:3341:	chip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);
./drivers/mtd/nand/nand_base.c:3344:			((uint8_t *)p)[j] = chip->read_byte(mtd);
./drivers/mtd/nand/nand_base.c:3359:		chip->onfi_version = 23;
./drivers/mtd/nand/nand_base.c:3361:		chip->onfi_version = 22;
./drivers/mtd/nand/nand_base.c:3363:		chip->onfi_version = 21;
./drivers/mtd/nand/nand_base.c:3365:		chip->onfi_version = 20;
./drivers/mtd/nand/nand_base.c:3367:		chip->onfi_version = 10;
./drivers/mtd/nand/nand_base.c:3369:	if (!chip->onfi_version) {
./drivers/mtd/nand/nand_base.c:3392:	chip->chipsize = 1 << (fls(le32_to_cpu(p->blocks_per_lun)) - 1);
./drivers/mtd/nand/nand_base.c:3393:	chip->chipsize *= (uint64_t)mtd->erasesize * p->lun_count;
./drivers/mtd/nand/nand_base.c:3394:	chip->bits_per_cell = p->bits_per_cell;
./drivers/mtd/nand/nand_base.c:3402:		chip->ecc_strength_ds = p->ecc_bits;
./drivers/mtd/nand/nand_base.c:3403:		chip->ecc_step_ds = 512;
./drivers/mtd/nand/nand_base.c:3404:	} else if (chip->onfi_version >= 21 &&
./drivers/mtd/nand/nand_base.c:3410:		 * by the chip->cmdfunc. So try to update the chip->cmdfunc
./drivers/mtd/nand/nand_base.c:3413:		if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
./drivers/mtd/nand/nand_base.c:3414:			chip->cmdfunc = nand_command_lp;
./drivers/mtd/nand/nand_base.c:3435:	struct nand_jedec_params *p = &chip->jedec_params;
./drivers/mtd/nand/nand_base.c:3441:	chip->cmdfunc(mtd, NAND_CMD_READID, 0x40, -1);
./drivers/mtd/nand/nand_base.c:3442:	if (chip->read_byte(mtd) != 'J' || chip->read_byte(mtd) != 'E' ||
./drivers/mtd/nand/nand_base.c:3443:		chip->read_byte(mtd) != 'D' || chip->read_byte(mtd) != 'E' ||
./drivers/mtd/nand/nand_base.c:3444:		chip->read_byte(mtd) != 'C')
./drivers/mtd/nand/nand_base.c:3447:	chip->cmdfunc(mtd, NAND_CMD_PARAM, 0x40, -1);
./drivers/mtd/nand/nand_base.c:3450:			((uint8_t *)p)[j] = chip->read_byte(mtd);
./drivers/mtd/nand/nand_base.c:3465:		chip->jedec_version = 10;
./drivers/mtd/nand/nand_base.c:3467:		chip->jedec_version = 1; /* vendor specific version */
./drivers/mtd/nand/nand_base.c:3469:	if (!chip->jedec_version) {
./drivers/mtd/nand/nand_base.c:3488:	chip->chipsize = 1 << (fls(le32_to_cpu(p->blocks_per_lun)) - 1);
./drivers/mtd/nand/nand_base.c:3489:	chip->chipsize *= (uint64_t)mtd->erasesize * p->lun_count;
./drivers/mtd/nand/nand_base.c:3490:	chip->bits_per_cell = p->bits_per_cell;
./drivers/mtd/nand/nand_base.c:3501:		chip->ecc_strength_ds = ecc->ecc_bits;
./drivers/mtd/nand/nand_base.c:3502:		chip->ecc_step_ds = 1 << ecc->codeword_size;
./drivers/mtd/nand/nand_base.c:3589:	chip->bits_per_cell = nand_get_bits_per_cell(id_data[2]);
./drivers/mtd/nand/nand_base.c:3729:	chip->bits_per_cell = 1;
./drivers/mtd/nand/nand_base.c:3756:	if (mtd->writesize > 512 || (chip->options & NAND_BUSWIDTH_16))
./drivers/mtd/nand/nand_base.c:3757:		chip->badblockpos = NAND_LARGE_BADBLOCK_POS;
./drivers/mtd/nand/nand_base.c:3759:		chip->badblockpos = NAND_SMALL_BADBLOCK_POS;
./drivers/mtd/nand/nand_base.c:3770:		chip->bbt_options |= NAND_BBT_SCANLASTPAGE;
./drivers/mtd/nand/nand_base.c:3779:		chip->bbt_options |= NAND_BBT_SCAN2NDPAGE;
./drivers/mtd/nand/nand_base.c:3795:		chip->bits_per_cell = nand_get_bits_per_cell(id_data[2]);
./drivers/mtd/nand/nand_base.c:3796:		chip->chipsize = (uint64_t)type->chipsize << 20;
./drivers/mtd/nand/nand_base.c:3797:		chip->options |= type->options;
./drivers/mtd/nand/nand_base.c:3798:		chip->ecc_strength_ds = NAND_ECC_STRENGTH(type);
./drivers/mtd/nand/nand_base.c:3799:		chip->ecc_step_ds = NAND_ECC_STEP(type);
./drivers/mtd/nand/nand_base.c:3800:		chip->onfi_timing_mode_default =
./drivers/mtd/nand/nand_base.c:3826:	chip->select_chip(mtd, 0);
./drivers/mtd/nand/nand_base.c:3832:	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
./drivers/mtd/nand/nand_base.c:3835:	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
./drivers/mtd/nand/nand_base.c:3838:	*maf_id = chip->read_byte(mtd);
./drivers/mtd/nand/nand_base.c:3839:	*dev_id = chip->read_byte(mtd);
./drivers/mtd/nand/nand_base.c:3848:	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
./drivers/mtd/nand/nand_base.c:3852:		id_data[i] = chip->read_byte(mtd);
./drivers/mtd/nand/nand_base.c:3872:	chip->onfi_version = 0;
./drivers/mtd/nand/nand_base.c:3889:	chip->chipsize = (uint64_t)type->chipsize << 20;
./drivers/mtd/nand/nand_base.c:3898:	chip->options |= type->options;
./drivers/mtd/nand/nand_base.c:3905:		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
./drivers/mtd/nand/nand_base.c:3914:	if (chip->options & NAND_BUSWIDTH_AUTO) {
./drivers/mtd/nand/nand_base.c:3915:		WARN_ON(chip->options & NAND_BUSWIDTH_16);
./drivers/mtd/nand/nand_base.c:3916:		chip->options |= busw;
./drivers/mtd/nand/nand_base.c:3918:	} else if (busw != (chip->options & NAND_BUSWIDTH_16)) {
./drivers/mtd/nand/nand_base.c:3927:			   (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
./drivers/mtd/nand/nand_base.c:3935:	chip->page_shift = ffs(mtd->writesize) - 1;
./drivers/mtd/nand/nand_base.c:3937:	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;
./drivers/mtd/nand/nand_base.c:3939:	chip->bbt_erase_shift = chip->phys_erase_shift =
./drivers/mtd/nand/nand_base.c:3941:	if (chip->chipsize & 0xffffffff)
./drivers/mtd/nand/nand_base.c:3942:		chip->chip_shift = ffs((unsigned)chip->chipsize) - 1;
./drivers/mtd/nand/nand_base.c:3944:		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32));
./drivers/mtd/nand/nand_base.c:3945:		chip->chip_shift += 32 - 1;
./drivers/mtd/nand/nand_base.c:3948:	chip->badblockbits = 8;
./drivers/mtd/nand/nand_base.c:3949:	chip->erase = single_erase;
./drivers/mtd/nand/nand_base.c:3952:	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
./drivers/mtd/nand/nand_base.c:3953:		chip->cmdfunc = nand_command_lp;
./drivers/mtd/nand/nand_base.c:3958:	if (chip->onfi_version)
./drivers/mtd/nand/nand_base.c:3960:				chip->onfi_params.model);
./drivers/mtd/nand/nand_base.c:3961:	else if (chip->jedec_version)
./drivers/mtd/nand/nand_base.c:3963:				chip->jedec_params.model);
./drivers/mtd/nand/nand_base.c:3969:		(int)(chip->chipsize >> 20), nand_is_slc(chip) ? "SLC" : "MLC",
./drivers/mtd/nand/nand_base.c:4088:		chip->options |= NAND_BUSWIDTH_16;
./drivers/mtd/nand/nand_base.c:4091:		chip->bbt_options |= NAND_BBT_USE_FLASH;
./drivers/mtd/nand/nand_base.c:4105:		chip->ecc.mode = ecc_mode;
./drivers/mtd/nand/nand_base.c:4108:		chip->ecc.algo = ecc_algo;
./drivers/mtd/nand/nand_base.c:4111:		chip->ecc.strength = ecc_strength;
./drivers/mtd/nand/nand_base.c:4114:		chip->ecc.size = ecc_step;
./drivers/mtd/nand/nand_base.c:4145:	nand_set_defaults(chip, chip->options & NAND_BUSWIDTH_16);
./drivers/mtd/nand/nand_base.c:4152:		if (!(chip->options & NAND_SCAN_SILENT_NODEV))
./drivers/mtd/nand/nand_base.c:4154:		chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:4158:	chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:4162:		chip->select_chip(mtd, i);
./drivers/mtd/nand/nand_base.c:4164:		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
./drivers/mtd/nand/nand_base.c:4166:		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
./drivers/mtd/nand/nand_base.c:4168:		if (nand_maf_id != chip->read_byte(mtd) ||
./drivers/mtd/nand/nand_base.c:4169:		    nand_dev_id != chip->read_byte(mtd)) {
./drivers/mtd/nand/nand_base.c:4170:			chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:4173:		chip->select_chip(mtd, -1);
./drivers/mtd/nand/nand_base.c:4179:	chip->numchips = i;
./drivers/mtd/nand/nand_base.c:4180:	mtd->size = i * chip->chipsize;
./drivers/mtd/nand/nand_base.c:4189:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/nand_base.c:4279:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/nand_base.c:4282:	if (ecc->size == 0 || chip->ecc_step_ds == 0)
./drivers/mtd/nand/nand_base.c:4291:	ds_corr = (mtd->writesize * chip->ecc_strength_ds) / chip->ecc_step_ds;
./drivers/mtd/nand/nand_base.c:4293:	return corr >= ds_corr && ecc->strength >= chip->ecc_strength_ds;
./drivers/mtd/nand/nand_base.c:4307:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/nand_base.c:4312:	if (WARN_ON((chip->bbt_options & NAND_BBT_NO_OOB_BBM) &&
./drivers/mtd/nand/nand_base.c:4313:		   !(chip->bbt_options & NAND_BBT_USE_FLASH)))
./drivers/mtd/nand/nand_base.c:4316:	if (!(chip->options & NAND_OWN_BUFFERS)) {
./drivers/mtd/nand/nand_base.c:4325:		chip->buffers = nbuf;
./drivers/mtd/nand/nand_base.c:4327:		if (!chip->buffers)
./drivers/mtd/nand/nand_base.c:4332:	chip->oob_poi = chip->buffers->databuf + mtd->writesize;
./drivers/mtd/nand/nand_base.c:4356:	if (!chip->write_page)
./drivers/mtd/nand/nand_base.c:4357:		chip->write_page = nand_write_page;
./drivers/mtd/nand/nand_base.c:4496:	if (!(chip->options & NAND_NO_SUBPAGE_WRITE) && nand_is_slc(chip)) {
./drivers/mtd/nand/nand_base.c:4508:	chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
./drivers/mtd/nand/nand_base.c:4511:	chip->state = FL_READY;
./drivers/mtd/nand/nand_base.c:4514:	chip->pagebuf = -1;
./drivers/mtd/nand/nand_base.c:4519:		if (chip->page_shift > 9)
./drivers/mtd/nand/nand_base.c:4520:			chip->options |= NAND_SUBPAGE_READ;
./drivers/mtd/nand/nand_base.c:4529:	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
./drivers/mtd/nand/nand_base.c:4559:	if (chip->options & NAND_SKIP_BBTSCAN)
./drivers/mtd/nand/nand_base.c:4563:	return chip->scan_bbt(mtd);
./drivers/mtd/nand/nand_base.c:4565:	if (!(chip->options & NAND_OWN_BUFFERS))
./drivers/mtd/nand/nand_base.c:4566:		kfree(chip->buffers);
./drivers/mtd/nand/nand_base.c:4611:	if (chip->ecc.mode == NAND_ECC_SOFT &&
./drivers/mtd/nand/nand_base.c:4612:	    chip->ecc.algo == NAND_ECC_BCH)
./drivers/mtd/nand/nand_base.c:4613:		nand_bch_free((struct nand_bch_control *)chip->ecc.priv);
./drivers/mtd/nand/nand_base.c:4618:	kfree(chip->bbt);
./drivers/mtd/nand/nand_base.c:4619:	if (!(chip->options & NAND_OWN_BUFFERS))
./drivers/mtd/nand/nand_base.c:4620:		kfree(chip->buffers);
./drivers/mtd/nand/nand_base.c:4623:	if (chip->badblock_pattern && chip->badblock_pattern->options
./drivers/mtd/nand/nand_base.c:4625:		kfree(chip->badblock_pattern);
./drivers/mtd/nand/omap2.c:950:	unsigned int dev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;
./drivers/mtd/nand/omap2.c:1062:		nsectors = chip->ecc.steps;
./drivers/mtd/nand/omap2.c:1082:		nsectors = chip->ecc.steps;
./drivers/mtd/nand/omap2.c:1095:		nsectors = chip->ecc.steps;
./drivers/mtd/nand/omap2.c:1116:	dev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;
./drivers/mtd/nand/omap2.c:1483: * @oob_required:	must write chip->oob_poi to OOB
./drivers/mtd/nand/omap2.c:1492:	uint8_t *ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/omap2.c:1495:	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
./drivers/mtd/nand/omap2.c:1498:	chip->write_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/omap2.c:1501:	chip->ecc.calculate(mtd, buf, &ecc_calc[0]);
./drivers/mtd/nand/omap2.c:1503:	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,
./drivers/mtd/nand/omap2.c:1504:					 chip->ecc.total);
./drivers/mtd/nand/omap2.c:1509:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/omap2.c:1518: * @oob_required:	caller requires OOB data read to chip->oob_poi
./drivers/mtd/nand/omap2.c:1531:	uint8_t *ecc_calc = chip->buffers->ecccalc;
./drivers/mtd/nand/omap2.c:1532:	uint8_t *ecc_code = chip->buffers->ecccode;
./drivers/mtd/nand/omap2.c:1537:	chip->ecc.hwctl(mtd, NAND_ECC_READ);
./drivers/mtd/nand/omap2.c:1540:	chip->read_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/omap2.c:1543:	chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
./drivers/mtd/nand/omap2.c:1545:	chip->read_buf(mtd, chip->oob_poi + BADBLOCK_MARKER_LENGTH,
./drivers/mtd/nand/omap2.c:1546:		       chip->ecc.total);
./drivers/mtd/nand/omap2.c:1549:	chip->ecc.calculate(mtd, buf, ecc_calc);
./drivers/mtd/nand/omap2.c:1551:	ret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,
./drivers/mtd/nand/omap2.c:1552:					 chip->ecc.total);
./drivers/mtd/nand/omap2.c:1556:	stat = chip->ecc.correct(mtd, buf, ecc_code, ecc_calc);
./drivers/mtd/nand/omap2.c:1718:	    !(chip->options & NAND_BUSWIDTH_16))
./drivers/mtd/nand/omap2.c:1725:	oobregion->length = chip->ecc.total;
./drivers/mtd/nand/omap2.c:1738:	    !(chip->options & NAND_BUSWIDTH_16))
./drivers/mtd/nand/omap2.c:1744:	off += chip->ecc.total;
./drivers/mtd/nand/omap2.c:1765:	if (section >= chip->ecc.steps)
./drivers/mtd/nand/omap2.c:1772:	oobregion->offset = off + (section * (chip->ecc.bytes + 1));
./drivers/mtd/nand/omap2.c:1773:	oobregion->length = chip->ecc.bytes;
./drivers/mtd/nand/omap2.c:1791:	off += ((chip->ecc.bytes + 1) * chip->ecc.steps);
./drivers/mtd/nand/omap2.c:1859:	nand_chip->ecc.priv	= NULL;
./drivers/mtd/nand/omap2.c:1863:	nand_chip->IO_ADDR_R = devm_ioremap_resource(&pdev->dev, res);
./drivers/mtd/nand/omap2.c:1864:	if (IS_ERR(nand_chip->IO_ADDR_R))
./drivers/mtd/nand/omap2.c:1865:		return PTR_ERR(nand_chip->IO_ADDR_R);
./drivers/mtd/nand/omap2.c:1869:	nand_chip->controller = &omap_gpmc_controller;
./drivers/mtd/nand/omap2.c:1871:	nand_chip->IO_ADDR_W = nand_chip->IO_ADDR_R;
./drivers/mtd/nand/omap2.c:1872:	nand_chip->cmd_ctrl  = omap_hwcontrol;
./drivers/mtd/nand/omap2.c:1889:		nand_chip->dev_ready = omap_dev_ready;
./drivers/mtd/nand/omap2.c:1890:		nand_chip->chip_delay = 0;
./drivers/mtd/nand/omap2.c:1892:		nand_chip->waitfunc = omap_wait;
./drivers/mtd/nand/omap2.c:1893:		nand_chip->chip_delay = 50;
./drivers/mtd/nand/omap2.c:1897:		nand_chip->bbt_options |= NAND_BBT_USE_FLASH;
./drivers/mtd/nand/omap2.c:1900:	nand_chip->options |= info->devsize & NAND_BUSWIDTH_16;
./drivers/mtd/nand/omap2.c:1908:	if (nand_chip->bbt_options & NAND_BBT_USE_FLASH)
./drivers/mtd/nand/omap2.c:1909:		nand_chip->bbt_options |= NAND_BBT_NO_OOB;
./drivers/mtd/nand/omap2.c:1911:		nand_chip->options |= NAND_SKIP_BBTSCAN;
./drivers/mtd/nand/omap2.c:1916:		nand_chip->read_buf   = omap_read_buf_pref;
./drivers/mtd/nand/omap2.c:1917:		nand_chip->write_buf  = omap_write_buf_pref;
./drivers/mtd/nand/omap2.c:1949:			nand_chip->read_buf   = omap_read_buf_dma_pref;
./drivers/mtd/nand/omap2.c:1950:			nand_chip->write_buf  = omap_write_buf_dma_pref;
./drivers/mtd/nand/omap2.c:1987:		nand_chip->read_buf  = omap_read_buf_irq_pref;
./drivers/mtd/nand/omap2.c:1988:		nand_chip->write_buf = omap_write_buf_irq_pref;
./drivers/mtd/nand/omap2.c:2009:		nand_chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/omap2.c:2010:		nand_chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/omap2.c:2018:		nand_chip->ecc.mode             = NAND_ECC_HW;
./drivers/mtd/nand/omap2.c:2019:		nand_chip->ecc.bytes            = 3;
./drivers/mtd/nand/omap2.c:2020:		nand_chip->ecc.size             = 512;
./drivers/mtd/nand/omap2.c:2021:		nand_chip->ecc.strength         = 1;
./drivers/mtd/nand/omap2.c:2022:		nand_chip->ecc.calculate        = omap_calculate_ecc;
./drivers/mtd/nand/omap2.c:2023:		nand_chip->ecc.hwctl            = omap_enable_hwecc;
./drivers/mtd/nand/omap2.c:2024:		nand_chip->ecc.correct          = omap_correct_data;
./drivers/mtd/nand/omap2.c:2026:		oobbytes_per_step		= nand_chip->ecc.bytes;
./drivers/mtd/nand/omap2.c:2028:		if (!(nand_chip->options & NAND_BUSWIDTH_16))
./drivers/mtd/nand/omap2.c:2035:		nand_chip->ecc.mode		= NAND_ECC_HW;
./drivers/mtd/nand/omap2.c:2036:		nand_chip->ecc.size		= 512;
./drivers/mtd/nand/omap2.c:2037:		nand_chip->ecc.bytes		= 7;
./drivers/mtd/nand/omap2.c:2038:		nand_chip->ecc.strength		= 4;
./drivers/mtd/nand/omap2.c:2039:		nand_chip->ecc.hwctl		= omap_enable_hwecc_bch;
./drivers/mtd/nand/omap2.c:2040:		nand_chip->ecc.correct		= nand_bch_correct_data;
./drivers/mtd/nand/omap2.c:2041:		nand_chip->ecc.calculate	= omap_calculate_ecc_bch;
./drivers/mtd/nand/omap2.c:2044:		oobbytes_per_step		= nand_chip->ecc.bytes + 1;
./drivers/mtd/nand/omap2.c:2046:		nand_chip->ecc.priv		= nand_bch_init(mtd);
./drivers/mtd/nand/omap2.c:2047:		if (!nand_chip->ecc.priv) {
./drivers/mtd/nand/omap2.c:2056:		nand_chip->ecc.mode		= NAND_ECC_HW;
./drivers/mtd/nand/omap2.c:2057:		nand_chip->ecc.size		= 512;
./drivers/mtd/nand/omap2.c:2059:		nand_chip->ecc.bytes		= 7 + 1;
./drivers/mtd/nand/omap2.c:2060:		nand_chip->ecc.strength		= 4;
./drivers/mtd/nand/omap2.c:2061:		nand_chip->ecc.hwctl		= omap_enable_hwecc_bch;
./drivers/mtd/nand/omap2.c:2062:		nand_chip->ecc.correct		= omap_elm_correct_data;
./drivers/mtd/nand/omap2.c:2063:		nand_chip->ecc.calculate	= omap_calculate_ecc_bch;
./drivers/mtd/nand/omap2.c:2064:		nand_chip->ecc.read_page	= omap_read_page_bch;
./drivers/mtd/nand/omap2.c:2065:		nand_chip->ecc.write_page	= omap_write_page_bch;
./drivers/mtd/nand/omap2.c:2067:		oobbytes_per_step		= nand_chip->ecc.bytes;
./drivers/mtd/nand/omap2.c:2070:				 mtd->writesize / nand_chip->ecc.size,
./drivers/mtd/nand/omap2.c:2071:				 nand_chip->ecc.size, nand_chip->ecc.bytes);
./drivers/mtd/nand/omap2.c:2078:		nand_chip->ecc.mode		= NAND_ECC_HW;
./drivers/mtd/nand/omap2.c:2079:		nand_chip->ecc.size		= 512;
./drivers/mtd/nand/omap2.c:2080:		nand_chip->ecc.bytes		= 13;
./drivers/mtd/nand/omap2.c:2081:		nand_chip->ecc.strength		= 8;
./drivers/mtd/nand/omap2.c:2082:		nand_chip->ecc.hwctl		= omap_enable_hwecc_bch;
./drivers/mtd/nand/omap2.c:2083:		nand_chip->ecc.correct		= nand_bch_correct_data;
./drivers/mtd/nand/omap2.c:2084:		nand_chip->ecc.calculate	= omap_calculate_ecc_bch;
./drivers/mtd/nand/omap2.c:2087:		oobbytes_per_step		= nand_chip->ecc.bytes + 1;
./drivers/mtd/nand/omap2.c:2089:		nand_chip->ecc.priv		= nand_bch_init(mtd);
./drivers/mtd/nand/omap2.c:2090:		if (!nand_chip->ecc.priv) {
./drivers/mtd/nand/omap2.c:2099:		nand_chip->ecc.mode		= NAND_ECC_HW;
./drivers/mtd/nand/omap2.c:2100:		nand_chip->ecc.size		= 512;
./drivers/mtd/nand/omap2.c:2102:		nand_chip->ecc.bytes		= 13 + 1;
./drivers/mtd/nand/omap2.c:2103:		nand_chip->ecc.strength		= 8;
./drivers/mtd/nand/omap2.c:2104:		nand_chip->ecc.hwctl		= omap_enable_hwecc_bch;
./drivers/mtd/nand/omap2.c:2105:		nand_chip->ecc.correct		= omap_elm_correct_data;
./drivers/mtd/nand/omap2.c:2106:		nand_chip->ecc.calculate	= omap_calculate_ecc_bch;
./drivers/mtd/nand/omap2.c:2107:		nand_chip->ecc.read_page	= omap_read_page_bch;
./drivers/mtd/nand/omap2.c:2108:		nand_chip->ecc.write_page	= omap_write_page_bch;
./drivers/mtd/nand/omap2.c:2110:		oobbytes_per_step		= nand_chip->ecc.bytes;
./drivers/mtd/nand/omap2.c:2113:				 mtd->writesize / nand_chip->ecc.size,
./drivers/mtd/nand/omap2.c:2114:				 nand_chip->ecc.size, nand_chip->ecc.bytes);
./drivers/mtd/nand/omap2.c:2122:		nand_chip->ecc.mode		= NAND_ECC_HW;
./drivers/mtd/nand/omap2.c:2123:		nand_chip->ecc.size		= 512;
./drivers/mtd/nand/omap2.c:2124:		nand_chip->ecc.bytes		= 26;
./drivers/mtd/nand/omap2.c:2125:		nand_chip->ecc.strength		= 16;
./drivers/mtd/nand/omap2.c:2126:		nand_chip->ecc.hwctl		= omap_enable_hwecc_bch;
./drivers/mtd/nand/omap2.c:2127:		nand_chip->ecc.correct		= omap_elm_correct_data;
./drivers/mtd/nand/omap2.c:2128:		nand_chip->ecc.calculate	= omap_calculate_ecc_bch;
./drivers/mtd/nand/omap2.c:2129:		nand_chip->ecc.read_page	= omap_read_page_bch;
./drivers/mtd/nand/omap2.c:2130:		nand_chip->ecc.write_page	= omap_write_page_bch;
./drivers/mtd/nand/omap2.c:2132:		oobbytes_per_step		= nand_chip->ecc.bytes;
./drivers/mtd/nand/omap2.c:2135:				 mtd->writesize / nand_chip->ecc.size,
./drivers/mtd/nand/omap2.c:2136:				 nand_chip->ecc.size, nand_chip->ecc.bytes);
./drivers/mtd/nand/omap2.c:2149:			 (mtd->writesize / nand_chip->ecc.size));
./drivers/mtd/nand/omap2.c:2177:	if (nand_chip->ecc.priv) {
./drivers/mtd/nand/omap2.c:2178:		nand_bch_free(nand_chip->ecc.priv);
./drivers/mtd/nand/omap2.c:2179:		nand_chip->ecc.priv = NULL;
./drivers/mtd/nand/omap2.c:2189:	if (nand_chip->ecc.priv) {
./drivers/mtd/nand/omap2.c:2190:		nand_bch_free(nand_chip->ecc.priv);
./drivers/mtd/nand/omap2.c:2191:		nand_chip->ecc.priv = NULL;
./drivers/mtd/nand/sm_common.c:169:	chip->options |= NAND_SKIP_BBTSCAN;
./drivers/mtd/nand/sm_common.c:179:	chip->badblockpos = 0x05;
./drivers/mtd/nand/sm_common.c:180:	chip->badblockbits = 7;
./drivers/mtd/nand/sm_common.c:181:	chip->block_markbad = sm_block_markbad;
./drivers/mtd/nand/jz4780_nand.c:164:	struct jz4780_nand_controller *nfc = to_jz4780_nand_controller(chip->controller);
./drivers/mtd/nand/jz4780_nand.c:167:	chip->ecc.bytes = fls((1 + 8) * chip->ecc.size)	*
./drivers/mtd/nand/jz4780_nand.c:168:				(chip->ecc.strength / 8);
./drivers/mtd/nand/jz4780_nand.c:170:	switch (chip->ecc.mode) {
./drivers/mtd/nand/jz4780_nand.c:177:		chip->ecc.hwctl = jz4780_nand_ecc_hwctl;
./drivers/mtd/nand/jz4780_nand.c:178:		chip->ecc.calculate = jz4780_nand_ecc_calculate;
./drivers/mtd/nand/jz4780_nand.c:179:		chip->ecc.correct = jz4780_nand_ecc_correct;
./drivers/mtd/nand/jz4780_nand.c:184:			chip->ecc.strength, chip->ecc.size, chip->ecc.bytes);
./drivers/mtd/nand/jz4780_nand.c:190:		dev_err(dev, "ECC mode %d not supported\n", chip->ecc.mode);
./drivers/mtd/nand/jz4780_nand.c:195:	if (chip->ecc.mode != NAND_ECC_HW)
./drivers/mtd/nand/jz4780_nand.c:199:	eccbytes = mtd->writesize / chip->ecc.size * chip->ecc.bytes;
./drivers/mtd/nand/jz4780_nand.c:272:	chip->IO_ADDR_R = cs->base + OFFSET_DATA;
./drivers/mtd/nand/jz4780_nand.c:273:	chip->IO_ADDR_W = cs->base + OFFSET_DATA;
./drivers/mtd/nand/jz4780_nand.c:274:	chip->chip_delay = RB_DELAY_US;
./drivers/mtd/nand/jz4780_nand.c:275:	chip->options = NAND_NO_SUBPAGE_WRITE;
./drivers/mtd/nand/jz4780_nand.c:276:	chip->select_chip = jz4780_nand_select_chip;
./drivers/mtd/nand/jz4780_nand.c:277:	chip->cmd_ctrl = jz4780_nand_cmd_ctrl;
./drivers/mtd/nand/jz4780_nand.c:278:	chip->ecc.mode = NAND_ECC_HW;
./drivers/mtd/nand/jz4780_nand.c:279:	chip->controller = &nfc->controller;
./drivers/mtd/nand/jz4780_nand.c:311:		nand_release(nand_to_mtd(&chip->chip));
./drivers/mtd/nand/jz4780_nand.c:312:		list_del(&chip->chip_list);
./drivers/mtd/nand/fsl_elbc_nand.c:88:	if (section >= chip->ecc.steps)
./drivers/mtd/nand/fsl_elbc_nand.c:95:	oobregion->length = chip->ecc.bytes;
./drivers/mtd/nand/fsl_elbc_nand.c:106:	if (section > chip->ecc.steps)
./drivers/mtd/nand/fsl_elbc_nand.c:117:		if (section < chip->ecc.steps)
./drivers/mtd/nand/fsl_elbc_nand.c:210:	         chip->phys_erase_shift, chip->page_shift);
./drivers/mtd/nand/fsl_elbc_nand.c:260:	if (chip->ecc.mode != NAND_ECC_HW)
./drivers/mtd/nand/fsl_elbc_nand.c:650:	if (chip->pagemask & 0xffff0000)
./drivers/mtd/nand/fsl_elbc_nand.c:652:	if (chip->pagemask & 0xff000000)
./drivers/mtd/nand/fsl_elbc_nand.c:658:	        chip->numchips);
./drivers/mtd/nand/fsl_elbc_nand.c:660:	        chip->chipsize);
./drivers/mtd/nand/fsl_elbc_nand.c:662:	        chip->pagemask);
./drivers/mtd/nand/fsl_elbc_nand.c:664:	        chip->chip_delay);
./drivers/mtd/nand/fsl_elbc_nand.c:666:	        chip->badblockpos);
./drivers/mtd/nand/fsl_elbc_nand.c:668:	        chip->chip_shift);
./drivers/mtd/nand/fsl_elbc_nand.c:670:	        chip->page_shift);
./drivers/mtd/nand/fsl_elbc_nand.c:672:	        chip->phys_erase_shift);
./drivers/mtd/nand/fsl_elbc_nand.c:674:	        chip->ecc.mode);
./drivers/mtd/nand/fsl_elbc_nand.c:676:	        chip->ecc.steps);
./drivers/mtd/nand/fsl_elbc_nand.c:678:	        chip->ecc.bytes);
./drivers/mtd/nand/fsl_elbc_nand.c:680:	        chip->ecc.total);
./drivers/mtd/nand/fsl_elbc_nand.c:718:		fsl_elbc_read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/fsl_elbc_nand.c:733:	fsl_elbc_write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/fsl_elbc_nand.c:746:	fsl_elbc_write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/fsl_elbc_nand.c:772:	chip->read_byte = fsl_elbc_read_byte;
./drivers/mtd/nand/fsl_elbc_nand.c:773:	chip->write_buf = fsl_elbc_write_buf;
./drivers/mtd/nand/fsl_elbc_nand.c:774:	chip->read_buf = fsl_elbc_read_buf;
./drivers/mtd/nand/fsl_elbc_nand.c:775:	chip->select_chip = fsl_elbc_select_chip;
./drivers/mtd/nand/fsl_elbc_nand.c:776:	chip->cmdfunc = fsl_elbc_cmdfunc;
./drivers/mtd/nand/fsl_elbc_nand.c:777:	chip->waitfunc = fsl_elbc_wait;
./drivers/mtd/nand/fsl_elbc_nand.c:779:	chip->bbt_td = &bbt_main_descr;
./drivers/mtd/nand/fsl_elbc_nand.c:780:	chip->bbt_md = &bbt_mirror_descr;
./drivers/mtd/nand/fsl_elbc_nand.c:783:	chip->bbt_options = NAND_BBT_USE_FLASH;
./drivers/mtd/nand/fsl_elbc_nand.c:785:	chip->controller = &elbc_fcm_ctrl->controller;
./drivers/mtd/nand/fsl_elbc_nand.c:788:	chip->ecc.read_page = fsl_elbc_read_page;
./drivers/mtd/nand/fsl_elbc_nand.c:789:	chip->ecc.write_page = fsl_elbc_write_page;
./drivers/mtd/nand/fsl_elbc_nand.c:790:	chip->ecc.write_subpage = fsl_elbc_write_subpage;
./drivers/mtd/nand/fsl_elbc_nand.c:795:		chip->ecc.mode = NAND_ECC_HW;
./drivers/mtd/nand/fsl_elbc_nand.c:797:		chip->ecc.size = 512;
./drivers/mtd/nand/fsl_elbc_nand.c:798:		chip->ecc.bytes = 3;
./drivers/mtd/nand/fsl_elbc_nand.c:799:		chip->ecc.strength = 1;
./drivers/mtd/nand/fsl_elbc_nand.c:802:		chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/fsl_elbc_nand.c:803:		chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/jz4740_nand.c:95:		chip->IO_ADDR_R = nand->bank_base[banknr];
./drivers/mtd/nand/jz4740_nand.c:96:		chip->IO_ADDR_W = nand->bank_base[banknr];
./drivers/mtd/nand/jz4740_nand.c:118:		chip->IO_ADDR_W = bank_base;
./drivers/mtd/nand/jz4740_nand.c:128:		writeb(dat, chip->IO_ADDR_W);
./drivers/mtd/nand/jz4740_nand.c:352:		chip->select_chip(mtd, 0);
./drivers/mtd/nand/jz4740_nand.c:353:		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
./drivers/mtd/nand/jz4740_nand.c:354:		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
./drivers/mtd/nand/jz4740_nand.c:355:		*nand_maf_id = chip->read_byte(mtd);
./drivers/mtd/nand/jz4740_nand.c:356:		*nand_dev_id = chip->read_byte(mtd);
./drivers/mtd/nand/jz4740_nand.c:359:		chip->select_chip(mtd, chipnr);
./drivers/mtd/nand/jz4740_nand.c:360:		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
./drivers/mtd/nand/jz4740_nand.c:361:		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
./drivers/mtd/nand/jz4740_nand.c:362:		if (*nand_maf_id != chip->read_byte(mtd)
./drivers/mtd/nand/jz4740_nand.c:363:		 || *nand_dev_id != chip->read_byte(mtd)) {
./drivers/mtd/nand/jz4740_nand.c:369:		chip->numchips++;
./drivers/mtd/nand/jz4740_nand.c:370:		mtd->size += chip->chipsize;
./drivers/mtd/nand/jz4740_nand.c:420:	chip->ecc.hwctl		= jz_nand_hwctl;
./drivers/mtd/nand/jz4740_nand.c:421:	chip->ecc.calculate	= jz_nand_calculate_ecc_rs;
./drivers/mtd/nand/jz4740_nand.c:422:	chip->ecc.correct	= jz_nand_correct_ecc_rs;
./drivers/mtd/nand/jz4740_nand.c:423:	chip->ecc.mode		= NAND_ECC_HW_OOB_FIRST;
./drivers/mtd/nand/jz4740_nand.c:424:	chip->ecc.size		= 512;
./drivers/mtd/nand/jz4740_nand.c:425:	chip->ecc.bytes		= 9;
./drivers/mtd/nand/jz4740_nand.c:426:	chip->ecc.strength	= 4;
./drivers/mtd/nand/jz4740_nand.c:427:	chip->ecc.options	= NAND_ECC_GENERIC_ERASED_CHECK;
./drivers/mtd/nand/jz4740_nand.c:429:	chip->chip_delay = 50;
./drivers/mtd/nand/jz4740_nand.c:430:	chip->cmd_ctrl = jz_nand_cmd_ctrl;
./drivers/mtd/nand/jz4740_nand.c:431:	chip->select_chip = jz_nand_select_chip;
./drivers/mtd/nand/jz4740_nand.c:434:		chip->dev_ready = jz_nand_dev_ready;
./drivers/mtd/nand/jz4740_nand.c:441:	 * always the case for external memory banks. And a fixed chip-to-bank
./drivers/mtd/nand/lpc32xx_slc.c:402:	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
./drivers/mtd/nand/lpc32xx_slc.c:403:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/lpc32xx_slc.c:416:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
./drivers/mtd/nand/lpc32xx_slc.c:417:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/lpc32xx_slc.c:420:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/lpc32xx_slc.c:422:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/lpc32xx_slc.c:554:	for (i = 0; i < chip->ecc.steps; i++) {
./drivers/mtd/nand/lpc32xx_slc.c:557:				       dma_buf + i * chip->ecc.size,
./drivers/mtd/nand/lpc32xx_slc.c:558:				       mtd->writesize / chip->ecc.steps, dir);
./drivers/mtd/nand/lpc32xx_slc.c:563:		if (i == chip->ecc.steps - 1)
./drivers/mtd/nand/lpc32xx_slc.c:595:	host->ecc_buf[chip->ecc.steps - 1] =
./drivers/mtd/nand/lpc32xx_slc.c:635:	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
./drivers/mtd/nand/lpc32xx_slc.c:638:	status = lpc32xx_xfer(mtd, buf, chip->ecc.steps, 1);
./drivers/mtd/nand/lpc32xx_slc.c:641:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/lpc32xx_slc.c:644:	lpc32xx_slc_ecc_copy(tmpecc, (uint32_t *) host->ecc_buf, chip->ecc.steps);
./drivers/mtd/nand/lpc32xx_slc.c:651:	oobecc = chip->oob_poi + oobregion.offset;
./drivers/mtd/nand/lpc32xx_slc.c:653:	for (i = 0; i < chip->ecc.steps; i++) {
./drivers/mtd/nand/lpc32xx_slc.c:654:		stat = chip->ecc.correct(mtd, buf, oobecc,
./drivers/mtd/nand/lpc32xx_slc.c:655:					 &tmpecc[i * chip->ecc.bytes]);
./drivers/mtd/nand/lpc32xx_slc.c:661:		buf += chip->ecc.size;
./drivers/mtd/nand/lpc32xx_slc.c:662:		oobecc += chip->ecc.bytes;
./drivers/mtd/nand/lpc32xx_slc.c:678:	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
./drivers/mtd/nand/lpc32xx_slc.c:681:	chip->read_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);
./drivers/mtd/nand/lpc32xx_slc.c:682:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/lpc32xx_slc.c:702:	error = lpc32xx_xfer(mtd, (uint8_t *)buf, chip->ecc.steps, 0);
./drivers/mtd/nand/lpc32xx_slc.c:714:	pb = chip->oob_poi + oobregion.offset;
./drivers/mtd/nand/lpc32xx_slc.c:715:	lpc32xx_slc_ecc_copy(pb, (uint32_t *)host->ecc_buf, chip->ecc.steps);
./drivers/mtd/nand/lpc32xx_slc.c:718:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/lpc32xx_slc.c:732:	chip->write_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);
./drivers/mtd/nand/lpc32xx_slc.c:733:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/lpc32xx_slc.c:851:	chip->IO_ADDR_R = SLC_DATA(host->io_base);
./drivers/mtd/nand/lpc32xx_slc.c:852:	chip->IO_ADDR_W = SLC_DATA(host->io_base);
./drivers/mtd/nand/lpc32xx_slc.c:853:	chip->cmd_ctrl = lpc32xx_nand_cmd_ctrl;
./drivers/mtd/nand/lpc32xx_slc.c:854:	chip->dev_ready = lpc32xx_nand_device_ready;
./drivers/mtd/nand/lpc32xx_slc.c:855:	chip->chip_delay = 20; /* 20us command delay time */
./drivers/mtd/nand/lpc32xx_slc.c:863:	chip->ecc.mode = NAND_ECC_HW_SYNDROME;
./drivers/mtd/nand/lpc32xx_slc.c:864:	chip->read_byte = lpc32xx_nand_read_byte;
./drivers/mtd/nand/lpc32xx_slc.c:865:	chip->read_buf = lpc32xx_nand_read_buf;
./drivers/mtd/nand/lpc32xx_slc.c:866:	chip->write_buf = lpc32xx_nand_write_buf;
./drivers/mtd/nand/lpc32xx_slc.c:867:	chip->ecc.read_page_raw = lpc32xx_nand_read_page_raw_syndrome;
./drivers/mtd/nand/lpc32xx_slc.c:868:	chip->ecc.read_page = lpc32xx_nand_read_page_syndrome;
./drivers/mtd/nand/lpc32xx_slc.c:869:	chip->ecc.write_page_raw = lpc32xx_nand_write_page_raw_syndrome;
./drivers/mtd/nand/lpc32xx_slc.c:870:	chip->ecc.write_page = lpc32xx_nand_write_page_syndrome;
./drivers/mtd/nand/lpc32xx_slc.c:871:	chip->ecc.write_oob = lpc32xx_nand_write_oob_syndrome;
./drivers/mtd/nand/lpc32xx_slc.c:872:	chip->ecc.read_oob = lpc32xx_nand_read_oob_syndrome;
./drivers/mtd/nand/lpc32xx_slc.c:873:	chip->ecc.calculate = lpc32xx_nand_ecc_calculate;
./drivers/mtd/nand/lpc32xx_slc.c:874:	chip->ecc.correct = nand_correct_data;
./drivers/mtd/nand/lpc32xx_slc.c:875:	chip->ecc.strength = 1;
./drivers/mtd/nand/lpc32xx_slc.c:876:	chip->ecc.hwctl = lpc32xx_nand_ecc_enable;
./drivers/mtd/nand/lpc32xx_slc.c:914:	chip->ecc.size = 256;
./drivers/mtd/nand/lpc32xx_slc.c:915:	chip->ecc.bytes = LPC32XX_SLC_DEV_ECC_BYTES;
./drivers/mtd/nand/lpc32xx_slc.c:916:	chip->ecc.prepad = chip->ecc.postpad = 0;
./drivers/mtd/nand/lpc32xx_slc.c:923:	if ((chip->bbt_options & NAND_BBT_USE_FLASH) &&
./drivers/mtd/nand/lpc32xx_slc.c:925:		chip->bbt_td = &bbt_smallpage_main_descr;
./drivers/mtd/nand/lpc32xx_slc.c:926:		chip->bbt_md = &bbt_smallpage_mirror_descr;
./drivers/mtd/nand/davinci_nand.c:204:			if ((diff >> (12 + 3)) < chip->ecc.size) {
./drivers/mtd/nand/davinci_nand.c:444:		ioread32_rep(chip->IO_ADDR_R, buf, len >> 2);
./drivers/mtd/nand/davinci_nand.c:446:		ioread16_rep(chip->IO_ADDR_R, buf, len >> 1);
./drivers/mtd/nand/davinci_nand.c:448:		ioread8_rep(chip->IO_ADDR_R, buf, len);
./drivers/mtd/nand/davinci_nand.c:457:		iowrite32_rep(chip->IO_ADDR_R, buf, len >> 2);
./drivers/mtd/nand/davinci_nand.c:459:		iowrite16_rep(chip->IO_ADDR_R, buf, len >> 1);
./drivers/mtd/nand/davinci_nand.c:461:		iowrite8_rep(chip->IO_ADDR_R, buf, len);
./drivers/mtd/nand/sh_flctl.c:54:	oobregion->length = chip->ecc.bytes;
./drivers/mtd/nand/sh_flctl.c:81:	if (section >= chip->ecc.steps)
./drivers/mtd/nand/sh_flctl.c:85:	oobregion->length = chip->ecc.bytes;
./drivers/mtd/nand/sh_flctl.c:95:	if (section >= chip->ecc.steps)
./drivers/mtd/nand/sh_flctl.c:611:	chip->read_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/sh_flctl.c:613:		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/sh_flctl.c:621:	chip->write_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/sh_flctl.c:622:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/sh_flctl.c:1006:		if (chip->chipsize > (32 << 20)) {
./drivers/mtd/nand/sh_flctl.c:1010:		} else if (chip->chipsize > (2 << 16)) {
./drivers/mtd/nand/sh_flctl.c:1020:		if (chip->chipsize > (128 << 20)) {
./drivers/mtd/nand/sh_flctl.c:1024:		} else if (chip->chipsize > (8 << 16)) {
./drivers/mtd/nand/sh_flctl.c:1037:			chip->badblock_pattern = &flctl_4secc_smallpage;
./drivers/mtd/nand/sh_flctl.c:1040:			chip->badblock_pattern = &flctl_4secc_largepage;
./drivers/mtd/nand/sh_flctl.c:1043:		chip->ecc.size = 512;
./drivers/mtd/nand/sh_flctl.c:1044:		chip->ecc.bytes = 10;
./drivers/mtd/nand/sh_flctl.c:1045:		chip->ecc.strength = 4;
./drivers/mtd/nand/sh_flctl.c:1046:		chip->ecc.read_page = flctl_read_page_hwecc;
./drivers/mtd/nand/sh_flctl.c:1047:		chip->ecc.write_page = flctl_write_page_hwecc;
./drivers/mtd/nand/sh_flctl.c:1048:		chip->ecc.mode = NAND_ECC_HW;
./drivers/mtd/nand/sh_flctl.c:1053:		chip->ecc.mode = NAND_ECC_SOFT;
./drivers/mtd/nand/sh_flctl.c:1054:		chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/fsl_upm.c:105:	fsl_upm_run_pattern(&fun->upm, chip->IO_ADDR_R, mar);
./drivers/mtd/nand/fsl_upm.c:117:		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
./drivers/mtd/nand/fsl_upm.c:120:		chip->IO_ADDR_R = fun->io_base + fun->mchip_offsets[mchip_nr];
./drivers/mtd/nand/fsl_upm.c:121:		chip->IO_ADDR_W = chip->IO_ADDR_R;
./drivers/mtd/nand/fsl_upm.c:281:	prop = of_get_property(ofdev->dev.of_node, "chip-delay", NULL);
./drivers/mtd/nand/brcmnand/brcmnand.c:133:	/* List of NAND hosts (one for each chip-select) */
./drivers/mtd/nand/brcmnand/brcmnand.c:145:	const u8		*cs_offsets; /* within each chip-select */
./drivers/mtd/nand/brcmnand/brcmnand.c:351:/* Per chip-select offsets for v7.1 */
./drivers/mtd/nand/brcmnand/brcmnand.c:360:/* Per chip-select offsets for pre v7.1, except CS0 on <= v5.0 */
./drivers/mtd/nand/brcmnand/brcmnand.c:369:/* Per chip-select offset for <= v5.0 on CS0 only */
./drivers/mtd/nand/brcmnand/brcmnand.c:453:	/* Per chip-select registers */
./drivers/mtd/nand/brcmnand/brcmnand.c:857:	oobregion->offset = (section * (sas + 1)) - chip->ecc.bytes;
./drivers/mtd/nand/brcmnand/brcmnand.c:858:	oobregion->length = chip->ecc.bytes;
./drivers/mtd/nand/brcmnand/brcmnand.c:875:	if (sas <= chip->ecc.bytes)
./drivers/mtd/nand/brcmnand/brcmnand.c:879:	oobregion->length = sas - chip->ecc.bytes;
./drivers/mtd/nand/brcmnand/brcmnand.c:897:	if (section > 1 || sas - chip->ecc.bytes < 6 ||
./drivers/mtd/nand/brcmnand/brcmnand.c:898:	    (section && sas - chip->ecc.bytes == 6))
./drivers/mtd/nand/brcmnand/brcmnand.c:906:		oobregion->length = sas - chip->ecc.bytes - 6;
./drivers/mtd/nand/brcmnand/brcmnand.c:1207:	u64 addr = (u64)page_addr << chip->page_shift;
./drivers/mtd/nand/brcmnand/brcmnand.c:1344:			chip->cmdfunc(mtd, NAND_CMD_RNDOUT, addr, -1);
./drivers/mtd/nand/brcmnand/brcmnand.c:1602:	u8 *oob = oob_required ? (u8 *)chip->oob_poi : NULL;
./drivers/mtd/nand/brcmnand/brcmnand.c:1612:	u8 *oob = oob_required ? (u8 *)chip->oob_poi : NULL;
./drivers/mtd/nand/brcmnand/brcmnand.c:1625:	return brcmnand_read(mtd, chip, (u64)page << chip->page_shift,
./drivers/mtd/nand/brcmnand/brcmnand.c:1627:			NULL, (u8 *)chip->oob_poi);
./drivers/mtd/nand/brcmnand/brcmnand.c:1636:	brcmnand_read(mtd, chip, (u64)page << chip->page_shift,
./drivers/mtd/nand/brcmnand/brcmnand.c:1638:		NULL, (u8 *)chip->oob_poi);
./drivers/mtd/nand/brcmnand/brcmnand.c:1718:	void *oob = oob_required ? chip->oob_poi : NULL;
./drivers/mtd/nand/brcmnand/brcmnand.c:1729:	void *oob = oob_required ? chip->oob_poi : NULL;
./drivers/mtd/nand/brcmnand/brcmnand.c:1740:	return brcmnand_write(mtd, chip, (u64)page << chip->page_shift,
./drivers/mtd/nand/brcmnand/brcmnand.c:1741:				  NULL, chip->oob_poi);
./drivers/mtd/nand/brcmnand/brcmnand.c:1751:	ret = brcmnand_write(mtd, chip, (u64)page << chip->page_shift, NULL,
./drivers/mtd/nand/brcmnand/brcmnand.c:1752:				 (u8 *)chip->oob_poi);
./drivers/mtd/nand/brcmnand/brcmnand.c:1855:	brcmnand_wr_corr_thresh(host, DIV_ROUND_UP(chip->ecc.strength * 3, 4));
./drivers/mtd/nand/brcmnand/brcmnand.c:1924:	cfg->device_width = (chip->options & NAND_BUSWIDTH_16) ? 16 : 8;
./drivers/mtd/nand/brcmnand/brcmnand.c:1928:	if (chip->ecc.mode != NAND_ECC_HW) {
./drivers/mtd/nand/brcmnand/brcmnand.c:1930:			chip->ecc.mode);
./drivers/mtd/nand/brcmnand/brcmnand.c:1934:	if (chip->ecc.algo == NAND_ECC_UNKNOWN) {
./drivers/mtd/nand/brcmnand/brcmnand.c:1935:		if (chip->ecc.strength == 1 && chip->ecc.size == 512)
./drivers/mtd/nand/brcmnand/brcmnand.c:1937:			chip->ecc.algo = NAND_ECC_HAMMING;
./drivers/mtd/nand/brcmnand/brcmnand.c:1940:			chip->ecc.algo = NAND_ECC_BCH;
./drivers/mtd/nand/brcmnand/brcmnand.c:1943:	if (chip->ecc.algo == NAND_ECC_HAMMING && (chip->ecc.strength != 1 ||
./drivers/mtd/nand/brcmnand/brcmnand.c:1944:						   chip->ecc.size != 512)) {
./drivers/mtd/nand/brcmnand/brcmnand.c:1946:			chip->ecc.strength, chip->ecc.size);
./drivers/mtd/nand/brcmnand/brcmnand.c:1950:	switch (chip->ecc.size) {
./drivers/mtd/nand/brcmnand/brcmnand.c:1952:		if (chip->ecc.algo == NAND_ECC_HAMMING)
./drivers/mtd/nand/brcmnand/brcmnand.c:1955:			cfg->ecc_level = chip->ecc.strength;
./drivers/mtd/nand/brcmnand/brcmnand.c:1963:		if (chip->ecc.strength & 0x1) {
./drivers/mtd/nand/brcmnand/brcmnand.c:1969:		cfg->ecc_level = chip->ecc.strength >> 1;
./drivers/mtd/nand/brcmnand/brcmnand.c:1974:			chip->ecc.size);
./drivers/mtd/nand/brcmnand/brcmnand.c:2025:		dev_err(&pdev->dev, "can't get chip-select\n");
./drivers/mtd/nand/brcmnand/brcmnand.c:2039:	chip->IO_ADDR_R = (void __iomem *)0xdeadbeef;
./drivers/mtd/nand/brcmnand/brcmnand.c:2040:	chip->IO_ADDR_W = (void __iomem *)0xdeadbeef;
./drivers/mtd/nand/brcmnand/brcmnand.c:2042:	chip->cmd_ctrl = brcmnand_cmd_ctrl;
./drivers/mtd/nand/brcmnand/brcmnand.c:2043:	chip->cmdfunc = brcmnand_cmdfunc;
./drivers/mtd/nand/brcmnand/brcmnand.c:2044:	chip->waitfunc = brcmnand_waitfunc;
./drivers/mtd/nand/brcmnand/brcmnand.c:2045:	chip->read_byte = brcmnand_read_byte;
./drivers/mtd/nand/brcmnand/brcmnand.c:2046:	chip->read_buf = brcmnand_read_buf;
./drivers/mtd/nand/brcmnand/brcmnand.c:2047:	chip->write_buf = brcmnand_write_buf;
./drivers/mtd/nand/brcmnand/brcmnand.c:2049:	chip->ecc.mode = NAND_ECC_HW;
./drivers/mtd/nand/brcmnand/brcmnand.c:2050:	chip->ecc.read_page = brcmnand_read_page;
./drivers/mtd/nand/brcmnand/brcmnand.c:2051:	chip->ecc.write_page = brcmnand_write_page;
./drivers/mtd/nand/brcmnand/brcmnand.c:2052:	chip->ecc.read_page_raw = brcmnand_read_page_raw;
./drivers/mtd/nand/brcmnand/brcmnand.c:2053:	chip->ecc.write_page_raw = brcmnand_write_page_raw;
./drivers/mtd/nand/brcmnand/brcmnand.c:2054:	chip->ecc.write_oob_raw = brcmnand_write_oob_raw;
./drivers/mtd/nand/brcmnand/brcmnand.c:2055:	chip->ecc.read_oob_raw = brcmnand_read_oob_raw;
./drivers/mtd/nand/brcmnand/brcmnand.c:2056:	chip->ecc.read_oob = brcmnand_read_oob;
./drivers/mtd/nand/brcmnand/brcmnand.c:2057:	chip->ecc.write_oob = brcmnand_write_oob;
./drivers/mtd/nand/brcmnand/brcmnand.c:2059:	chip->controller = &ctrl->controller;
./drivers/mtd/nand/brcmnand/brcmnand.c:2073:	chip->options |= NAND_NO_SUBPAGE_WRITE;
./drivers/mtd/nand/brcmnand/brcmnand.c:2079:	chip->options |= NAND_USE_BOUNCE_BUFFER;
./drivers/mtd/nand/brcmnand/brcmnand.c:2081:	if (chip->bbt_options & NAND_BBT_USE_FLASH)
./drivers/mtd/nand/brcmnand/brcmnand.c:2082:		chip->bbt_options |= NAND_BBT_NO_OOB;
./drivers/mtd/nand/brcmnand/brcmnand.c:2087:	chip->ecc.size = host->hwcfg.sector_size_1k ? 1024 : 512;
./drivers/mtd/nand/brcmnand/brcmnand.c:2178:		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
./drivers/mtd/nand/brcmnand/brcmnand.c:2377:				continue; /* Try all chip-selects */
./drivers/mtd/nand/brcmnand/brcmnand.c:2384:	/* No chip-selects could initialize properly */
./drivers/mtd/nand/mxc_nand.c:664:	if (nand_chip->options & NAND_BUSWIDTH_16) {
./drivers/mtd/nand/mxc_nand.c:882:	if (section >= nand_chip->ecc.steps)
./drivers/mtd/nand/mxc_nand.c:886:	oobregion->length = nand_chip->ecc.bytes;
./drivers/mtd/nand/mxc_nand.c:896:	if (section > nand_chip->ecc.steps)
./drivers/mtd/nand/mxc_nand.c:909:				    nand_chip->ecc.bytes + 6;
./drivers/mtd/nand/mxc_nand.c:910:		if (section < nand_chip->ecc.steps)
./drivers/mtd/nand/mxc_nand.c:929:	int stepsize = nand_chip->ecc.bytes == 9 ? 16 : 26;
./drivers/mtd/nand/mxc_nand.c:931:	if (section >= nand_chip->ecc.steps)
./drivers/mtd/nand/mxc_nand.c:935:	oobregion->length = nand_chip->ecc.bytes;
./drivers/mtd/nand/mxc_nand.c:944:	int stepsize = nand_chip->ecc.bytes == 9 ? 16 : 26;
./drivers/mtd/nand/mxc_nand.c:946:	if (section > nand_chip->ecc.steps)
./drivers/mtd/nand/mxc_nand.c:993:	if (nand_chip->ecc.mode == NAND_ECC_HW && mtd->writesize)
./drivers/mtd/nand/mxc_nand.c:1029:		if (nand_chip->ecc.mode == NAND_ECC_HW)
./drivers/mtd/nand/mxc_nand.c:1088:	addr_phases = fls(chip->pagemask) >> 3;
./drivers/mtd/nand/mxc_nand.c:1102:		if (chip->ecc.mode == NAND_ECC_HW)
./drivers/mtd/nand/mxc_nand.c:1121:	if (!(chip->options & NAND_BUSWIDTH_16))
./drivers/mtd/nand/pxa3xx_nand.c:480:	u32 tR = chip->chip_delay * 1000;
./drivers/mtd/nand/pxa3xx_nand.c:517:	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
./drivers/mtd/nand/pxa3xx_nand.c:519:	id = chip->read_byte(mtd);
./drivers/mtd/nand/pxa3xx_nand.c:520:	id |= chip->read_byte(mtd) << 0x8;
./drivers/mtd/nand/pxa3xx_nand.c:576:			chip->options |= NAND_BUSWIDTH_16;
./drivers/mtd/nand/pxa3xx_nand.c:1340:	chip->write_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/pxa3xx_nand.c:1341:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/pxa3xx_nand.c:1353:	chip->read_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/pxa3xx_nand.c:1354:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/pxa3xx_nand.c:1486:	info->reg_ndcr |= (chip->page_shift == 6) ? NDCR_PG_PER_BLK : 0;
./drivers/mtd/nand/pxa3xx_nand.c:1573:	struct nand_ecc_ctrl *ecc = &chip->ecc;
./drivers/mtd/nand/pxa3xx_nand.c:1671:		chip->options |= NAND_BUSWIDTH_16;
./drivers/mtd/nand/pxa3xx_nand.c:1678:		chip->bbt_options |= NAND_BBT_USE_FLASH;
./drivers/mtd/nand/pxa3xx_nand.c:1680:	chip->ecc.strength = pdata->ecc_strength;
./drivers/mtd/nand/pxa3xx_nand.c:1681:	chip->ecc.size = pdata->ecc_step_size;
./drivers/mtd/nand/pxa3xx_nand.c:1695:	if (chip->bbt_options & NAND_BBT_USE_FLASH) {
./drivers/mtd/nand/pxa3xx_nand.c:1700:		chip->bbt_options |= NAND_BBT_NO_OOB_BBM;
./drivers/mtd/nand/pxa3xx_nand.c:1701:		chip->bbt_td = &bbt_main_descr;
./drivers/mtd/nand/pxa3xx_nand.c:1702:		chip->bbt_md = &bbt_mirror_descr;
./drivers/mtd/nand/pxa3xx_nand.c:1712:			chip->cmdfunc = nand_cmdfunc_extended;
./drivers/mtd/nand/pxa3xx_nand.c:1720:	ecc_strength = chip->ecc.strength;
./drivers/mtd/nand/pxa3xx_nand.c:1721:	ecc_step = chip->ecc.size;
./drivers/mtd/nand/pxa3xx_nand.c:1723:		ecc_strength = chip->ecc_strength_ds;
./drivers/mtd/nand/pxa3xx_nand.c:1724:		ecc_step = chip->ecc_step_ds;
./drivers/mtd/nand/pxa3xx_nand.c:1754:	if ((mtd->size >> chip->page_shift) > 65536)
./drivers/mtd/nand/pxa3xx_nand.c:1800:		chip->ecc.read_page	= pxa3xx_nand_read_page_hwecc;
./drivers/mtd/nand/pxa3xx_nand.c:1801:		chip->ecc.write_page	= pxa3xx_nand_write_page_hwecc;
./drivers/mtd/nand/pxa3xx_nand.c:1802:		chip->controller        = &info->controller;
./drivers/mtd/nand/pxa3xx_nand.c:1803:		chip->waitfunc		= pxa3xx_nand_waitfunc;
./drivers/mtd/nand/pxa3xx_nand.c:1804:		chip->select_chip	= pxa3xx_nand_select_chip;
./drivers/mtd/nand/pxa3xx_nand.c:1805:		chip->read_word		= pxa3xx_nand_read_word;
./drivers/mtd/nand/pxa3xx_nand.c:1806:		chip->read_byte		= pxa3xx_nand_read_byte;
./drivers/mtd/nand/pxa3xx_nand.c:1807:		chip->read_buf		= pxa3xx_nand_read_buf;
./drivers/mtd/nand/pxa3xx_nand.c:1808:		chip->write_buf		= pxa3xx_nand_write_buf;
./drivers/mtd/nand/pxa3xx_nand.c:1809:		chip->options		|= NAND_NO_SUBPAGE_WRITE;
./drivers/mtd/nand/pxa3xx_nand.c:1810:		chip->cmdfunc		= nand_cmdfunc;
./drivers/mtd/nand/pxa3xx_nand.c:1813:	spin_lock_init(&chip->controller->lock);
./drivers/mtd/nand/pxa3xx_nand.c:1814:	init_waitqueue_head(&chip->controller->wq);
./drivers/mtd/nand/nuc900_nand.c:148:			if (chip->options & NAND_BUSWIDTH_16 &&
./drivers/mtd/nand/nuc900_nand.c:157:			if (chip->chipsize > (128 << 20)) {
./drivers/mtd/nand/nuc900_nand.c:177:		if (chip->dev_ready)
./drivers/mtd/nand/nuc900_nand.c:179:		udelay(chip->chip_delay);
./drivers/mtd/nand/nuc900_nand.c:198:		if (!chip->dev_ready) {
./drivers/mtd/nand/nuc900_nand.c:199:			udelay(chip->chip_delay);
./drivers/mtd/nand/nuc900_nand.c:208:	while (!chip->dev_ready(mtd))
./drivers/mtd/nand/nuc900_nand.c:256:	chip->cmdfunc		= nuc900_nand_command_lp;
./drivers/mtd/nand/nuc900_nand.c:257:	chip->dev_ready		= nuc900_nand_devready;
./drivers/mtd/nand/nuc900_nand.c:258:	chip->read_byte		= nuc900_nand_read_byte;
./drivers/mtd/nand/nuc900_nand.c:259:	chip->write_buf		= nuc900_nand_write_buf;
./drivers/mtd/nand/nuc900_nand.c:260:	chip->read_buf		= nuc900_nand_read_buf;
./drivers/mtd/nand/nuc900_nand.c:261:	chip->chip_delay	= 50;
./drivers/mtd/nand/nuc900_nand.c:262:	chip->options		= 0;
./drivers/mtd/nand/nuc900_nand.c:263:	chip->ecc.mode		= NAND_ECC_SOFT;
./drivers/mtd/nand/nuc900_nand.c:264:	chip->ecc.algo		= NAND_ECC_HAMMING;
./drivers/mtd/nand/lpc32xx_mlc.c:146:	if (section >= nand_chip->ecc.steps)
./drivers/mtd/nand/lpc32xx_mlc.c:149:	oobregion->offset = ((section + 1) * 16) - nand_chip->ecc.bytes;
./drivers/mtd/nand/lpc32xx_mlc.c:150:	oobregion->length = nand_chip->ecc.bytes;
./drivers/mtd/nand/lpc32xx_mlc.c:160:	if (section >= nand_chip->ecc.steps)
./drivers/mtd/nand/lpc32xx_mlc.c:164:	oobregion->length = 16 - nand_chip->ecc.bytes;
./drivers/mtd/nand/lpc32xx_mlc.c:449:	uint8_t *oobbuf = chip->oob_poi;
./drivers/mtd/nand/lpc32xx_mlc.c:464:	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
./drivers/mtd/nand/lpc32xx_mlc.c:515:	const uint8_t *oobbuf = chip->oob_poi;
./drivers/mtd/nand/lpc32xx_mlc.c:710:	nand_chip->cmd_ctrl = lpc32xx_nand_cmd_ctrl;
./drivers/mtd/nand/lpc32xx_mlc.c:711:	nand_chip->dev_ready = lpc32xx_nand_device_ready;
./drivers/mtd/nand/lpc32xx_mlc.c:712:	nand_chip->chip_delay = 25; /* us */
./drivers/mtd/nand/lpc32xx_mlc.c:713:	nand_chip->IO_ADDR_R = MLC_DATA(host->io_base);
./drivers/mtd/nand/lpc32xx_mlc.c:714:	nand_chip->IO_ADDR_W = MLC_DATA(host->io_base);
./drivers/mtd/nand/lpc32xx_mlc.c:722:	nand_chip->ecc.hwctl = lpc32xx_ecc_enable;
./drivers/mtd/nand/lpc32xx_mlc.c:723:	nand_chip->ecc.read_page_raw = lpc32xx_read_page;
./drivers/mtd/nand/lpc32xx_mlc.c:724:	nand_chip->ecc.read_page = lpc32xx_read_page;
./drivers/mtd/nand/lpc32xx_mlc.c:725:	nand_chip->ecc.write_page_raw = lpc32xx_write_page_lowlevel;
./drivers/mtd/nand/lpc32xx_mlc.c:726:	nand_chip->ecc.write_page = lpc32xx_write_page_lowlevel;
./drivers/mtd/nand/lpc32xx_mlc.c:727:	nand_chip->ecc.write_oob = lpc32xx_write_oob;
./drivers/mtd/nand/lpc32xx_mlc.c:728:	nand_chip->ecc.read_oob = lpc32xx_read_oob;
./drivers/mtd/nand/lpc32xx_mlc.c:729:	nand_chip->ecc.strength = 4;
./drivers/mtd/nand/lpc32xx_mlc.c:730:	nand_chip->ecc.bytes = 10;
./drivers/mtd/nand/lpc32xx_mlc.c:731:	nand_chip->waitfunc = lpc32xx_waitfunc;
./drivers/mtd/nand/lpc32xx_mlc.c:733:	nand_chip->options = NAND_NO_SUBPAGE_WRITE;
./drivers/mtd/nand/lpc32xx_mlc.c:734:	nand_chip->bbt_options = NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;
./drivers/mtd/nand/lpc32xx_mlc.c:735:	nand_chip->bbt_td = &lpc32xx_nand_bbt;
./drivers/mtd/nand/lpc32xx_mlc.c:736:	nand_chip->bbt_md = &lpc32xx_nand_bbt_mirror;
./drivers/mtd/nand/lpc32xx_mlc.c:767:	nand_chip->ecc.mode = NAND_ECC_HW;
./drivers/mtd/nand/lpc32xx_mlc.c:768:	nand_chip->ecc.size = 512;
./drivers/mtd/nand/cafe_nand.c:358:	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
./drivers/mtd/nand/cafe_nand.c:359:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/cafe_nand.c:360:	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
./drivers/mtd/nand/cafe_nand.c:361:	status = chip->waitfunc(mtd, chip);
./drivers/mtd/nand/cafe_nand.c:370:	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
./drivers/mtd/nand/cafe_nand.c:371:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/cafe_nand.c:379: * @oob_required:	caller expects OOB data read to chip->oob_poi
./drivers/mtd/nand/cafe_nand.c:394:	chip->read_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/cafe_nand.c:395:	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/cafe_nand.c:400:		u8 *oob = chip->oob_poi;
./drivers/mtd/nand/cafe_nand.c:471:	oobregion->length = chip->ecc.total;
./drivers/mtd/nand/cafe_nand.c:484:	oobregion->offset = chip->ecc.total;
./drivers/mtd/nand/cafe_nand.c:485:	oobregion->length = mtd->oobsize - chip->ecc.total;
./drivers/mtd/nand/cafe_nand.c:552:	chip->write_buf(mtd, buf, mtd->writesize);
./drivers/mtd/nand/cafe_nand.c:553:	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/vf610_nfc.c:561:	int eccsize = chip->ecc.size;
./drivers/mtd/nand/vf610_nfc.c:566:		vf610_nfc_read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/vf610_nfc.c:568:	stat = vf610_nfc_correct_data(mtd, buf, chip->oob_poi, page);
./drivers/mtd/nand/vf610_nfc.c:586:		vf610_nfc_write_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/mtd/nand/vf610_nfc.c:699:	chip->dev_ready = vf610_nfc_dev_ready;
./drivers/mtd/nand/vf610_nfc.c:700:	chip->cmdfunc = vf610_nfc_command;
./drivers/mtd/nand/vf610_nfc.c:701:	chip->read_byte = vf610_nfc_read_byte;
./drivers/mtd/nand/vf610_nfc.c:702:	chip->read_word = vf610_nfc_read_word;
./drivers/mtd/nand/vf610_nfc.c:703:	chip->read_buf = vf610_nfc_read_buf;
./drivers/mtd/nand/vf610_nfc.c:704:	chip->write_buf = vf610_nfc_write_buf;
./drivers/mtd/nand/vf610_nfc.c:705:	chip->select_chip = vf610_nfc_select_chip;
./drivers/mtd/nand/vf610_nfc.c:707:	chip->options |= NAND_NO_SUBPAGE_WRITE;
./drivers/mtd/nand/vf610_nfc.c:728:	if (chip->bbt_options & NAND_BBT_USE_FLASH)
./drivers/mtd/nand/vf610_nfc.c:729:		chip->bbt_options |= NAND_BBT_NO_OOB;
./drivers/mtd/nand/vf610_nfc.c:738:	if (chip->ecc.mode == NAND_ECC_HW) {
./drivers/mtd/nand/vf610_nfc.c:745:		if (chip->ecc.size != mtd->writesize) {
./drivers/mtd/nand/vf610_nfc.c:759:		if (chip->ecc.strength == 32) {
./drivers/mtd/nand/vf610_nfc.c:761:			chip->ecc.bytes = 60;
./drivers/mtd/nand/vf610_nfc.c:762:		} else if (chip->ecc.strength == 24) {
./drivers/mtd/nand/vf610_nfc.c:764:			chip->ecc.bytes = 45;
./drivers/mtd/nand/vf610_nfc.c:771:		chip->ecc.read_page = vf610_nfc_read_page;
./drivers/mtd/nand/vf610_nfc.c:772:		chip->ecc.write_page = vf610_nfc_write_page;
./drivers/mtd/nand/vf610_nfc.c:774:		chip->ecc.size = PAGE_2K;
./drivers/mtd/nand/tmio_nand.c:159:		tmio_iowrite8(cmd, chip->IO_ADDR_W);
./drivers/mtd/nand/tmio_nand.c:177:	if (unlikely(!waitqueue_active(&nand_chip->controller->wq)))
./drivers/mtd/nand/tmio_nand.c:180:	wake_up(&nand_chip->controller->wq);
./drivers/mtd/nand/tmio_nand.c:200:	timeout = wait_event_timeout(nand_chip->controller->wq,
./drivers/mtd/nand/tmio_nand.c:202:		msecs_to_jiffies(nand_chip->state == FL_ERASING ? 400 : 20));
./drivers/mtd/nand/tmio_nand.c:207:			nand_chip->state == FL_ERASING ? "erase" : "program",
./drivers/mtd/nand/tmio_nand.c:208:			nand_chip->state == FL_ERASING ? 400 : 20);
./drivers/mtd/nand/tmio_nand.c:215:	nand_chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
./drivers/mtd/nand/tmio_nand.c:216:	return nand_chip->read_byte(mtd);
./drivers/mtd/nand/tmio_nand.c:402:	nand_chip->IO_ADDR_R = tmio->fcr;
./drivers/mtd/nand/tmio_nand.c:403:	nand_chip->IO_ADDR_W = tmio->fcr;
./drivers/mtd/nand/tmio_nand.c:406:	nand_chip->cmd_ctrl = tmio_nand_hwcontrol;
./drivers/mtd/nand/tmio_nand.c:407:	nand_chip->dev_ready = tmio_nand_dev_ready;
./drivers/mtd/nand/tmio_nand.c:408:	nand_chip->read_byte = tmio_nand_read_byte;
./drivers/mtd/nand/tmio_nand.c:409:	nand_chip->write_buf = tmio_nand_write_buf;
./drivers/mtd/nand/tmio_nand.c:410:	nand_chip->read_buf = tmio_nand_read_buf;
./drivers/mtd/nand/tmio_nand.c:413:	nand_chip->ecc.mode = NAND_ECC_HW;
./drivers/mtd/nand/tmio_nand.c:414:	nand_chip->ecc.size = 512;
./drivers/mtd/nand/tmio_nand.c:415:	nand_chip->ecc.bytes = 6;
./drivers/mtd/nand/tmio_nand.c:416:	nand_chip->ecc.strength = 2;
./drivers/mtd/nand/tmio_nand.c:417:	nand_chip->ecc.hwctl = tmio_nand_enable_hwecc;
./drivers/mtd/nand/tmio_nand.c:418:	nand_chip->ecc.calculate = tmio_nand_calculate_ecc;
./drivers/mtd/nand/tmio_nand.c:419:	nand_chip->ecc.correct = tmio_nand_correct_data;
./drivers/mtd/nand/tmio_nand.c:422:		nand_chip->badblock_pattern = data->badblock_pattern;
./drivers/mtd/nand/tmio_nand.c:425:	nand_chip->chip_delay = 15;
./drivers/mtd/nand/tmio_nand.c:435:	nand_chip->waitfunc = tmio_nand_wait;
./drivers/mtd/lpddr/lpddr_cmds.c:96:			chip->start += j << lpddr->chipshift;
./drivers/mtd/lpddr/lpddr_cmds.c:97:			chip->oldstate = chip->state = FL_READY;
./drivers/mtd/lpddr/lpddr_cmds.c:98:			chip->priv = &shared[i];
./drivers/mtd/lpddr/lpddr_cmds.c:101:			init_waitqueue_head(&chip->wq);
./drivers/mtd/lpddr/lpddr_cmds.c:102:			mutex_init(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:116:	flstate_t chip_state = chip->state;
./drivers/mtd/lpddr/lpddr_cmds.c:138:		mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:153:		mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:155:		while (chip->state != chip_state) {
./drivers/mtd/lpddr/lpddr_cmds.c:159:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/lpddr/lpddr_cmds.c:160:			mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:162:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/lpddr/lpddr_cmds.c:163:			mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:165:		if (chip->erase_suspended || chip->write_suspended)  {
./drivers/mtd/lpddr/lpddr_cmds.c:168:			chip->erase_suspended = chip->write_suspended = 0;
./drivers/mtd/lpddr/lpddr_cmds.c:180:	chip->state = FL_READY;
./drivers/mtd/lpddr/lpddr_cmds.c:190:	if (chip->priv && (mode == FL_WRITING || mode == FL_ERASING)
./drivers/mtd/lpddr/lpddr_cmds.c:191:		&& chip->state != FL_SYNCING) {
./drivers/mtd/lpddr/lpddr_cmds.c:210:		struct flchip_shared *shared = chip->priv;
./drivers/mtd/lpddr/lpddr_cmds.c:228:			mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:230:			mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:244:			if (chip->state == FL_SYNCING) {
./drivers/mtd/lpddr/lpddr_cmds.c:258:			add_wait_queue(&chip->wq, &wait);
./drivers/mtd/lpddr/lpddr_cmds.c:259:			mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:261:			remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/lpddr/lpddr_cmds.c:262:			mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:287:	if (FL_SYNCING == mode && FL_READY != chip->oldstate)
./drivers/mtd/lpddr/lpddr_cmds.c:290:	switch (chip->state) {
./drivers/mtd/lpddr/lpddr_cmds.c:302:		chip->oldstate = FL_ERASING;
./drivers/mtd/lpddr/lpddr_cmds.c:303:		chip->state = FL_ERASE_SUSPENDING;
./drivers/mtd/lpddr/lpddr_cmds.c:313:		chip->erase_suspended = 1;
./drivers/mtd/lpddr/lpddr_cmds.c:314:		chip->state = FL_READY;
./drivers/mtd/lpddr/lpddr_cmds.c:319:		if (mode == FL_READY && chip->oldstate == FL_READY)
./drivers/mtd/lpddr/lpddr_cmds.c:325:		add_wait_queue(&chip->wq, &wait);
./drivers/mtd/lpddr/lpddr_cmds.c:326:		mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:328:		remove_wait_queue(&chip->wq, &wait);
./drivers/mtd/lpddr/lpddr_cmds.c:329:		mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:336:	if (chip->priv) {
./drivers/mtd/lpddr/lpddr_cmds.c:337:		struct flchip_shared *shared = chip->priv;
./drivers/mtd/lpddr/lpddr_cmds.c:339:		if (shared->writing == chip && chip->oldstate == FL_READY) {
./drivers/mtd/lpddr/lpddr_cmds.c:347:				mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:349:				mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:351:				wake_up(&chip->wq);
./drivers/mtd/lpddr/lpddr_cmds.c:365:			wake_up(&chip->wq);
./drivers/mtd/lpddr/lpddr_cmds.c:371:	switch (chip->oldstate) {
./drivers/mtd/lpddr/lpddr_cmds.c:377:		chip->oldstate = FL_READY;
./drivers/mtd/lpddr/lpddr_cmds.c:378:		chip->state = FL_ERASING;
./drivers/mtd/lpddr/lpddr_cmds.c:384:				map->name, chip->oldstate);
./drivers/mtd/lpddr/lpddr_cmds.c:386:	wake_up(&chip->wq);
./drivers/mtd/lpddr/lpddr_cmds.c:402:	mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:405:		mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:457:	chip->state = FL_WRITING;
./drivers/mtd/lpddr/lpddr_cmds.c:466:	mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:478:	mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:481:		mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:485:	chip->state = FL_ERASING;
./drivers/mtd/lpddr/lpddr_cmds.c:493:	mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:506:	mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:509:		mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:517:	mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:536:	*mtdbuf = (void *)map->virt + chip->start + ofs;
./drivers/mtd/lpddr/lpddr_cmds.c:546:			last_end = chip->start;
./drivers/mtd/lpddr/lpddr_cmds.c:547:		else if (chip->start != last_end)
./drivers/mtd/lpddr/lpddr_cmds.c:555:		mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:557:		mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:561:		chip->state = FL_POINT;
./drivers/mtd/lpddr/lpddr_cmds.c:562:		chip->ref_point_counter++;
./drivers/mtd/lpddr/lpddr_cmds.c:597:		mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:598:		if (chip->state == FL_POINT) {
./drivers/mtd/lpddr/lpddr_cmds.c:599:			chip->ref_point_counter--;
./drivers/mtd/lpddr/lpddr_cmds.c:600:			if (chip->ref_point_counter == 0)
./drivers/mtd/lpddr/lpddr_cmds.c:601:				chip->state = FL_READY;
./drivers/mtd/lpddr/lpddr_cmds.c:609:		mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:712:	mutex_lock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:715:		mutex_unlock(&chip->mutex);
./drivers/mtd/lpddr/lpddr_cmds.c:721:		chip->state = FL_LOCKING;
./drivers/mtd/lpddr/lpddr_cmds.c:724:		chip->state = FL_UNLOCKING;
./drivers/mtd/lpddr/lpddr_cmds.c:735:	mutex_unlock(&chip->mutex);
./drivers/gpio/gpio-dwapb.c:156:	if (chip->irq_eoi)
./drivers/gpio/gpio-dwapb.c:157:		chip->irq_eoi(irq_desc_get_irq_data(desc));
./drivers/gpio/gpio-ml-ioh.c:112:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:113:	reg_val = ioread32(&chip->reg->regs[chip->ch].po);
./drivers/gpio/gpio-ml-ioh.c:119:	iowrite32(reg_val, &chip->reg->regs[chip->ch].po);
./drivers/gpio/gpio-ml-ioh.c:120:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:127:	return !!(ioread32(&chip->reg->regs[chip->ch].pi) & (1 << nr));
./drivers/gpio/gpio-ml-ioh.c:138:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:139:	pm = ioread32(&chip->reg->regs[chip->ch].pm) &
./drivers/gpio/gpio-ml-ioh.c:140:					((1 << num_ports[chip->ch]) - 1);
./drivers/gpio/gpio-ml-ioh.c:142:	iowrite32(pm, &chip->reg->regs[chip->ch].pm);
./drivers/gpio/gpio-ml-ioh.c:144:	reg_val = ioread32(&chip->reg->regs[chip->ch].po);
./drivers/gpio/gpio-ml-ioh.c:149:	iowrite32(reg_val, &chip->reg->regs[chip->ch].po);
./drivers/gpio/gpio-ml-ioh.c:151:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:162:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:163:	pm = ioread32(&chip->reg->regs[chip->ch].pm) &
./drivers/gpio/gpio-ml-ioh.c:164:				((1 << num_ports[chip->ch]) - 1);
./drivers/gpio/gpio-ml-ioh.c:166:	iowrite32(pm, &chip->reg->regs[chip->ch].pm);
./drivers/gpio/gpio-ml-ioh.c:167:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:181:		chip->ioh_gpio_reg.po_reg =
./drivers/gpio/gpio-ml-ioh.c:182:					ioread32(&chip->reg->regs[chip->ch].po);
./drivers/gpio/gpio-ml-ioh.c:183:		chip->ioh_gpio_reg.pm_reg =
./drivers/gpio/gpio-ml-ioh.c:184:					ioread32(&chip->reg->regs[chip->ch].pm);
./drivers/gpio/gpio-ml-ioh.c:185:		chip->ioh_gpio_reg.ien_reg =
./drivers/gpio/gpio-ml-ioh.c:186:				       ioread32(&chip->reg->regs[chip->ch].ien);
./drivers/gpio/gpio-ml-ioh.c:187:		chip->ioh_gpio_reg.imask_reg =
./drivers/gpio/gpio-ml-ioh.c:188:				     ioread32(&chip->reg->regs[chip->ch].imask);
./drivers/gpio/gpio-ml-ioh.c:189:		chip->ioh_gpio_reg.im0_reg =
./drivers/gpio/gpio-ml-ioh.c:190:				      ioread32(&chip->reg->regs[chip->ch].im_0);
./drivers/gpio/gpio-ml-ioh.c:191:		chip->ioh_gpio_reg.im1_reg =
./drivers/gpio/gpio-ml-ioh.c:192:				      ioread32(&chip->reg->regs[chip->ch].im_1);
./drivers/gpio/gpio-ml-ioh.c:194:			chip->ioh_gpio_reg.use_sel_reg =
./drivers/gpio/gpio-ml-ioh.c:195:					   ioread32(&chip->reg->ioh_sel_reg[i]);
./drivers/gpio/gpio-ml-ioh.c:207:		iowrite32(chip->ioh_gpio_reg.po_reg,
./drivers/gpio/gpio-ml-ioh.c:208:			  &chip->reg->regs[chip->ch].po);
./drivers/gpio/gpio-ml-ioh.c:209:		iowrite32(chip->ioh_gpio_reg.pm_reg,
./drivers/gpio/gpio-ml-ioh.c:210:			  &chip->reg->regs[chip->ch].pm);
./drivers/gpio/gpio-ml-ioh.c:211:		iowrite32(chip->ioh_gpio_reg.ien_reg,
./drivers/gpio/gpio-ml-ioh.c:212:			  &chip->reg->regs[chip->ch].ien);
./drivers/gpio/gpio-ml-ioh.c:213:		iowrite32(chip->ioh_gpio_reg.imask_reg,
./drivers/gpio/gpio-ml-ioh.c:214:			  &chip->reg->regs[chip->ch].imask);
./drivers/gpio/gpio-ml-ioh.c:215:		iowrite32(chip->ioh_gpio_reg.im0_reg,
./drivers/gpio/gpio-ml-ioh.c:216:			  &chip->reg->regs[chip->ch].im_0);
./drivers/gpio/gpio-ml-ioh.c:217:		iowrite32(chip->ioh_gpio_reg.im1_reg,
./drivers/gpio/gpio-ml-ioh.c:218:			  &chip->reg->regs[chip->ch].im_1);
./drivers/gpio/gpio-ml-ioh.c:220:			iowrite32(chip->ioh_gpio_reg.use_sel_reg,
./drivers/gpio/gpio-ml-ioh.c:221:				  &chip->reg->ioh_sel_reg[i]);
./drivers/gpio/gpio-ml-ioh.c:229:	return chip->irq_base + offset;
./drivers/gpio/gpio-ml-ioh.c:234:	struct gpio_chip *gpio = &chip->gpio;
./drivers/gpio/gpio-ml-ioh.c:236:	gpio->label = dev_name(chip->dev);
./drivers/gpio/gpio-ml-ioh.c:262:	ch = irq - chip->irq_base;
./drivers/gpio/gpio-ml-ioh.c:263:	if (irq <= chip->irq_base + 7) {
./drivers/gpio/gpio-ml-ioh.c:264:		im_reg = &chip->reg->regs[chip->ch].im_0;
./drivers/gpio/gpio-ml-ioh.c:267:		im_reg = &chip->reg->regs[chip->ch].im_1;
./drivers/gpio/gpio-ml-ioh.c:270:	dev_dbg(chip->dev, "%s:irq=%d type=%d ch=%d pos=%d type=%d\n",
./drivers/gpio/gpio-ml-ioh.c:273:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:294:		dev_warn(chip->dev, "%s: unknown type(%dd)",
./drivers/gpio/gpio-ml-ioh.c:304:	iowrite32(BIT(ch), &chip->reg->regs[chip->ch].iclr);
./drivers/gpio/gpio-ml-ioh.c:307:	iowrite32(BIT(ch), &chip->reg->regs[chip->ch].imaskclr);
./drivers/gpio/gpio-ml-ioh.c:310:	ien = ioread32(&chip->reg->regs[chip->ch].ien);
./drivers/gpio/gpio-ml-ioh.c:311:	iowrite32(ien | BIT(ch), &chip->reg->regs[chip->ch].ien);
./drivers/gpio/gpio-ml-ioh.c:313:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:323:	iowrite32(1 << (d->irq - chip->irq_base),
./drivers/gpio/gpio-ml-ioh.c:324:		  &chip->reg->regs[chip->ch].imaskclr);
./drivers/gpio/gpio-ml-ioh.c:332:	iowrite32(1 << (d->irq - chip->irq_base),
./drivers/gpio/gpio-ml-ioh.c:333:		  &chip->reg->regs[chip->ch].imask);
./drivers/gpio/gpio-ml-ioh.c:343:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:344:	ien = ioread32(&chip->reg->regs[chip->ch].ien);
./drivers/gpio/gpio-ml-ioh.c:345:	ien &= ~(1 << (d->irq - chip->irq_base));
./drivers/gpio/gpio-ml-ioh.c:346:	iowrite32(ien, &chip->reg->regs[chip->ch].ien);
./drivers/gpio/gpio-ml-ioh.c:347:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:357:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:358:	ien = ioread32(&chip->reg->regs[chip->ch].ien);
./drivers/gpio/gpio-ml-ioh.c:359:	ien |= 1 << (d->irq - chip->irq_base);
./drivers/gpio/gpio-ml-ioh.c:360:	iowrite32(ien, &chip->reg->regs[chip->ch].ien);
./drivers/gpio/gpio-ml-ioh.c:361:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:372:		reg_val = ioread32(&chip->reg->regs[i].istatus);
./drivers/gpio/gpio-ml-ioh.c:375:				dev_dbg(chip->dev,
./drivers/gpio/gpio-ml-ioh.c:379:					  &chip->reg->regs[chip->ch].iclr);
./drivers/gpio/gpio-ml-ioh.c:380:				generic_handle_irq(chip->irq_base + j);
./drivers/gpio/gpio-ml-ioh.c:394:	gc = irq_alloc_generic_chip("ioh_gpio", 1, irq_start, chip->base,
./drivers/gpio/gpio-ml-ioh.c:447:		chip->dev = &pdev->dev;
./drivers/gpio/gpio-ml-ioh.c:448:		chip->base = base;
./drivers/gpio/gpio-ml-ioh.c:449:		chip->reg = chip->base;
./drivers/gpio/gpio-ml-ioh.c:450:		chip->ch = i;
./drivers/gpio/gpio-ml-ioh.c:451:		spin_lock_init(&chip->spinlock);
./drivers/gpio/gpio-ml-ioh.c:453:		ret = gpiochip_add_data(&chip->gpio, chip);
./drivers/gpio/gpio-ml-ioh.c:467:			chip->irq_base = -1;
./drivers/gpio/gpio-ml-ioh.c:471:		chip->irq_base = irq_base;
./drivers/gpio/gpio-ml-ioh.c:492:		chip--;
./drivers/gpio/gpio-ml-ioh.c:493:		irq_free_descs(chip->irq_base, num_ports[j]);
./drivers/gpio/gpio-ml-ioh.c:499:		chip--;
./drivers/gpio/gpio-ml-ioh.c:500:		gpiochip_remove(&chip->gpio);
./drivers/gpio/gpio-ml-ioh.c:530:		irq_free_descs(chip->irq_base, num_ports[i]);
./drivers/gpio/gpio-ml-ioh.c:531:		gpiochip_remove(&chip->gpio);
./drivers/gpio/gpio-ml-ioh.c:535:	pci_iounmap(pdev, chip->base);
./drivers/gpio/gpio-ml-ioh.c:548:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:550:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:582:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-ml-ioh.c:583:	iowrite32(0x01, &chip->reg->srst);
./drivers/gpio/gpio-ml-ioh.c:584:	iowrite32(0x00, &chip->reg->srst);
./drivers/gpio/gpio-ml-ioh.c:586:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-octeon.c:101:	chip->label = "octeon-gpio";
./drivers/gpio/gpio-octeon.c:102:	chip->parent = &pdev->dev;
./drivers/gpio/gpio-octeon.c:103:	chip->owner = THIS_MODULE;
./drivers/gpio/gpio-octeon.c:104:	chip->base = 0;
./drivers/gpio/gpio-octeon.c:105:	chip->can_sleep = false;
./drivers/gpio/gpio-octeon.c:106:	chip->ngpio = 20;
./drivers/gpio/gpio-octeon.c:107:	chip->direction_input = octeon_gpio_dir_in;
./drivers/gpio/gpio-octeon.c:108:	chip->get = octeon_gpio_get;
./drivers/gpio/gpio-octeon.c:109:	chip->direction_output = octeon_gpio_dir_out;
./drivers/gpio/gpio-octeon.c:110:	chip->set = octeon_gpio_set;
./drivers/gpio/gpio-msic.c:256:	chip->irq_eoi(data);
./drivers/gpio/gpio-pca953x.c:93:#define NBANK(chip) DIV_ROUND_UP(chip->gpio_chip.ngpio, BANK_SZ)
./drivers/gpio/gpio-pca953x.c:120:	int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
./drivers/gpio/gpio-pca953x.c:123:	ret = i2c_smbus_read_byte_data(chip->client,
./drivers/gpio/gpio-pca953x.c:128:		dev_err(&chip->client->dev, "failed reading register\n");
./drivers/gpio/gpio-pca953x.c:139:	int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
./drivers/gpio/gpio-pca953x.c:142:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/gpio/gpio-pca953x.c:146:		dev_err(&chip->client->dev, "failed writing register\n");
./drivers/gpio/gpio-pca953x.c:157:	if (chip->gpio_chip.ngpio <= 8)
./drivers/gpio/gpio-pca953x.c:158:		ret = i2c_smbus_write_byte_data(chip->client, reg, *val);
./drivers/gpio/gpio-pca953x.c:159:	else if (chip->gpio_chip.ngpio >= 24) {
./drivers/gpio/gpio-pca953x.c:160:		int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
./drivers/gpio/gpio-pca953x.c:161:		ret = i2c_smbus_write_i2c_block_data(chip->client,
./drivers/gpio/gpio-pca953x.c:165:		switch (chip->chip_type) {
./drivers/gpio/gpio-pca953x.c:167:			ret = i2c_smbus_write_word_data(chip->client,
./drivers/gpio/gpio-pca953x.c:171:			ret = i2c_smbus_write_byte_data(chip->client, reg << 1,
./drivers/gpio/gpio-pca953x.c:175:			ret = i2c_smbus_write_byte_data(chip->client,
./drivers/gpio/gpio-pca953x.c:183:		dev_err(&chip->client->dev, "failed writing register\n");
./drivers/gpio/gpio-pca953x.c:194:	if (chip->gpio_chip.ngpio <= 8) {
./drivers/gpio/gpio-pca953x.c:195:		ret = i2c_smbus_read_byte_data(chip->client, reg);
./drivers/gpio/gpio-pca953x.c:197:	} else if (chip->gpio_chip.ngpio >= 24) {
./drivers/gpio/gpio-pca953x.c:198:		int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
./drivers/gpio/gpio-pca953x.c:200:		ret = i2c_smbus_read_i2c_block_data(chip->client,
./drivers/gpio/gpio-pca953x.c:204:		ret = i2c_smbus_read_word_data(chip->client, reg << 1);
./drivers/gpio/gpio-pca953x.c:209:		dev_err(&chip->client->dev, "failed reading register\n");
./drivers/gpio/gpio-pca953x.c:222:	mutex_lock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:223:	reg_val = chip->reg_direction[off / BANK_SZ] | (1u << (off % BANK_SZ));
./drivers/gpio/gpio-pca953x.c:225:	switch (chip->chip_type) {
./drivers/gpio/gpio-pca953x.c:237:	chip->reg_direction[off / BANK_SZ] = reg_val;
./drivers/gpio/gpio-pca953x.c:240:	mutex_unlock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:251:	mutex_lock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:254:		reg_val = chip->reg_output[off / BANK_SZ]
./drivers/gpio/gpio-pca953x.c:257:		reg_val = chip->reg_output[off / BANK_SZ]
./drivers/gpio/gpio-pca953x.c:260:	switch (chip->chip_type) {
./drivers/gpio/gpio-pca953x.c:272:	chip->reg_output[off / BANK_SZ] = reg_val;
./drivers/gpio/gpio-pca953x.c:275:	reg_val = chip->reg_direction[off / BANK_SZ] & ~(1u << (off % BANK_SZ));
./drivers/gpio/gpio-pca953x.c:276:	switch (chip->chip_type) {
./drivers/gpio/gpio-pca953x.c:288:	chip->reg_direction[off / BANK_SZ] = reg_val;
./drivers/gpio/gpio-pca953x.c:291:	mutex_unlock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:301:	mutex_lock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:302:	switch (chip->chip_type) {
./drivers/gpio/gpio-pca953x.c:311:	mutex_unlock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:329:	mutex_lock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:331:		reg_val = chip->reg_output[off / BANK_SZ]
./drivers/gpio/gpio-pca953x.c:334:		reg_val = chip->reg_output[off / BANK_SZ]
./drivers/gpio/gpio-pca953x.c:337:	switch (chip->chip_type) {
./drivers/gpio/gpio-pca953x.c:349:	chip->reg_output[off / BANK_SZ] = reg_val;
./drivers/gpio/gpio-pca953x.c:351:	mutex_unlock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:361:	int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
./drivers/gpio/gpio-pca953x.c:364:	switch (chip->chip_type) {
./drivers/gpio/gpio-pca953x.c:373:	memcpy(reg_val, chip->reg_output, NBANK(chip));
./drivers/gpio/gpio-pca953x.c:374:	mutex_lock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:384:	ret = i2c_smbus_write_i2c_block_data(chip->client, offset << bank_shift, NBANK(chip), reg_val);
./drivers/gpio/gpio-pca953x.c:388:	memcpy(chip->reg_output, reg_val, NBANK(chip));
./drivers/gpio/gpio-pca953x.c:390:	mutex_unlock(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:397:	gc = &chip->gpio_chip;
./drivers/gpio/gpio-pca953x.c:406:	gc->base = chip->gpio_start;
./drivers/gpio/gpio-pca953x.c:408:	gc->label = chip->client->name;
./drivers/gpio/gpio-pca953x.c:409:	gc->parent = &chip->client->dev;
./drivers/gpio/gpio-pca953x.c:411:	gc->names = chip->names;
./drivers/gpio/gpio-pca953x.c:420:	chip->irq_mask[d->hwirq / BANK_SZ] &= ~(1 << (d->hwirq % BANK_SZ));
./drivers/gpio/gpio-pca953x.c:428:	chip->irq_mask[d->hwirq / BANK_SZ] |= 1 << (d->hwirq % BANK_SZ);
./drivers/gpio/gpio-pca953x.c:436:	mutex_lock(&chip->irq_lock);
./drivers/gpio/gpio-pca953x.c:447:	if (chip->driver_data & PCA_PCAL) {
./drivers/gpio/gpio-pca953x.c:449:		pca953x_write_regs(chip, PCAL953X_IN_LATCH, chip->irq_mask);
./drivers/gpio/gpio-pca953x.c:452:			invert_irq_mask[i] = ~chip->irq_mask[i];
./drivers/gpio/gpio-pca953x.c:460:		new_irqs = chip->irq_trig_fall[i] | chip->irq_trig_raise[i];
./drivers/gpio/gpio-pca953x.c:461:		new_irqs &= ~chip->reg_direction[i];
./drivers/gpio/gpio-pca953x.c:465:			pca953x_gpio_direction_input(&chip->gpio_chip,
./drivers/gpio/gpio-pca953x.c:471:	mutex_unlock(&chip->irq_lock);
./drivers/gpio/gpio-pca953x.c:482:		dev_err(&chip->client->dev, "irq %d: unsupported type %d\n",
./drivers/gpio/gpio-pca953x.c:488:		chip->irq_trig_fall[bank_nb] |= mask;
./drivers/gpio/gpio-pca953x.c:490:		chip->irq_trig_fall[bank_nb] &= ~mask;
./drivers/gpio/gpio-pca953x.c:493:		chip->irq_trig_raise[bank_nb] |= mask;
./drivers/gpio/gpio-pca953x.c:495:		chip->irq_trig_raise[bank_nb] &= ~mask;
./drivers/gpio/gpio-pca953x.c:518:	if (chip->driver_data & PCA_PCAL) {
./drivers/gpio/gpio-pca953x.c:531:			pending[i] = (~cur_stat[i] & chip->irq_trig_fall[i]) |
./drivers/gpio/gpio-pca953x.c:532:				(cur_stat[i] & chip->irq_trig_raise[i]);
./drivers/gpio/gpio-pca953x.c:541:	switch (chip->chip_type) {
./drivers/gpio/gpio-pca953x.c:555:		cur_stat[i] &= chip->reg_direction[i];
./drivers/gpio/gpio-pca953x.c:557:	memcpy(old_stat, chip->irq_stat, NBANK(chip));
./drivers/gpio/gpio-pca953x.c:560:		trigger[i] = (cur_stat[i] ^ old_stat[i]) & chip->irq_mask[i];
./drivers/gpio/gpio-pca953x.c:568:	memcpy(chip->irq_stat, cur_stat, NBANK(chip));
./drivers/gpio/gpio-pca953x.c:571:		pending[i] = (old_stat[i] & chip->irq_trig_fall[i]) |
./drivers/gpio/gpio-pca953x.c:572:			(cur_stat[i] & chip->irq_trig_raise[i]);
./drivers/gpio/gpio-pca953x.c:595:			handle_nested_irq(irq_find_mapping(chip->gpio_chip.irqdomain,
./drivers/gpio/gpio-pca953x.c:608:	struct i2c_client *client = chip->client;
./drivers/gpio/gpio-pca953x.c:612:			&& (chip->driver_data & PCA_INT)) {
./drivers/gpio/gpio-pca953x.c:614:		switch (chip->chip_type) {
./drivers/gpio/gpio-pca953x.c:622:		ret = pca953x_read_regs(chip, offset, chip->irq_stat);
./drivers/gpio/gpio-pca953x.c:632:			chip->irq_stat[i] &= chip->reg_direction[i];
./drivers/gpio/gpio-pca953x.c:633:		mutex_init(&chip->irq_lock);
./drivers/gpio/gpio-pca953x.c:648:		ret =  gpiochip_irqchip_add(&chip->gpio_chip,
./drivers/gpio/gpio-pca953x.c:659:		gpiochip_set_chained_irqchip(&chip->gpio_chip,
./drivers/gpio/gpio-pca953x.c:671:	struct i2c_client *client = chip->client;
./drivers/gpio/gpio-pca953x.c:673:	if (irq_base != -1 && (chip->driver_data & PCA_INT))
./drivers/gpio/gpio-pca953x.c:685:	ret = pca953x_read_regs(chip, PCA953X_OUTPUT, chip->reg_output);
./drivers/gpio/gpio-pca953x.c:690:			       chip->reg_direction);
./drivers/gpio/gpio-pca953x.c:710:	ret = pca953x_read_regs(chip, PCA957X_OUT, chip->reg_output);
./drivers/gpio/gpio-pca953x.c:713:	ret = pca953x_read_regs(chip, PCA957X_CFG, chip->reg_direction);
./drivers/gpio/gpio-pca953x.c:756:		chip->gpio_start = pdata->gpio_base;
./drivers/gpio/gpio-pca953x.c:758:		chip->names = pdata->names;
./drivers/gpio/gpio-pca953x.c:760:		chip->gpio_start = -1;
./drivers/gpio/gpio-pca953x.c:764:	chip->client = client;
./drivers/gpio/gpio-pca953x.c:767:		chip->driver_data = id->driver_data;
./drivers/gpio/gpio-pca953x.c:774:			chip->driver_data = (int)(uintptr_t)match->data;
./drivers/gpio/gpio-pca953x.c:780:			chip->driver_data = id->driver_data;
./drivers/gpio/gpio-pca953x.c:784:	chip->chip_type = PCA_CHIP_TYPE(chip->driver_data);
./drivers/gpio/gpio-pca953x.c:786:	mutex_init(&chip->i2c_lock);
./drivers/gpio/gpio-pca953x.c:791:	pca953x_setup_gpio(chip, chip->driver_data & PCA_GPIO_MASK);
./drivers/gpio/gpio-pca953x.c:793:	if (chip->chip_type == PCA953X_TYPE)
./drivers/gpio/gpio-pca953x.c:800:	ret = devm_gpiochip_add_data(&client->dev, &chip->gpio_chip, chip);
./drivers/gpio/gpio-pca953x.c:809:		ret = pdata->setup(client, chip->gpio_chip.base,
./drivers/gpio/gpio-pca953x.c:810:				chip->gpio_chip.ngpio, pdata->context);
./drivers/gpio/gpio-pca953x.c:826:		ret = pdata->teardown(client, chip->gpio_chip.base,
./drivers/gpio/gpio-pca953x.c:827:				chip->gpio_chip.ngpio, pdata->context);
./drivers/gpio/gpio-adnp.c:252:	chip->direction_input = adnp_gpio_direction_input;
./drivers/gpio/gpio-adnp.c:253:	chip->direction_output = adnp_gpio_direction_output;
./drivers/gpio/gpio-adnp.c:254:	chip->get = adnp_gpio_get;
./drivers/gpio/gpio-adnp.c:255:	chip->set = adnp_gpio_set;
./drivers/gpio/gpio-adnp.c:256:	chip->can_sleep = true;
./drivers/gpio/gpio-adnp.c:259:		chip->dbg_show = adnp_gpio_dbg_show;
./drivers/gpio/gpio-adnp.c:261:	chip->base = -1;
./drivers/gpio/gpio-adnp.c:262:	chip->ngpio = num_gpios;
./drivers/gpio/gpio-adnp.c:263:	chip->label = adnp->client->name;
./drivers/gpio/gpio-adnp.c:264:	chip->parent = &adnp->client->dev;
./drivers/gpio/gpio-adnp.c:265:	chip->of_node = chip->parent->of_node;
./drivers/gpio/gpio-adnp.c:266:	chip->owner = THIS_MODULE;
./drivers/gpio/gpio-adnp.c:433:	adnp->irq_enable = devm_kzalloc(chip->parent, num_regs * 6,
./drivers/gpio/gpio-adnp.c:461:	err = devm_request_threaded_irq(chip->parent, adnp->client->irq,
./drivers/gpio/gpio-adnp.c:464:					dev_name(chip->parent), adnp);
./drivers/gpio/gpio-adnp.c:466:		dev_err(chip->parent, "can't request IRQ#%d: %d\n",
./drivers/gpio/gpio-adnp.c:477:		dev_err(chip->parent,
./drivers/gpio/gpio-mb86s7x.c:52:	spin_lock_irqsave(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:54:	val = readl(gchip->base + PFR(gpio));
./drivers/gpio/gpio-mb86s7x.c:56:		spin_unlock_irqrestore(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:61:	writel(val, gchip->base + PFR(gpio));
./drivers/gpio/gpio-mb86s7x.c:63:	spin_unlock_irqrestore(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:74:	spin_lock_irqsave(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:76:	val = readl(gchip->base + PFR(gpio));
./drivers/gpio/gpio-mb86s7x.c:78:	writel(val, gchip->base + PFR(gpio));
./drivers/gpio/gpio-mb86s7x.c:80:	spin_unlock_irqrestore(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:89:	spin_lock_irqsave(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:91:	val = readl(gchip->base + DDR(gpio));
./drivers/gpio/gpio-mb86s7x.c:93:	writel(val, gchip->base + DDR(gpio));
./drivers/gpio/gpio-mb86s7x.c:95:	spin_unlock_irqrestore(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:107:	spin_lock_irqsave(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:109:	val = readl(gchip->base + PDR(gpio));
./drivers/gpio/gpio-mb86s7x.c:114:	writel(val, gchip->base + PDR(gpio));
./drivers/gpio/gpio-mb86s7x.c:116:	val = readl(gchip->base + DDR(gpio));
./drivers/gpio/gpio-mb86s7x.c:118:	writel(val, gchip->base + DDR(gpio));
./drivers/gpio/gpio-mb86s7x.c:120:	spin_unlock_irqrestore(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:129:	return !!(readl(gchip->base + PDR(gpio)) & OFFSET(gpio));
./drivers/gpio/gpio-mb86s7x.c:138:	spin_lock_irqsave(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:140:	val = readl(gchip->base + PDR(gpio));
./drivers/gpio/gpio-mb86s7x.c:145:	writel(val, gchip->base + PDR(gpio));
./drivers/gpio/gpio-mb86s7x.c:147:	spin_unlock_irqrestore(&gchip->lock, flags);
./drivers/gpio/gpio-mb86s7x.c:163:	gchip->base = devm_ioremap_resource(&pdev->dev, res);
./drivers/gpio/gpio-mb86s7x.c:164:	if (IS_ERR(gchip->base))
./drivers/gpio/gpio-mb86s7x.c:165:		return PTR_ERR(gchip->base);
./drivers/gpio/gpio-mb86s7x.c:167:	gchip->clk = devm_clk_get(&pdev->dev, NULL);
./drivers/gpio/gpio-mb86s7x.c:168:	if (IS_ERR(gchip->clk))
./drivers/gpio/gpio-mb86s7x.c:169:		return PTR_ERR(gchip->clk);
./drivers/gpio/gpio-mb86s7x.c:171:	clk_prepare_enable(gchip->clk);
./drivers/gpio/gpio-mb86s7x.c:173:	spin_lock_init(&gchip->lock);
./drivers/gpio/gpio-mb86s7x.c:175:	gchip->gc.direction_output = mb86s70_gpio_direction_output;
./drivers/gpio/gpio-mb86s7x.c:176:	gchip->gc.direction_input = mb86s70_gpio_direction_input;
./drivers/gpio/gpio-mb86s7x.c:177:	gchip->gc.request = mb86s70_gpio_request;
./drivers/gpio/gpio-mb86s7x.c:178:	gchip->gc.free = mb86s70_gpio_free;
./drivers/gpio/gpio-mb86s7x.c:179:	gchip->gc.get = mb86s70_gpio_get;
./drivers/gpio/gpio-mb86s7x.c:180:	gchip->gc.set = mb86s70_gpio_set;
./drivers/gpio/gpio-mb86s7x.c:181:	gchip->gc.label = dev_name(&pdev->dev);
./drivers/gpio/gpio-mb86s7x.c:182:	gchip->gc.ngpio = 32;
./drivers/gpio/gpio-mb86s7x.c:183:	gchip->gc.owner = THIS_MODULE;
./drivers/gpio/gpio-mb86s7x.c:184:	gchip->gc.parent = &pdev->dev;
./drivers/gpio/gpio-mb86s7x.c:185:	gchip->gc.base = -1;
./drivers/gpio/gpio-mb86s7x.c:187:	ret = gpiochip_add_data(&gchip->gc, gchip);
./drivers/gpio/gpio-mb86s7x.c:190:		clk_disable_unprepare(gchip->clk);
./drivers/gpio/gpio-mb86s7x.c:200:	gpiochip_remove(&gchip->gc);
./drivers/gpio/gpio-mb86s7x.c:201:	clk_disable_unprepare(gchip->clk);
./drivers/gpio/gpio-wm8994.c:198:	for (i = 0; i < chip->ngpio; i++) {
./drivers/gpio/gpio-wm8994.c:199:		int gpio = i + chip->base;
./drivers/gpio/gpio-mcp23s08.c:467:	err = devm_request_threaded_irq(chip->parent, mcp->irq, NULL,
./drivers/gpio/gpio-mcp23s08.c:469:					irqflags, dev_name(chip->parent), mcp);
./drivers/gpio/gpio-mcp23s08.c:471:		dev_err(chip->parent, "unable to request IRQ#%d: %d\n",
./drivers/gpio/gpio-mcp23s08.c:482:		dev_err(chip->parent,
./drivers/gpio/gpio-mcp23s08.c:524:	for (t = 0, mask = 1; t < chip->ngpio; t++, mask <<= 1) {
./drivers/gpio/gpio-mcp23s08.c:532:			chip->base + t, bank, t, label,
./drivers/gpio/gpio-mpc5200.c:77:		chip->shadow_dvo |= 1 << (7 - gpio);
./drivers/gpio/gpio-mpc5200.c:79:		chip->shadow_dvo &= ~(1 << (7 - gpio));
./drivers/gpio/gpio-mpc5200.c:81:	out_8(&regs->wkup_dvo, chip->shadow_dvo);
./drivers/gpio/gpio-mpc5200.c:108:	chip->shadow_ddr &= ~(1 << (7 - gpio));
./drivers/gpio/gpio-mpc5200.c:109:	out_8(&regs->wkup_ddr, chip->shadow_ddr);
./drivers/gpio/gpio-mpc5200.c:112:	chip->shadow_gpioe |= 1 << (7 - gpio);
./drivers/gpio/gpio-mpc5200.c:113:	out_8(&regs->wkup_gpioe, chip->shadow_gpioe);
./drivers/gpio/gpio-mpc5200.c:133:	chip->shadow_ddr |= 1 << (7 - gpio);
./drivers/gpio/gpio-mpc5200.c:134:	out_8(&regs->wkup_ddr, chip->shadow_ddr);
./drivers/gpio/gpio-mpc5200.c:137:	chip->shadow_gpioe |= 1 << (7 - gpio);
./drivers/gpio/gpio-mpc5200.c:138:	out_8(&regs->wkup_gpioe, chip->shadow_gpioe);
./drivers/gpio/gpio-mpc5200.c:160:	gc = &chip->mmchip.gc;
./drivers/gpio/gpio-mpc5200.c:168:	ret = of_mm_gpiochip_add_data(ofdev->dev.of_node, &chip->mmchip, chip);
./drivers/gpio/gpio-mpc5200.c:172:	regs = chip->mmchip.regs;
./drivers/gpio/gpio-mpc5200.c:173:	chip->shadow_gpioe = in_8(&regs->wkup_gpioe);
./drivers/gpio/gpio-mpc5200.c:174:	chip->shadow_ddr = in_8(&regs->wkup_ddr);
./drivers/gpio/gpio-mpc5200.c:175:	chip->shadow_dvo = in_8(&regs->wkup_dvo);
./drivers/gpio/gpio-mpc5200.c:184:	of_mm_gpiochip_remove(&chip->mmchip);
./drivers/gpio/gpio-mpc5200.c:239:		chip->shadow_dvo |= 1 << (31 - gpio);
./drivers/gpio/gpio-mpc5200.c:241:		chip->shadow_dvo &= ~(1 << (31 - gpio));
./drivers/gpio/gpio-mpc5200.c:242:	out_be32(&regs->simple_dvo, chip->shadow_dvo);
./drivers/gpio/gpio-mpc5200.c:269:	chip->shadow_ddr &= ~(1 << (31 - gpio));
./drivers/gpio/gpio-mpc5200.c:270:	out_be32(&regs->simple_ddr, chip->shadow_ddr);
./drivers/gpio/gpio-mpc5200.c:273:	chip->shadow_gpioe |= 1 << (31 - gpio);
./drivers/gpio/gpio-mpc5200.c:274:	out_be32(&regs->simple_gpioe, chip->shadow_gpioe);
./drivers/gpio/gpio-mpc5200.c:295:	chip->shadow_ddr |= 1 << (31 - gpio);
./drivers/gpio/gpio-mpc5200.c:296:	out_be32(&regs->simple_ddr, chip->shadow_ddr);
./drivers/gpio/gpio-mpc5200.c:299:	chip->shadow_gpioe |= 1 << (31 - gpio);
./drivers/gpio/gpio-mpc5200.c:300:	out_be32(&regs->simple_gpioe, chip->shadow_gpioe);
./drivers/gpio/gpio-mpc5200.c:322:	gc = &chip->mmchip.gc;
./drivers/gpio/gpio-mpc5200.c:330:	ret = of_mm_gpiochip_add_data(ofdev->dev.of_node, &chip->mmchip, chip);
./drivers/gpio/gpio-mpc5200.c:334:	regs = chip->mmchip.regs;
./drivers/gpio/gpio-mpc5200.c:335:	chip->shadow_gpioe = in_be32(&regs->simple_gpioe);
./drivers/gpio/gpio-mpc5200.c:336:	chip->shadow_ddr = in_be32(&regs->simple_ddr);
./drivers/gpio/gpio-mpc5200.c:337:	chip->shadow_dvo = in_be32(&regs->simple_dvo);
./drivers/gpio/gpio-max732x.c:166:	client = group_a ? chip->client_group_a : chip->client_group_b;
./drivers/gpio/gpio-max732x.c:181:	client = group_a ? chip->client_group_a : chip->client_group_b;
./drivers/gpio/gpio-max732x.c:194:	return (1u << off) & chip->mask_group_a;
./drivers/gpio/gpio-max732x.c:217:	mutex_lock(&chip->lock);
./drivers/gpio/gpio-max732x.c:219:	reg_out = (off > 7) ? chip->reg_out[1] : chip->reg_out[0];
./drivers/gpio/gpio-max732x.c:228:		chip->reg_out[1] = reg_out;
./drivers/gpio/gpio-max732x.c:230:		chip->reg_out[0] = reg_out;
./drivers/gpio/gpio-max732x.c:232:	mutex_unlock(&chip->lock);
./drivers/gpio/gpio-max732x.c:260:	if ((mask & chip->dir_input) == 0) {
./drivers/gpio/gpio-max732x.c:261:		dev_dbg(&chip->client->dev, "%s port %d is output only\n",
./drivers/gpio/gpio-max732x.c:262:			chip->client->name, off);
./drivers/gpio/gpio-max732x.c:270:	if ((mask & chip->dir_output))
./drivers/gpio/gpio-max732x.c:282:	if ((mask & chip->dir_output) == 0) {
./drivers/gpio/gpio-max732x.c:283:		dev_dbg(&chip->client->dev, "%s port %d is input only\n",
./drivers/gpio/gpio-max732x.c:284:			chip->client->name, off);
./drivers/gpio/gpio-max732x.c:299:	ret = i2c_master_send(chip->client_group_a, (char *)&val, 2);
./drivers/gpio/gpio-max732x.c:301:		dev_err(&chip->client_group_a->dev, "failed writing\n");
./drivers/gpio/gpio-max732x.c:312:	ret = i2c_master_recv(chip->client_group_a, (char *)val, 2);
./drivers/gpio/gpio-max732x.c:314:		dev_err(&chip->client_group_a->dev, "failed reading\n");
./drivers/gpio/gpio-max732x.c:326:	if (chip->irq_mask == chip->irq_mask_cur)
./drivers/gpio/gpio-max732x.c:329:	chip->irq_mask = chip->irq_mask_cur;
./drivers/gpio/gpio-max732x.c:331:	if (chip->irq_features == INT_NO_MASK)
./drivers/gpio/gpio-max732x.c:334:	mutex_lock(&chip->lock);
./drivers/gpio/gpio-max732x.c:336:	switch (chip->irq_features) {
./drivers/gpio/gpio-max732x.c:338:		msg = (chip->irq_mask << 8) | chip->reg_out[0];
./drivers/gpio/gpio-max732x.c:343:		msg = chip->irq_mask | chip->reg_out[0];
./drivers/gpio/gpio-max732x.c:348:	mutex_unlock(&chip->lock);
./drivers/gpio/gpio-max732x.c:356:	chip->irq_mask_cur &= ~(1 << d->hwirq);
./drivers/gpio/gpio-max732x.c:364:	chip->irq_mask_cur |= 1 << d->hwirq;
./drivers/gpio/gpio-max732x.c:372:	mutex_lock(&chip->irq_lock);
./drivers/gpio/gpio-max732x.c:373:	chip->irq_mask_cur = chip->irq_mask;
./drivers/gpio/gpio-max732x.c:385:	new_irqs = chip->irq_trig_fall | chip->irq_trig_raise;
./drivers/gpio/gpio-max732x.c:388:		max732x_gpio_direction_input(&chip->gpio_chip, level);
./drivers/gpio/gpio-max732x.c:392:	mutex_unlock(&chip->irq_lock);
./drivers/gpio/gpio-max732x.c:402:	if (!(mask & chip->dir_input)) {
./drivers/gpio/gpio-max732x.c:403:		dev_dbg(&chip->client->dev, "%s port %d is output only\n",
./drivers/gpio/gpio-max732x.c:404:			chip->client->name, off);
./drivers/gpio/gpio-max732x.c:409:		dev_err(&chip->client->dev, "irq %d: unsupported type %d\n",
./drivers/gpio/gpio-max732x.c:415:		chip->irq_trig_fall |= mask;
./drivers/gpio/gpio-max732x.c:417:		chip->irq_trig_fall &= ~mask;
./drivers/gpio/gpio-max732x.c:420:		chip->irq_trig_raise |= mask;
./drivers/gpio/gpio-max732x.c:422:		chip->irq_trig_raise &= ~mask;
./drivers/gpio/gpio-max732x.c:431:	irq_set_irq_wake(chip->client->irq, on);
./drivers/gpio/gpio-max732x.c:459:	trigger &= chip->irq_mask;
./drivers/gpio/gpio-max732x.c:465:	cur_stat &= chip->irq_mask;
./drivers/gpio/gpio-max732x.c:469:	pending = (old_stat & chip->irq_trig_fall) |
./drivers/gpio/gpio-max732x.c:470:		  (cur_stat & chip->irq_trig_raise);
./drivers/gpio/gpio-max732x.c:489:		handle_nested_irq(irq_find_mapping(chip->gpio_chip.irqdomain,
./drivers/gpio/gpio-max732x.c:501:	struct i2c_client *client = chip->client;
./drivers/gpio/gpio-max732x.c:511:		chip->irq_features = has_irq;
./drivers/gpio/gpio-max732x.c:512:		mutex_init(&chip->irq_lock);
./drivers/gpio/gpio-max732x.c:523:		ret =  gpiochip_irqchip_add(&chip->gpio_chip,
./drivers/gpio/gpio-max732x.c:533:		gpiochip_set_chained_irqchip(&chip->gpio_chip,
./drivers/gpio/gpio-max732x.c:546:	struct i2c_client *client = chip->client;
./drivers/gpio/gpio-max732x.c:561:	struct gpio_chip *gc = &chip->gpio_chip;
./drivers/gpio/gpio-max732x.c:570:			chip->dir_output |= mask;
./drivers/gpio/gpio-max732x.c:573:			chip->dir_input |= mask;
./drivers/gpio/gpio-max732x.c:576:			chip->dir_output |= mask;
./drivers/gpio/gpio-max732x.c:577:			chip->dir_input |= mask;
./drivers/gpio/gpio-max732x.c:584:			chip->mask_group_a |= mask;
./drivers/gpio/gpio-max732x.c:588:	if (chip->dir_input)
./drivers/gpio/gpio-max732x.c:590:	if (chip->dir_output) {
./drivers/gpio/gpio-max732x.c:600:	gc->label = chip->client->name;
./drivers/gpio/gpio-max732x.c:601:	gc->parent = &chip->client->dev;
./drivers/gpio/gpio-max732x.c:644:	chip->client = client;
./drivers/gpio/gpio-max732x.c:647:	chip->gpio_chip.parent = &client->dev;
./drivers/gpio/gpio-max732x.c:654:		chip->client_group_a = client;
./drivers/gpio/gpio-max732x.c:657:			chip->client_group_b = chip->client_dummy = c;
./drivers/gpio/gpio-max732x.c:661:		chip->client_group_b = client;
./drivers/gpio/gpio-max732x.c:664:			chip->client_group_a = chip->client_dummy = c;
./drivers/gpio/gpio-max732x.c:674:	if (nr_port > 8 && !chip->client_dummy) {
./drivers/gpio/gpio-max732x.c:681:	mutex_init(&chip->lock);
./drivers/gpio/gpio-max732x.c:683:	ret = max732x_readb(chip, is_group_a(chip, 0), &chip->reg_out[0]);
./drivers/gpio/gpio-max732x.c:687:		ret = max732x_readb(chip, is_group_a(chip, 8), &chip->reg_out[1]);
./drivers/gpio/gpio-max732x.c:692:	ret = gpiochip_add_data(&chip->gpio_chip, chip);
./drivers/gpio/gpio-max732x.c:698:		gpiochip_remove(&chip->gpio_chip);
./drivers/gpio/gpio-max732x.c:703:		ret = pdata->setup(client, chip->gpio_chip.base,
./drivers/gpio/gpio-max732x.c:704:				chip->gpio_chip.ngpio, pdata->context);
./drivers/gpio/gpio-max732x.c:713:	if (chip->client_dummy)
./drivers/gpio/gpio-max732x.c:714:		i2c_unregister_device(chip->client_dummy);
./drivers/gpio/gpio-max732x.c:726:		ret = pdata->teardown(client, chip->gpio_chip.base,
./drivers/gpio/gpio-max732x.c:727:				chip->gpio_chip.ngpio, pdata->context);
./drivers/gpio/gpio-max732x.c:735:	gpiochip_remove(&chip->gpio_chip);
./drivers/gpio/gpio-max732x.c:738:	if (chip->client_dummy)
./drivers/gpio/gpio-max732x.c:739:		i2c_unregister_device(chip->client_dummy);
./drivers/gpio/gpio-104-dio-48e.c:293:		generic_handle_irq(irq_find_mapping(chip->irqdomain,
./drivers/gpio/gpiolib-of.c:261:	for_each_available_child_of_node(chip->of_node, np) {
./drivers/gpio/gpiolib-of.c:393:	struct device_node *np = chip->of_node;
./drivers/gpio/gpiolib-of.c:479:	if ((!chip->of_node) && (chip->parent))
./drivers/gpio/gpiolib-of.c:480:		chip->of_node = chip->parent->of_node;
./drivers/gpio/gpiolib-of.c:482:	if (!chip->of_node)
./drivers/gpio/gpiolib-of.c:485:	if (!chip->of_xlate) {
./drivers/gpio/gpiolib-of.c:486:		chip->of_gpio_n_cells = 2;
./drivers/gpio/gpiolib-of.c:487:		chip->of_xlate = of_gpio_simple_xlate;
./drivers/gpio/gpiolib-of.c:495:	if (!chip->names)
./drivers/gpio/gpiolib-of.c:498:	of_node_get(chip->of_node);
./drivers/gpio/gpiolib-of.c:506:	of_node_put(chip->of_node);
./drivers/gpio/gpio-em.c:242:	return pinctrl_request_gpio(chip->base + offset);
./drivers/gpio/gpio-em.c:247:	pinctrl_free_gpio(chip->base + offset);
./drivers/gpio/gpio-em.c:326:	gpio_chip->of_node = pdev->dev.of_node;
./drivers/gpio/gpio-em.c:327:	gpio_chip->direction_input = em_gio_direction_input;
./drivers/gpio/gpio-em.c:328:	gpio_chip->get = em_gio_get;
./drivers/gpio/gpio-em.c:329:	gpio_chip->direction_output = em_gio_direction_output;
./drivers/gpio/gpio-em.c:330:	gpio_chip->set = em_gio_set;
./drivers/gpio/gpio-em.c:331:	gpio_chip->to_irq = em_gio_to_irq;
./drivers/gpio/gpio-em.c:332:	gpio_chip->request = em_gio_request;
./drivers/gpio/gpio-em.c:333:	gpio_chip->free = em_gio_free;
./drivers/gpio/gpio-em.c:334:	gpio_chip->label = name;
./drivers/gpio/gpio-em.c:335:	gpio_chip->parent = &pdev->dev;
./drivers/gpio/gpio-em.c:336:	gpio_chip->owner = THIS_MODULE;
./drivers/gpio/gpio-em.c:337:	gpio_chip->base = -1;
./drivers/gpio/gpio-em.c:338:	gpio_chip->ngpio = ngpios;
./drivers/gpio/gpio-em.c:341:	irq_chip->name = name;
./drivers/gpio/gpio-em.c:342:	irq_chip->irq_mask = em_gio_irq_disable;
./drivers/gpio/gpio-em.c:343:	irq_chip->irq_unmask = em_gio_irq_enable;
./drivers/gpio/gpio-em.c:344:	irq_chip->irq_set_type = em_gio_irq_set_type;
./drivers/gpio/gpio-em.c:345:	irq_chip->irq_request_resources = em_gio_irq_reqres;
./drivers/gpio/gpio-em.c:346:	irq_chip->irq_release_resources = em_gio_irq_relres;
./drivers/gpio/gpio-em.c:347:	irq_chip->flags	= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_MASK_ON_SUSPEND;
./drivers/gpio/gpio-lynxpoint.c:262:	chip->irq_eoi(data);
./drivers/gpio/gpiolib-sysfs.c:405:	return sprintf(buf, "%d\n", chip->base);
./drivers/gpio/gpiolib-sysfs.c:414:	return sprintf(buf, "%s\n", chip->label ? : "");
./drivers/gpio/gpiolib-sysfs.c:423:	return sprintf(buf, "%u\n", chip->ngpio);
./drivers/gpio/gpiolib-sysfs.c:601:	if (chip->direction_input && chip->direction_output)
./drivers/gpio/gpiolib-sysfs.c:607:	if (chip->names && chip->names[offset])
./drivers/gpio/gpiolib-sysfs.c:608:		ioname = chip->names[offset];
./drivers/gpio/gpiolib-sysfs.c:740:	if (chip->parent)
./drivers/gpio/gpiolib-sysfs.c:741:		parent = chip->parent;
./drivers/gpio/gpiolib-sysfs.c:745:	/* use chip->base for the ID; it's already known to be unique */
./drivers/gpio/gpiolib-sysfs.c:749:					"gpiochip%d", chip->base);
./drivers/gpio/gpiolib-sysfs.c:777:	for (i = 0; i < chip->ngpio; i++) {
./drivers/gpio/gpiolib-sysfs.c:797:	 * We run before arch_initcall() so chip->dev nodes can have
./drivers/gpio/gpio-sch311x.c:146:		dev_err(chip->parent, "Failed to request region 0x%04x.\n",
./drivers/gpio/gpio-ws16c48.c:297:					chip->irqdomain, gpio + 8*port));
./drivers/gpio/gpio-intel-mid.c:80:	unsigned nreg = chip->ngpio / 32;
./drivers/gpio/gpio-intel-mid.c:90:	unsigned nreg = chip->ngpio / 32;
./drivers/gpio/gpio-intel-mid.c:303:	chip->irq_eoi(data);
./drivers/gpio/gpio-etraxfs.c:216:	return 4 * etraxfs_gpio_chip_to_port(&chip->gc) + gpio / 8;
./drivers/gpio/gpio-etraxfs.c:223:	struct etraxfs_gpio_block *block = chip->block;
./drivers/gpio/gpio-etraxfs.c:233:	struct etraxfs_gpio_block *block = chip->block;
./drivers/gpio/gpio-etraxfs.c:246:	struct etraxfs_gpio_block *block = chip->block;
./drivers/gpio/gpio-etraxfs.c:259:	struct etraxfs_gpio_block *block = chip->block;
./drivers/gpio/gpio-etraxfs.c:296:	struct etraxfs_gpio_block *block = chip->block;
./drivers/gpio/gpio-etraxfs.c:304:	ret = gpiochip_lock_as_irq(&chip->gc, d->hwirq);
./drivers/gpio/gpio-etraxfs.c:327:	struct etraxfs_gpio_block *block = chip->block;
./drivers/gpio/gpio-etraxfs.c:332:	gpiochip_unlock_as_irq(&chip->gc, d->hwirq);
./drivers/gpio/gpio-etraxfs.c:415:		struct gpio_chip *gc = &chip->gc;
./drivers/gpio/gpio-etraxfs.c:422:		chip->block = block;
./drivers/gpio/gpio-lpc32xx.c:365:	if (pin < chip->ngpio)
./drivers/gpio/gpio-mvebu.c:102:	return mvchip->membase + GPIO_OUT_OFF;
./drivers/gpio/gpio-mvebu.c:107:	return mvchip->membase + GPIO_BLINK_EN_OFF;
./drivers/gpio/gpio-mvebu.c:113:	return mvchip->membase + GPIO_IO_CONF_OFF;
./drivers/gpio/gpio-mvebu.c:118:	return mvchip->membase + GPIO_IN_POL_OFF;
./drivers/gpio/gpio-mvebu.c:124:	return mvchip->membase + GPIO_DATA_IN_OFF;
./drivers/gpio/gpio-mvebu.c:132:	switch (mvchip->soc_variant) {
./drivers/gpio/gpio-mvebu.c:135:		return mvchip->membase + GPIO_EDGE_CAUSE_OFF;
./drivers/gpio/gpio-mvebu.c:138:		return mvchip->percpu_membase +
./drivers/gpio/gpio-mvebu.c:150:	switch (mvchip->soc_variant) {
./drivers/gpio/gpio-mvebu.c:152:		return mvchip->membase + GPIO_EDGE_MASK_OFF;
./drivers/gpio/gpio-mvebu.c:155:		return mvchip->membase + GPIO_EDGE_MASK_MV78200_OFF(cpu);
./drivers/gpio/gpio-mvebu.c:158:		return mvchip->percpu_membase +
./drivers/gpio/gpio-mvebu.c:169:	switch (mvchip->soc_variant) {
./drivers/gpio/gpio-mvebu.c:171:		return mvchip->membase + GPIO_LEVEL_MASK_OFF;
./drivers/gpio/gpio-mvebu.c:174:		return mvchip->membase + GPIO_LEVEL_MASK_MV78200_OFF(cpu);
./drivers/gpio/gpio-mvebu.c:177:		return mvchip->percpu_membase +
./drivers/gpio/gpio-mvebu.c:194:	spin_lock_irqsave(&mvchip->lock, flags);
./drivers/gpio/gpio-mvebu.c:201:	spin_unlock_irqrestore(&mvchip->lock, flags);
./drivers/gpio/gpio-mvebu.c:225:	spin_lock_irqsave(&mvchip->lock, flags);
./drivers/gpio/gpio-mvebu.c:232:	spin_unlock_irqrestore(&mvchip->lock, flags);
./drivers/gpio/gpio-mvebu.c:244:	ret = pinctrl_gpio_direction_input(chip->base + pin);
./drivers/gpio/gpio-mvebu.c:248:	spin_lock_irqsave(&mvchip->lock, flags);
./drivers/gpio/gpio-mvebu.c:252:	spin_unlock_irqrestore(&mvchip->lock, flags);
./drivers/gpio/gpio-mvebu.c:267:	ret = pinctrl_gpio_direction_output(chip->base + pin);
./drivers/gpio/gpio-mvebu.c:274:	spin_lock_irqsave(&mvchip->lock, flags);
./drivers/gpio/gpio-mvebu.c:278:	spin_unlock_irqrestore(&mvchip->lock, flags);
./drivers/gpio/gpio-mvebu.c:286:	return irq_create_mapping(mvchip->domain, pin);
./drivers/gpio/gpio-mvebu.c:462:	for (i = 0; i < mvchip->chip.ngpio; i++) {
./drivers/gpio/gpio-mvebu.c:465:		irq = mvchip->irqbase + i;
./drivers/gpio/gpio-mvebu.c:504:	for (i = 0; i < chip->ngpio; i++) {
./drivers/gpio/gpio-mvebu.c:516:		seq_printf(s, " gpio-%-3d (%-20.20s)", chip->base + i, label);
./drivers/gpio/gpio-mvebu.c:566:	mvchip->out_reg = readl(mvebu_gpioreg_out(mvchip));
./drivers/gpio/gpio-mvebu.c:567:	mvchip->io_conf_reg = readl(mvebu_gpioreg_io_conf(mvchip));
./drivers/gpio/gpio-mvebu.c:568:	mvchip->blink_en_reg = readl(mvebu_gpioreg_blink(mvchip));
./drivers/gpio/gpio-mvebu.c:569:	mvchip->in_pol_reg = readl(mvebu_gpioreg_in_pol(mvchip));
./drivers/gpio/gpio-mvebu.c:571:	switch (mvchip->soc_variant) {
./drivers/gpio/gpio-mvebu.c:573:		mvchip->edge_mask_regs[0] =
./drivers/gpio/gpio-mvebu.c:574:			readl(mvchip->membase + GPIO_EDGE_MASK_OFF);
./drivers/gpio/gpio-mvebu.c:575:		mvchip->level_mask_regs[0] =
./drivers/gpio/gpio-mvebu.c:576:			readl(mvchip->membase + GPIO_LEVEL_MASK_OFF);
./drivers/gpio/gpio-mvebu.c:580:			mvchip->edge_mask_regs[i] =
./drivers/gpio/gpio-mvebu.c:581:				readl(mvchip->membase +
./drivers/gpio/gpio-mvebu.c:583:			mvchip->level_mask_regs[i] =
./drivers/gpio/gpio-mvebu.c:584:				readl(mvchip->membase +
./drivers/gpio/gpio-mvebu.c:590:			mvchip->edge_mask_regs[i] =
./drivers/gpio/gpio-mvebu.c:591:				readl(mvchip->membase +
./drivers/gpio/gpio-mvebu.c:593:			mvchip->level_mask_regs[i] =
./drivers/gpio/gpio-mvebu.c:594:				readl(mvchip->membase +
./drivers/gpio/gpio-mvebu.c:610:	writel(mvchip->out_reg, mvebu_gpioreg_out(mvchip));
./drivers/gpio/gpio-mvebu.c:611:	writel(mvchip->io_conf_reg, mvebu_gpioreg_io_conf(mvchip));
./drivers/gpio/gpio-mvebu.c:612:	writel(mvchip->blink_en_reg, mvebu_gpioreg_blink(mvchip));
./drivers/gpio/gpio-mvebu.c:613:	writel(mvchip->in_pol_reg, mvebu_gpioreg_in_pol(mvchip));
./drivers/gpio/gpio-mvebu.c:615:	switch (mvchip->soc_variant) {
./drivers/gpio/gpio-mvebu.c:617:		writel(mvchip->edge_mask_regs[0],
./drivers/gpio/gpio-mvebu.c:618:		       mvchip->membase + GPIO_EDGE_MASK_OFF);
./drivers/gpio/gpio-mvebu.c:619:		writel(mvchip->level_mask_regs[0],
./drivers/gpio/gpio-mvebu.c:620:		       mvchip->membase + GPIO_LEVEL_MASK_OFF);
./drivers/gpio/gpio-mvebu.c:624:			writel(mvchip->edge_mask_regs[i],
./drivers/gpio/gpio-mvebu.c:625:			       mvchip->membase + GPIO_EDGE_MASK_MV78200_OFF(i));
./drivers/gpio/gpio-mvebu.c:626:			writel(mvchip->level_mask_regs[i],
./drivers/gpio/gpio-mvebu.c:627:			       mvchip->membase +
./drivers/gpio/gpio-mvebu.c:633:			writel(mvchip->edge_mask_regs[i],
./drivers/gpio/gpio-mvebu.c:634:			       mvchip->membase +
./drivers/gpio/gpio-mvebu.c:636:			writel(mvchip->level_mask_regs[i],
./drivers/gpio/gpio-mvebu.c:637:			       mvchip->membase +
./drivers/gpio/gpio-mvebu.c:691:	mvchip->soc_variant = soc_variant;
./drivers/gpio/gpio-mvebu.c:692:	mvchip->chip.label = dev_name(&pdev->dev);
./drivers/gpio/gpio-mvebu.c:693:	mvchip->chip.parent = &pdev->dev;
./drivers/gpio/gpio-mvebu.c:694:	mvchip->chip.request = gpiochip_generic_request;
./drivers/gpio/gpio-mvebu.c:695:	mvchip->chip.free = gpiochip_generic_free;
./drivers/gpio/gpio-mvebu.c:696:	mvchip->chip.direction_input = mvebu_gpio_direction_input;
./drivers/gpio/gpio-mvebu.c:697:	mvchip->chip.get = mvebu_gpio_get;
./drivers/gpio/gpio-mvebu.c:698:	mvchip->chip.direction_output = mvebu_gpio_direction_output;
./drivers/gpio/gpio-mvebu.c:699:	mvchip->chip.set = mvebu_gpio_set;
./drivers/gpio/gpio-mvebu.c:700:	mvchip->chip.to_irq = mvebu_gpio_to_irq;
./drivers/gpio/gpio-mvebu.c:701:	mvchip->chip.base = id * MVEBU_MAX_GPIO_PER_BANK;
./drivers/gpio/gpio-mvebu.c:702:	mvchip->chip.ngpio = ngpios;
./drivers/gpio/gpio-mvebu.c:703:	mvchip->chip.can_sleep = false;
./drivers/gpio/gpio-mvebu.c:704:	mvchip->chip.of_node = np;
./drivers/gpio/gpio-mvebu.c:705:	mvchip->chip.dbg_show = mvebu_gpio_dbg_show;
./drivers/gpio/gpio-mvebu.c:707:	spin_lock_init(&mvchip->lock);
./drivers/gpio/gpio-mvebu.c:709:	mvchip->membase = devm_ioremap_resource(&pdev->dev, res);
./drivers/gpio/gpio-mvebu.c:710:	if (IS_ERR(mvchip->membase))
./drivers/gpio/gpio-mvebu.c:711:		return PTR_ERR(mvchip->membase);
./drivers/gpio/gpio-mvebu.c:717:		mvchip->percpu_membase = devm_ioremap_resource(&pdev->dev,
./drivers/gpio/gpio-mvebu.c:719:		if (IS_ERR(mvchip->percpu_membase))
./drivers/gpio/gpio-mvebu.c:720:			return PTR_ERR(mvchip->percpu_membase);
./drivers/gpio/gpio-mvebu.c:728:		writel_relaxed(0, mvchip->membase + GPIO_EDGE_CAUSE_OFF);
./drivers/gpio/gpio-mvebu.c:729:		writel_relaxed(0, mvchip->membase + GPIO_EDGE_MASK_OFF);
./drivers/gpio/gpio-mvebu.c:730:		writel_relaxed(0, mvchip->membase + GPIO_LEVEL_MASK_OFF);
./drivers/gpio/gpio-mvebu.c:733:		writel_relaxed(0, mvchip->membase + GPIO_EDGE_CAUSE_OFF);
./drivers/gpio/gpio-mvebu.c:735:			writel_relaxed(0, mvchip->membase +
./drivers/gpio/gpio-mvebu.c:737:			writel_relaxed(0, mvchip->membase +
./drivers/gpio/gpio-mvebu.c:742:		writel_relaxed(0, mvchip->membase + GPIO_EDGE_CAUSE_OFF);
./drivers/gpio/gpio-mvebu.c:743:		writel_relaxed(0, mvchip->membase + GPIO_EDGE_MASK_OFF);
./drivers/gpio/gpio-mvebu.c:744:		writel_relaxed(0, mvchip->membase + GPIO_LEVEL_MASK_OFF);
./drivers/gpio/gpio-mvebu.c:746:			writel_relaxed(0, mvchip->percpu_membase +
./drivers/gpio/gpio-mvebu.c:748:			writel_relaxed(0, mvchip->percpu_membase +
./drivers/gpio/gpio-mvebu.c:750:			writel_relaxed(0, mvchip->percpu_membase +
./drivers/gpio/gpio-mvebu.c:758:	devm_gpiochip_add_data(&pdev->dev, &mvchip->chip, mvchip);
./drivers/gpio/gpio-mvebu.c:776:	mvchip->irqbase = irq_alloc_descs(-1, 0, ngpios, -1);
./drivers/gpio/gpio-mvebu.c:777:	if (mvchip->irqbase < 0) {
./drivers/gpio/gpio-mvebu.c:779:		return mvchip->irqbase;
./drivers/gpio/gpio-mvebu.c:782:	gc = irq_alloc_generic_chip("mvebu_gpio_irq", 2, mvchip->irqbase,
./drivers/gpio/gpio-mvebu.c:783:				    mvchip->membase, handle_level_irq);
./drivers/gpio/gpio-mvebu.c:795:	ct->chip.name = mvchip->chip.label;
./drivers/gpio/gpio-mvebu.c:804:	ct->chip.name = mvchip->chip.label;
./drivers/gpio/gpio-mvebu.c:810:	mvchip->domain = irq_domain_add_simple(np, mvchip->chip.ngpio,
./drivers/gpio/gpio-mvebu.c:811:					       mvchip->irqbase,
./drivers/gpio/gpio-mvebu.c:814:	if (!mvchip->domain) {
./drivers/gpio/gpio-mvebu.c:816:			mvchip->chip.label);
./drivers/gpio/gpiolib-acpi.c:137:	offset = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
./drivers/gpio/gpiolib-acpi.c:187:	handle = ACPI_HANDLE(chip->parent);
./drivers/gpio/gpiolib-acpi.c:205:	pin = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
./drivers/gpio/gpiolib-acpi.c:211:		dev_err(chip->parent, "Failed to request GPIO\n");
./drivers/gpio/gpiolib-acpi.c:219:		dev_err(chip->parent, "Failed to lock GPIO as interrupt\n");
./drivers/gpio/gpiolib-acpi.c:225:		dev_err(chip->parent, "Failed to translate GPIO to IRQ\n");
./drivers/gpio/gpiolib-acpi.c:262:		dev_err(chip->parent,
./drivers/gpio/gpiolib-acpi.c:297:	if (!chip->parent || !chip->to_irq)
./drivers/gpio/gpiolib-acpi.c:300:	handle = ACPI_HANDLE(chip->parent);
./drivers/gpio/gpiolib-acpi.c:327:	if (!chip->parent || !chip->to_irq)
./drivers/gpio/gpiolib-acpi.c:330:	handle = ACPI_HANDLE(chip->parent);
./drivers/gpio/gpiolib-acpi.c:641:	struct gpio_chip *chip = achip->chip;
./drivers/gpio/gpiolib-acpi.c:650:	status = acpi_buffer_to_resource(achip->conn_info.connection,
./drivers/gpio/gpiolib-acpi.c:651:					 achip->conn_info.length, &ares);
./drivers/gpio/gpiolib-acpi.c:676:		pin = acpi_gpiochip_pin_to_gpio_offset(chip->gpiodev, pin);
./drivers/gpio/gpiolib-acpi.c:682:		mutex_lock(&achip->conn_lock);
./drivers/gpio/gpiolib-acpi.c:685:		list_for_each_entry(conn, &achip->conns, node) {
./drivers/gpio/gpiolib-acpi.c:702:			list_for_each_entry(event, &achip->events, node) {
./drivers/gpio/gpiolib-acpi.c:716:				mutex_unlock(&achip->conn_lock);
./drivers/gpio/gpiolib-acpi.c:747:				mutex_unlock(&achip->conn_lock);
./drivers/gpio/gpiolib-acpi.c:753:			list_add_tail(&conn->node, &achip->conns);
./drivers/gpio/gpiolib-acpi.c:756:		mutex_unlock(&achip->conn_lock);
./drivers/gpio/gpiolib-acpi.c:772:	struct gpio_chip *chip = achip->chip;
./drivers/gpio/gpiolib-acpi.c:773:	acpi_handle handle = ACPI_HANDLE(chip->parent);
./drivers/gpio/gpiolib-acpi.c:776:	INIT_LIST_HEAD(&achip->conns);
./drivers/gpio/gpiolib-acpi.c:777:	mutex_init(&achip->conn_lock);
./drivers/gpio/gpiolib-acpi.c:782:		dev_err(chip->parent,
./drivers/gpio/gpiolib-acpi.c:788:	struct gpio_chip *chip = achip->chip;
./drivers/gpio/gpiolib-acpi.c:789:	acpi_handle handle = ACPI_HANDLE(chip->parent);
./drivers/gpio/gpiolib-acpi.c:796:		dev_err(chip->parent,
./drivers/gpio/gpiolib-acpi.c:801:	list_for_each_entry_safe_reverse(conn, tmp, &achip->conns, node) {
./drivers/gpio/gpiolib-acpi.c:814:	if (!chip || !chip->parent)
./drivers/gpio/gpiolib-acpi.c:817:	handle = ACPI_HANDLE(chip->parent);
./drivers/gpio/gpiolib-acpi.c:823:		dev_err(chip->parent,
./drivers/gpio/gpiolib-acpi.c:833:		dev_err(chip->parent, "Failed to attach ACPI GPIO chip\n");
./drivers/gpio/gpiolib-acpi.c:847:	if (!chip || !chip->parent)
./drivers/gpio/gpiolib-acpi.c:850:	handle = ACPI_HANDLE(chip->parent);
./drivers/gpio/gpiolib-acpi.c:856:		dev_warn(chip->parent, "Failed to retrieve ACPI GPIO chip\n");
./drivers/gpio/gpio-xgene.c:58:	return !!(ioread32(chip->base + bank_offset) & BIT(bit_offset));
./drivers/gpio/gpio-xgene.c:70:	setval = ioread32(chip->base + bank_offset);
./drivers/gpio/gpio-xgene.c:75:	iowrite32(setval, chip->base + bank_offset);
./drivers/gpio/gpio-xgene.c:83:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-xgene.c:85:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-xgene.c:96:	return !!(ioread32(chip->base + bank_offset) & BIT(bit_offset));
./drivers/gpio/gpio-xgene.c:108:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-xgene.c:110:	dirval = ioread32(chip->base + bank_offset);
./drivers/gpio/gpio-xgene.c:112:	iowrite32(dirval, chip->base + bank_offset);
./drivers/gpio/gpio-xgene.c:114:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-xgene.c:129:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-xgene.c:131:	dirval = ioread32(chip->base + bank_offset);
./drivers/gpio/gpio-xgene.c:133:	iowrite32(dirval, chip->base + bank_offset);
./drivers/gpio/gpio-xgene.c:136:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-pch.c:115:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:116:	reg_val = ioread32(&chip->reg->po);
./drivers/gpio/gpio-pch.c:122:	iowrite32(reg_val, &chip->reg->po);
./drivers/gpio/gpio-pch.c:123:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:130:	return (ioread32(&chip->reg->pi) >> nr) & 1;
./drivers/gpio/gpio-pch.c:141:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:143:	reg_val = ioread32(&chip->reg->po);
./drivers/gpio/gpio-pch.c:148:	iowrite32(reg_val, &chip->reg->po);
./drivers/gpio/gpio-pch.c:150:	pm = ioread32(&chip->reg->pm) & ((1 << gpio_pins[chip->ioh]) - 1);
./drivers/gpio/gpio-pch.c:152:	iowrite32(pm, &chip->reg->pm);
./drivers/gpio/gpio-pch.c:154:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:165:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:166:	pm = ioread32(&chip->reg->pm) & ((1 << gpio_pins[chip->ioh]) - 1);
./drivers/gpio/gpio-pch.c:168:	iowrite32(pm, &chip->reg->pm);
./drivers/gpio/gpio-pch.c:169:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:180:	chip->pch_gpio_reg.ien_reg = ioread32(&chip->reg->ien);
./drivers/gpio/gpio-pch.c:181:	chip->pch_gpio_reg.imask_reg = ioread32(&chip->reg->imask);
./drivers/gpio/gpio-pch.c:182:	chip->pch_gpio_reg.po_reg = ioread32(&chip->reg->po);
./drivers/gpio/gpio-pch.c:183:	chip->pch_gpio_reg.pm_reg = ioread32(&chip->reg->pm);
./drivers/gpio/gpio-pch.c:184:	chip->pch_gpio_reg.im0_reg = ioread32(&chip->reg->im0);
./drivers/gpio/gpio-pch.c:185:	if (chip->ioh == INTEL_EG20T_PCH)
./drivers/gpio/gpio-pch.c:186:		chip->pch_gpio_reg.im1_reg = ioread32(&chip->reg->im1);
./drivers/gpio/gpio-pch.c:187:	if (chip->ioh == OKISEMI_ML7223n_IOH)
./drivers/gpio/gpio-pch.c:188:		chip->pch_gpio_reg.gpio_use_sel_reg =\
./drivers/gpio/gpio-pch.c:189:					    ioread32(&chip->reg->gpio_use_sel);
./drivers/gpio/gpio-pch.c:197:	iowrite32(chip->pch_gpio_reg.ien_reg, &chip->reg->ien);
./drivers/gpio/gpio-pch.c:198:	iowrite32(chip->pch_gpio_reg.imask_reg, &chip->reg->imask);
./drivers/gpio/gpio-pch.c:200:	iowrite32(chip->pch_gpio_reg.po_reg, &chip->reg->po);
./drivers/gpio/gpio-pch.c:202:	iowrite32(chip->pch_gpio_reg.pm_reg, &chip->reg->pm);
./drivers/gpio/gpio-pch.c:203:	iowrite32(chip->pch_gpio_reg.im0_reg, &chip->reg->im0);
./drivers/gpio/gpio-pch.c:204:	if (chip->ioh == INTEL_EG20T_PCH)
./drivers/gpio/gpio-pch.c:205:		iowrite32(chip->pch_gpio_reg.im1_reg, &chip->reg->im1);
./drivers/gpio/gpio-pch.c:206:	if (chip->ioh == OKISEMI_ML7223n_IOH)
./drivers/gpio/gpio-pch.c:207:		iowrite32(chip->pch_gpio_reg.gpio_use_sel_reg,
./drivers/gpio/gpio-pch.c:208:			  &chip->reg->gpio_use_sel);
./drivers/gpio/gpio-pch.c:215:	return chip->irq_base + offset;
./drivers/gpio/gpio-pch.c:220:	struct gpio_chip *gpio = &chip->gpio;
./drivers/gpio/gpio-pch.c:222:	gpio->label = dev_name(chip->dev);
./drivers/gpio/gpio-pch.c:223:	gpio->parent = chip->dev;
./drivers/gpio/gpio-pch.c:231:	gpio->ngpio = gpio_pins[chip->ioh];
./drivers/gpio/gpio-pch.c:245:	ch = irq - chip->irq_base;
./drivers/gpio/gpio-pch.c:246:	if (irq <= chip->irq_base + 7) {
./drivers/gpio/gpio-pch.c:247:		im_reg = &chip->reg->im0;
./drivers/gpio/gpio-pch.c:250:		im_reg = &chip->reg->im1;
./drivers/gpio/gpio-pch.c:253:	dev_dbg(chip->dev, "%s:irq=%d type=%d ch=%d pos=%d\n",
./drivers/gpio/gpio-pch.c:256:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:289:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:298:	iowrite32(1 << (d->irq - chip->irq_base), &chip->reg->imaskclr);
./drivers/gpio/gpio-pch.c:306:	iowrite32(1 << (d->irq - chip->irq_base), &chip->reg->imask);
./drivers/gpio/gpio-pch.c:314:	iowrite32(1 << (d->irq - chip->irq_base), &chip->reg->iclr);
./drivers/gpio/gpio-pch.c:320:	u32 reg_val = ioread32(&chip->reg->istatus);
./drivers/gpio/gpio-pch.c:323:	for (i = 0; i < gpio_pins[chip->ioh]; i++) {
./drivers/gpio/gpio-pch.c:325:			dev_dbg(chip->dev, "%s:[%d]:irq=%d  status=0x%x\n",
./drivers/gpio/gpio-pch.c:327:			generic_handle_irq(chip->irq_base + i);
./drivers/gpio/gpio-pch.c:340:	gc = irq_alloc_generic_chip("pch_gpio", 1, irq_start, chip->base,
./drivers/gpio/gpio-pch.c:366:	chip->dev = &pdev->dev;
./drivers/gpio/gpio-pch.c:379:	chip->base = pci_iomap(pdev, 1, 0);
./drivers/gpio/gpio-pch.c:380:	if (!chip->base) {
./drivers/gpio/gpio-pch.c:387:		chip->ioh = INTEL_EG20T_PCH;
./drivers/gpio/gpio-pch.c:389:		chip->ioh = OKISEMI_ML7223m_IOH;
./drivers/gpio/gpio-pch.c:391:		chip->ioh = OKISEMI_ML7223n_IOH;
./drivers/gpio/gpio-pch.c:393:	chip->reg = chip->base;
./drivers/gpio/gpio-pch.c:395:	spin_lock_init(&chip->spinlock);
./drivers/gpio/gpio-pch.c:398:	chip->gpio.of_node = pdev->dev.of_node;
./drivers/gpio/gpio-pch.c:400:	ret = gpiochip_add_data(&chip->gpio, chip);
./drivers/gpio/gpio-pch.c:406:	irq_base = irq_alloc_descs(-1, 0, gpio_pins[chip->ioh], NUMA_NO_NODE);
./drivers/gpio/gpio-pch.c:409:		chip->irq_base = -1;
./drivers/gpio/gpio-pch.c:412:	chip->irq_base = irq_base;
./drivers/gpio/gpio-pch.c:415:	msk = (1 << gpio_pins[chip->ioh]) - 1;
./drivers/gpio/gpio-pch.c:416:	iowrite32(msk, &chip->reg->imask);
./drivers/gpio/gpio-pch.c:417:	iowrite32(msk, &chip->reg->ien);
./drivers/gpio/gpio-pch.c:427:	pch_gpio_alloc_generic_chip(chip, irq_base, gpio_pins[chip->ioh]);
./drivers/gpio/gpio-pch.c:433:	irq_free_descs(irq_base, gpio_pins[chip->ioh]);
./drivers/gpio/gpio-pch.c:434:	gpiochip_remove(&chip->gpio);
./drivers/gpio/gpio-pch.c:437:	pci_iounmap(pdev, chip->base);
./drivers/gpio/gpio-pch.c:455:	if (chip->irq_base != -1) {
./drivers/gpio/gpio-pch.c:458:		irq_free_descs(chip->irq_base, gpio_pins[chip->ioh]);
./drivers/gpio/gpio-pch.c:461:	gpiochip_remove(&chip->gpio);
./drivers/gpio/gpio-pch.c:462:	pci_iounmap(pdev, chip->base);
./drivers/gpio/gpio-pch.c:475:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:477:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:509:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/gpio/gpio-pch.c:510:	iowrite32(0x01, &chip->reg->reset);
./drivers/gpio/gpio-pch.c:511:	iowrite32(0x00, &chip->reg->reset);
./drivers/gpio/gpio-pch.c:513:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/gpio/gpio-zx.c:59:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-zx.c:60:	gpiodir = readw_relaxed(chip->base + ZX_GPIO_DIR);
./drivers/gpio/gpio-zx.c:62:	writew_relaxed(gpiodir, chip->base + ZX_GPIO_DIR);
./drivers/gpio/gpio-zx.c:63:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-zx.c:78:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-zx.c:79:	gpiodir = readw_relaxed(chip->base + ZX_GPIO_DIR);
./drivers/gpio/gpio-zx.c:81:	writew_relaxed(gpiodir, chip->base + ZX_GPIO_DIR);
./drivers/gpio/gpio-zx.c:84:		writew_relaxed(BIT(offset), chip->base + ZX_GPIO_DO1);
./drivers/gpio/gpio-zx.c:86:		writew_relaxed(BIT(offset), chip->base + ZX_GPIO_DO0);
./drivers/gpio/gpio-zx.c:87:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-zx.c:96:	return !!(readw_relaxed(chip->base + ZX_GPIO_DI) & BIT(offset));
./drivers/gpio/gpio-zx.c:104:		writew_relaxed(BIT(offset), chip->base + ZX_GPIO_DO1);
./drivers/gpio/gpio-zx.c:106:		writew_relaxed(BIT(offset), chip->base + ZX_GPIO_DO0);
./drivers/gpio/gpio-zx.c:121:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-zx.c:123:	gpioiev = readw_relaxed(chip->base + ZX_GPIO_IV);
./drivers/gpio/gpio-zx.c:124:	gpiois = readw_relaxed(chip->base + ZX_GPIO_IVE);
./drivers/gpio/gpio-zx.c:125:	gpioi_epos = readw_relaxed(chip->base + ZX_GPIO_IEP);
./drivers/gpio/gpio-zx.c:126:	gpioi_eneg = readw_relaxed(chip->base + ZX_GPIO_IEN);
./drivers/gpio/gpio-zx.c:150:	writew_relaxed(gpiois, chip->base + ZX_GPIO_IVE);
./drivers/gpio/gpio-zx.c:151:	writew_relaxed(gpioi_epos, chip->base + ZX_GPIO_IEP);
./drivers/gpio/gpio-zx.c:152:	writew_relaxed(gpioi_eneg, chip->base + ZX_GPIO_IEN);
./drivers/gpio/gpio-zx.c:153:	writew_relaxed(gpioiev, chip->base + ZX_GPIO_IV);
./drivers/gpio/gpio-zx.c:154:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-zx.c:169:	pending = readw_relaxed(chip->base + ZX_GPIO_MIS);
./drivers/gpio/gpio-zx.c:170:	writew_relaxed(pending, chip->base + ZX_GPIO_IC);
./drivers/gpio/gpio-zx.c:187:	spin_lock(&chip->lock);
./drivers/gpio/gpio-zx.c:188:	gpioie = readw_relaxed(chip->base + ZX_GPIO_IM) | mask;
./drivers/gpio/gpio-zx.c:189:	writew_relaxed(gpioie, chip->base + ZX_GPIO_IM);
./drivers/gpio/gpio-zx.c:190:	gpioie = readw_relaxed(chip->base + ZX_GPIO_IE) & ~mask;
./drivers/gpio/gpio-zx.c:191:	writew_relaxed(gpioie, chip->base + ZX_GPIO_IE);
./drivers/gpio/gpio-zx.c:192:	spin_unlock(&chip->lock);
./drivers/gpio/gpio-zx.c:202:	spin_lock(&chip->lock);
./drivers/gpio/gpio-zx.c:203:	gpioie = readw_relaxed(chip->base + ZX_GPIO_IM) & ~mask;
./drivers/gpio/gpio-zx.c:204:	writew_relaxed(gpioie, chip->base + ZX_GPIO_IM);
./drivers/gpio/gpio-zx.c:205:	gpioie = readw_relaxed(chip->base + ZX_GPIO_IE) | mask;
./drivers/gpio/gpio-zx.c:206:	writew_relaxed(gpioie, chip->base + ZX_GPIO_IE);
./drivers/gpio/gpio-zx.c:207:	spin_unlock(&chip->lock);
./drivers/gpio/gpio-zx.c:229:	chip->base = devm_ioremap_resource(dev, res);
./drivers/gpio/gpio-zx.c:230:	if (IS_ERR(chip->base))
./drivers/gpio/gpio-zx.c:231:		return PTR_ERR(chip->base);
./drivers/gpio/gpio-zx.c:233:	spin_lock_init(&chip->lock);
./drivers/gpio/gpio-zx.c:235:		chip->gc.request = gpiochip_generic_request;
./drivers/gpio/gpio-zx.c:236:		chip->gc.free = gpiochip_generic_free;
./drivers/gpio/gpio-zx.c:240:	chip->gc.direction_input = zx_direction_input;
./drivers/gpio/gpio-zx.c:241:	chip->gc.direction_output = zx_direction_output;
./drivers/gpio/gpio-zx.c:242:	chip->gc.get = zx_get_value;
./drivers/gpio/gpio-zx.c:243:	chip->gc.set = zx_set_value;
./drivers/gpio/gpio-zx.c:244:	chip->gc.base = ZX_GPIO_NR * id;
./drivers/gpio/gpio-zx.c:245:	chip->gc.ngpio = ZX_GPIO_NR;
./drivers/gpio/gpio-zx.c:246:	chip->gc.label = dev_name(dev);
./drivers/gpio/gpio-zx.c:247:	chip->gc.parent = dev;
./drivers/gpio/gpio-zx.c:248:	chip->gc.owner = THIS_MODULE;
./drivers/gpio/gpio-zx.c:250:	ret = gpiochip_add_data(&chip->gc, chip);
./drivers/gpio/gpio-zx.c:257:	writew_relaxed(0xffff, chip->base + ZX_GPIO_IM);
./drivers/gpio/gpio-zx.c:258:	writew_relaxed(0, chip->base + ZX_GPIO_IE);
./drivers/gpio/gpio-zx.c:262:		gpiochip_remove(&chip->gc);
./drivers/gpio/gpio-zx.c:266:	ret = gpiochip_irqchip_add(&chip->gc, &zx_irqchip,
./drivers/gpio/gpio-zx.c:271:		gpiochip_remove(&chip->gc);
./drivers/gpio/gpio-zx.c:274:	gpiochip_set_chained_irqchip(&chip->gc, &zx_irqchip,
./drivers/gpio/gpio-twl6040.c:39:	struct twl6040 *twl6040 = dev_get_drvdata(chip->parent->parent);
./drivers/gpio/gpio-twl6040.c:58:	struct twl6040 *twl6040 = dev_get_drvdata(chip->parent->parent);
./drivers/gpio/gpio-sx150x.c:276:	return (chip->dev_cfg->ngpios == offset);
./drivers/gpio/gpio-sx150x.c:316:	err = sx150x_i2c_read(chip->client, reg, &data);
./drivers/gpio/gpio-sx150x.c:322:	return sx150x_i2c_write(chip->client, reg, data);
./drivers/gpio/gpio-sx150x.c:327:	u8  reg = chip->dev_cfg->reg_data;
./drivers/gpio/gpio-sx150x.c:334:	err = sx150x_i2c_read(chip->client, reg, &data);
./drivers/gpio/gpio-sx150x.c:343:	sx150x_i2c_write(chip->client,
./drivers/gpio/gpio-sx150x.c:344:			chip->dev_cfg->pri.x789.reg_clock,
./drivers/gpio/gpio-sx150x.c:353:			chip->dev_cfg->reg_data,
./drivers/gpio/gpio-sx150x.c:362:				chip->dev_cfg->reg_dir,
./drivers/gpio/gpio-sx150x.c:373:			chip->dev_cfg->reg_data,
./drivers/gpio/gpio-sx150x.c:379:				chip->dev_cfg->reg_dir,
./drivers/gpio/gpio-sx150x.c:390:		mutex_lock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:392:		mutex_unlock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:402:	mutex_lock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:407:	mutex_unlock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:417:	if (chip->dev_cfg->model != SX150X_789)
./drivers/gpio/gpio-sx150x.c:424:					chip->dev_cfg->pri.x789.reg_drain,
./drivers/gpio/gpio-sx150x.c:431:					chip->dev_cfg->pri.x789.reg_drain,
./drivers/gpio/gpio-sx150x.c:442:		mutex_lock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:444:		mutex_unlock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:457:		mutex_lock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:459:		mutex_unlock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:469:	chip->irq_masked |= (1 << n);
./drivers/gpio/gpio-sx150x.c:470:	chip->irq_update = n;
./drivers/gpio/gpio-sx150x.c:478:	chip->irq_masked &= ~(1 << n);
./drivers/gpio/gpio-sx150x.c:479:	chip->irq_update = n;
./drivers/gpio/gpio-sx150x.c:497:	chip->irq_sense &= ~(3UL << (n * 2));
./drivers/gpio/gpio-sx150x.c:498:	chip->irq_sense |= val << (n * 2);
./drivers/gpio/gpio-sx150x.c:499:	chip->irq_update = n;
./drivers/gpio/gpio-sx150x.c:513:	for (i = (chip->dev_cfg->ngpios / 8) - 1; i >= 0; --i) {
./drivers/gpio/gpio-sx150x.c:514:		err = sx150x_i2c_read(chip->client,
./drivers/gpio/gpio-sx150x.c:515:				      chip->dev_cfg->reg_irq_src - i,
./drivers/gpio/gpio-sx150x.c:520:		sx150x_i2c_write(chip->client,
./drivers/gpio/gpio-sx150x.c:521:				chip->dev_cfg->reg_irq_src - i,
./drivers/gpio/gpio-sx150x.c:526:					chip->gpio_chip.irqdomain,
./drivers/gpio/gpio-sx150x.c:541:	mutex_lock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:549:	if (chip->irq_update == NO_UPDATE_PENDING)
./drivers/gpio/gpio-sx150x.c:552:	n = chip->irq_update;
./drivers/gpio/gpio-sx150x.c:553:	chip->irq_update = NO_UPDATE_PENDING;
./drivers/gpio/gpio-sx150x.c:556:	if (chip->dev_sense == chip->irq_sense &&
./drivers/gpio/gpio-sx150x.c:557:	    chip->dev_masked == chip->irq_masked)
./drivers/gpio/gpio-sx150x.c:560:	chip->dev_sense = chip->irq_sense;
./drivers/gpio/gpio-sx150x.c:561:	chip->dev_masked = chip->irq_masked;
./drivers/gpio/gpio-sx150x.c:563:	if (chip->irq_masked & (1 << n)) {
./drivers/gpio/gpio-sx150x.c:564:		sx150x_write_cfg(chip, n, 1, chip->dev_cfg->reg_irq_mask, 1);
./drivers/gpio/gpio-sx150x.c:565:		sx150x_write_cfg(chip, n, 2, chip->dev_cfg->reg_sense, 0);
./drivers/gpio/gpio-sx150x.c:567:		sx150x_write_cfg(chip, n, 1, chip->dev_cfg->reg_irq_mask, 0);
./drivers/gpio/gpio-sx150x.c:568:		sx150x_write_cfg(chip, n, 2, chip->dev_cfg->reg_sense,
./drivers/gpio/gpio-sx150x.c:569:				 chip->irq_sense >> (n * 2));
./drivers/gpio/gpio-sx150x.c:572:	mutex_unlock(&chip->lock);
./drivers/gpio/gpio-sx150x.c:580:	mutex_init(&chip->lock);
./drivers/gpio/gpio-sx150x.c:582:	chip->client                     = client;
./drivers/gpio/gpio-sx150x.c:583:	chip->dev_cfg                    = &sx150x_devices[driver_data];
./drivers/gpio/gpio-sx150x.c:584:	chip->gpio_chip.parent              = &client->dev;
./drivers/gpio/gpio-sx150x.c:585:	chip->gpio_chip.label            = client->name;
./drivers/gpio/gpio-sx150x.c:586:	chip->gpio_chip.direction_input  = sx150x_gpio_direction_input;
./drivers/gpio/gpio-sx150x.c:587:	chip->gpio_chip.direction_output = sx150x_gpio_direction_output;
./drivers/gpio/gpio-sx150x.c:588:	chip->gpio_chip.get              = sx150x_gpio_get;
./drivers/gpio/gpio-sx150x.c:589:	chip->gpio_chip.set              = sx150x_gpio_set;
./drivers/gpio/gpio-sx150x.c:590:	chip->gpio_chip.set_single_ended = sx150x_gpio_set_single_ended;
./drivers/gpio/gpio-sx150x.c:591:	chip->gpio_chip.base             = pdata->gpio_base;
./drivers/gpio/gpio-sx150x.c:592:	chip->gpio_chip.can_sleep        = true;
./drivers/gpio/gpio-sx150x.c:593:	chip->gpio_chip.ngpio            = chip->dev_cfg->ngpios;
./drivers/gpio/gpio-sx150x.c:595:	chip->gpio_chip.of_node          = client->dev.of_node;
./drivers/gpio/gpio-sx150x.c:596:	chip->gpio_chip.of_gpio_n_cells  = 2;
./drivers/gpio/gpio-sx150x.c:599:		++chip->gpio_chip.ngpio;
./drivers/gpio/gpio-sx150x.c:601:	chip->irq_chip.name                = client->name;
./drivers/gpio/gpio-sx150x.c:602:	chip->irq_chip.irq_mask            = sx150x_irq_mask;
./drivers/gpio/gpio-sx150x.c:603:	chip->irq_chip.irq_unmask          = sx150x_irq_unmask;
./drivers/gpio/gpio-sx150x.c:604:	chip->irq_chip.irq_set_type        = sx150x_irq_set_type;
./drivers/gpio/gpio-sx150x.c:605:	chip->irq_chip.irq_bus_lock        = sx150x_irq_bus_lock;
./drivers/gpio/gpio-sx150x.c:606:	chip->irq_chip.irq_bus_sync_unlock = sx150x_irq_bus_sync_unlock;
./drivers/gpio/gpio-sx150x.c:607:	chip->irq_summary                  = -1;
./drivers/gpio/gpio-sx150x.c:608:	chip->irq_base                     = -1;
./drivers/gpio/gpio-sx150x.c:609:	chip->irq_masked                   = ~0;
./drivers/gpio/gpio-sx150x.c:610:	chip->irq_sense                    = 0;
./drivers/gpio/gpio-sx150x.c:611:	chip->dev_masked                   = ~0;
./drivers/gpio/gpio-sx150x.c:612:	chip->dev_sense                    = 0;
./drivers/gpio/gpio-sx150x.c:613:	chip->irq_update		   = NO_UPDATE_PENDING;
./drivers/gpio/gpio-sx150x.c:621:	for (n = 0; err >= 0 && n < (chip->dev_cfg->ngpios / 8); ++n)
./drivers/gpio/gpio-sx150x.c:622:		err = sx150x_i2c_write(chip->client, base - n, cfg >> (n * 8));
./drivers/gpio/gpio-sx150x.c:630:	err = i2c_smbus_write_byte_data(chip->client,
./drivers/gpio/gpio-sx150x.c:631:					chip->dev_cfg->pri.x789.reg_reset,
./drivers/gpio/gpio-sx150x.c:636:	err = i2c_smbus_write_byte_data(chip->client,
./drivers/gpio/gpio-sx150x.c:637:					chip->dev_cfg->pri.x789.reg_reset,
./drivers/gpio/gpio-sx150x.c:653:	if (chip->dev_cfg->model == SX150X_789)
./drivers/gpio/gpio-sx150x.c:654:		err = sx150x_i2c_write(chip->client,
./drivers/gpio/gpio-sx150x.c:655:				chip->dev_cfg->pri.x789.reg_misc,
./drivers/gpio/gpio-sx150x.c:657:	else if (chip->dev_cfg->model == SX150X_456)
./drivers/gpio/gpio-sx150x.c:658:		err = sx150x_i2c_write(chip->client,
./drivers/gpio/gpio-sx150x.c:659:				chip->dev_cfg->pri.x456.reg_advance,
./drivers/gpio/gpio-sx150x.c:662:		err = sx150x_i2c_write(chip->client,
./drivers/gpio/gpio-sx150x.c:663:				chip->dev_cfg->pri.x123.reg_advance,
./drivers/gpio/gpio-sx150x.c:668:	err = sx150x_init_io(chip, chip->dev_cfg->reg_pullup,
./drivers/gpio/gpio-sx150x.c:673:	err = sx150x_init_io(chip, chip->dev_cfg->reg_pulldn,
./drivers/gpio/gpio-sx150x.c:678:	if (chip->dev_cfg->model == SX150X_789) {
./drivers/gpio/gpio-sx150x.c:680:				chip->dev_cfg->pri.x789.reg_polarity,
./drivers/gpio/gpio-sx150x.c:684:	} else if (chip->dev_cfg->model == SX150X_456) {
./drivers/gpio/gpio-sx150x.c:687:				chip->dev_cfg->pri.x456.reg_pld_mode,
./drivers/gpio/gpio-sx150x.c:694:				chip->dev_cfg->pri.x123.reg_pld_mode,
./drivers/gpio/gpio-sx150x.c:713:	chip->irq_summary = irq_summary;
./drivers/gpio/gpio-sx150x.c:714:	chip->irq_base    = irq_base;
./drivers/gpio/gpio-sx150x.c:717:	err = gpiochip_irqchip_add(&chip->gpio_chip,
./drivers/gpio/gpio-sx150x.c:718:		&chip->irq_chip, chip->irq_base,
./drivers/gpio/gpio-sx150x.c:721:		dev_err(&chip->client->dev,
./drivers/gpio/gpio-sx150x.c:726:	err = devm_request_threaded_irq(&chip->client->dev,
./drivers/gpio/gpio-sx150x.c:729:			chip->irq_chip.name, chip);
./drivers/gpio/gpio-sx150x.c:731:		chip->irq_summary = -1;
./drivers/gpio/gpio-sx150x.c:732:		chip->irq_base    = -1;
./drivers/gpio/gpio-sx150x.c:764:	rc = devm_gpiochip_add_data(&client->dev, &chip->gpio_chip, chip);
./drivers/gpio/gpio-mxs.c:163:	desc->irq_data.chip->irq_ack(&desc->irq_data);
./drivers/gpio/gpio-mmio.c:501:	if (gpio_pin < chip->ngpio)
./drivers/gpio/gpio-ep93xx.c:297:	int gpio = chip->base + offset;
./drivers/gpio/gpio-ep93xx.c:315:	int gpio = chip->base + offset;
./drivers/gpio/gpio-ts4800.c:57:	chip->ngpio = ngpios;
./drivers/gpio/gpio-davinci.c:551:		irq_chip->name = "GPIO-AINTC";
./drivers/gpio/gpio-davinci.c:552:		irq_chip->irq_set_type = gpio_irq_type_unbanked;
./drivers/gpio/gpio-rcar.c:245:	return pinctrl_request_gpio(chip->base + offset);
./drivers/gpio/gpio-rcar.c:250:	pinctrl_free_gpio(chip->base + offset);
./drivers/gpio/gpio-rcar.c:294:	bankmask = mask[0] & GENMASK(chip->ngpio - 1, 0);
./drivers/gpio/gpio-rcar.c:441:	gpio_chip->request = gpio_rcar_request;
./drivers/gpio/gpio-rcar.c:442:	gpio_chip->free = gpio_rcar_free;
./drivers/gpio/gpio-rcar.c:443:	gpio_chip->direction_input = gpio_rcar_direction_input;
./drivers/gpio/gpio-rcar.c:444:	gpio_chip->get = gpio_rcar_get;
./drivers/gpio/gpio-rcar.c:445:	gpio_chip->direction_output = gpio_rcar_direction_output;
./drivers/gpio/gpio-rcar.c:446:	gpio_chip->set = gpio_rcar_set;
./drivers/gpio/gpio-rcar.c:447:	gpio_chip->set_multiple = gpio_rcar_set_multiple;
./drivers/gpio/gpio-rcar.c:448:	gpio_chip->label = name;
./drivers/gpio/gpio-rcar.c:449:	gpio_chip->parent = dev;
./drivers/gpio/gpio-rcar.c:450:	gpio_chip->owner = THIS_MODULE;
./drivers/gpio/gpio-rcar.c:451:	gpio_chip->base = -1;
./drivers/gpio/gpio-rcar.c:452:	gpio_chip->ngpio = npins;
./drivers/gpio/gpio-rcar.c:455:	irq_chip->name = name;
./drivers/gpio/gpio-rcar.c:456:	irq_chip->irq_mask = gpio_rcar_irq_disable;
./drivers/gpio/gpio-rcar.c:457:	irq_chip->irq_unmask = gpio_rcar_irq_enable;
./drivers/gpio/gpio-rcar.c:458:	irq_chip->irq_set_type = gpio_rcar_irq_set_type;
./drivers/gpio/gpio-rcar.c:459:	irq_chip->irq_set_wake = gpio_rcar_irq_set_wake;
./drivers/gpio/gpio-rcar.c:460:	irq_chip->flags	= IRQCHIP_SET_TYPE_MASKED | IRQCHIP_MASK_ON_SUSPEND;
./drivers/gpio/gpio-vr41xx.c:338:	if (pin >= chip->ngpio)
./drivers/gpio/gpio-vr41xx.c:423:	if (pin >= chip->ngpio)
./drivers/gpio/gpio-vr41xx.c:452:	if (pin >= chip->ngpio)
./drivers/gpio/gpio-vr41xx.c:497:	if (offset >= chip->ngpio)
./drivers/gpio/gpio-pxa.c:209:	base = gpio_bank_base(&pchip->chip, gpio);
./drivers/gpio/gpio-pxa.c:237:	irq_gpio0 = irq_find_mapping(pchip->irqdomain, 0);
./drivers/gpio/gpio-pxa.c:248:	return irq_find_mapping(pchip->irqdomain, offset);
./drivers/gpio/gpio-pxa.c:258:	ret = pinctrl_gpio_direction_input(chip->base + offset);
./drivers/gpio/gpio-pxa.c:265:	if (__gpio_is_inverted(chip->base + offset))
./drivers/gpio/gpio-pxa.c:285:	ret = pinctrl_gpio_direction_output(chip->base + offset);
./drivers/gpio/gpio-pxa.c:292:	if (__gpio_is_inverted(chip->base + offset))
./drivers/gpio/gpio-pxa.c:335:	return pinctrl_request_gpio(chip->base + offset);
./drivers/gpio/gpio-pxa.c:340:	pinctrl_free_gpio(chip->base + offset);
./drivers/gpio/gpio-pxa.c:349:	pchip->banks = devm_kcalloc(pchip->dev, nbanks, sizeof(*pchip->banks),
./drivers/gpio/gpio-pxa.c:351:	if (!pchip->banks)
./drivers/gpio/gpio-pxa.c:354:	pchip->chip.label = "gpio-pxa";
./drivers/gpio/gpio-pxa.c:355:	pchip->chip.direction_input  = pxa_gpio_direction_input;
./drivers/gpio/gpio-pxa.c:356:	pchip->chip.direction_output = pxa_gpio_direction_output;
./drivers/gpio/gpio-pxa.c:357:	pchip->chip.get = pxa_gpio_get;
./drivers/gpio/gpio-pxa.c:358:	pchip->chip.set = pxa_gpio_set;
./drivers/gpio/gpio-pxa.c:359:	pchip->chip.to_irq = pxa_gpio_to_irq;
./drivers/gpio/gpio-pxa.c:360:	pchip->chip.ngpio = ngpio;
./drivers/gpio/gpio-pxa.c:361:	pchip->chip.request = pxa_gpio_request;
./drivers/gpio/gpio-pxa.c:362:	pchip->chip.free = pxa_gpio_free;
./drivers/gpio/gpio-pxa.c:364:	pchip->chip.of_node = np;
./drivers/gpio/gpio-pxa.c:365:	pchip->chip.of_xlate = pxa_gpio_of_xlate;
./drivers/gpio/gpio-pxa.c:366:	pchip->chip.of_gpio_n_cells = 2;
./drivers/gpio/gpio-pxa.c:370:		bank = pchip->banks + i;
./drivers/gpio/gpio-pxa.c:374:	return gpiochip_add_data(&pchip->chip, pchip);
./drivers/gpio/gpio-pxa.c:396:	struct pxa_gpio_bank *c = gpio_to_pxabank(&pchip->chip, gpio);
./drivers/gpio/gpio-pxa.c:467:	if (in_irq == pchip->irq0) {
./drivers/gpio/gpio-pxa.c:469:	} else if (in_irq == pchip->irq1) {
./drivers/gpio/gpio-pxa.c:482:	void __iomem *base = gpio_bank_base(&pchip->chip, gpio);
./drivers/gpio/gpio-pxa.c:491:	struct pxa_gpio_bank *b = gpio_to_pxabank(&pchip->chip, gpio);
./drivers/gpio/gpio-pxa.c:492:	void __iomem *base = gpio_bank_base(&pchip->chip, gpio);
./drivers/gpio/gpio-pxa.c:508:	if (pchip->set_wake)
./drivers/gpio/gpio-pxa.c:509:		return pchip->set_wake(gpio, on);
./drivers/gpio/gpio-pxa.c:518:	struct pxa_gpio_bank *c = gpio_to_pxabank(&pchip->chip, gpio);
./drivers/gpio/gpio-pxa.c:629:	pchip->dev = &pdev->dev;
./drivers/gpio/gpio-pxa.c:637:		pchip->set_wake = info->gpio_set_wake;
./drivers/gpio/gpio-pxa.c:647:	pchip->irqdomain = irq_domain_add_legacy(pdev->dev.of_node,
./drivers/gpio/gpio-pxa.c:650:	if (!pchip->irqdomain)
./drivers/gpio/gpio-pxa.c:660:	pchip->irq0 = irq0;
./drivers/gpio/gpio-pxa.c:661:	pchip->irq1 = irq1;
./drivers/gpio/gpio-altera.c:145:	spin_lock_irqsave(&chip->gpio_lock, flags);
./drivers/gpio/gpio-altera.c:152:	spin_unlock_irqrestore(&chip->gpio_lock, flags);
./drivers/gpio/gpio-altera.c:165:	spin_lock_irqsave(&chip->gpio_lock, flags);
./drivers/gpio/gpio-altera.c:170:	spin_unlock_irqrestore(&chip->gpio_lock, flags);
./drivers/gpio/gpio-altera.c:186:	spin_lock_irqsave(&chip->gpio_lock, flags);
./drivers/gpio/gpio-altera.c:199:	spin_unlock_irqrestore(&chip->gpio_lock, flags);
./drivers/gpio/gpio-bcm-kona.c:274:		dev_err(chip->parent, "Debounce value %u not in range\n",
./drivers/gpio/gpio-bcm-kona.c:599:	chip->of_node = dev->of_node;
./drivers/gpio/gpio-bcm-kona.c:600:	chip->ngpio = kona_gpio->num_bank * GPIO_PER_BANK;
./drivers/gpio/gpio-bcm-kona.c:603:						      chip->ngpio,
./drivers/gpio/gpio-sta2x11.c:63:	return chip->regs[nr / GSTA_GPIO_PER_BLOCK];
./drivers/gpio/gpio-sta2x11.c:125:	return chip->irq_base + offset;
./drivers/gpio/gpio-sta2x11.c:130:	struct gpio_chip *gpio = &chip->gpio;
./drivers/gpio/gpio-sta2x11.c:140:	gpio->label = dev_name(chip->dev);
./drivers/gpio/gpio-sta2x11.c:180:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-sta2x11.c:188:		spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-sta2x11.c:222:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-sta2x11.c:236:	int nr = data->irq - chip->irq_base;
./drivers/gpio/gpio-sta2x11.c:242:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-sta2x11.c:243:	if (chip->irq_type[nr] & IRQ_TYPE_EDGE_RISING) {
./drivers/gpio/gpio-sta2x11.c:247:	if (chip->irq_type[nr] & IRQ_TYPE_EDGE_FALLING) {
./drivers/gpio/gpio-sta2x11.c:251:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-sta2x11.c:259:	int nr = data->irq - chip->irq_base;
./drivers/gpio/gpio-sta2x11.c:266:	type = chip->irq_type[nr];
./drivers/gpio/gpio-sta2x11.c:268:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-sta2x11.c:279:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-sta2x11.c:287:	int nr = d->irq - chip->irq_base;
./drivers/gpio/gpio-sta2x11.c:295:	chip->irq_type[nr] = type; /* used for enable/disable */
./drivers/gpio/gpio-sta2x11.c:310:		regs = chip->regs[i];
./drivers/gpio/gpio-sta2x11.c:311:		base = chip->irq_base + i * GSTA_GPIO_PER_BLOCK;
./drivers/gpio/gpio-sta2x11.c:328:	gc = irq_alloc_generic_chip(KBUILD_MODNAME, 1, chip->irq_base,
./drivers/gpio/gpio-sta2x11.c:329:				     chip->reg_base, handle_simple_irq);
./drivers/gpio/gpio-sta2x11.c:346:			i = chip->irq_base + j;
./drivers/gpio/gpio-sta2x11.c:376:	chip->dev = &dev->dev;
./drivers/gpio/gpio-sta2x11.c:377:	chip->reg_base = devm_ioremap_resource(&dev->dev, res);
./drivers/gpio/gpio-sta2x11.c:378:	if (IS_ERR(chip->reg_base))
./drivers/gpio/gpio-sta2x11.c:379:		return PTR_ERR(chip->reg_base);
./drivers/gpio/gpio-sta2x11.c:382:		chip->regs[i] = chip->reg_base + i * 4096;
./drivers/gpio/gpio-sta2x11.c:384:		writel(0, &chip->regs[i]->rimsc);
./drivers/gpio/gpio-sta2x11.c:385:		writel(0, &chip->regs[i]->fimsc);
./drivers/gpio/gpio-sta2x11.c:386:		writel(~0, &chip->regs[i]->ic);
./drivers/gpio/gpio-sta2x11.c:388:	spin_lock_init(&chip->lock);
./drivers/gpio/gpio-sta2x11.c:401:	chip->irq_base = err;
./drivers/gpio/gpio-sta2x11.c:412:	err = devm_gpiochip_add_data(&dev->dev, &chip->gpio, chip);
./drivers/gpio/gpio-sta2x11.c:425:	irq_free_descs(chip->irq_base, GSTA_NR_GPIO);
./drivers/gpio/gpio-adp5588.c:164:  * genirq core code can issue chip->mask/unmask from atomic context.
./drivers/gpio/gpio-tz1090.c:52: * @label:	Debug GPIO bank label, used for storage of chip->label
./drivers/gpio/gpio-tz1090.c:235:	ret = pinctrl_request_gpio(chip->base + offset);
./drivers/gpio/gpio-tz1090.c:249:	pinctrl_free_gpio(chip->base + offset);
./drivers/gpio/gpio-syscon.c:157:		dev_err(chip->parent, "gpio write failed ret(%d)\n", ret);
./drivers/gpio/gpio-omap.c:632:		pm_runtime_get_sync(chip->parent);
./drivers/gpio/gpio-omap.c:661:		pm_runtime_put(chip->parent);
./drivers/gpio/gpio-zynq.c:590:	ret = pm_runtime_get_sync(chip->parent);
./drivers/gpio/gpio-zynq.c:601:	pm_runtime_put(chip->parent);
./drivers/gpio/gpio-zynq.c:694:	chip->label = gpio->p_data->label;
./drivers/gpio/gpio-zynq.c:695:	chip->owner = THIS_MODULE;
./drivers/gpio/gpio-zynq.c:696:	chip->parent = &pdev->dev;
./drivers/gpio/gpio-zynq.c:697:	chip->get = zynq_gpio_get_value;
./drivers/gpio/gpio-zynq.c:698:	chip->set = zynq_gpio_set_value;
./drivers/gpio/gpio-zynq.c:699:	chip->request = zynq_gpio_request;
./drivers/gpio/gpio-zynq.c:700:	chip->free = zynq_gpio_free;
./drivers/gpio/gpio-zynq.c:701:	chip->direction_input = zynq_gpio_dir_in;
./drivers/gpio/gpio-zynq.c:702:	chip->direction_output = zynq_gpio_dir_out;
./drivers/gpio/gpio-zynq.c:703:	chip->base = -1;
./drivers/gpio/gpio-zynq.c:704:	chip->ngpio = gpio->p_data->ngpio;
./drivers/gpio/gpio-twl4030.c:254:		pdata = dev_get_platdata(chip->parent);
./drivers/gpio/gpio-74x164.c:39:		.tx_buf = chip->buffer,
./drivers/gpio/gpio-74x164.c:40:		.len = chip->registers,
./drivers/gpio/gpio-74x164.c:43:	return spi_sync_transfer(to_spi_device(chip->gpio_chip.parent),
./drivers/gpio/gpio-74x164.c:50:	u8 bank = chip->registers - 1 - offset / 8;
./drivers/gpio/gpio-74x164.c:54:	mutex_lock(&chip->lock);
./drivers/gpio/gpio-74x164.c:55:	ret = (chip->buffer[bank] >> pin) & 0x1;
./drivers/gpio/gpio-74x164.c:56:	mutex_unlock(&chip->lock);
./drivers/gpio/gpio-74x164.c:65:	u8 bank = chip->registers - 1 - offset / 8;
./drivers/gpio/gpio-74x164.c:68:	mutex_lock(&chip->lock);
./drivers/gpio/gpio-74x164.c:70:		chip->buffer[bank] |= (1 << pin);
./drivers/gpio/gpio-74x164.c:72:		chip->buffer[bank] &= ~(1 << pin);
./drivers/gpio/gpio-74x164.c:75:	mutex_unlock(&chip->lock);
./drivers/gpio/gpio-74x164.c:85:	mutex_lock(&chip->lock);
./drivers/gpio/gpio-74x164.c:86:	for (i = 0, bank = chip->registers - 1; i < chip->registers;
./drivers/gpio/gpio-74x164.c:94:		chip->buffer[bank] &= ~bankmask;
./drivers/gpio/gpio-74x164.c:95:		chip->buffer[bank] |= bankmask & (bits[idx] >> shift);
./drivers/gpio/gpio-74x164.c:98:	mutex_unlock(&chip->lock);
./drivers/gpio/gpio-74x164.c:136:	chip->gpio_chip.label = spi->modalias;
./drivers/gpio/gpio-74x164.c:137:	chip->gpio_chip.direction_output = gen_74x164_direction_output;
./drivers/gpio/gpio-74x164.c:138:	chip->gpio_chip.get = gen_74x164_get_value;
./drivers/gpio/gpio-74x164.c:139:	chip->gpio_chip.set = gen_74x164_set_value;
./drivers/gpio/gpio-74x164.c:140:	chip->gpio_chip.set_multiple = gen_74x164_set_multiple;
./drivers/gpio/gpio-74x164.c:141:	chip->gpio_chip.base = -1;
./drivers/gpio/gpio-74x164.c:143:	chip->registers = nregs;
./drivers/gpio/gpio-74x164.c:144:	chip->gpio_chip.ngpio = GEN_74X164_NUMBER_GPIOS * chip->registers;
./drivers/gpio/gpio-74x164.c:146:	chip->gpio_chip.can_sleep = true;
./drivers/gpio/gpio-74x164.c:147:	chip->gpio_chip.parent = &spi->dev;
./drivers/gpio/gpio-74x164.c:148:	chip->gpio_chip.owner = THIS_MODULE;
./drivers/gpio/gpio-74x164.c:150:	mutex_init(&chip->lock);
./drivers/gpio/gpio-74x164.c:158:	ret = gpiochip_add_data(&chip->gpio_chip, chip);
./drivers/gpio/gpio-74x164.c:163:	mutex_destroy(&chip->lock);
./drivers/gpio/gpio-74x164.c:172:	gpiochip_remove(&chip->gpio_chip);
./drivers/gpio/gpio-74x164.c:173:	mutex_destroy(&chip->lock);
./drivers/gpio/gpio-vf610.c:100:	return pinctrl_gpio_direction_input(chip->base + gpio);
./drivers/gpio/gpio-vf610.c:108:	return pinctrl_gpio_direction_output(chip->base + gpio);
./drivers/gpio/gpio-104-idio-16.c:77:	chip->set(chip, offset, value);
./drivers/gpio/gpio-104-idio-16.c:184:	for_each_set_bit(gpio, &idio16gpio->irq_mask, chip->ngpio)
./drivers/gpio/gpio-104-idio-16.c:185:		generic_handle_irq(irq_find_mapping(chip->irqdomain, gpio));
./drivers/gpio/gpio-stp-xway.c:94: * xway_stp_set() - gpio_chip->set - set gpios.
./drivers/gpio/gpio-stp-xway.c:106:		chip->shadow |= BIT(gpio);
./drivers/gpio/gpio-stp-xway.c:108:		chip->shadow &= ~BIT(gpio);
./drivers/gpio/gpio-stp-xway.c:109:	xway_stp_w32(chip->virt, chip->shadow, XWAY_STP_CPU0);
./drivers/gpio/gpio-stp-xway.c:110:	xway_stp_w32_mask(chip->virt, 0, XWAY_STP_CON_SWU, XWAY_STP_CON0);
./drivers/gpio/gpio-stp-xway.c:114: * xway_stp_dir_out() - gpio_chip->dir_out - set gpio direction.
./drivers/gpio/gpio-stp-xway.c:129: * xway_stp_request() - gpio_chip->request
./drivers/gpio/gpio-stp-xway.c:139:	if ((gpio < 8) && (chip->reserved & BIT(gpio))) {
./drivers/gpio/gpio-stp-xway.c:154:	xway_stp_w32(chip->virt, 0, XWAY_STP_AR);
./drivers/gpio/gpio-stp-xway.c:155:	xway_stp_w32(chip->virt, 0, XWAY_STP_CPU0);
./drivers/gpio/gpio-stp-xway.c:156:	xway_stp_w32(chip->virt, 0, XWAY_STP_CPU1);
./drivers/gpio/gpio-stp-xway.c:157:	xway_stp_w32(chip->virt, XWAY_STP_CON_SWU, XWAY_STP_CON0);
./drivers/gpio/gpio-stp-xway.c:158:	xway_stp_w32(chip->virt, 0, XWAY_STP_CON1);
./drivers/gpio/gpio-stp-xway.c:161:	xway_stp_w32_mask(chip->virt, XWAY_STP_EDGE_MASK,
./drivers/gpio/gpio-stp-xway.c:162:				chip->edge, XWAY_STP_CON0);
./drivers/gpio/gpio-stp-xway.c:165:	xway_stp_w32_mask(chip->virt, XWAY_STP_GROUP_MASK,
./drivers/gpio/gpio-stp-xway.c:166:				chip->groups, XWAY_STP_CON1);
./drivers/gpio/gpio-stp-xway.c:169:	xway_stp_w32_mask(chip->virt,
./drivers/gpio/gpio-stp-xway.c:171:			chip->dsl << XWAY_STP_ADSL_SHIFT,
./drivers/gpio/gpio-stp-xway.c:175:	xway_stp_w32_mask(chip->virt,
./drivers/gpio/gpio-stp-xway.c:177:			chip->phy1 << XWAY_STP_PHY1_SHIFT,
./drivers/gpio/gpio-stp-xway.c:179:	xway_stp_w32_mask(chip->virt,
./drivers/gpio/gpio-stp-xway.c:181:			chip->phy2 << XWAY_STP_PHY2_SHIFT,
./drivers/gpio/gpio-stp-xway.c:185:	chip->reserved = (chip->phy2 << 5) | (chip->phy1 << 2) | chip->dsl;
./drivers/gpio/gpio-stp-xway.c:191:	if (chip->reserved)
./drivers/gpio/gpio-stp-xway.c:192:		xway_stp_w32_mask(chip->virt, XWAY_STP_UPD_MASK,
./drivers/gpio/gpio-stp-xway.c:211:	chip->virt = devm_ioremap_resource(&pdev->dev, res);
./drivers/gpio/gpio-stp-xway.c:212:	if (IS_ERR(chip->virt))
./drivers/gpio/gpio-stp-xway.c:213:		return PTR_ERR(chip->virt);
./drivers/gpio/gpio-stp-xway.c:215:	chip->gc.parent = &pdev->dev;
./drivers/gpio/gpio-stp-xway.c:216:	chip->gc.label = "stp-xway";
./drivers/gpio/gpio-stp-xway.c:217:	chip->gc.direction_output = xway_stp_dir_out;
./drivers/gpio/gpio-stp-xway.c:218:	chip->gc.set = xway_stp_set;
./drivers/gpio/gpio-stp-xway.c:219:	chip->gc.request = xway_stp_request;
./drivers/gpio/gpio-stp-xway.c:220:	chip->gc.base = -1;
./drivers/gpio/gpio-stp-xway.c:221:	chip->gc.owner = THIS_MODULE;
./drivers/gpio/gpio-stp-xway.c:225:		chip->shadow = shadow;
./drivers/gpio/gpio-stp-xway.c:229:		chip->groups = groups & XWAY_STP_GROUP_MASK;
./drivers/gpio/gpio-stp-xway.c:231:		chip->groups = XWAY_STP_GROUP0;
./drivers/gpio/gpio-stp-xway.c:232:	chip->gc.ngpio = fls(chip->groups) * 8;
./drivers/gpio/gpio-stp-xway.c:236:		chip->dsl = dsl & XWAY_STP_ADSL_MASK;
./drivers/gpio/gpio-stp-xway.c:243:			chip->phy1 = phy & XWAY_STP_PHY_MASK;
./drivers/gpio/gpio-stp-xway.c:245:			chip->phy2 = phy & XWAY_STP_PHY_MASK;
./drivers/gpio/gpio-stp-xway.c:250:		chip->edge = XWAY_STP_FALLING;
./drivers/gpio/gpio-stp-xway.c:261:		ret = devm_gpiochip_add_data(&pdev->dev, &chip->gc, chip);
./drivers/gpio/gpio-mm-lantiq.c:49:	__raw_writew(chip->shadow, chip->mmchip.regs);
./drivers/gpio/gpio-mm-lantiq.c:55: * ltq_mm_set() - gpio_chip->set - set gpios.
./drivers/gpio/gpio-mm-lantiq.c:67:		chip->shadow |= (1 << offset);
./drivers/gpio/gpio-mm-lantiq.c:69:		chip->shadow &= ~(1 << offset);
./drivers/gpio/gpio-mm-lantiq.c:74: * ltq_mm_dir_out() - gpio_chip->dir_out - set gpio direction.
./drivers/gpio/gpio-mm-lantiq.c:98:	ltq_ebu_w32(CPHYSADDR(chip->mmchip.regs) | 0x1, LTQ_EBU_ADDRSEL1);
./drivers/gpio/gpio-mm-lantiq.c:114:	chip->mmchip.gc.ngpio = 16;
./drivers/gpio/gpio-mm-lantiq.c:115:	chip->mmchip.gc.direction_output = ltq_mm_dir_out;
./drivers/gpio/gpio-mm-lantiq.c:116:	chip->mmchip.gc.set = ltq_mm_set;
./drivers/gpio/gpio-mm-lantiq.c:117:	chip->mmchip.save_regs = ltq_mm_save_regs;
./drivers/gpio/gpio-mm-lantiq.c:121:		chip->shadow = shadow;
./drivers/gpio/gpio-mm-lantiq.c:123:	return of_mm_gpiochip_add_data(pdev->dev.of_node, &chip->mmchip, chip);
./drivers/gpio/gpio-mm-lantiq.c:130:	of_mm_gpiochip_remove(&chip->mmchip);
./drivers/gpio/gpio-cs5535.c:66:	unsigned long addr = chip->base + 0x80 + reg;
./drivers/gpio/gpio-cs5535.c:91:		outl(1 << offset, chip->base + reg);
./drivers/gpio/gpio-cs5535.c:102:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:104:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:113:		outl(1 << (offset + 16), chip->base + reg);
./drivers/gpio/gpio-cs5535.c:124:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:126:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:136:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:139:		val = inl(chip->base + reg);
./drivers/gpio/gpio-cs5535.c:142:		val = inl(chip->base + 0x80 + reg);
./drivers/gpio/gpio-cs5535.c:145:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:184:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:185:	val = inl(chip->base + offset);
./drivers/gpio/gpio-cs5535.c:197:	outl(val, chip->base + offset);
./drivers/gpio/gpio-cs5535.c:198:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:211:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:215:		dev_info(&chip->pdev->dev,
./drivers/gpio/gpio-cs5535.c:217:		spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:228:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:251:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:254:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:264:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-cs5535.c:273:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-wm831x.c:164:	for (i = 0; i < chip->ngpio; i++) {
./drivers/gpio/gpio-wm831x.c:165:		int gpio = i + chip->base;
./drivers/gpio/gpio-ich.c:284:	chip->owner = THIS_MODULE;
./drivers/gpio/gpio-ich.c:285:	chip->label = DRV_NAME;
./drivers/gpio/gpio-ich.c:286:	chip->parent = &ichx_priv.dev->dev;
./drivers/gpio/gpio-ich.c:288:	/* Allow chip-specific overrides of request()/get() */
./drivers/gpio/gpio-ich.c:289:	chip->request = ichx_priv.desc->request ?
./drivers/gpio/gpio-ich.c:291:	chip->get = ichx_priv.desc->get ?
./drivers/gpio/gpio-ich.c:294:	chip->set = ichx_gpio_set;
./drivers/gpio/gpio-ich.c:295:	chip->get_direction = ichx_gpio_get_direction;
./drivers/gpio/gpio-ich.c:296:	chip->direction_input = ichx_gpio_direction_input;
./drivers/gpio/gpio-ich.c:297:	chip->direction_output = ichx_gpio_direction_output;
./drivers/gpio/gpio-ich.c:298:	chip->base = modparam_gpiobase;
./drivers/gpio/gpio-ich.c:299:	chip->ngpio = ichx_priv.desc->ngpio;
./drivers/gpio/gpio-ich.c:300:	chip->can_sleep = false;
./drivers/gpio/gpio-ich.c:301:	chip->dbg_show = NULL;
./drivers/gpio/gpio-104-idi-48.c:212:			generic_handle_irq(irq_find_mapping(chip->irqdomain,
./drivers/gpio/gpio-mpc8xxx.c:109:	if (chip->irq_eoi)
./drivers/gpio/gpio-mpc8xxx.c:110:		chip->irq_eoi(&desc->irq_data);
./drivers/gpio/gpio-xilinx.c:59:	if (gpio >= chip->gpio_width[0])
./drivers/gpio/gpio-xilinx.c:76:		return gpio - chip->gpio_width[0];
./drivers/gpio/gpio-xilinx.c:121:	spin_lock_irqsave(&chip->gpio_lock[index], flags);
./drivers/gpio/gpio-xilinx.c:125:		chip->gpio_state[index] |= BIT(offset);
./drivers/gpio/gpio-xilinx.c:127:		chip->gpio_state[index] &= ~BIT(offset);
./drivers/gpio/gpio-xilinx.c:130:		       xgpio_regoffset(chip, gpio), chip->gpio_state[index]);
./drivers/gpio/gpio-xilinx.c:132:	spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
./drivers/gpio/gpio-xilinx.c:152:	spin_lock_irqsave(&chip->gpio_lock[index], flags);
./drivers/gpio/gpio-xilinx.c:155:	chip->gpio_dir[index] |= BIT(offset);
./drivers/gpio/gpio-xilinx.c:157:		       xgpio_regoffset(chip, gpio), chip->gpio_dir[index]);
./drivers/gpio/gpio-xilinx.c:159:	spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
./drivers/gpio/gpio-xilinx.c:184:	spin_lock_irqsave(&chip->gpio_lock[index], flags);
./drivers/gpio/gpio-xilinx.c:188:		chip->gpio_state[index] |= BIT(offset);
./drivers/gpio/gpio-xilinx.c:190:		chip->gpio_state[index] &= ~BIT(offset);
./drivers/gpio/gpio-xilinx.c:192:			xgpio_regoffset(chip, gpio), chip->gpio_state[index]);
./drivers/gpio/gpio-xilinx.c:195:	chip->gpio_dir[index] &= ~BIT(offset);
./drivers/gpio/gpio-xilinx.c:197:			xgpio_regoffset(chip, gpio), chip->gpio_dir[index]);
./drivers/gpio/gpio-xilinx.c:199:	spin_unlock_irqrestore(&chip->gpio_lock[index], flags);
./drivers/gpio/gpio-xilinx.c:213:	xgpio_writereg(mm_gc->regs + XGPIO_DATA_OFFSET,	chip->gpio_state[0]);
./drivers/gpio/gpio-xilinx.c:214:	xgpio_writereg(mm_gc->regs + XGPIO_TRI_OFFSET, chip->gpio_dir[0]);
./drivers/gpio/gpio-xilinx.c:216:	if (!chip->gpio_width[1])
./drivers/gpio/gpio-xilinx.c:220:		       chip->gpio_state[1]);
./drivers/gpio/gpio-xilinx.c:222:		       chip->gpio_dir[1]);
./drivers/gpio/gpio-xilinx.c:237:	of_mm_gpiochip_remove(&chip->mmchip);
./drivers/gpio/gpio-xilinx.c:264:	of_property_read_u32(np, "xlnx,dout-default", &chip->gpio_state[0]);
./drivers/gpio/gpio-xilinx.c:267:	if (of_property_read_u32(np, "xlnx,tri-default", &chip->gpio_dir[0]))
./drivers/gpio/gpio-xilinx.c:268:		chip->gpio_dir[0] = 0xFFFFFFFF;
./drivers/gpio/gpio-xilinx.c:274:	if (of_property_read_u32(np, "xlnx,gpio-width", &chip->gpio_width[0]))
./drivers/gpio/gpio-xilinx.c:275:		chip->gpio_width[0] = 32;
./drivers/gpio/gpio-xilinx.c:277:	spin_lock_init(&chip->gpio_lock[0]);
./drivers/gpio/gpio-xilinx.c:285:				     &chip->gpio_state[1]);
./drivers/gpio/gpio-xilinx.c:289:					 &chip->gpio_dir[1]))
./drivers/gpio/gpio-xilinx.c:290:			chip->gpio_dir[1] = 0xFFFFFFFF;
./drivers/gpio/gpio-xilinx.c:297:					 &chip->gpio_width[1]))
./drivers/gpio/gpio-xilinx.c:298:			chip->gpio_width[1] = 32;
./drivers/gpio/gpio-xilinx.c:300:		spin_lock_init(&chip->gpio_lock[1]);
./drivers/gpio/gpio-xilinx.c:303:	chip->mmchip.gc.ngpio = chip->gpio_width[0] + chip->gpio_width[1];
./drivers/gpio/gpio-xilinx.c:304:	chip->mmchip.gc.parent = &pdev->dev;
./drivers/gpio/gpio-xilinx.c:305:	chip->mmchip.gc.direction_input = xgpio_dir_in;
./drivers/gpio/gpio-xilinx.c:306:	chip->mmchip.gc.direction_output = xgpio_dir_out;
./drivers/gpio/gpio-xilinx.c:307:	chip->mmchip.gc.get = xgpio_get;
./drivers/gpio/gpio-xilinx.c:308:	chip->mmchip.gc.set = xgpio_set;
./drivers/gpio/gpio-xilinx.c:310:	chip->mmchip.save_regs = xgpio_save_regs;
./drivers/gpio/gpio-xilinx.c:313:	status = of_mm_gpiochip_add_data(np, &chip->mmchip, chip);
./drivers/gpio/gpio-timberdale.c:203:	data->chip->irq_ack(data);
./drivers/gpio/gpiolib.c:112:	struct gpio_device *gdev = chip->gpiodev;
./drivers/gpio/gpiolib.c:185:	if (!chip->get_direction)
./drivers/gpio/gpiolib.c:188:	status = chip->get_direction(chip, offset);
./drivers/gpio/gpiolib.c:486:		 dev_name(&gdev->dev), gdev->chip->label ? : "generic");
./drivers/gpio/gpiolib.c:512: * @chip: the chip to register, with chip->base initialized
./drivers/gpio/gpiolib.c:516: * because the chip->base is invalid or already associated with a
./drivers/gpio/gpiolib.c:520: * can be freely used, the chip->parent device must be registered before
./drivers/gpio/gpiolib.c:527: * If chip->base is negative, this requests dynamic assignment of
./drivers/gpio/gpiolib.c:535:	int		base = chip->base;
./drivers/gpio/gpiolib.c:547:	chip->gpiodev = gdev;
./drivers/gpio/gpiolib.c:548:	if (chip->parent) {
./drivers/gpio/gpiolib.c:549:		gdev->dev.parent = chip->parent;
./drivers/gpio/gpiolib.c:550:		gdev->dev.of_node = chip->parent->of_node;
./drivers/gpio/gpiolib.c:554:		if (chip->of_node)
./drivers/gpio/gpiolib.c:555:			gdev->dev.of_node = chip->of_node;
./drivers/gpio/gpiolib.c:566:	if (chip->parent && chip->parent->driver)
./drivers/gpio/gpiolib.c:567:		gdev->owner = chip->parent->driver->owner;
./drivers/gpio/gpiolib.c:568:	else if (chip->owner)
./drivers/gpio/gpiolib.c:569:		/* TODO: remove chip->owner */
./drivers/gpio/gpiolib.c:570:		gdev->owner = chip->owner;
./drivers/gpio/gpiolib.c:574:	gdev->descs = kcalloc(chip->ngpio, sizeof(gdev->descs[0]), GFP_KERNEL);
./drivers/gpio/gpiolib.c:580:	if (chip->ngpio == 0) {
./drivers/gpio/gpiolib.c:586:	if (chip->label)
./drivers/gpio/gpiolib.c:587:		gdev->label = kstrdup(chip->label, GFP_KERNEL);
./drivers/gpio/gpiolib.c:595:	gdev->ngpio = chip->ngpio;
./drivers/gpio/gpiolib.c:608:		base = gpiochip_find_base(chip->ngpio);
./drivers/gpio/gpiolib.c:620:		chip->base = base;
./drivers/gpio/gpiolib.c:632:	for (i = 0; i < chip->ngpio; i++) {
./drivers/gpio/gpiolib.c:641:		 * chip->get_direction is not set, we may expose the
./drivers/gpio/gpiolib.c:645:		if (chip->get_direction) {
./drivers/gpio/gpiolib.c:650:			int dir = chip->get_direction(chip, i);
./drivers/gpio/gpiolib.c:654:		} else if (!chip->direction_input) {
./drivers/gpio/gpiolib.c:709:	       chip->label ? : "generic");
./drivers/gpio/gpiolib.c:720:	return chip->gpiodev->data;
./drivers/gpio/gpiolib.c:732:	struct gpio_device *gdev = chip->gpiodev;
./drivers/gpio/gpiolib.c:800: * @chip: the chip to register, with chip->base initialized
./drivers/gpio/gpiolib.c:804: * because the chip->base is invalid or already associated with a
./drivers/gpio/gpiolib.c:891:	return !strcmp(chip->label, name);
./drivers/gpio/gpiolib.c:922:	if (!gpiochip->irqdomain) {
./drivers/gpio/gpiolib.c:929:		if (gpiochip->can_sleep) {
./drivers/gpio/gpiolib.c:942:		gpiochip->irq_parent = parent_irq;
./drivers/gpio/gpiolib.c:946:	for (offset = 0; offset < gpiochip->ngpio; offset++)
./drivers/gpio/gpiolib.c:947:		irq_set_parent(irq_find_mapping(gpiochip->irqdomain, offset),
./drivers/gpio/gpiolib.c:972:	irq_set_lockdep_class(irq, chip->lock_key);
./drivers/gpio/gpiolib.c:973:	irq_set_chip_and_handler(irq, chip->irqchip, chip->irq_handler);
./drivers/gpio/gpiolib.c:975:	if (chip->can_sleep && !chip->irq_not_threaded)
./drivers/gpio/gpiolib.c:983:	if (chip->irq_default_type != IRQ_TYPE_NONE)
./drivers/gpio/gpiolib.c:984:		irq_set_irq_type(irq, chip->irq_default_type);
./drivers/gpio/gpiolib.c:993:	if (chip->can_sleep)
./drivers/gpio/gpiolib.c:1010:	if (!try_module_get(chip->gpiodev->owner))
./drivers/gpio/gpiolib.c:1017:		module_put(chip->gpiodev->owner);
./drivers/gpio/gpiolib.c:1028:	module_put(chip->gpiodev->owner);
./drivers/gpio/gpiolib.c:1033:	return irq_find_mapping(chip->irqdomain, offset);
./drivers/gpio/gpiolib.c:1048:	if (gpiochip->irq_parent) {
./drivers/gpio/gpiolib.c:1049:		irq_set_chained_handler(gpiochip->irq_parent, NULL);
./drivers/gpio/gpiolib.c:1050:		irq_set_handler_data(gpiochip->irq_parent, NULL);
./drivers/gpio/gpiolib.c:1054:	if (gpiochip->irqdomain) {
./drivers/gpio/gpiolib.c:1055:		for (offset = 0; offset < gpiochip->ngpio; offset++)
./drivers/gpio/gpiolib.c:1057:				irq_find_mapping(gpiochip->irqdomain, offset));
./drivers/gpio/gpiolib.c:1058:		irq_domain_remove(gpiochip->irqdomain);
./drivers/gpio/gpiolib.c:1061:	if (gpiochip->irqchip) {
./drivers/gpio/gpiolib.c:1062:		gpiochip->irqchip->irq_request_resources = NULL;
./drivers/gpio/gpiolib.c:1063:		gpiochip->irqchip->irq_release_resources = NULL;
./drivers/gpio/gpiolib.c:1064:		gpiochip->irqchip = NULL;
./drivers/gpio/gpiolib.c:1107:	if (!gpiochip->parent) {
./drivers/gpio/gpiolib.c:1111:	of_node = gpiochip->parent->of_node;
./drivers/gpio/gpiolib.c:1115:	 * FIXME: get rid of this and use gpiochip->parent->of_node
./drivers/gpio/gpiolib.c:1118:	if (gpiochip->of_node)
./drivers/gpio/gpiolib.c:1119:		of_node = gpiochip->of_node;
./drivers/gpio/gpiolib.c:1121:	gpiochip->irqchip = irqchip;
./drivers/gpio/gpiolib.c:1122:	gpiochip->irq_handler = handler;
./drivers/gpio/gpiolib.c:1123:	gpiochip->irq_default_type = type;
./drivers/gpio/gpiolib.c:1124:	gpiochip->to_irq = gpiochip_to_irq;
./drivers/gpio/gpiolib.c:1125:	gpiochip->lock_key = lock_key;
./drivers/gpio/gpiolib.c:1126:	gpiochip->irqdomain = irq_domain_add_simple(of_node,
./drivers/gpio/gpiolib.c:1127:					gpiochip->ngpio, first_irq,
./drivers/gpio/gpiolib.c:1129:	if (!gpiochip->irqdomain) {
./drivers/gpio/gpiolib.c:1130:		gpiochip->irqchip = NULL;
./drivers/gpio/gpiolib.c:1138:	if (!irqchip->irq_request_resources &&
./drivers/gpio/gpiolib.c:1139:	    !irqchip->irq_release_resources) {
./drivers/gpio/gpiolib.c:1140:		irqchip->irq_request_resources = gpiochip_irq_reqres;
./drivers/gpio/gpiolib.c:1141:		irqchip->irq_release_resources = gpiochip_irq_relres;
./drivers/gpio/gpiolib.c:1149:	for (offset = 0; offset < gpiochip->ngpio; offset++) {
./drivers/gpio/gpiolib.c:1150:		irq_base = irq_create_mapping(gpiochip->irqdomain, offset);
./drivers/gpio/gpiolib.c:1156:			gpiochip->irq_base = irq_base;
./drivers/gpio/gpiolib.c:1178:	return pinctrl_request_gpio(chip->gpiodev->base + offset);
./drivers/gpio/gpiolib.c:1189:	pinctrl_free_gpio(chip->gpiodev->base + offset);
./drivers/gpio/gpiolib.c:1207:	struct gpio_device *gdev = chip->gpiodev;
./drivers/gpio/gpiolib.c:1219:	pin_range->range.name = chip->label;
./drivers/gpio/gpiolib.c:1257:	struct gpio_device *gdev = chip->gpiodev;
./drivers/gpio/gpiolib.c:1269:	pin_range->range.name = chip->label;
./drivers/gpio/gpiolib.c:1299:	struct gpio_device *gdev = chip->gpiodev;
./drivers/gpio/gpiolib.c:1336:	if (chip->request) {
./drivers/gpio/gpiolib.c:1337:		/* chip->request may sleep */
./drivers/gpio/gpiolib.c:1339:		status = chip->request(chip, gpio_chip_hwgpio(desc));
./drivers/gpio/gpiolib.c:1348:	if (chip->get_direction) {
./drivers/gpio/gpiolib.c:1349:		/* chip->get_direction may sleep */
./drivers/gpio/gpiolib.c:1436:		if (chip->free) {
./drivers/gpio/gpiolib.c:1438:			might_sleep_if(chip->can_sleep);
./drivers/gpio/gpiolib.c:1439:			chip->free(chip, gpio_chip_hwgpio(desc));
./drivers/gpio/gpiolib.c:1482:	if (offset >= chip->ngpio)
./drivers/gpio/gpiolib.c:1485:	desc = &chip->gpiodev->descs[offset];
./drivers/gpio/gpiolib.c:1564:	if (!chip->get || !chip->direction_input) {
./drivers/gpio/gpiolib.c:1571:	status = chip->direction_input(chip, gpio_chip_hwgpio(desc));
./drivers/gpio/gpiolib.c:1693:	if (!chip->set || !chip->set_debounce) {
./drivers/gpio/gpiolib.c:1700:	return chip->set_debounce(chip, gpio_chip_hwgpio(desc), debounce);
./drivers/gpio/gpiolib.c:1747:	value = chip->get ? chip->get(chip, offset) : -EIO;
./drivers/gpio/gpiolib.c:1767:	WARN_ON(desc->gdev->chip->can_sleep);
./drivers/gpio/gpiolib.c:1788:	WARN_ON(desc->gdev->chip->can_sleep);
./drivers/gpio/gpiolib.c:1813:		err = chip->direction_input(chip, offset);
./drivers/gpio/gpiolib.c:1817:		err = chip->direction_output(chip, offset, 0);
./drivers/gpio/gpiolib.c:1840:		err = chip->direction_output(chip, offset, 1);
./drivers/gpio/gpiolib.c:1844:		err = chip->direction_input(chip, offset);
./drivers/gpio/gpiolib.c:1866:		chip->set(chip, gpio_chip_hwgpio(desc), value);
./drivers/gpio/gpiolib.c:1881:	if (chip->set_multiple) {
./drivers/gpio/gpiolib.c:1882:		chip->set_multiple(chip, mask, bits);
./drivers/gpio/gpiolib.c:1885:		for (i = 0; i < chip->ngpio; i++) {
./drivers/gpio/gpiolib.c:1894:				chip->set(chip, i, test_bit(i, bits));
./drivers/gpio/gpiolib.c:1908:		unsigned long mask[BITS_TO_LONGS(chip->ngpio)];
./drivers/gpio/gpiolib.c:1909:		unsigned long bits[BITS_TO_LONGS(chip->ngpio)];
./drivers/gpio/gpiolib.c:1913:			WARN_ON(chip->can_sleep);
./drivers/gpio/gpiolib.c:1964:	WARN_ON(desc->gdev->chip->can_sleep);
./drivers/gpio/gpiolib.c:1984:	WARN_ON(desc->gdev->chip->can_sleep);
./drivers/gpio/gpiolib.c:2043:	return desc->gdev->chip->can_sleep;
./drivers/gpio/gpiolib.c:2069:	if (chip->to_irq) {
./drivers/gpio/gpiolib.c:2070:		int retirq = chip->to_irq(chip, offset);
./drivers/gpio/gpiolib.c:2099:	if (chip->get_direction) {
./drivers/gpio/gpiolib.c:2100:		int dir = chip->get_direction(chip, offset);
./drivers/gpio/gpiolib.c:2130:	if (offset >= chip->ngpio)
./drivers/gpio/gpiolib.c:2133:	clear_bit(FLAG_USED_AS_IRQ, &chip->gpiodev->descs[offset].flags);
./drivers/gpio/gpiolib.c:2139:	if (offset >= chip->ngpio)
./drivers/gpio/gpiolib.c:2142:	return test_bit(FLAG_USED_AS_IRQ, &chip->gpiodev->descs[offset].flags);
./drivers/gpio/gpiolib.c:2148:	if (offset >= chip->ngpio)
./drivers/gpio/gpiolib.c:2151:	return test_bit(FLAG_OPEN_DRAIN, &chip->gpiodev->descs[offset].flags);
./drivers/gpio/gpiolib.c:2157:	if (offset >= chip->ngpio)
./drivers/gpio/gpiolib.c:2160:	return test_bit(FLAG_OPEN_SOURCE, &chip->gpiodev->descs[offset].flags);
./drivers/gpio/gpiolib.c:2467:		if (chip->ngpio <= p->chip_hwnum) {
./drivers/gpio/gpiolib.c:2470:				idx, chip->ngpio, chip->label);
./drivers/gpio/gpiolib.c:2803:		       name, chip->label, hwnum, status);
./drivers/gpio/gpiolib.c:2810:		       name, chip->label, hwnum, status);
./drivers/gpio/gpiolib.c:2837:	for (id = 0; id < chip->ngpio; id++) {
./drivers/gpio/gpiolib.c:2838:		if (test_bit(FLAG_IS_HOGGED, &chip->gpiodev->descs[id].flags))
./drivers/gpio/gpiolib.c:2839:			gpiochip_free_own_desc(&chip->gpiodev->descs[id]);
./drivers/gpio/gpiolib.c:2985:			chip->get
./drivers/gpio/gpiolib.c:2986:				? (chip->get(chip, i) ? "hi" : "lo")
./drivers/gpio/gpiolib.c:3050:	parent = chip->parent;
./drivers/gpio/gpiolib.c:3055:	if (chip->label)
./drivers/gpio/gpiolib.c:3056:		seq_printf(s, ", %s", chip->label);
./drivers/gpio/gpiolib.c:3057:	if (chip->can_sleep)
./drivers/gpio/gpiolib.c:3061:	if (chip->dbg_show)
./drivers/gpio/gpiolib.c:3062:		chip->dbg_show(s, chip);
./drivers/gpio/gpio-pl061.c:68:	return !(readb(chip->base + GPIODIR) & BIT(offset));
./drivers/gpio/gpio-pl061.c:77:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-pl061.c:78:	gpiodir = readb(chip->base + GPIODIR);
./drivers/gpio/gpio-pl061.c:80:	writeb(gpiodir, chip->base + GPIODIR);
./drivers/gpio/gpio-pl061.c:81:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-pl061.c:93:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-pl061.c:94:	writeb(!!value << offset, chip->base + (BIT(offset + 2)));
./drivers/gpio/gpio-pl061.c:95:	gpiodir = readb(chip->base + GPIODIR);
./drivers/gpio/gpio-pl061.c:97:	writeb(gpiodir, chip->base + GPIODIR);
./drivers/gpio/gpio-pl061.c:103:	writeb(!!value << offset, chip->base + (BIT(offset + 2)));
./drivers/gpio/gpio-pl061.c:104:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-pl061.c:113:	return !!readb(chip->base + (BIT(offset + 2)));
./drivers/gpio/gpio-pl061.c:120:	writeb(!!value << offset, chip->base + (BIT(offset + 2)));
./drivers/gpio/gpio-pl061.c:146:	spin_lock_irqsave(&chip->lock, flags);
./drivers/gpio/gpio-pl061.c:148:	gpioiev = readb(chip->base + GPIOIEV);
./drivers/gpio/gpio-pl061.c:149:	gpiois = readb(chip->base + GPIOIS);
./drivers/gpio/gpio-pl061.c:150:	gpioibe = readb(chip->base + GPIOIBE);
./drivers/gpio/gpio-pl061.c:202:	writeb(gpiois, chip->base + GPIOIS);
./drivers/gpio/gpio-pl061.c:203:	writeb(gpioibe, chip->base + GPIOIBE);
./drivers/gpio/gpio-pl061.c:204:	writeb(gpioiev, chip->base + GPIOIEV);
./drivers/gpio/gpio-pl061.c:206:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/gpio/gpio-pl061.c:221:	pending = readb(chip->base + GPIOMIS);
./drivers/gpio/gpio-pl061.c:238:	spin_lock(&chip->lock);
./drivers/gpio/gpio-pl061.c:239:	gpioie = readb(chip->base + GPIOIE) & ~mask;
./drivers/gpio/gpio-pl061.c:240:	writeb(gpioie, chip->base + GPIOIE);
./drivers/gpio/gpio-pl061.c:241:	spin_unlock(&chip->lock);
./drivers/gpio/gpio-pl061.c:251:	spin_lock(&chip->lock);
./drivers/gpio/gpio-pl061.c:252:	gpioie = readb(chip->base + GPIOIE) | mask;
./drivers/gpio/gpio-pl061.c:253:	writeb(gpioie, chip->base + GPIOIE);
./drivers/gpio/gpio-pl061.c:254:	spin_unlock(&chip->lock);
./drivers/gpio/gpio-pl061.c:271:	spin_lock(&chip->lock);
./drivers/gpio/gpio-pl061.c:272:	writeb(mask, chip->base + GPIOIC);
./drivers/gpio/gpio-pl061.c:273:	spin_unlock(&chip->lock);
./drivers/gpio/gpio-pl061.c:304:		chip->gc.base = pdata->gpio_base;
./drivers/gpio/gpio-pl061.c:311:		chip->gc.base = -1;
./drivers/gpio/gpio-pl061.c:315:	chip->base = devm_ioremap_resource(dev, &adev->res);
./drivers/gpio/gpio-pl061.c:316:	if (IS_ERR(chip->base))
./drivers/gpio/gpio-pl061.c:317:		return PTR_ERR(chip->base);
./drivers/gpio/gpio-pl061.c:319:	spin_lock_init(&chip->lock);
./drivers/gpio/gpio-pl061.c:321:		chip->gc.request = gpiochip_generic_request;
./drivers/gpio/gpio-pl061.c:322:		chip->gc.free = gpiochip_generic_free;
./drivers/gpio/gpio-pl061.c:325:	chip->gc.get_direction = pl061_get_direction;
./drivers/gpio/gpio-pl061.c:326:	chip->gc.direction_input = pl061_direction_input;
./drivers/gpio/gpio-pl061.c:327:	chip->gc.direction_output = pl061_direction_output;
./drivers/gpio/gpio-pl061.c:328:	chip->gc.get = pl061_get_value;
./drivers/gpio/gpio-pl061.c:329:	chip->gc.set = pl061_set_value;
./drivers/gpio/gpio-pl061.c:330:	chip->gc.ngpio = PL061_GPIO_NR;
./drivers/gpio/gpio-pl061.c:331:	chip->gc.label = dev_name(dev);
./drivers/gpio/gpio-pl061.c:332:	chip->gc.parent = dev;
./drivers/gpio/gpio-pl061.c:333:	chip->gc.owner = THIS_MODULE;
./drivers/gpio/gpio-pl061.c:335:	ret = gpiochip_add_data(&chip->gc, chip);
./drivers/gpio/gpio-pl061.c:342:	writeb(0, chip->base + GPIOIE); /* disable irqs */
./drivers/gpio/gpio-pl061.c:349:	ret = gpiochip_irqchip_add(&chip->gc, &pl061_irqchip,
./drivers/gpio/gpio-pl061.c:356:	gpiochip_set_chained_irqchip(&chip->gc, &pl061_irqchip,
./drivers/gpio/gpio-pl061.c:362:				pl061_direction_output(&chip->gc, i,
./drivers/gpio/gpio-pl061.c:365:				pl061_direction_input(&chip->gc, i);
./drivers/gpio/gpio-pl061.c:382:	chip->csave_regs.gpio_data = 0;
./drivers/gpio/gpio-pl061.c:383:	chip->csave_regs.gpio_dir = readb(chip->base + GPIODIR);
./drivers/gpio/gpio-pl061.c:384:	chip->csave_regs.gpio_is = readb(chip->base + GPIOIS);
./drivers/gpio/gpio-pl061.c:385:	chip->csave_regs.gpio_ibe = readb(chip->base + GPIOIBE);
./drivers/gpio/gpio-pl061.c:386:	chip->csave_regs.gpio_iev = readb(chip->base + GPIOIEV);
./drivers/gpio/gpio-pl061.c:387:	chip->csave_regs.gpio_ie = readb(chip->base + GPIOIE);
./drivers/gpio/gpio-pl061.c:390:		if (chip->csave_regs.gpio_dir & (BIT(offset)))
./drivers/gpio/gpio-pl061.c:391:			chip->csave_regs.gpio_data |=
./drivers/gpio/gpio-pl061.c:392:				pl061_get_value(&chip->gc, offset) << offset;
./drivers/gpio/gpio-pl061.c:404:		if (chip->csave_regs.gpio_dir & (BIT(offset)))
./drivers/gpio/gpio-pl061.c:405:			pl061_direction_output(&chip->gc, offset,
./drivers/gpio/gpio-pl061.c:406:					chip->csave_regs.gpio_data &
./drivers/gpio/gpio-pl061.c:409:			pl061_direction_input(&chip->gc, offset);
./drivers/gpio/gpio-pl061.c:412:	writeb(chip->csave_regs.gpio_is, chip->base + GPIOIS);
./drivers/gpio/gpio-pl061.c:413:	writeb(chip->csave_regs.gpio_ibe, chip->base + GPIOIBE);
./drivers/gpio/gpio-pl061.c:414:	writeb(chip->csave_regs.gpio_iev, chip->base + GPIOIEV);
./drivers/gpio/gpio-pl061.c:415:	writeb(chip->csave_regs.gpio_ie, chip->base + GPIOIE);
./drivers/gpio/gpio-viperboard.c:174:			dev_err(chip->parent, "usb error setting pin value\n");
./drivers/gpio/gpio-viperboard.c:342:			dev_err(chip->parent, "usb error setting pin value\n");
./drivers/gpio/gpio-viperboard.c:362:		dev_err(chip->parent, "usb error setting pin to input\n");
./drivers/gpio/gpio-viperboard.c:380:		dev_err(chip->parent, "usb error setting pin to output\n");
./drivers/gpio/gpio-kempld.c:162:	chip->label = "gpio-kempld";
./drivers/gpio/gpio-kempld.c:163:	chip->owner = THIS_MODULE;
./drivers/gpio/gpio-kempld.c:164:	chip->parent = dev;
./drivers/gpio/gpio-kempld.c:165:	chip->can_sleep = true;
./drivers/gpio/gpio-kempld.c:167:		chip->base = pdata->gpio_base;
./drivers/gpio/gpio-kempld.c:169:		chip->base = -1;
./drivers/gpio/gpio-kempld.c:170:	chip->direction_input = kempld_gpio_direction_input;
./drivers/gpio/gpio-kempld.c:171:	chip->direction_output = kempld_gpio_direction_output;
./drivers/gpio/gpio-kempld.c:172:	chip->get_direction = kempld_gpio_get_direction;
./drivers/gpio/gpio-kempld.c:173:	chip->get = kempld_gpio_get;
./drivers/gpio/gpio-kempld.c:174:	chip->set = kempld_gpio_set;
./drivers/gpio/gpio-kempld.c:175:	chip->ngpio = kempld_gpio_pincount(pld);
./drivers/gpio/gpio-kempld.c:176:	if (chip->ngpio == 0) {
./drivers/gpio/gpio-kempld.c:188:		 chip->ngpio);
./drivers/video/fbdev/via/dvi.c:297:	restore = tmds_chip->tmds_chip_slave_addr;
./drivers/video/fbdev/via/dvi.c:298:	tmds_chip->tmds_chip_slave_addr = 0xA0;
./drivers/video/fbdev/via/dvi.c:323:	tmds_chip->tmds_chip_slave_addr = restore;
./drivers/video/fbdev/cirrusfb.c:104: * chip-specific information
./drivers/video/fbdev/riva/nv_driver.c:163:	switch (chip->Architecture) {
./drivers/video/fbdev/riva/nv_driver.c:165:		if (NV_RD32(chip->PFB, 0x00000000) & 0x00000020) {
./drivers/video/fbdev/riva/nv_driver.c:166:			if (((NV_RD32(chip->PMC, 0x00000000) & 0xF0) == 0x20)
./drivers/video/fbdev/riva/nv_driver.c:167:			    && ((NV_RD32(chip->PMC, 0x00000000)&0x0F)>=0x02)) {
./drivers/video/fbdev/riva/nv_driver.c:171:				switch (NV_RD32(chip->PFB,0x00000000) & 0x03) {
./drivers/video/fbdev/riva/nv_driver.c:189:			switch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003) {
./drivers/video/fbdev/riva/nv_driver.c:203:		if (NV_RD32(chip->PFB, 0x00000000) & 0x00000100) {
./drivers/video/fbdev/riva/nv_driver.c:204:			memlen = ((NV_RD32(chip->PFB, 0x00000000)>>12)&0x0F) *
./drivers/video/fbdev/riva/nv_driver.c:207:			switch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003) {
./drivers/video/fbdev/riva/nv_driver.c:239:			switch ((NV_RD32(chip->PFB, 0x0000020C) >> 20) &
./drivers/video/fbdev/riva/nv_driver.c:277:	switch (chip->Architecture) {
./drivers/video/fbdev/riva/nv_driver.c:279:		if (NV_RD32(chip->PFB, 0x00000000) & 0x00000020) {
./drivers/video/fbdev/riva/nv_driver.c:280:			if (((NV_RD32(chip->PMC, 0x00000000) & 0xF0) == 0x20)
./drivers/video/fbdev/riva/nv_driver.c:281:			    && ((NV_RD32(chip->PMC,0x00000000)&0x0F) >= 0x02)) {
./drivers/video/fbdev/riva/nv_driver.c:300:		switch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003) {
./drivers/video/fbdev/riva/riva_hw.c:65:    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||
./drivers/video/fbdev/riva/riva_hw.c:66:	    NV_RD32(&chip->PGRAPH[0x000006B0/4], 0) & 0x01);
./drivers/video/fbdev/riva/riva_hw.c:73:    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||
./drivers/video/fbdev/riva/riva_hw.c:74:	    NV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);
./drivers/video/fbdev/riva/riva_hw.c:81:    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||
./drivers/video/fbdev/riva/riva_hw.c:82:	    NV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);
./drivers/video/fbdev/riva/riva_hw.c:92:    VGA_WR08(chip->PCIO, 0x3D4, 0x11);
./drivers/video/fbdev/riva/riva_hw.c:93:    cr11 = VGA_RD08(chip->PCIO, 0x3D5);
./drivers/video/fbdev/riva/riva_hw.c:96:    VGA_WR08(chip->PCIO, 0x3D5, cr11);
./drivers/video/fbdev/riva/riva_hw.c:104:    VGA_WR08(chip->PVIO, 0x3C4, 0x06);
./drivers/video/fbdev/riva/riva_hw.c:105:    VGA_WR08(chip->PVIO, 0x3C5, Lock ? 0x99 : 0x57);
./drivers/video/fbdev/riva/riva_hw.c:114:    VGA_WR08(chip->PCIO, 0x3D4, 0x1F);
./drivers/video/fbdev/riva/riva_hw.c:115:    VGA_WR08(chip->PCIO, 0x3D5, Lock ? 0x99 : 0x57);
./drivers/video/fbdev/riva/riva_hw.c:126:    cursor                      =  chip->CurrentState->cursor1;
./drivers/video/fbdev/riva/riva_hw.c:127:    chip->CurrentState->cursor1 = (chip->CurrentState->cursor1 & 0xFE) |
./drivers/video/fbdev/riva/riva_hw.c:129:    VGA_WR08(chip->PCIO, 0x3D4, 0x31);
./drivers/video/fbdev/riva/riva_hw.c:130:    VGA_WR08(chip->PCIO, 0x3D5, chip->CurrentState->cursor1);
./drivers/video/fbdev/riva/riva_hw.c:621:    pll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);
./drivers/video/fbdev/riva/riva_hw.c:623:    MClk = (N * chip->CrystalFreqKHz / M) >> P;
./drivers/video/fbdev/riva/riva_hw.c:628:    sim_data.memory_width   = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?
./drivers/video/fbdev/riva/riva_hw.c:810:    pll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);
./drivers/video/fbdev/riva/riva_hw.c:812:    MClk  = (N * chip->CrystalFreqKHz / M) >> P;
./drivers/video/fbdev/riva/riva_hw.c:813:    pll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);
./drivers/video/fbdev/riva/riva_hw.c:815:    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
./drivers/video/fbdev/riva/riva_hw.c:816:    cfg1 = NV_RD32(&chip->PFB[0x00000204/4], 0);
./drivers/video/fbdev/riva/riva_hw.c:820:    sim_data.memory_width   = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?
./drivers/video/fbdev/riva/riva_hw.c:1073:    pll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);
./drivers/video/fbdev/riva/riva_hw.c:1075:    MClk  = (N * chip->CrystalFreqKHz / M) >> P;
./drivers/video/fbdev/riva/riva_hw.c:1076:    pll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);
./drivers/video/fbdev/riva/riva_hw.c:1078:    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
./drivers/video/fbdev/riva/riva_hw.c:1079:    cfg1 = NV_RD32(&chip->PFB[0x00000204/4], 0);
./drivers/video/fbdev/riva/riva_hw.c:1083:    sim_data.memory_type    = (NV_RD32(&chip->PFB[0x00000200/4], 0) & 0x01) ?
./drivers/video/fbdev/riva/riva_hw.c:1085:    sim_data.memory_width   = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?
./drivers/video/fbdev/riva/riva_hw.c:1128:    pll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);
./drivers/video/fbdev/riva/riva_hw.c:1130:    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
./drivers/video/fbdev/riva/riva_hw.c:1187:    if (chip->CrystalFreqKHz == 13500)
./drivers/video/fbdev/riva/riva_hw.c:1190:        highM = 13 - (chip->Architecture == NV_ARCH_03);
./drivers/video/fbdev/riva/riva_hw.c:1195:        highM = 14 - (chip->Architecture == NV_ARCH_03);
./drivers/video/fbdev/riva/riva_hw.c:1198:    highP = 4 - (chip->Architecture == NV_ARCH_03);
./drivers/video/fbdev/riva/riva_hw.c:1202:        if ((Freq >= 128000) && (Freq <= chip->MaxVClockFreqKHz))
./drivers/video/fbdev/riva/riva_hw.c:1206:                N    = (VClk << P) * M / chip->CrystalFreqKHz;
./drivers/video/fbdev/riva/riva_hw.c:1208:                Freq = (chip->CrystalFreqKHz * N / M) >> P;
./drivers/video/fbdev/riva/riva_hw.c:1261:    switch (chip->Architecture)
./drivers/video/fbdev/riva/riva_hw.c:1296:            if((chip->Chipset == NV_CHIP_IGEFORCE2) ||
./drivers/video/fbdev/riva/riva_hw.c:1297:               (chip->Chipset == NV_CHIP_0x01F0))
./drivers/video/fbdev/riva/riva_hw.c:1311:            state->cursor0  = 0x80 | (chip->CursorStart >> 17);
./drivers/video/fbdev/riva/riva_hw.c:1312:            state->cursor1  = (chip->CursorStart >> 11) << 2;
./drivers/video/fbdev/riva/riva_hw.c:1313:            state->cursor2  = chip->CursorStart >> 24;
./drivers/video/fbdev/riva/riva_hw.c:1315:            state->config   = NV_RD32(&chip->PFB[0x00000200/4], 0);
./drivers/video/fbdev/riva/riva_hw.c:1323:    if((bpp != 8) && (chip->Architecture != NV_ARCH_03))
./drivers/video/fbdev/riva/riva_hw.c:1346:        chip->dev[tbl##Table##dev[i][0]] = tbl##Table##dev[i][1]
./drivers/video/fbdev/riva/riva_hw.c:1349:        chip->dev[tbl##Table##dev##_8BPP[i][0]] = tbl##Table##dev##_8BPP[i][1]
./drivers/video/fbdev/riva/riva_hw.c:1352:        chip->dev[tbl##Table##dev##_15BPP[i][0]] = tbl##Table##dev##_15BPP[i][1]
./drivers/video/fbdev/riva/riva_hw.c:1355:        chip->dev[tbl##Table##dev##_16BPP[i][0]] = tbl##Table##dev##_16BPP[i][1]
./drivers/video/fbdev/riva/riva_hw.c:1358:        chip->dev[tbl##Table##dev##_32BPP[i][0]] = tbl##Table##dev##_32BPP[i][1]
./drivers/video/fbdev/riva/riva_hw.c:1363:        NV_WR32(&chip->dev[tbl##Table##dev[i][0]], 0, tbl##Table##dev[i][1])
./drivers/video/fbdev/riva/riva_hw.c:1366:        NV_WR32(&chip->dev[tbl##Table##dev##_8BPP[i][0]], 0, tbl##Table##dev##_8BPP[i][1])
./drivers/video/fbdev/riva/riva_hw.c:1369:        NV_WR32(&chip->dev[tbl##Table##dev##_15BPP[i][0]], 0, tbl##Table##dev##_15BPP[i][1])
./drivers/video/fbdev/riva/riva_hw.c:1372:        NV_WR32(&chip->dev[tbl##Table##dev##_16BPP[i][0]], 0, tbl##Table##dev##_16BPP[i][1])
./drivers/video/fbdev/riva/riva_hw.c:1375:        NV_WR32(&chip->dev[tbl##Table##dev##_32BPP[i][0]], 0, tbl##Table##dev##_32BPP[i][1])
./drivers/video/fbdev/riva/riva_hw.c:1384:    switch (chip->Architecture)
./drivers/video/fbdev/riva/riva_hw.c:1388:            chip->Tri03 = NULL;
./drivers/video/fbdev/riva/riva_hw.c:1389:            chip->Tri05 = (RivaTexturedTriangle05 __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1399:            chip->Tri03 = NULL;
./drivers/video/fbdev/riva/riva_hw.c:1400:            chip->Tri05 = (RivaTexturedTriangle05 __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1417:    switch (chip->Architecture)
./drivers/video/fbdev/riva/riva_hw.c:1423:            NV_WR32(chip->PFB, 0x00000200, state->config);
./drivers/video/fbdev/riva/riva_hw.c:1433:                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1439:                    chip->Tri03 = NULL;
./drivers/video/fbdev/riva/riva_hw.c:1445:                    chip->Tri03 = NULL;
./drivers/video/fbdev/riva/riva_hw.c:1449:                NV_WR32(&chip->PRAMIN[0x00000502 + i], 0, (i << 12) | 0x03);
./drivers/video/fbdev/riva/riva_hw.c:1450:            NV_WR32(chip->PGRAPH, 0x00000630, state->offset0);
./drivers/video/fbdev/riva/riva_hw.c:1451:            NV_WR32(chip->PGRAPH, 0x00000634, state->offset1);
./drivers/video/fbdev/riva/riva_hw.c:1452:            NV_WR32(chip->PGRAPH, 0x00000638, state->offset2);
./drivers/video/fbdev/riva/riva_hw.c:1453:            NV_WR32(chip->PGRAPH, 0x0000063C, state->offset3);
./drivers/video/fbdev/riva/riva_hw.c:1454:            NV_WR32(chip->PGRAPH, 0x00000650, state->pitch0);
./drivers/video/fbdev/riva/riva_hw.c:1455:            NV_WR32(chip->PGRAPH, 0x00000654, state->pitch1);
./drivers/video/fbdev/riva/riva_hw.c:1456:            NV_WR32(chip->PGRAPH, 0x00000658, state->pitch2);
./drivers/video/fbdev/riva/riva_hw.c:1457:            NV_WR32(chip->PGRAPH, 0x0000065C, state->pitch3);
./drivers/video/fbdev/riva/riva_hw.c:1463:            NV_WR32(chip->PFB, 0x00000200, state->config);
./drivers/video/fbdev/riva/riva_hw.c:1472:                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1477:                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1483:                    chip->Tri03 = NULL;
./drivers/video/fbdev/riva/riva_hw.c:1489:                    chip->Tri03 = NULL;
./drivers/video/fbdev/riva/riva_hw.c:1492:            NV_WR32(chip->PGRAPH, 0x00000640, state->offset0);
./drivers/video/fbdev/riva/riva_hw.c:1493:            NV_WR32(chip->PGRAPH, 0x00000644, state->offset1);
./drivers/video/fbdev/riva/riva_hw.c:1494:            NV_WR32(chip->PGRAPH, 0x00000648, state->offset2);
./drivers/video/fbdev/riva/riva_hw.c:1495:            NV_WR32(chip->PGRAPH, 0x0000064C, state->offset3);
./drivers/video/fbdev/riva/riva_hw.c:1496:            NV_WR32(chip->PGRAPH, 0x00000670, state->pitch0);
./drivers/video/fbdev/riva/riva_hw.c:1497:            NV_WR32(chip->PGRAPH, 0x00000674, state->pitch1);
./drivers/video/fbdev/riva/riva_hw.c:1498:            NV_WR32(chip->PGRAPH, 0x00000678, state->pitch2);
./drivers/video/fbdev/riva/riva_hw.c:1499:            NV_WR32(chip->PGRAPH, 0x0000067C, state->pitch3);
./drivers/video/fbdev/riva/riva_hw.c:1504:            if(chip->twoHeads) {
./drivers/video/fbdev/riva/riva_hw.c:1505:               VGA_WR08(chip->PCIO, 0x03D4, 0x44);
./drivers/video/fbdev/riva/riva_hw.c:1506:               VGA_WR08(chip->PCIO, 0x03D5, state->crtcOwner);
./drivers/video/fbdev/riva/riva_hw.c:1507:               chip->LockUnlock(chip, 0);
./drivers/video/fbdev/riva/riva_hw.c:1518:                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1523:                    chip->Tri03 = (RivaTexturedTriangle03  __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1529:                    chip->Tri03 = NULL;
./drivers/video/fbdev/riva/riva_hw.c:1535:                    chip->Tri03 = NULL;
./drivers/video/fbdev/riva/riva_hw.c:1539:            if(chip->Architecture == NV_ARCH_10) {
./drivers/video/fbdev/riva/riva_hw.c:1540:                NV_WR32(chip->PGRAPH, 0x00000640, state->offset0);
./drivers/video/fbdev/riva/riva_hw.c:1541:                NV_WR32(chip->PGRAPH, 0x00000644, state->offset1);
./drivers/video/fbdev/riva/riva_hw.c:1542:                NV_WR32(chip->PGRAPH, 0x00000648, state->offset2);
./drivers/video/fbdev/riva/riva_hw.c:1543:                NV_WR32(chip->PGRAPH, 0x0000064C, state->offset3);
./drivers/video/fbdev/riva/riva_hw.c:1544:                NV_WR32(chip->PGRAPH, 0x00000670, state->pitch0);
./drivers/video/fbdev/riva/riva_hw.c:1545:                NV_WR32(chip->PGRAPH, 0x00000674, state->pitch1);
./drivers/video/fbdev/riva/riva_hw.c:1546:                NV_WR32(chip->PGRAPH, 0x00000678, state->pitch2);
./drivers/video/fbdev/riva/riva_hw.c:1547:                NV_WR32(chip->PGRAPH, 0x0000067C, state->pitch3);
./drivers/video/fbdev/riva/riva_hw.c:1548:                NV_WR32(chip->PGRAPH, 0x00000680, state->pitch3);
./drivers/video/fbdev/riva/riva_hw.c:1550:        NV_WR32(chip->PGRAPH, 0x00000820, state->offset0);
./drivers/video/fbdev/riva/riva_hw.c:1551:        NV_WR32(chip->PGRAPH, 0x00000824, state->offset1);
./drivers/video/fbdev/riva/riva_hw.c:1552:        NV_WR32(chip->PGRAPH, 0x00000828, state->offset2);
./drivers/video/fbdev/riva/riva_hw.c:1553:        NV_WR32(chip->PGRAPH, 0x0000082C, state->offset3);
./drivers/video/fbdev/riva/riva_hw.c:1554:        NV_WR32(chip->PGRAPH, 0x00000850, state->pitch0);
./drivers/video/fbdev/riva/riva_hw.c:1555:        NV_WR32(chip->PGRAPH, 0x00000854, state->pitch1);
./drivers/video/fbdev/riva/riva_hw.c:1556:        NV_WR32(chip->PGRAPH, 0x00000858, state->pitch2);
./drivers/video/fbdev/riva/riva_hw.c:1557:        NV_WR32(chip->PGRAPH, 0x0000085C, state->pitch3);
./drivers/video/fbdev/riva/riva_hw.c:1558:        NV_WR32(chip->PGRAPH, 0x00000860, state->pitch3);
./drivers/video/fbdev/riva/riva_hw.c:1559:        NV_WR32(chip->PGRAPH, 0x00000864, state->pitch3);
./drivers/video/fbdev/riva/riva_hw.c:1560:        NV_WR32(chip->PGRAPH, 0x000009A4, NV_RD32(chip->PFB, 0x00000200));
./drivers/video/fbdev/riva/riva_hw.c:1561:        NV_WR32(chip->PGRAPH, 0x000009A8, NV_RD32(chip->PFB, 0x00000204));
./drivers/video/fbdev/riva/riva_hw.c:1563:            if(chip->twoHeads) {
./drivers/video/fbdev/riva/riva_hw.c:1564:               NV_WR32(chip->PCRTC0, 0x00000860, state->head);
./drivers/video/fbdev/riva/riva_hw.c:1565:               NV_WR32(chip->PCRTC0, 0x00002860, state->head2);
./drivers/video/fbdev/riva/riva_hw.c:1567:            NV_WR32(chip->PRAMDAC, 0x00000404, NV_RD32(chip->PRAMDAC, 0x00000404) | (1 << 25));
./drivers/video/fbdev/riva/riva_hw.c:1569:            NV_WR32(chip->PMC, 0x00008704, 1);
./drivers/video/fbdev/riva/riva_hw.c:1570:            NV_WR32(chip->PMC, 0x00008140, 0);
./drivers/video/fbdev/riva/riva_hw.c:1571:            NV_WR32(chip->PMC, 0x00008920, 0);
./drivers/video/fbdev/riva/riva_hw.c:1572:            NV_WR32(chip->PMC, 0x00008924, 0);
./drivers/video/fbdev/riva/riva_hw.c:1573:            NV_WR32(chip->PMC, 0x00008908, 0x01ffffff);
./drivers/video/fbdev/riva/riva_hw.c:1574:            NV_WR32(chip->PMC, 0x0000890C, 0x01ffffff);
./drivers/video/fbdev/riva/riva_hw.c:1575:            NV_WR32(chip->PMC, 0x00001588, 0);
./drivers/video/fbdev/riva/riva_hw.c:1577:            NV_WR32(chip->PFB, 0x00000240, 0);
./drivers/video/fbdev/riva/riva_hw.c:1578:            NV_WR32(chip->PFB, 0x00000250, 0);
./drivers/video/fbdev/riva/riva_hw.c:1579:            NV_WR32(chip->PFB, 0x00000260, 0);
./drivers/video/fbdev/riva/riva_hw.c:1580:            NV_WR32(chip->PFB, 0x00000270, 0);
./drivers/video/fbdev/riva/riva_hw.c:1581:            NV_WR32(chip->PFB, 0x00000280, 0);
./drivers/video/fbdev/riva/riva_hw.c:1582:            NV_WR32(chip->PFB, 0x00000290, 0);
./drivers/video/fbdev/riva/riva_hw.c:1583:            NV_WR32(chip->PFB, 0x000002A0, 0);
./drivers/video/fbdev/riva/riva_hw.c:1584:            NV_WR32(chip->PFB, 0x000002B0, 0);
./drivers/video/fbdev/riva/riva_hw.c:1586:            NV_WR32(chip->PGRAPH, 0x00000B00, NV_RD32(chip->PFB, 0x00000240));
./drivers/video/fbdev/riva/riva_hw.c:1587:            NV_WR32(chip->PGRAPH, 0x00000B04, NV_RD32(chip->PFB, 0x00000244));
./drivers/video/fbdev/riva/riva_hw.c:1588:            NV_WR32(chip->PGRAPH, 0x00000B08, NV_RD32(chip->PFB, 0x00000248));
./drivers/video/fbdev/riva/riva_hw.c:1589:            NV_WR32(chip->PGRAPH, 0x00000B0C, NV_RD32(chip->PFB, 0x0000024C));
./drivers/video/fbdev/riva/riva_hw.c:1590:            NV_WR32(chip->PGRAPH, 0x00000B10, NV_RD32(chip->PFB, 0x00000250));
./drivers/video/fbdev/riva/riva_hw.c:1591:            NV_WR32(chip->PGRAPH, 0x00000B14, NV_RD32(chip->PFB, 0x00000254));
./drivers/video/fbdev/riva/riva_hw.c:1592:            NV_WR32(chip->PGRAPH, 0x00000B18, NV_RD32(chip->PFB, 0x00000258));
./drivers/video/fbdev/riva/riva_hw.c:1593:            NV_WR32(chip->PGRAPH, 0x00000B1C, NV_RD32(chip->PFB, 0x0000025C));
./drivers/video/fbdev/riva/riva_hw.c:1594:            NV_WR32(chip->PGRAPH, 0x00000B20, NV_RD32(chip->PFB, 0x00000260));
./drivers/video/fbdev/riva/riva_hw.c:1595:            NV_WR32(chip->PGRAPH, 0x00000B24, NV_RD32(chip->PFB, 0x00000264));
./drivers/video/fbdev/riva/riva_hw.c:1596:            NV_WR32(chip->PGRAPH, 0x00000B28, NV_RD32(chip->PFB, 0x00000268));
./drivers/video/fbdev/riva/riva_hw.c:1597:            NV_WR32(chip->PGRAPH, 0x00000B2C, NV_RD32(chip->PFB, 0x0000026C));
./drivers/video/fbdev/riva/riva_hw.c:1598:            NV_WR32(chip->PGRAPH, 0x00000B30, NV_RD32(chip->PFB, 0x00000270));
./drivers/video/fbdev/riva/riva_hw.c:1599:            NV_WR32(chip->PGRAPH, 0x00000B34, NV_RD32(chip->PFB, 0x00000274));
./drivers/video/fbdev/riva/riva_hw.c:1600:            NV_WR32(chip->PGRAPH, 0x00000B38, NV_RD32(chip->PFB, 0x00000278));
./drivers/video/fbdev/riva/riva_hw.c:1601:            NV_WR32(chip->PGRAPH, 0x00000B3C, NV_RD32(chip->PFB, 0x0000027C));
./drivers/video/fbdev/riva/riva_hw.c:1602:            NV_WR32(chip->PGRAPH, 0x00000B40, NV_RD32(chip->PFB, 0x00000280));
./drivers/video/fbdev/riva/riva_hw.c:1603:            NV_WR32(chip->PGRAPH, 0x00000B44, NV_RD32(chip->PFB, 0x00000284));
./drivers/video/fbdev/riva/riva_hw.c:1604:            NV_WR32(chip->PGRAPH, 0x00000B48, NV_RD32(chip->PFB, 0x00000288));
./drivers/video/fbdev/riva/riva_hw.c:1605:            NV_WR32(chip->PGRAPH, 0x00000B4C, NV_RD32(chip->PFB, 0x0000028C));
./drivers/video/fbdev/riva/riva_hw.c:1606:            NV_WR32(chip->PGRAPH, 0x00000B50, NV_RD32(chip->PFB, 0x00000290));
./drivers/video/fbdev/riva/riva_hw.c:1607:            NV_WR32(chip->PGRAPH, 0x00000B54, NV_RD32(chip->PFB, 0x00000294));
./drivers/video/fbdev/riva/riva_hw.c:1608:            NV_WR32(chip->PGRAPH, 0x00000B58, NV_RD32(chip->PFB, 0x00000298));
./drivers/video/fbdev/riva/riva_hw.c:1609:            NV_WR32(chip->PGRAPH, 0x00000B5C, NV_RD32(chip->PFB, 0x0000029C));
./drivers/video/fbdev/riva/riva_hw.c:1610:            NV_WR32(chip->PGRAPH, 0x00000B60, NV_RD32(chip->PFB, 0x000002A0));
./drivers/video/fbdev/riva/riva_hw.c:1611:            NV_WR32(chip->PGRAPH, 0x00000B64, NV_RD32(chip->PFB, 0x000002A4));
./drivers/video/fbdev/riva/riva_hw.c:1612:            NV_WR32(chip->PGRAPH, 0x00000B68, NV_RD32(chip->PFB, 0x000002A8));
./drivers/video/fbdev/riva/riva_hw.c:1613:            NV_WR32(chip->PGRAPH, 0x00000B6C, NV_RD32(chip->PFB, 0x000002AC));
./drivers/video/fbdev/riva/riva_hw.c:1614:            NV_WR32(chip->PGRAPH, 0x00000B70, NV_RD32(chip->PFB, 0x000002B0));
./drivers/video/fbdev/riva/riva_hw.c:1615:            NV_WR32(chip->PGRAPH, 0x00000B74, NV_RD32(chip->PFB, 0x000002B4));
./drivers/video/fbdev/riva/riva_hw.c:1616:            NV_WR32(chip->PGRAPH, 0x00000B78, NV_RD32(chip->PFB, 0x000002B8));
./drivers/video/fbdev/riva/riva_hw.c:1617:            NV_WR32(chip->PGRAPH, 0x00000B7C, NV_RD32(chip->PFB, 0x000002BC));
./drivers/video/fbdev/riva/riva_hw.c:1618:            NV_WR32(chip->PGRAPH, 0x00000F40, 0x10000000);
./drivers/video/fbdev/riva/riva_hw.c:1619:            NV_WR32(chip->PGRAPH, 0x00000F44, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1620:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);
./drivers/video/fbdev/riva/riva_hw.c:1621:            NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000008);
./drivers/video/fbdev/riva/riva_hw.c:1622:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000200);
./drivers/video/fbdev/riva/riva_hw.c:1624:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1625:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);
./drivers/video/fbdev/riva/riva_hw.c:1626:            NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1627:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000800);
./drivers/video/fbdev/riva/riva_hw.c:1629:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1630:            NV_WR32(chip->PGRAPH, 0x00000F40, 0x30000000);
./drivers/video/fbdev/riva/riva_hw.c:1631:            NV_WR32(chip->PGRAPH, 0x00000F44, 0x00000004);
./drivers/video/fbdev/riva/riva_hw.c:1632:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00006400);
./drivers/video/fbdev/riva/riva_hw.c:1634:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1635:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00006800);
./drivers/video/fbdev/riva/riva_hw.c:1637:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1638:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00006C00);
./drivers/video/fbdev/riva/riva_hw.c:1640:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1641:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00007000);
./drivers/video/fbdev/riva/riva_hw.c:1643:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1644:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00007400);
./drivers/video/fbdev/riva/riva_hw.c:1646:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1647:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00007800);
./drivers/video/fbdev/riva/riva_hw.c:1649:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1650:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00004400);
./drivers/video/fbdev/riva/riva_hw.c:1652:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1653:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1655:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1656:            NV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);
./drivers/video/fbdev/riva/riva_hw.c:1658:                NV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);
./drivers/video/fbdev/riva/riva_hw.c:1660:            NV_WR32(chip->PCRTC, 0x00000810, state->cursorConfig);
./drivers/video/fbdev/riva/riva_hw.c:1662:            if(chip->flatPanel) {
./drivers/video/fbdev/riva/riva_hw.c:1663:               if((chip->Chipset & 0x0ff0) == 0x0110) {
./drivers/video/fbdev/riva/riva_hw.c:1664:                   NV_WR32(chip->PRAMDAC, 0x0528, state->dither);
./drivers/video/fbdev/riva/riva_hw.c:1666:               if((chip->Chipset & 0x0ff0) >= 0x0170) {
./drivers/video/fbdev/riva/riva_hw.c:1667:                   NV_WR32(chip->PRAMDAC, 0x083C, state->dither);
./drivers/video/fbdev/riva/riva_hw.c:1670:               VGA_WR08(chip->PCIO, 0x03D4, 0x53);
./drivers/video/fbdev/riva/riva_hw.c:1671:               VGA_WR08(chip->PCIO, 0x03D5, 0);
./drivers/video/fbdev/riva/riva_hw.c:1672:               VGA_WR08(chip->PCIO, 0x03D4, 0x54);
./drivers/video/fbdev/riva/riva_hw.c:1673:               VGA_WR08(chip->PCIO, 0x03D5, 0);
./drivers/video/fbdev/riva/riva_hw.c:1674:               VGA_WR08(chip->PCIO, 0x03D4, 0x21);
./drivers/video/fbdev/riva/riva_hw.c:1675:               VGA_WR08(chip->PCIO, 0x03D5, 0xfa);
./drivers/video/fbdev/riva/riva_hw.c:1678:            VGA_WR08(chip->PCIO, 0x03D4, 0x41);
./drivers/video/fbdev/riva/riva_hw.c:1679:            VGA_WR08(chip->PCIO, 0x03D5, state->extra);
./drivers/video/fbdev/riva/riva_hw.c:1686:    VGA_WR08(chip->PCIO, 0x03D4, 0x19);
./drivers/video/fbdev/riva/riva_hw.c:1687:    VGA_WR08(chip->PCIO, 0x03D5, state->repaint0);
./drivers/video/fbdev/riva/riva_hw.c:1688:    VGA_WR08(chip->PCIO, 0x03D4, 0x1A);
./drivers/video/fbdev/riva/riva_hw.c:1689:    VGA_WR08(chip->PCIO, 0x03D5, state->repaint1);
./drivers/video/fbdev/riva/riva_hw.c:1690:    VGA_WR08(chip->PCIO, 0x03D4, 0x25);
./drivers/video/fbdev/riva/riva_hw.c:1691:    VGA_WR08(chip->PCIO, 0x03D5, state->screen);
./drivers/video/fbdev/riva/riva_hw.c:1692:    VGA_WR08(chip->PCIO, 0x03D4, 0x28);
./drivers/video/fbdev/riva/riva_hw.c:1693:    VGA_WR08(chip->PCIO, 0x03D5, state->pixel);
./drivers/video/fbdev/riva/riva_hw.c:1694:    VGA_WR08(chip->PCIO, 0x03D4, 0x2D);
./drivers/video/fbdev/riva/riva_hw.c:1695:    VGA_WR08(chip->PCIO, 0x03D5, state->horiz);
./drivers/video/fbdev/riva/riva_hw.c:1696:    VGA_WR08(chip->PCIO, 0x03D4, 0x1B);
./drivers/video/fbdev/riva/riva_hw.c:1697:    VGA_WR08(chip->PCIO, 0x03D5, state->arbitration0);
./drivers/video/fbdev/riva/riva_hw.c:1698:    VGA_WR08(chip->PCIO, 0x03D4, 0x20);
./drivers/video/fbdev/riva/riva_hw.c:1699:    VGA_WR08(chip->PCIO, 0x03D5, state->arbitration1);
./drivers/video/fbdev/riva/riva_hw.c:1700:    VGA_WR08(chip->PCIO, 0x03D4, 0x30);
./drivers/video/fbdev/riva/riva_hw.c:1701:    VGA_WR08(chip->PCIO, 0x03D5, state->cursor0);
./drivers/video/fbdev/riva/riva_hw.c:1702:    VGA_WR08(chip->PCIO, 0x03D4, 0x31);
./drivers/video/fbdev/riva/riva_hw.c:1703:    VGA_WR08(chip->PCIO, 0x03D5, state->cursor1);
./drivers/video/fbdev/riva/riva_hw.c:1704:    VGA_WR08(chip->PCIO, 0x03D4, 0x2F);
./drivers/video/fbdev/riva/riva_hw.c:1705:    VGA_WR08(chip->PCIO, 0x03D5, state->cursor2);
./drivers/video/fbdev/riva/riva_hw.c:1706:    VGA_WR08(chip->PCIO, 0x03D4, 0x39);
./drivers/video/fbdev/riva/riva_hw.c:1707:    VGA_WR08(chip->PCIO, 0x03D5, state->interlace);
./drivers/video/fbdev/riva/riva_hw.c:1709:    if(!chip->flatPanel) {
./drivers/video/fbdev/riva/riva_hw.c:1710:       NV_WR32(chip->PRAMDAC0, 0x00000508, state->vpll);
./drivers/video/fbdev/riva/riva_hw.c:1711:       NV_WR32(chip->PRAMDAC0, 0x0000050C, state->pllsel);
./drivers/video/fbdev/riva/riva_hw.c:1712:       if(chip->twoHeads)
./drivers/video/fbdev/riva/riva_hw.c:1713:          NV_WR32(chip->PRAMDAC0, 0x00000520, state->vpll2);
./drivers/video/fbdev/riva/riva_hw.c:1715:       NV_WR32(chip->PRAMDAC, 0x00000848 , state->scale);
./drivers/video/fbdev/riva/riva_hw.c:1717:    NV_WR32(chip->PRAMDAC, 0x00000600 , state->general);
./drivers/video/fbdev/riva/riva_hw.c:1722:    NV_WR32(chip->PCRTC, 0x00000140, 0);
./drivers/video/fbdev/riva/riva_hw.c:1723:    NV_WR32(chip->PCRTC, 0x00000100, chip->VBlankBit);
./drivers/video/fbdev/riva/riva_hw.c:1727:    NV_WR32(chip->PMC, 0x00000140, chip->EnableIRQ & 0x01);
./drivers/video/fbdev/riva/riva_hw.c:1731:    chip->CurrentState = state;
./drivers/video/fbdev/riva/riva_hw.c:1735:    chip->FifoFreeCount  = 0;
./drivers/video/fbdev/riva/riva_hw.c:1737:    chip->FifoEmptyCount = NV_RD32(&chip->Rop->FifoFree, 0);
./drivers/video/fbdev/riva/riva_hw.c:1748:    VGA_WR08(chip->PCIO, 0x03D4, 0x19);
./drivers/video/fbdev/riva/riva_hw.c:1749:    state->repaint0     = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1750:    VGA_WR08(chip->PCIO, 0x03D4, 0x1A);
./drivers/video/fbdev/riva/riva_hw.c:1751:    state->repaint1     = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1752:    VGA_WR08(chip->PCIO, 0x03D4, 0x25);
./drivers/video/fbdev/riva/riva_hw.c:1753:    state->screen       = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1754:    VGA_WR08(chip->PCIO, 0x03D4, 0x28);
./drivers/video/fbdev/riva/riva_hw.c:1755:    state->pixel        = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1756:    VGA_WR08(chip->PCIO, 0x03D4, 0x2D);
./drivers/video/fbdev/riva/riva_hw.c:1757:    state->horiz        = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1758:    VGA_WR08(chip->PCIO, 0x03D4, 0x1B);
./drivers/video/fbdev/riva/riva_hw.c:1759:    state->arbitration0 = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1760:    VGA_WR08(chip->PCIO, 0x03D4, 0x20);
./drivers/video/fbdev/riva/riva_hw.c:1761:    state->arbitration1 = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1762:    VGA_WR08(chip->PCIO, 0x03D4, 0x30);
./drivers/video/fbdev/riva/riva_hw.c:1763:    state->cursor0      = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1764:    VGA_WR08(chip->PCIO, 0x03D4, 0x31);
./drivers/video/fbdev/riva/riva_hw.c:1765:    state->cursor1      = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1766:    VGA_WR08(chip->PCIO, 0x03D4, 0x2F);
./drivers/video/fbdev/riva/riva_hw.c:1767:    state->cursor2      = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1768:    VGA_WR08(chip->PCIO, 0x03D4, 0x39);
./drivers/video/fbdev/riva/riva_hw.c:1769:    state->interlace    = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1770:    state->vpll         = NV_RD32(chip->PRAMDAC0, 0x00000508);
./drivers/video/fbdev/riva/riva_hw.c:1771:    state->vpll2        = NV_RD32(chip->PRAMDAC0, 0x00000520);
./drivers/video/fbdev/riva/riva_hw.c:1772:    state->pllsel       = NV_RD32(chip->PRAMDAC0, 0x0000050C);
./drivers/video/fbdev/riva/riva_hw.c:1773:    state->general      = NV_RD32(chip->PRAMDAC, 0x00000600);
./drivers/video/fbdev/riva/riva_hw.c:1774:    state->scale        = NV_RD32(chip->PRAMDAC, 0x00000848);
./drivers/video/fbdev/riva/riva_hw.c:1775:    state->config       = NV_RD32(chip->PFB, 0x00000200);
./drivers/video/fbdev/riva/riva_hw.c:1776:    switch (chip->Architecture)
./drivers/video/fbdev/riva/riva_hw.c:1779:            state->offset0  = NV_RD32(chip->PGRAPH, 0x00000630);
./drivers/video/fbdev/riva/riva_hw.c:1780:            state->offset1  = NV_RD32(chip->PGRAPH, 0x00000634);
./drivers/video/fbdev/riva/riva_hw.c:1781:            state->offset2  = NV_RD32(chip->PGRAPH, 0x00000638);
./drivers/video/fbdev/riva/riva_hw.c:1782:            state->offset3  = NV_RD32(chip->PGRAPH, 0x0000063C);
./drivers/video/fbdev/riva/riva_hw.c:1783:            state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000650);
./drivers/video/fbdev/riva/riva_hw.c:1784:            state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000654);
./drivers/video/fbdev/riva/riva_hw.c:1785:            state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000658);
./drivers/video/fbdev/riva/riva_hw.c:1786:            state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000065C);
./drivers/video/fbdev/riva/riva_hw.c:1789:            state->offset0  = NV_RD32(chip->PGRAPH, 0x00000640);
./drivers/video/fbdev/riva/riva_hw.c:1790:            state->offset1  = NV_RD32(chip->PGRAPH, 0x00000644);
./drivers/video/fbdev/riva/riva_hw.c:1791:            state->offset2  = NV_RD32(chip->PGRAPH, 0x00000648);
./drivers/video/fbdev/riva/riva_hw.c:1792:            state->offset3  = NV_RD32(chip->PGRAPH, 0x0000064C);
./drivers/video/fbdev/riva/riva_hw.c:1793:            state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000670);
./drivers/video/fbdev/riva/riva_hw.c:1794:            state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000674);
./drivers/video/fbdev/riva/riva_hw.c:1795:            state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000678);
./drivers/video/fbdev/riva/riva_hw.c:1796:            state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000067C);
./drivers/video/fbdev/riva/riva_hw.c:1801:            state->offset0  = NV_RD32(chip->PGRAPH, 0x00000640);
./drivers/video/fbdev/riva/riva_hw.c:1802:            state->offset1  = NV_RD32(chip->PGRAPH, 0x00000644);
./drivers/video/fbdev/riva/riva_hw.c:1803:            state->offset2  = NV_RD32(chip->PGRAPH, 0x00000648);
./drivers/video/fbdev/riva/riva_hw.c:1804:            state->offset3  = NV_RD32(chip->PGRAPH, 0x0000064C);
./drivers/video/fbdev/riva/riva_hw.c:1805:            state->pitch0   = NV_RD32(chip->PGRAPH, 0x00000670);
./drivers/video/fbdev/riva/riva_hw.c:1806:            state->pitch1   = NV_RD32(chip->PGRAPH, 0x00000674);
./drivers/video/fbdev/riva/riva_hw.c:1807:            state->pitch2   = NV_RD32(chip->PGRAPH, 0x00000678);
./drivers/video/fbdev/riva/riva_hw.c:1808:            state->pitch3   = NV_RD32(chip->PGRAPH, 0x0000067C);
./drivers/video/fbdev/riva/riva_hw.c:1809:            if(chip->twoHeads) {
./drivers/video/fbdev/riva/riva_hw.c:1810:               state->head     = NV_RD32(chip->PCRTC0, 0x00000860);
./drivers/video/fbdev/riva/riva_hw.c:1811:               state->head2    = NV_RD32(chip->PCRTC0, 0x00002860);
./drivers/video/fbdev/riva/riva_hw.c:1812:               VGA_WR08(chip->PCIO, 0x03D4, 0x44);
./drivers/video/fbdev/riva/riva_hw.c:1813:               state->crtcOwner = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1815:            VGA_WR08(chip->PCIO, 0x03D4, 0x41);
./drivers/video/fbdev/riva/riva_hw.c:1816:            state->extra = VGA_RD08(chip->PCIO, 0x03D5);
./drivers/video/fbdev/riva/riva_hw.c:1817:            state->cursorConfig = NV_RD32(chip->PCRTC, 0x00000810);
./drivers/video/fbdev/riva/riva_hw.c:1819:            if((chip->Chipset & 0x0ff0) == 0x0110) {
./drivers/video/fbdev/riva/riva_hw.c:1820:                state->dither = NV_RD32(chip->PRAMDAC, 0x0528);
./drivers/video/fbdev/riva/riva_hw.c:1822:            if((chip->Chipset & 0x0ff0) >= 0x0170) {
./drivers/video/fbdev/riva/riva_hw.c:1823:                state->dither = NV_RD32(chip->PRAMDAC, 0x083C);
./drivers/video/fbdev/riva/riva_hw.c:1834:    NV_WR32(chip->PCRTC, 0x800, start);
./drivers/video/fbdev/riva/riva_hw.c:1850:    chip->LockUnlock(chip, 0);
./drivers/video/fbdev/riva/riva_hw.c:1854:    VGA_WR08(chip->PCIO, 0x3D4, 0x0D); VGA_WR08(chip->PCIO, 0x3D5, offset);
./drivers/video/fbdev/riva/riva_hw.c:1856:    VGA_WR08(chip->PCIO, 0x3D4, 0x0C); VGA_WR08(chip->PCIO, 0x3D5, offset);
./drivers/video/fbdev/riva/riva_hw.c:1858:    VGA_WR08(chip->PCIO, 0x3D4, 0x19); tmp = VGA_RD08(chip->PCIO, 0x3D5);
./drivers/video/fbdev/riva/riva_hw.c:1859:    VGA_WR08(chip->PCIO, 0x3D5, (offset & 0x01F) | (tmp & ~0x1F));
./drivers/video/fbdev/riva/riva_hw.c:1860:    VGA_WR08(chip->PCIO, 0x3D4, 0x2D); tmp = VGA_RD08(chip->PCIO, 0x3D5);
./drivers/video/fbdev/riva/riva_hw.c:1861:    VGA_WR08(chip->PCIO, 0x3D5, (offset & 0x60) | (tmp & ~0x60));
./drivers/video/fbdev/riva/riva_hw.c:1865:    offset = VGA_RD08(chip->PCIO, chip->IO + 0x0A);
./drivers/video/fbdev/riva/riva_hw.c:1866:    VGA_WR08(chip->PCIO, 0x3C0, 0x13);
./drivers/video/fbdev/riva/riva_hw.c:1867:    VGA_WR08(chip->PCIO, 0x3C0, pan);
./drivers/video/fbdev/riva/riva_hw.c:1877:	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1880:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);
./drivers/video/fbdev/riva/riva_hw.c:1882:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);
./drivers/video/fbdev/riva/riva_hw.c:1884:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000013);
./drivers/video/fbdev/riva/riva_hw.c:1894:	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1896:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);
./drivers/video/fbdev/riva/riva_hw.c:1898:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);
./drivers/video/fbdev/riva/riva_hw.c:1900:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);
./drivers/video/fbdev/riva/riva_hw.c:1910:	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1912:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);
./drivers/video/fbdev/riva/riva_hw.c:1914:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);
./drivers/video/fbdev/riva/riva_hw.c:1916:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);
./drivers/video/fbdev/riva/riva_hw.c:1926:	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1929:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000005);
./drivers/video/fbdev/riva/riva_hw.c:1931:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000006);
./drivers/video/fbdev/riva/riva_hw.c:1933:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000013);
./drivers/video/fbdev/riva/riva_hw.c:1943:	(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1945:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000005);
./drivers/video/fbdev/riva/riva_hw.c:1947:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000006);
./drivers/video/fbdev/riva/riva_hw.c:1949:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);
./drivers/video/fbdev/riva/riva_hw.c:1959:	(RivaSurface3D __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/riva_hw.c:1962:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000007);
./drivers/video/fbdev/riva/riva_hw.c:1965:    NV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);
./drivers/video/fbdev/riva/riva_hw.c:1982:    if (NV_RD32(&chip->PFB[0x00000000/4], 0) & 0x00000020)
./drivers/video/fbdev/riva/riva_hw.c:1984:        if (((NV_RD32(chip->PMC, 0x00000000) & 0xF0) == 0x20)
./drivers/video/fbdev/riva/riva_hw.c:1985:         && ((NV_RD32(chip->PMC, 0x00000000) & 0x0F) >= 0x02))
./drivers/video/fbdev/riva/riva_hw.c:1990:            chip->RamBandwidthKBytesPerSec = 800000;
./drivers/video/fbdev/riva/riva_hw.c:1991:            switch (NV_RD32(chip->PFB, 0x00000000) & 0x03)
./drivers/video/fbdev/riva/riva_hw.c:1994:                    chip->RamAmountKBytes = 1024 * 4;
./drivers/video/fbdev/riva/riva_hw.c:1997:                    chip->RamAmountKBytes = 1024 * 2;
./drivers/video/fbdev/riva/riva_hw.c:2000:                    chip->RamAmountKBytes = 1024 * 8;
./drivers/video/fbdev/riva/riva_hw.c:2006:            chip->RamBandwidthKBytesPerSec = 1000000;
./drivers/video/fbdev/riva/riva_hw.c:2007:            chip->RamAmountKBytes          = 1024 * 8;
./drivers/video/fbdev/riva/riva_hw.c:2015:        chip->RamBandwidthKBytesPerSec = 1000000;
./drivers/video/fbdev/riva/riva_hw.c:2016:        switch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003)
./drivers/video/fbdev/riva/riva_hw.c:2019:                chip->RamAmountKBytes = 1024 * 8;
./drivers/video/fbdev/riva/riva_hw.c:2022:                chip->RamAmountKBytes = 1024 * 4;
./drivers/video/fbdev/riva/riva_hw.c:2025:                chip->RamAmountKBytes = 1024 * 2;
./drivers/video/fbdev/riva/riva_hw.c:2029:    chip->CrystalFreqKHz   = (NV_RD32(chip->PEXTDEV, 0x00000000) & 0x00000040) ? 14318 : 13500;
./drivers/video/fbdev/riva/riva_hw.c:2030:    chip->CURSOR           = &(chip->PRAMIN[0x00008000/4 - 0x0800/4]);
./drivers/video/fbdev/riva/riva_hw.c:2031:    chip->VBlankBit        = 0x00000100;
./drivers/video/fbdev/riva/riva_hw.c:2032:    chip->MaxVClockFreqKHz = 256000;
./drivers/video/fbdev/riva/riva_hw.c:2036:    chip->Busy            = nv3Busy;
./drivers/video/fbdev/riva/riva_hw.c:2037:    chip->ShowHideCursor  = ShowHideCursor;
./drivers/video/fbdev/riva/riva_hw.c:2038:    chip->LoadStateExt    = LoadStateExt;
./drivers/video/fbdev/riva/riva_hw.c:2039:    chip->UnloadStateExt  = UnloadStateExt;
./drivers/video/fbdev/riva/riva_hw.c:2040:    chip->SetStartAddress = SetStartAddress3;
./drivers/video/fbdev/riva/riva_hw.c:2041:    chip->SetSurfaces2D   = nv3SetSurfaces2D;
./drivers/video/fbdev/riva/riva_hw.c:2042:    chip->SetSurfaces3D   = nv3SetSurfaces3D;
./drivers/video/fbdev/riva/riva_hw.c:2043:    chip->LockUnlock      = nv3LockUnlock;
./drivers/video/fbdev/riva/riva_hw.c:2053:    if (NV_RD32(chip->PFB, 0x00000000) & 0x00000100)
./drivers/video/fbdev/riva/riva_hw.c:2055:        chip->RamAmountKBytes = ((NV_RD32(chip->PFB, 0x00000000) >> 12) & 0x0F) * 1024 * 2
./drivers/video/fbdev/riva/riva_hw.c:2060:        switch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003)
./drivers/video/fbdev/riva/riva_hw.c:2063:                chip->RamAmountKBytes = 1024 * 32;
./drivers/video/fbdev/riva/riva_hw.c:2066:                chip->RamAmountKBytes = 1024 * 4;
./drivers/video/fbdev/riva/riva_hw.c:2069:                chip->RamAmountKBytes = 1024 * 8;
./drivers/video/fbdev/riva/riva_hw.c:2073:                chip->RamAmountKBytes = 1024 * 16;
./drivers/video/fbdev/riva/riva_hw.c:2077:    switch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003)
./drivers/video/fbdev/riva/riva_hw.c:2080:            chip->RamBandwidthKBytesPerSec = 800000;
./drivers/video/fbdev/riva/riva_hw.c:2083:            chip->RamBandwidthKBytesPerSec = 1000000;
./drivers/video/fbdev/riva/riva_hw.c:2086:    chip->CrystalFreqKHz   = (NV_RD32(chip->PEXTDEV, 0x00000000) & 0x00000040) ? 14318 : 13500;
./drivers/video/fbdev/riva/riva_hw.c:2087:    chip->CURSOR           = &(chip->PRAMIN[0x00010000/4 - 0x0800/4]);
./drivers/video/fbdev/riva/riva_hw.c:2088:    chip->VBlankBit        = 0x00000001;
./drivers/video/fbdev/riva/riva_hw.c:2089:    chip->MaxVClockFreqKHz = 350000;
./drivers/video/fbdev/riva/riva_hw.c:2093:    chip->Busy            = nv4Busy;
./drivers/video/fbdev/riva/riva_hw.c:2094:    chip->ShowHideCursor  = ShowHideCursor;
./drivers/video/fbdev/riva/riva_hw.c:2095:    chip->LoadStateExt    = LoadStateExt;
./drivers/video/fbdev/riva/riva_hw.c:2096:    chip->UnloadStateExt  = UnloadStateExt;
./drivers/video/fbdev/riva/riva_hw.c:2097:    chip->SetStartAddress = SetStartAddress;
./drivers/video/fbdev/riva/riva_hw.c:2098:    chip->SetSurfaces2D   = nv4SetSurfaces2D;
./drivers/video/fbdev/riva/riva_hw.c:2099:    chip->SetSurfaces3D   = nv4SetSurfaces3D;
./drivers/video/fbdev/riva/riva_hw.c:2100:    chip->LockUnlock      = nv4LockUnlock;
./drivers/video/fbdev/riva/riva_hw.c:2113:    if(!(NV_RD32(chip->PMC, 0x00000004) & 0x01000001))
./drivers/video/fbdev/riva/riva_hw.c:2114:    	NV_WR32(chip->PMC, 0x00000004, 0x01000001);
./drivers/video/fbdev/riva/riva_hw.c:2124:        chip->RamAmountKBytes = (((amt >> 6) & 31) + 1) * 1024;
./drivers/video/fbdev/riva/riva_hw.c:2129:        chip->RamAmountKBytes = (((amt >> 4) & 127) + 1) * 1024;
./drivers/video/fbdev/riva/riva_hw.c:2131:        switch ((NV_RD32(chip->PFB, 0x0000020C) >> 20) & 0x000000FF)
./drivers/video/fbdev/riva/riva_hw.c:2134:                chip->RamAmountKBytes = 1024 * 2;
./drivers/video/fbdev/riva/riva_hw.c:2137:                chip->RamAmountKBytes = 1024 * 4;
./drivers/video/fbdev/riva/riva_hw.c:2140:                chip->RamAmountKBytes = 1024 * 8;
./drivers/video/fbdev/riva/riva_hw.c:2143:                chip->RamAmountKBytes = 1024 * 16;
./drivers/video/fbdev/riva/riva_hw.c:2146:                chip->RamAmountKBytes = 1024 * 32;
./drivers/video/fbdev/riva/riva_hw.c:2149:                chip->RamAmountKBytes = 1024 * 64;
./drivers/video/fbdev/riva/riva_hw.c:2152:                chip->RamAmountKBytes = 1024 * 128;
./drivers/video/fbdev/riva/riva_hw.c:2155:                chip->RamAmountKBytes = 1024 * 16;
./drivers/video/fbdev/riva/riva_hw.c:2159:    switch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003)
./drivers/video/fbdev/riva/riva_hw.c:2162:            chip->RamBandwidthKBytesPerSec = 800000;
./drivers/video/fbdev/riva/riva_hw.c:2165:            chip->RamBandwidthKBytesPerSec = 1000000;
./drivers/video/fbdev/riva/riva_hw.c:2168:    chip->CrystalFreqKHz = (NV_RD32(chip->PEXTDEV, 0x0000) & (1 << 6)) ?
./drivers/video/fbdev/riva/riva_hw.c:2182:       if(NV_RD32(chip->PEXTDEV, 0x0000) & (1 << 22))
./drivers/video/fbdev/riva/riva_hw.c:2183:           chip->CrystalFreqKHz = 27000;
./drivers/video/fbdev/riva/riva_hw.c:2189:    chip->CursorStart      = (chip->RamAmountKBytes - 128) * 1024;
./drivers/video/fbdev/riva/riva_hw.c:2190:    chip->CURSOR           = NULL;  /* can't set this here */
./drivers/video/fbdev/riva/riva_hw.c:2191:    chip->VBlankBit        = 0x00000001;
./drivers/video/fbdev/riva/riva_hw.c:2192:    chip->MaxVClockFreqKHz = 350000;
./drivers/video/fbdev/riva/riva_hw.c:2196:    chip->Busy            = nv10Busy;
./drivers/video/fbdev/riva/riva_hw.c:2197:    chip->ShowHideCursor  = ShowHideCursor;
./drivers/video/fbdev/riva/riva_hw.c:2198:    chip->LoadStateExt    = LoadStateExt;
./drivers/video/fbdev/riva/riva_hw.c:2199:    chip->UnloadStateExt  = UnloadStateExt;
./drivers/video/fbdev/riva/riva_hw.c:2200:    chip->SetStartAddress = SetStartAddress;
./drivers/video/fbdev/riva/riva_hw.c:2201:    chip->SetSurfaces2D   = nv10SetSurfaces2D;
./drivers/video/fbdev/riva/riva_hw.c:2202:    chip->SetSurfaces3D   = nv10SetSurfaces3D;
./drivers/video/fbdev/riva/riva_hw.c:2203:    chip->LockUnlock      = nv4LockUnlock;
./drivers/video/fbdev/riva/riva_hw.c:2217:        chip->twoHeads = TRUE;
./drivers/video/fbdev/riva/riva_hw.c:2220:        chip->twoHeads = FALSE;
./drivers/video/fbdev/riva/riva_hw.c:2233:    chip->Version = RIVA_SW_VERSION;
./drivers/video/fbdev/riva/riva_hw.c:2237:    switch (chip->Architecture)
./drivers/video/fbdev/riva/riva_hw.c:2253:    chip->Chipset = chipset;
./drivers/video/fbdev/riva/riva_hw.c:2257:    chip->Rop    = (RivaRop __iomem         *)&(chip->FIFO[0x00000000/4]);
./drivers/video/fbdev/riva/riva_hw.c:2258:    chip->Clip   = (RivaClip __iomem        *)&(chip->FIFO[0x00002000/4]);
./drivers/video/fbdev/riva/riva_hw.c:2259:    chip->Patt   = (RivaPattern __iomem     *)&(chip->FIFO[0x00004000/4]);
./drivers/video/fbdev/riva/riva_hw.c:2260:    chip->Pixmap = (RivaPixmap __iomem      *)&(chip->FIFO[0x00006000/4]);
./drivers/video/fbdev/riva/riva_hw.c:2261:    chip->Blt    = (RivaScreenBlt __iomem   *)&(chip->FIFO[0x00008000/4]);
./drivers/video/fbdev/riva/riva_hw.c:2262:    chip->Bitmap = (RivaBitmap __iomem      *)&(chip->FIFO[0x0000A000/4]);
./drivers/video/fbdev/riva/riva_hw.c:2263:    chip->Line   = (RivaLine __iomem        *)&(chip->FIFO[0x0000C000/4]);
./drivers/video/fbdev/riva/riva_hw.c:2264:    chip->Tri03  = (RivaTexturedTriangle03 __iomem *)&(chip->FIFO[0x0000E000/4]);
./drivers/video/fbdev/riva/fbdev.c:545:	VGA_WR08(chip->PDIO, 0x3c8, regnum);
./drivers/video/fbdev/riva/fbdev.c:546:	VGA_WR08(chip->PDIO, 0x3c9, red);
./drivers/video/fbdev/riva/fbdev.c:547:	VGA_WR08(chip->PDIO, 0x3c9, green);
./drivers/video/fbdev/riva/fbdev.c:548:	VGA_WR08(chip->PDIO, 0x3c9, blue);
./drivers/video/fbdev/riva/fbdev.c:570:	VGA_WR08(chip->PDIO, 0x3c7, regnum);
./drivers/video/fbdev/riva/fbdev.c:571:	*red = VGA_RD08(chip->PDIO, 0x3c9);
./drivers/video/fbdev/riva/fbdev.c:572:	*green = VGA_RD08(chip->PDIO, 0x3c9);
./drivers/video/fbdev/riva/fbdev.c:573:	*blue = VGA_RD08(chip->PDIO, 0x3c9);
./drivers/video/backlight/lm3639_bl.c:55:	struct lm3639_platform_data *pdata = pchip->pdata;
./drivers/video/backlight/lm3639_bl.c:59:	    regmap_update_bits(pchip->regmap, REG_BL_CONF_1, 0x08,
./drivers/video/backlight/lm3639_bl.c:65:	ret = regmap_update_bits(pchip->regmap, REG_IO_CTRL, 0x7C, reg_val);
./drivers/video/backlight/lm3639_bl.c:70:	ret = regmap_write(pchip->regmap, REG_BL_CONF_4, pdata->init_brt_led);
./drivers/video/backlight/lm3639_bl.c:74:	ret = regmap_write(pchip->regmap, REG_BL_CONF_3, pdata->init_brt_led);
./drivers/video/backlight/lm3639_bl.c:87:	ret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x79, reg_val);
./drivers/video/backlight/lm3639_bl.c:93:	dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3639_bl.c:103:	struct lm3639_platform_data *pdata = pchip->pdata;
./drivers/video/backlight/lm3639_bl.c:105:	ret = regmap_read(pchip->regmap, REG_FLAG, &reg_val);
./drivers/video/backlight/lm3639_bl.c:110:		dev_info(pchip->dev, "last flag is 0x%x\n", reg_val);
./drivers/video/backlight/lm3639_bl.c:118:			dev_err(pchip->dev,
./drivers/video/backlight/lm3639_bl.c:124:	ret = regmap_write(pchip->regmap, REG_BL_CONF_4, bl->props.brightness);
./drivers/video/backlight/lm3639_bl.c:127:	ret = regmap_write(pchip->regmap, REG_BL_CONF_3, bl->props.brightness);
./drivers/video/backlight/lm3639_bl.c:132:		ret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x01, 0x00);
./drivers/video/backlight/lm3639_bl.c:134:		ret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x01, 0x01);
./drivers/video/backlight/lm3639_bl.c:140:	dev_err(pchip->dev, "i2c failed to access registers\n");
./drivers/video/backlight/lm3639_bl.c:149:	struct lm3639_platform_data *pdata = pchip->pdata;
./drivers/video/backlight/lm3639_bl.c:155:			dev_err(pchip->dev,
./drivers/video/backlight/lm3639_bl.c:160:	ret = regmap_read(pchip->regmap, REG_BL_CONF_1, &reg_val);
./drivers/video/backlight/lm3639_bl.c:164:		ret = regmap_read(pchip->regmap, REG_BL_CONF_4, &reg_val);
./drivers/video/backlight/lm3639_bl.c:166:		ret = regmap_read(pchip->regmap, REG_BL_CONF_3, &reg_val);
./drivers/video/backlight/lm3639_bl.c:173:	dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3639_bl.c:198:		    regmap_update_bits(pchip->regmap, REG_BL_CONF_1, 0x10,
./drivers/video/backlight/lm3639_bl.c:202:		    regmap_update_bits(pchip->regmap, REG_BL_CONF_1, 0x10,
./drivers/video/backlight/lm3639_bl.c:211:	dev_err(pchip->dev, "%s:i2c access fail to register\n", __func__);
./drivers/video/backlight/lm3639_bl.c:215:	dev_err(pchip->dev, "%s:input conversion fail\n", __func__);
./drivers/video/backlight/lm3639_bl.c:232:	ret = regmap_read(pchip->regmap, REG_FLAG, &reg_val);
./drivers/video/backlight/lm3639_bl.c:236:		dev_info(pchip->dev, "last flag is 0x%x\n", reg_val);
./drivers/video/backlight/lm3639_bl.c:240:		ret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x00);
./drivers/video/backlight/lm3639_bl.c:246:	ret = regmap_update_bits(pchip->regmap,
./drivers/video/backlight/lm3639_bl.c:250:	ret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x02);
./drivers/video/backlight/lm3639_bl.c:256:	dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3639_bl.c:269:	ret = regmap_read(pchip->regmap, REG_FLAG, &reg_val);
./drivers/video/backlight/lm3639_bl.c:273:		dev_info(pchip->dev, "last flag is 0x%x\n", reg_val);
./drivers/video/backlight/lm3639_bl.c:276:	ret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x00);
./drivers/video/backlight/lm3639_bl.c:284:	ret = regmap_update_bits(pchip->regmap,
./drivers/video/backlight/lm3639_bl.c:288:	ret = regmap_update_bits(pchip->regmap, REG_ENABLE, 0x06, 0x06);
./drivers/video/backlight/lm3639_bl.c:294:	dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3639_bl.c:326:	pchip->pdata = pdata;
./drivers/video/backlight/lm3639_bl.c:327:	pchip->dev = &client->dev;
./drivers/video/backlight/lm3639_bl.c:329:	pchip->regmap = devm_regmap_init_i2c(client, &lm3639_regmap);
./drivers/video/backlight/lm3639_bl.c:330:	if (IS_ERR(pchip->regmap)) {
./drivers/video/backlight/lm3639_bl.c:331:		ret = PTR_ERR(pchip->regmap);
./drivers/video/backlight/lm3639_bl.c:349:	pchip->bled =
./drivers/video/backlight/lm3639_bl.c:350:	    devm_backlight_device_register(pchip->dev, "lm3639_bled",
./drivers/video/backlight/lm3639_bl.c:351:					   pchip->dev, pchip, &lm3639_bled_ops,
./drivers/video/backlight/lm3639_bl.c:353:	if (IS_ERR(pchip->bled)) {
./drivers/video/backlight/lm3639_bl.c:355:		ret = PTR_ERR(pchip->bled);
./drivers/video/backlight/lm3639_bl.c:359:	ret = device_create_file(&(pchip->bled->dev), &dev_attr_bled_mode);
./drivers/video/backlight/lm3639_bl.c:366:	pchip->cdev_flash.name = "lm3639_flash";
./drivers/video/backlight/lm3639_bl.c:367:	pchip->cdev_flash.max_brightness = 16;
./drivers/video/backlight/lm3639_bl.c:368:	pchip->cdev_flash.brightness_set = lm3639_flash_brightness_set;
./drivers/video/backlight/lm3639_bl.c:370:				    &client->dev, &pchip->cdev_flash);
./drivers/video/backlight/lm3639_bl.c:377:	pchip->cdev_torch.name = "lm3639_torch";
./drivers/video/backlight/lm3639_bl.c:378:	pchip->cdev_torch.max_brightness = 8;
./drivers/video/backlight/lm3639_bl.c:379:	pchip->cdev_torch.brightness_set = lm3639_torch_brightness_set;
./drivers/video/backlight/lm3639_bl.c:381:				    &client->dev, &pchip->cdev_torch);
./drivers/video/backlight/lm3639_bl.c:390:	led_classdev_unregister(&pchip->cdev_flash);
./drivers/video/backlight/lm3639_bl.c:392:	device_remove_file(&(pchip->bled->dev), &dev_attr_bled_mode);
./drivers/video/backlight/lm3639_bl.c:401:	regmap_write(pchip->regmap, REG_ENABLE, 0x00);
./drivers/video/backlight/lm3639_bl.c:403:	if (&pchip->cdev_torch)
./drivers/video/backlight/lm3639_bl.c:404:		led_classdev_unregister(&pchip->cdev_torch);
./drivers/video/backlight/lm3639_bl.c:405:	if (&pchip->cdev_flash)
./drivers/video/backlight/lm3639_bl.c:406:		led_classdev_unregister(&pchip->cdev_flash);
./drivers/video/backlight/lm3639_bl.c:407:	if (pchip->bled)
./drivers/video/backlight/lm3639_bl.c:408:		device_remove_file(&(pchip->bled->dev), &dev_attr_bled_mode);
./drivers/video/backlight/max8925_bl.c:47:	ret = max8925_reg_write(chip->i2c, data->reg_cntl, value);
./drivers/video/backlight/max8925_bl.c:53:		ret = max8925_set_bits(chip->i2c, data->reg_mode_cntl, 1, 1);
./drivers/video/backlight/max8925_bl.c:56:		ret = max8925_set_bits(chip->i2c, data->reg_mode_cntl, 1, 0);
./drivers/video/backlight/max8925_bl.c:59:	dev_dbg(chip->dev, "set brightness %d\n", value);
./drivers/video/backlight/max8925_bl.c:63:	dev_dbg(chip->dev, "set brightness %d failure with return value:%d\n",
./drivers/video/backlight/max8925_bl.c:90:	ret = max8925_reg_read(chip->i2c, data->reg_cntl);
./drivers/video/backlight/max8925_bl.c:94:	dev_dbg(chip->dev, "get brightness %d\n", data->current_brightness);
./drivers/video/backlight/max8925_bl.c:190:	ret = max8925_set_bits(chip->i2c, data->reg_mode_cntl, 0xfe, value);
./drivers/video/backlight/lm3630a_bl.c:56:	rval = regmap_read(pchip->regmap, reg, &reg_val);
./drivers/video/backlight/lm3630a_bl.c:65:	return regmap_write(pchip->regmap, reg, data);
./drivers/video/backlight/lm3630a_bl.c:72:	return regmap_update_bits(pchip->regmap, reg, mask, data);
./drivers/video/backlight/lm3630a_bl.c:79:	struct lm3630a_platform_data *pdata = pchip->pdata;
./drivers/video/backlight/lm3630a_bl.c:101:		dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3630a_bl.c:115:		dev_err(pchip->dev,
./drivers/video/backlight/lm3630a_bl.c:120:	dev_info(pchip->dev, "REG_INT_STATUS Register is 0x%x\n", rval);
./drivers/video/backlight/lm3630a_bl.c:129:	queue_delayed_work(pchip->irqthread, &pchip->work, delay);
./drivers/video/backlight/lm3630a_bl.c:133:		dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3630a_bl.c:147:	INIT_DELAYED_WORK(&pchip->work, lm3630a_delayed_func);
./drivers/video/backlight/lm3630a_bl.c:148:	pchip->irqthread = create_singlethread_workqueue("lm3630a-irqthd");
./drivers/video/backlight/lm3630a_bl.c:149:	if (!pchip->irqthread) {
./drivers/video/backlight/lm3630a_bl.c:150:		dev_err(pchip->dev, "create irq thread fail\n");
./drivers/video/backlight/lm3630a_bl.c:154:	    (pchip->irq, NULL, lm3630a_isr_func,
./drivers/video/backlight/lm3630a_bl.c:156:		dev_err(pchip->dev, "request threaded irq fail\n");
./drivers/video/backlight/lm3630a_bl.c:157:		destroy_workqueue(pchip->irqthread);
./drivers/video/backlight/lm3630a_bl.c:165:	unsigned int period = pchip->pdata->pwm_period;
./drivers/video/backlight/lm3630a_bl.c:168:	pwm_config(pchip->pwmd, duty, period);
./drivers/video/backlight/lm3630a_bl.c:170:		pwm_enable(pchip->pwmd);
./drivers/video/backlight/lm3630a_bl.c:172:		pwm_disable(pchip->pwmd);
./drivers/video/backlight/lm3630a_bl.c:180:	enum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;
./drivers/video/backlight/lm3630a_bl.c:206:	dev_err(pchip->dev, "i2c failed to access\n");
./drivers/video/backlight/lm3630a_bl.c:214:	enum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;
./drivers/video/backlight/lm3630a_bl.c:242:	dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3630a_bl.c:257:	enum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;
./drivers/video/backlight/lm3630a_bl.c:283:	dev_err(pchip->dev, "i2c failed to access REG_CTRL\n");
./drivers/video/backlight/lm3630a_bl.c:291:	enum lm3630a_pwm_ctrl pwm_ctrl = pchip->pdata->pwm_ctrl;
./drivers/video/backlight/lm3630a_bl.c:319:	dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3630a_bl.c:332:	struct lm3630a_platform_data *pdata = pchip->pdata;
./drivers/video/backlight/lm3630a_bl.c:338:		pchip->bleda =
./drivers/video/backlight/lm3630a_bl.c:339:		    devm_backlight_device_register(pchip->dev, "lm3630a_leda",
./drivers/video/backlight/lm3630a_bl.c:340:						   pchip->dev, pchip,
./drivers/video/backlight/lm3630a_bl.c:342:		if (IS_ERR(pchip->bleda))
./drivers/video/backlight/lm3630a_bl.c:343:			return PTR_ERR(pchip->bleda);
./drivers/video/backlight/lm3630a_bl.c:350:		pchip->bledb =
./drivers/video/backlight/lm3630a_bl.c:351:		    devm_backlight_device_register(pchip->dev, "lm3630a_ledb",
./drivers/video/backlight/lm3630a_bl.c:352:						   pchip->dev, pchip,
./drivers/video/backlight/lm3630a_bl.c:354:		if (IS_ERR(pchip->bledb))
./drivers/video/backlight/lm3630a_bl.c:355:			return PTR_ERR(pchip->bledb);
./drivers/video/backlight/lm3630a_bl.c:382:	pchip->dev = &client->dev;
./drivers/video/backlight/lm3630a_bl.c:384:	pchip->regmap = devm_regmap_init_i2c(client, &lm3630a_regmap);
./drivers/video/backlight/lm3630a_bl.c:385:	if (IS_ERR(pchip->regmap)) {
./drivers/video/backlight/lm3630a_bl.c:386:		rval = PTR_ERR(pchip->regmap);
./drivers/video/backlight/lm3630a_bl.c:393:		pdata = devm_kzalloc(pchip->dev,
./drivers/video/backlight/lm3630a_bl.c:406:	pchip->pdata = pdata;
./drivers/video/backlight/lm3630a_bl.c:422:		pchip->pwmd = devm_pwm_get(pchip->dev, "lm3630a-pwm");
./drivers/video/backlight/lm3630a_bl.c:423:		if (IS_ERR(pchip->pwmd)) {
./drivers/video/backlight/lm3630a_bl.c:425:			return PTR_ERR(pchip->pwmd);
./drivers/video/backlight/lm3630a_bl.c:432:		pwm_apply_args(pchip->pwmd);
./drivers/video/backlight/lm3630a_bl.c:436:	pchip->irq = client->irq;
./drivers/video/backlight/lm3630a_bl.c:437:	if (pchip->irq) {
./drivers/video/backlight/lm3630a_bl.c:453:		dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3630a_bl.c:457:		dev_err(pchip->dev, "i2c failed to access register\n");
./drivers/video/backlight/lm3630a_bl.c:459:	if (pchip->irq) {
./drivers/video/backlight/lm3630a_bl.c:460:		free_irq(pchip->irq, pchip);
./drivers/video/backlight/lm3630a_bl.c:461:		flush_workqueue(pchip->irqthread);
./drivers/video/backlight/lm3630a_bl.c:462:		destroy_workqueue(pchip->irqthread);
./drivers/video/backlight/88pm860x_bl.c:116:	dev_dbg(chip->dev, "set brightness %d\n", value);
./drivers/video/backlight/88pm860x_bl.c:120:	dev_dbg(chip->dev, "set brightness %d failure with return value: %d\n",
./drivers/video/backlight/88pm860x_bl.c:151:	dev_dbg(chip->dev, "get brightness %d\n", data->current_brightness);
./drivers/video/backlight/88pm860x_bl.c:232:	data->i2c = (chip->id == CHIP_PM8606) ? chip->client : chip->companion;
./drivers/media/dvb-frontends/stv0900_core.c:61:			((temp_chip->internal->i2c_adap != i2c_adap) ||
./drivers/media/dvb-frontends/stv0900_core.c:62:			(temp_chip->internal->i2c_addr != i2c_addr)))
./drivers/media/dvb-frontends/stv0900_core.c:64:			temp_chip = temp_chip->next_inode;
./drivers/media/pci/cx25821/cx25821-alsa.c:50:		pr_info("%s/1: " fmt, chip->dev->name, ##arg);	\
./drivers/media/pci/cx25821/cx25821-alsa.c:55:		printk(KERN_DEBUG "%s/1: " fmt, chip->dev->name, ##arg); \
./drivers/media/pci/cx25821/cx25821-alsa.c:149:	struct cx25821_audio_buffer *buf = chip->buf;
./drivers/media/pci/cx25821/cx25821-alsa.c:229:	struct cx25821_audio_buffer *buf = chip->buf;
./drivers/media/pci/cx25821/cx25821-alsa.c:230:	struct cx25821_dev *dev = chip->dev;
./drivers/media/pci/cx25821/cx25821-alsa.c:236:	cx25821_set_gpiopin_direction(chip->dev, 0, 0);
./drivers/media/pci/cx25821/cx25821-alsa.c:243:	cx25821_sram_channel_setup_audio(chip->dev, audio_ch, buf->bpl,
./drivers/media/pci/cx25821/cx25821-alsa.c:252:	atomic_set(&chip->count, 0);
./drivers/media/pci/cx25821/cx25821-alsa.c:263:		chip->num_periods, buf->bpl * chip->num_periods);
./drivers/media/pci/cx25821/cx25821-alsa.c:274:	cx_set(PCI_INT_MSK, chip->dev->pci_irqmask | PCI_MSK_AUD_INT);
./drivers/media/pci/cx25821/cx25821-alsa.c:290:	struct cx25821_dev *dev = chip->dev;
./drivers/media/pci/cx25821/cx25821-alsa.c:328:	struct cx25821_dev *dev = chip->dev;
./drivers/media/pci/cx25821/cx25821-alsa.c:355:		atomic_set(&chip->count, cx_read(AUD_A_GPCNT));
./drivers/media/pci/cx25821/cx25821-alsa.c:356:		snd_pcm_period_elapsed(chip->substream);
./drivers/media/pci/cx25821/cx25821-alsa.c:366:	struct cx25821_dev *dev = chip->dev;
./drivers/media/pci/cx25821/cx25821-alsa.c:411:	struct cx25821_riscmem *risc = &chip->buf->risc;
./drivers/media/pci/cx25821/cx25821-alsa.c:413:	BUG_ON(!chip->dma_size);
./drivers/media/pci/cx25821/cx25821-alsa.c:417:	cx25821_alsa_dma_free(chip->buf);
./drivers/media/pci/cx25821/cx25821-alsa.c:418:	pci_free_consistent(chip->pci, risc->size, risc->cpu, risc->dma);
./drivers/media/pci/cx25821/cx25821-alsa.c:419:	kfree(chip->buf);
./drivers/media/pci/cx25821/cx25821-alsa.c:421:	chip->buf = NULL;
./drivers/media/pci/cx25821/cx25821-alsa.c:422:	chip->dma_size = 0;
./drivers/media/pci/cx25821/cx25821-alsa.c:475:	chip->substream = substream;
./drivers/media/pci/cx25821/cx25821-alsa.c:521:	chip->period_size = params_period_bytes(hw_params);
./drivers/media/pci/cx25821/cx25821-alsa.c:522:	chip->num_periods = params_periods(hw_params);
./drivers/media/pci/cx25821/cx25821-alsa.c:523:	chip->dma_size = chip->period_size * params_periods(hw_params);
./drivers/media/pci/cx25821/cx25821-alsa.c:525:	BUG_ON(!chip->dma_size);
./drivers/media/pci/cx25821/cx25821-alsa.c:526:	BUG_ON(chip->num_periods & (chip->num_periods - 1));
./drivers/media/pci/cx25821/cx25821-alsa.c:532:	if (chip->period_size > AUDIO_LINE_SIZE)
./drivers/media/pci/cx25821/cx25821-alsa.c:533:		chip->period_size = AUDIO_LINE_SIZE;
./drivers/media/pci/cx25821/cx25821-alsa.c:535:	buf->bpl = chip->period_size;
./drivers/media/pci/cx25821/cx25821-alsa.c:536:	chip->buf = buf;
./drivers/media/pci/cx25821/cx25821-alsa.c:539:			(PAGE_ALIGN(chip->dma_size) >> PAGE_SHIFT));
./drivers/media/pci/cx25821/cx25821-alsa.c:547:	ret = cx25821_risc_databuffer_audio(chip->pci, &buf->risc, buf->sglist,
./drivers/media/pci/cx25821/cx25821-alsa.c:548:			chip->period_size, chip->num_periods, 1);
./drivers/media/pci/cx25821/cx25821-alsa.c:559:	substream->runtime->dma_area = chip->buf->vaddr;
./drivers/media/pci/cx25821/cx25821-alsa.c:560:	substream->runtime->dma_bytes = chip->dma_size;
./drivers/media/pci/cx25821/cx25821-alsa.c:566:	chip->buf = NULL;
./drivers/media/pci/cx25821/cx25821-alsa.c:604:	spin_lock(&chip->reg_lock);
./drivers/media/pci/cx25821/cx25821-alsa.c:618:	spin_unlock(&chip->reg_lock);
./drivers/media/pci/cx25821/cx25821-alsa.c:633:	count = atomic_read(&chip->count);
./drivers/media/pci/cx25821/cx25821-alsa.c:674:	err = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);
./drivers/media/pci/cx25821/cx25821-alsa.c:736:	spin_lock_init(&chip->reg_lock);
./drivers/media/pci/cx25821/cx25821-alsa.c:738:	chip->dev = dev;
./drivers/media/pci/cx25821/cx25821-alsa.c:739:	chip->card = card;
./drivers/media/pci/cx25821/cx25821-alsa.c:740:	chip->pci = dev->pci;
./drivers/media/pci/cx25821/cx25821-alsa.c:741:	chip->iobase = pci_resource_start(dev->pci, 0);
./drivers/media/pci/cx25821/cx25821-alsa.c:743:	chip->irq = dev->pci->irq;
./drivers/media/pci/cx25821/cx25821-alsa.c:746:			  IRQF_SHARED, chip->dev->name, chip);
./drivers/media/pci/cx25821/cx25821-alsa.c:749:		pr_err("ERROR %s: can't get IRQ %d for ALSA\n", chip->dev->name,
./drivers/media/pci/cx25821/cx25821-alsa.c:762:	sprintf(card->longname, "%s at 0x%lx irq %d", chip->dev->name,
./drivers/media/pci/cx25821/cx25821-alsa.c:763:		chip->iobase, chip->irq);
./drivers/media/pci/cx23885/altera-ci.c:156:				(temp_chip->internal->dev != dev))
./drivers/media/pci/cx23885/altera-ci.c:157:		temp_chip = temp_chip->next_inode;
./drivers/media/pci/cx23885/altera-ci.c:188:		if (temp_chip->internal != NULL) {
./drivers/media/pci/cx23885/altera-ci.c:189:			temp_int = temp_chip->internal;
./drivers/media/pci/cx23885/altera-ci.c:196:		temp_chip = temp_chip->next_inode;
./drivers/media/pci/cx23885/cx23885-alsa.c:46:		printk(KERN_INFO "%s: " fmt, chip->dev->name , ## arg);	\
./drivers/media/pci/cx23885/cx23885-alsa.c:50:	printk(KERN_DEBUG "%s: " fmt, chip->dev->name , ## arg)
./drivers/media/pci/cx23885/cx23885-alsa.c:85:	struct cx23885_audio_buffer *buf = chip->buf;
./drivers/media/pci/cx23885/cx23885-alsa.c:165:	struct cx23885_audio_buffer *buf = chip->buf;
./drivers/media/pci/cx23885/cx23885-alsa.c:166:	struct cx23885_dev *dev  = chip->dev;
./drivers/media/pci/cx23885/cx23885-alsa.c:176:	cx23885_sram_channel_setup(chip->dev, audio_ch, buf->bpl,
./drivers/media/pci/cx23885/cx23885-alsa.c:187:	atomic_set(&chip->count, 0);
./drivers/media/pci/cx23885/cx23885-alsa.c:191:		chip->num_periods, buf->bpl * chip->num_periods);
./drivers/media/pci/cx23885/cx23885-alsa.c:201:	cx_set(PCI_INT_MSK, chip->dev->pci_irqmask | PCI_MSK_AUD_INT);
./drivers/media/pci/cx23885/cx23885-alsa.c:208:		cx23885_sram_channel_dump(chip->dev, audio_ch);
./drivers/media/pci/cx23885/cx23885-alsa.c:218:	struct cx23885_dev *dev = chip->dev;
./drivers/media/pci/cx23885/cx23885-alsa.c:230:		cx23885_sram_channel_dump(chip->dev,
./drivers/media/pci/cx23885/cx23885-alsa.c:263:		atomic_set(&chip->count, cx_read(AUD_INT_A_GPCNT));
./drivers/media/pci/cx23885/cx23885-alsa.c:264:		snd_pcm_period_elapsed(chip->substream);
./drivers/media/pci/cx23885/cx23885-alsa.c:275:	BUG_ON(!chip->dma_size);
./drivers/media/pci/cx23885/cx23885-alsa.c:279:	cx23885_alsa_dma_free(chip->buf);
./drivers/media/pci/cx23885/cx23885-alsa.c:280:	risc = &chip->buf->risc;
./drivers/media/pci/cx23885/cx23885-alsa.c:281:	pci_free_consistent(chip->pci, risc->size, risc->cpu, risc->dma);
./drivers/media/pci/cx23885/cx23885-alsa.c:282:	kfree(chip->buf);
./drivers/media/pci/cx23885/cx23885-alsa.c:284:	chip->buf = NULL;
./drivers/media/pci/cx23885/cx23885-alsa.c:285:	chip->dma_size = 0;
./drivers/media/pci/cx23885/cx23885-alsa.c:340:	chip->substream = substream;
./drivers/media/pci/cx23885/cx23885-alsa.c:344:	if (chip->dev->sram_channels[AUDIO_SRAM_CHANNEL].fifo_size !=
./drivers/media/pci/cx23885/cx23885-alsa.c:346:		unsigned int bpl = chip->dev->
./drivers/media/pci/cx23885/cx23885-alsa.c:383:	chip->period_size = params_period_bytes(hw_params);
./drivers/media/pci/cx23885/cx23885-alsa.c:384:	chip->num_periods = params_periods(hw_params);
./drivers/media/pci/cx23885/cx23885-alsa.c:385:	chip->dma_size = chip->period_size * params_periods(hw_params);
./drivers/media/pci/cx23885/cx23885-alsa.c:387:	BUG_ON(!chip->dma_size);
./drivers/media/pci/cx23885/cx23885-alsa.c:388:	BUG_ON(chip->num_periods & (chip->num_periods-1));
./drivers/media/pci/cx23885/cx23885-alsa.c:394:	buf->bpl = chip->period_size;
./drivers/media/pci/cx23885/cx23885-alsa.c:395:	chip->buf = buf;
./drivers/media/pci/cx23885/cx23885-alsa.c:398:			(PAGE_ALIGN(chip->dma_size) >> PAGE_SHIFT));
./drivers/media/pci/cx23885/cx23885-alsa.c:406:	ret = cx23885_risc_databuffer(chip->pci, &buf->risc, buf->sglist,
./drivers/media/pci/cx23885/cx23885-alsa.c:407:				   chip->period_size, chip->num_periods, 1);
./drivers/media/pci/cx23885/cx23885-alsa.c:416:	substream->runtime->dma_area = chip->buf->vaddr;
./drivers/media/pci/cx23885/cx23885-alsa.c:417:	substream->runtime->dma_bytes = chip->dma_size;
./drivers/media/pci/cx23885/cx23885-alsa.c:424:	chip->buf = NULL;
./drivers/media/pci/cx23885/cx23885-alsa.c:462:	spin_lock(&chip->lock);
./drivers/media/pci/cx23885/cx23885-alsa.c:476:	spin_unlock(&chip->lock);
./drivers/media/pci/cx23885/cx23885-alsa.c:491:	count = atomic_read(&chip->count);
./drivers/media/pci/cx23885/cx23885-alsa.c:530:	err = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);
./drivers/media/pci/cx23885/cx23885-alsa.c:570:	chip->dev = dev;
./drivers/media/pci/cx23885/cx23885-alsa.c:571:	chip->pci = dev->pci;
./drivers/media/pci/cx23885/cx23885-alsa.c:572:	chip->card = card;
./drivers/media/pci/cx23885/cx23885-alsa.c:573:	spin_lock_init(&chip->lock);
./drivers/media/pci/cx23885/cx23885-alsa.c:606:	snd_card_free(chip->card);
./drivers/media/pci/cx23885/cx23885-ioctl.c:29:	if (chip->match.addr > 1)
./drivers/media/pci/cx23885/cx23885-ioctl.c:31:	if (chip->match.addr == 1) {
./drivers/media/pci/cx23885/cx23885-ioctl.c:34:		strlcpy(chip->name, "cx23417", sizeof(chip->name));
./drivers/media/pci/cx23885/cx23885-ioctl.c:36:		strlcpy(chip->name, dev->v4l2_dev.name, sizeof(chip->name));
./drivers/media/pci/saa7134/saa7134-alsa.c:401:	dev = chip->dev;
./drivers/media/pci/saa7134/saa7134-alsa.c:403:	spin_lock_irq(&chip->mixer_lock);
./drivers/media/pci/saa7134/saa7134-alsa.c:406:	old_addr = chip->capture_source_addr;
./drivers/media/pci/saa7134/saa7134-alsa.c:411:			 chip->capture_source[0] != left ||
./drivers/media/pci/saa7134/saa7134-alsa.c:412:			 chip->capture_source[1] != right;
./drivers/media/pci/saa7134/saa7134-alsa.c:414:		chip->capture_source[0] = left;
./drivers/media/pci/saa7134/saa7134-alsa.c:415:		chip->capture_source[1] = right;
./drivers/media/pci/saa7134/saa7134-alsa.c:416:		chip->capture_source_addr = addr;
./drivers/media/pci/saa7134/saa7134-alsa.c:419:	spin_unlock_irq(&chip->mixer_lock);
./drivers/media/pci/saa7134/saa7134-alsa.c:485:			snd_ctl_notify(chip->card,
./drivers/media/pci/saa7134/saa7134-alsa.c:487:				       &chip->capture_ctl[addr]->id);
./drivers/media/pci/saa7134/saa7134-alsa.c:490:			snd_ctl_notify(chip->card,
./drivers/media/pci/saa7134/saa7134-alsa.c:492:				       &chip->capture_ctl[old_addr]->id);
./drivers/media/pci/saa7134/saa7134-alsa.c:936:	ucontrol->value.integer.value[0] = chip->mixer_volume[addr][0];
./drivers/media/pci/saa7134/saa7134-alsa.c:937:	ucontrol->value.integer.value[1] = chip->mixer_volume[addr][1];
./drivers/media/pci/saa7134/saa7134-alsa.c:945:	struct saa7134_dev *dev = chip->dev;
./drivers/media/pci/saa7134/saa7134-alsa.c:960:	spin_lock_irq(&chip->mixer_lock);
./drivers/media/pci/saa7134/saa7134-alsa.c:962:	if (chip->mixer_volume[addr][0] != left) {
./drivers/media/pci/saa7134/saa7134-alsa.c:966:	if (chip->mixer_volume[addr][1] != right) {
./drivers/media/pci/saa7134/saa7134-alsa.c:1004:		chip->mixer_volume[addr][0] = left;
./drivers/media/pci/saa7134/saa7134-alsa.c:1005:		chip->mixer_volume[addr][1] = right;
./drivers/media/pci/saa7134/saa7134-alsa.c:1007:	spin_unlock_irq(&chip->mixer_lock);
./drivers/media/pci/saa7134/saa7134-alsa.c:1033:	spin_lock_irq(&chip->mixer_lock);
./drivers/media/pci/saa7134/saa7134-alsa.c:1034:	if (chip->capture_source_addr == addr) {
./drivers/media/pci/saa7134/saa7134-alsa.c:1035:		ucontrol->value.integer.value[0] = chip->capture_source[0];
./drivers/media/pci/saa7134/saa7134-alsa.c:1036:		ucontrol->value.integer.value[1] = chip->capture_source[1];
./drivers/media/pci/saa7134/saa7134-alsa.c:1041:	spin_unlock_irq(&chip->mixer_lock);
./drivers/media/pci/saa7134/saa7134-alsa.c:1078:	struct snd_card *card = chip->card;
./drivers/media/pci/saa7134/saa7134-alsa.c:1097:		chip->capture_ctl[addr] = kcontrol;
./drivers/media/pci/saa7134/saa7134-alsa.c:1103:	chip->capture_source_addr = MIXER_ADDR_UNSELECTED;
./drivers/media/pci/saa7134/saa7134-alsa.c:1111:	if (chip->dev->dmasound.priv_data == NULL)
./drivers/media/pci/saa7134/saa7134-alsa.c:1114:	if (chip->irq >= 0)
./drivers/media/pci/saa7134/saa7134-alsa.c:1115:		free_irq(chip->irq, &chip->dev->dmasound);
./drivers/media/pci/saa7134/saa7134-alsa.c:1117:	chip->dev->dmasound.priv_data = NULL;
./drivers/media/pci/saa7134/saa7134-alsa.c:1154:	spin_lock_init(&chip->lock);
./drivers/media/pci/saa7134/saa7134-alsa.c:1155:	spin_lock_init(&chip->mixer_lock);
./drivers/media/pci/saa7134/saa7134-alsa.c:1157:	chip->dev = dev;
./drivers/media/pci/saa7134/saa7134-alsa.c:1159:	chip->card = card;
./drivers/media/pci/saa7134/saa7134-alsa.c:1161:	chip->pci = dev->pci;
./drivers/media/pci/saa7134/saa7134-alsa.c:1162:	chip->iobase = pci_resource_start(dev->pci, 0);
./drivers/media/pci/saa7134/saa7134-alsa.c:1175:	chip->irq = dev->pci->irq;
./drivers/media/pci/saa7134/saa7134-alsa.c:1189:		chip->dev->name, chip->iobase, chip->irq);
./drivers/media/pci/cx88/cx88-alsa.c:50:		printk(KERN_INFO "%s/1: " fmt, chip->core->name , ## arg);\
./drivers/media/pci/cx88/cx88-alsa.c:55:		printk(KERN_DEBUG "%s/1: " fmt, chip->core->name , ## arg);\
./drivers/media/pci/cx88/cx88-alsa.c:140:	struct cx88_audio_buffer *buf = chip->buf;
./drivers/media/pci/cx88/cx88-alsa.c:141:	struct cx88_core *core=chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:148:	cx88_sram_channel_setup(chip->core, audio_ch, buf->bpl, buf->risc.dma);
./drivers/media/pci/cx88/cx88-alsa.c:155:	atomic_set(&chip->count, 0);
./drivers/media/pci/cx88/cx88-alsa.c:159:		chip->num_periods, buf->bpl * chip->num_periods);
./drivers/media/pci/cx88/cx88-alsa.c:169:	cx_set(MO_PCI_INTMSK, chip->core->pci_irqmask | PCI_INT_AUDINT);
./drivers/media/pci/cx88/cx88-alsa.c:176:		cx88_sram_channel_dump(chip->core, audio_ch);
./drivers/media/pci/cx88/cx88-alsa.c:186:	struct cx88_core *core=chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:198:		cx88_sram_channel_dump(chip->core, &cx88_sram_channels[SRAM_CH25]);
./drivers/media/pci/cx88/cx88-alsa.c:226:	struct cx88_core *core = chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:251:		atomic_set(&chip->count, cx_read(MO_AUDD_GPCNT));
./drivers/media/pci/cx88/cx88-alsa.c:252:		snd_pcm_period_elapsed(chip->substream);
./drivers/media/pci/cx88/cx88-alsa.c:263:	struct cx88_core *core = chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:296:	struct cx88_audio_buffer *buf = chip->buf;
./drivers/media/pci/cx88/cx88-alsa.c:373:	struct cx88_riscmem *risc = &chip->buf->risc;
./drivers/media/pci/cx88/cx88-alsa.c:375:	BUG_ON(!chip->dma_size);
./drivers/media/pci/cx88/cx88-alsa.c:379:	cx88_alsa_dma_free(chip->buf);
./drivers/media/pci/cx88/cx88-alsa.c:381:		pci_free_consistent(chip->pci, risc->size, risc->cpu, risc->dma);
./drivers/media/pci/cx88/cx88-alsa.c:382:	kfree(chip->buf);
./drivers/media/pci/cx88/cx88-alsa.c:384:	chip->buf = NULL;
./drivers/media/pci/cx88/cx88-alsa.c:437:	chip->substream = substream;
./drivers/media/pci/cx88/cx88-alsa.c:478:	chip->period_size = params_period_bytes(hw_params);
./drivers/media/pci/cx88/cx88-alsa.c:479:	chip->num_periods = params_periods(hw_params);
./drivers/media/pci/cx88/cx88-alsa.c:480:	chip->dma_size = chip->period_size * params_periods(hw_params);
./drivers/media/pci/cx88/cx88-alsa.c:482:	BUG_ON(!chip->dma_size);
./drivers/media/pci/cx88/cx88-alsa.c:483:	BUG_ON(chip->num_periods & (chip->num_periods-1));
./drivers/media/pci/cx88/cx88-alsa.c:489:	chip->buf = buf;
./drivers/media/pci/cx88/cx88-alsa.c:490:	buf->bpl = chip->period_size;
./drivers/media/pci/cx88/cx88-alsa.c:493:			(PAGE_ALIGN(chip->dma_size) >> PAGE_SHIFT));
./drivers/media/pci/cx88/cx88-alsa.c:501:	ret = cx88_risc_databuffer(chip->pci, &buf->risc, buf->sglist,
./drivers/media/pci/cx88/cx88-alsa.c:502:				   chip->period_size, chip->num_periods, 1);
./drivers/media/pci/cx88/cx88-alsa.c:510:	substream->runtime->dma_area = chip->buf->vaddr;
./drivers/media/pci/cx88/cx88-alsa.c:511:	substream->runtime->dma_bytes = chip->dma_size;
./drivers/media/pci/cx88/cx88-alsa.c:553:	spin_lock(&chip->reg_lock);
./drivers/media/pci/cx88/cx88-alsa.c:567:	spin_unlock(&chip->reg_lock);
./drivers/media/pci/cx88/cx88-alsa.c:581:	count = atomic_read(&chip->count);
./drivers/media/pci/cx88/cx88-alsa.c:622:	err = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);
./drivers/media/pci/cx88/cx88-alsa.c:650:	struct cx88_core *core=chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:665:	struct cx88_core *core = chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:687:	struct cx88_core *core=chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:705:	spin_lock_irq(&chip->reg_lock);
./drivers/media/pci/cx88/cx88-alsa.c:715:	spin_unlock_irq(&chip->reg_lock);
./drivers/media/pci/cx88/cx88-alsa.c:737:	struct cx88_core *core = chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:748:	struct cx88_core *core = chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:753:	spin_lock_irq(&chip->reg_lock);
./drivers/media/pci/cx88/cx88-alsa.c:763:	spin_unlock_irq(&chip->reg_lock);
./drivers/media/pci/cx88/cx88-alsa.c:789:	struct cx88_core *core = chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:801:	struct cx88_core *core = chip->core;
./drivers/media/pci/cx88/cx88-alsa.c:843:	if (chip->irq >= 0)
./drivers/media/pci/cx88/cx88-alsa.c:844:		free_irq(chip->irq, chip);
./drivers/media/pci/cx88/cx88-alsa.c:846:	cx88_core_put(chip->core,chip->pci);
./drivers/media/pci/cx88/cx88-alsa.c:848:	pci_disable_device(chip->pci);
./drivers/media/pci/cx88/cx88-alsa.c:902:	chip->card = card;
./drivers/media/pci/cx88/cx88-alsa.c:903:	chip->pci = pci;
./drivers/media/pci/cx88/cx88-alsa.c:904:	chip->irq = -1;
./drivers/media/pci/cx88/cx88-alsa.c:905:	spin_lock_init(&chip->reg_lock);
./drivers/media/pci/cx88/cx88-alsa.c:907:	chip->core = core;
./drivers/media/pci/cx88/cx88-alsa.c:910:	err = request_irq(chip->pci->irq, cx8801_irq,
./drivers/media/pci/cx88/cx88-alsa.c:911:			  IRQF_SHARED, chip->core->name, chip);
./drivers/media/pci/cx88/cx88-alsa.c:914:		       chip->core->name, chip->pci->irq);
./drivers/media/pci/cx88/cx88-alsa.c:926:	chip->irq = pci->irq;
./drivers/media/pci/cx88/cx88-alsa.c:927:	synchronize_irq(chip->irq);
./drivers/media/usb/cx231xx/cx231xx-video.c:1353:	switch (chip->match.addr) {
./drivers/media/usb/cx231xx/cx231xx-video.c:1357:		strlcpy(chip->name, "AFE (byte)", sizeof(chip->name));
./drivers/media/usb/cx231xx/cx231xx-video.c:1360:		strlcpy(chip->name, "Video (byte)", sizeof(chip->name));
./drivers/media/usb/cx231xx/cx231xx-video.c:1363:		strlcpy(chip->name, "I2S (byte)", sizeof(chip->name));
./drivers/media/usb/cx231xx/cx231xx-video.c:1366:		strlcpy(chip->name, "AFE (dword)", sizeof(chip->name));
./drivers/media/usb/cx231xx/cx231xx-video.c:1369:		strlcpy(chip->name, "Video (dword)", sizeof(chip->name));
./drivers/media/usb/cx231xx/cx231xx-video.c:1372:		strlcpy(chip->name, "I2S (dword)", sizeof(chip->name));
./drivers/media/usb/gspca/sn9c20x.c:1607:	if (chip->match.addr > 1)
./drivers/media/usb/gspca/sn9c20x.c:1609:	if (chip->match.addr == 1)
./drivers/media/usb/gspca/sn9c20x.c:1610:		strlcpy(chip->name, "sensor", sizeof(chip->name));
./drivers/media/usb/gspca/gspca.c:1041:	return chip->match.addr ? -EINVAL : 0;
./drivers/media/usb/em28xx/em28xx-video.c:1769:	if (chip->match.addr > 1)
./drivers/media/usb/em28xx/em28xx-video.c:1771:	if (chip->match.addr == 1)
./drivers/media/usb/em28xx/em28xx-video.c:1772:		strlcpy(chip->name, "ac97", sizeof(chip->name));
./drivers/media/usb/em28xx/em28xx-video.c:1774:		strlcpy(chip->name,
./drivers/media/usb/em28xx/em28xx-video.c:1775:			dev->v4l2->v4l2_dev.name, sizeof(chip->name));
./drivers/media/usb/usbtv/usbtv-audio.c:56:	chip->snd_substream = substream;
./drivers/media/usb/usbtv/usbtv-audio.c:66:	if (atomic_read(&chip->snd_stream)) {
./drivers/media/usb/usbtv/usbtv-audio.c:67:		atomic_set(&chip->snd_stream, 0);
./drivers/media/usb/usbtv/usbtv-audio.c:68:		schedule_work(&chip->snd_trigger);
./drivers/media/usb/usbtv/usbtv-audio.c:84:		dev_warn(chip->dev, "pcm audio buffer allocation failure %i\n",
./drivers/media/usb/usbtv/usbtv-audio.c:102:	chip->snd_buffer_pos = 0;
./drivers/media/usb/usbtv/usbtv-audio.c:103:	chip->snd_period_pos = 0;
./drivers/media/usb/usbtv/usbtv-audio.c:111:	struct snd_pcm_substream *substream = chip->snd_substream;
./drivers/media/usb/usbtv/usbtv-audio.c:127:		dev_warn(chip->dev, "unknown audio urb status %i\n",
./drivers/media/usb/usbtv/usbtv-audio.c:131:	if (!atomic_read(&chip->snd_stream))
./drivers/media/usb/usbtv/usbtv-audio.c:137:	buffer_pos = chip->snd_buffer_pos;
./drivers/media/usb/usbtv/usbtv-audio.c:138:	period_pos = chip->snd_period_pos;
./drivers/media/usb/usbtv/usbtv-audio.c:170:	chip->snd_buffer_pos = buffer_pos;
./drivers/media/usb/usbtv/usbtv-audio.c:171:	chip->snd_period_pos = period_pos;
./drivers/media/usb/usbtv/usbtv-audio.c:209:	chip->snd_bulk_urb = usb_alloc_urb(0, GFP_KERNEL);
./drivers/media/usb/usbtv/usbtv-audio.c:210:	if (chip->snd_bulk_urb == NULL)
./drivers/media/usb/usbtv/usbtv-audio.c:213:	pipe = usb_rcvbulkpipe(chip->udev, USBTV_AUDIO_ENDP);
./drivers/media/usb/usbtv/usbtv-audio.c:215:	chip->snd_bulk_urb->transfer_buffer = kzalloc(
./drivers/media/usb/usbtv/usbtv-audio.c:217:	if (chip->snd_bulk_urb->transfer_buffer == NULL)
./drivers/media/usb/usbtv/usbtv-audio.c:220:	usb_fill_bulk_urb(chip->snd_bulk_urb, chip->udev, pipe,
./drivers/media/usb/usbtv/usbtv-audio.c:221:		chip->snd_bulk_urb->transfer_buffer, USBTV_AUDIO_URBSIZE,
./drivers/media/usb/usbtv/usbtv-audio.c:227:	usb_clear_halt(chip->udev, pipe);
./drivers/media/usb/usbtv/usbtv-audio.c:228:	usb_submit_urb(chip->snd_bulk_urb, GFP_ATOMIC);
./drivers/media/usb/usbtv/usbtv-audio.c:233:	usb_free_urb(chip->snd_bulk_urb);
./drivers/media/usb/usbtv/usbtv-audio.c:234:	chip->snd_bulk_urb = NULL;
./drivers/media/usb/usbtv/usbtv-audio.c:253:	if (chip->snd_bulk_urb) {
./drivers/media/usb/usbtv/usbtv-audio.c:254:		usb_kill_urb(chip->snd_bulk_urb);
./drivers/media/usb/usbtv/usbtv-audio.c:255:		kfree(chip->snd_bulk_urb->transfer_buffer);
./drivers/media/usb/usbtv/usbtv-audio.c:256:		usb_free_urb(chip->snd_bulk_urb);
./drivers/media/usb/usbtv/usbtv-audio.c:257:		chip->snd_bulk_urb = NULL;
./drivers/media/usb/usbtv/usbtv-audio.c:281:	if (!chip->snd)
./drivers/media/usb/usbtv/usbtv-audio.c:284:	if (atomic_read(&chip->snd_stream))
./drivers/media/usb/usbtv/usbtv-audio.c:298:		atomic_set(&chip->snd_stream, 1);
./drivers/media/usb/usbtv/usbtv-audio.c:303:		atomic_set(&chip->snd_stream, 0);
./drivers/media/usb/usbtv/usbtv-audio.c:309:	schedule_work(&chip->snd_trigger);
./drivers/media/usb/usbtv/usbtv-audio.c:318:	return chip->snd_buffer_pos;
./drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c:256:		   that the normal i2c chip-level driver expects. */
./drivers/media/usb/tm6000/tm6000-alsa.c:36:		printk(KERN_INFO "%s/1: " fmt, chip->core->name , ## arg); \
./drivers/media/usb/tm6000/tm6000-alsa.c:78:	struct tm6000_core *core = chip->core;
./drivers/media/usb/tm6000/tm6000-alsa.c:95:	struct tm6000_core *core = chip->core;
./drivers/media/usb/tm6000/tm6000-alsa.c:182:	chip->substream = substream;
./drivers/media/usb/tm6000/tm6000-alsa.c:199:	struct tm6000_core *core = chip->core;
./drivers/media/usb/tm6000/tm6000-alsa.c:212:	struct snd_pcm_substream *substream = chip->substream;
./drivers/media/usb/tm6000/tm6000-alsa.c:232:	buf_pos = chip->buf_pos;
./drivers/media/usb/tm6000/tm6000-alsa.c:261:	chip->buf_pos += length;
./drivers/media/usb/tm6000/tm6000-alsa.c:262:	if (chip->buf_pos >= runtime->buffer_size)
./drivers/media/usb/tm6000/tm6000-alsa.c:263:		chip->buf_pos -= runtime->buffer_size;
./drivers/media/usb/tm6000/tm6000-alsa.c:265:	chip->period_pos += length;
./drivers/media/usb/tm6000/tm6000-alsa.c:266:	if (chip->period_pos >= runtime->period_size) {
./drivers/media/usb/tm6000/tm6000-alsa.c:267:		chip->period_pos -= runtime->period_size;
./drivers/media/usb/tm6000/tm6000-alsa.c:302:	struct tm6000_core *core = chip->core;
./drivers/media/usb/tm6000/tm6000-alsa.c:320:	chip->buf_pos = 0;
./drivers/media/usb/tm6000/tm6000-alsa.c:321:	chip->period_pos = 0;
./drivers/media/usb/tm6000/tm6000-alsa.c:348:	struct tm6000_core *core = chip->core;
./drivers/media/usb/tm6000/tm6000-alsa.c:377:	return chip->buf_pos;
./drivers/media/usb/tm6000/tm6000-alsa.c:456:	chip->core = dev;
./drivers/media/usb/tm6000/tm6000-alsa.c:457:	chip->card = card;
./drivers/media/usb/tm6000/tm6000-alsa.c:459:	spin_lock_init(&chip->reg_lock);
./drivers/media/usb/tm6000/tm6000-alsa.c:499:	if (!chip->card)
./drivers/media/usb/tm6000/tm6000-alsa.c:502:	snd_card_free(chip->card);
./drivers/media/usb/tm6000/tm6000-alsa.c:503:	chip->card = NULL;
./drivers/media/common/saa7146/saa7146_core.c:383:	/* get chip-revision; this is needed to enable bug-fixes */
./drivers/media/i2c/tvaudio.c:123:	/* chip-specific description - should point to
./drivers/media/i2c/tvaudio.c:158:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:164:		chip->shadow.bytes[1] = val;
./drivers/media/i2c/tvaudio.c:171:		if (subaddr + 1 >= ARRAY_SIZE(chip->shadow.bytes)) {
./drivers/media/i2c/tvaudio.c:180:		chip->shadow.bytes[subaddr+1] = val;
./drivers/media/i2c/tvaudio.c:195:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:199:			val = (chip->shadow.bytes[1] & ~mask) | (val & mask);
./drivers/media/i2c/tvaudio.c:201:			if (subaddr + 1 >= ARRAY_SIZE(chip->shadow.bytes)) {
./drivers/media/i2c/tvaudio.c:208:			val = (chip->shadow.bytes[subaddr+1] & ~mask) | (val & mask);
./drivers/media/i2c/tvaudio.c:216:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:230:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:261:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:268:	if (cmd->count + cmd->bytes[0] - 1 >= ARRAY_SIZE(chip->shadow.bytes)) {
./drivers/media/i2c/tvaudio.c:283:		chip->shadow.bytes[i+cmd->bytes[0]] = cmd->bytes[i];
./drivers/media/i2c/tvaudio.c:306:	wake_up_process(chip->thread);
./drivers/media/i2c/tvaudio.c:312:	struct CHIPDESC  *desc = chip->desc;
./drivers/media/i2c/tvaudio.c:313:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:329:		if (chip->radio)
./drivers/media/i2c/tvaudio.c:334:		if (mode == chip->prevmode)
./drivers/media/i2c/tvaudio.c:340:		chip->prevmode = mode;
./drivers/media/i2c/tvaudio.c:343:		switch (chip->audmode) {
./drivers/media/i2c/tvaudio.c:370:		mod_timer(&chip->wt, jiffies+msecs_to_jiffies(2000));
./drivers/media/i2c/tvaudio.c:402:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:421:	int t = chip->shadow.bytes[TDA9840_SW + 1] & ~0x7e;
./drivers/media/i2c/tvaudio.c:578:	int c6 = chip->shadow.bytes[TDA985x_C6+1] & 0x3f;
./drivers/media/i2c/tvaudio.c:722:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:739:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:740:	int sw_data  = chip->shadow.bytes[TDA9873_SW+1] & ~ TDA9873_TR_MASK;
./drivers/media/i2c/tvaudio.c:741:	/*	int adj_data = chip->shadow.bytes[TDA9873_AD+1] ; */
./drivers/media/i2c/tvaudio.c:750:		 "tda9873_setaudmode(): chip->shadow.bytes[%d] = %d\n",
./drivers/media/i2c/tvaudio.c:751:		 TDA9873_SW+1, chip->shadow.bytes[TDA9873_SW+1]);
./drivers/media/i2c/tvaudio.c:886:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:925:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:939:	chip->shadow.bytes[MAXREGS-2] = dsr;
./drivers/media/i2c/tvaudio.c:940:	chip->shadow.bytes[MAXREGS-1] = nsr;
./drivers/media/i2c/tvaudio.c:970:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:975:		if(chip->shadow.bytes[MAXREGS-2] & 0x20) /* DSR.RSSF=1 */
./drivers/media/i2c/tvaudio.c:1061:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:1202:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:1301:	int s1 = chip->shadow.bytes[TDA8425_S1+1] & 0xe1;
./drivers/media/i2c/tvaudio.c:1389:	/* v4l2_dbg(1, debug, &chip->sd,
./drivers/media/i2c/tvaudio.c:1403:	struct v4l2_subdev *sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:1697:	struct CHIPDESC *desc = chip->desc;
./drivers/media/i2c/tvaudio.c:1701:		chip->muted = ctrl->val;
./drivers/media/i2c/tvaudio.c:1702:		if (chip->muted)
./drivers/media/i2c/tvaudio.c:1706:					desc->inputmap[chip->input],desc->inputmask);
./drivers/media/i2c/tvaudio.c:1712:		volume = chip->volume->val;
./drivers/media/i2c/tvaudio.c:1713:		balance = chip->balance->val;
./drivers/media/i2c/tvaudio.c:1739:	chip->radio = 1;
./drivers/media/i2c/tvaudio.c:1740:	/* del_timer(&chip->wt); */
./drivers/media/i2c/tvaudio.c:1748:	struct CHIPDESC *desc = chip->desc;
./drivers/media/i2c/tvaudio.c:1755:	chip->input = input;
./drivers/media/i2c/tvaudio.c:1756:	if (chip->muted)
./drivers/media/i2c/tvaudio.c:1759:			desc->inputmap[chip->input], desc->inputmask);
./drivers/media/i2c/tvaudio.c:1766:	struct CHIPDESC *desc = chip->desc;
./drivers/media/i2c/tvaudio.c:1770:	if (chip->radio)
./drivers/media/i2c/tvaudio.c:1783:	chip->audmode = vt->audmode;
./drivers/media/i2c/tvaudio.c:1785:	if (chip->thread)
./drivers/media/i2c/tvaudio.c:1786:		wake_up_process(chip->thread);
./drivers/media/i2c/tvaudio.c:1796:	struct CHIPDESC *desc = chip->desc;
./drivers/media/i2c/tvaudio.c:1800:	if (chip->radio)
./drivers/media/i2c/tvaudio.c:1803:	vt->audmode = chip->audmode;
./drivers/media/i2c/tvaudio.c:1815:	chip->radio = 0;
./drivers/media/i2c/tvaudio.c:1822:	struct CHIPDESC *desc = chip->desc;
./drivers/media/i2c/tvaudio.c:1832:	if (chip->thread) {
./drivers/media/i2c/tvaudio.c:1834:		chip->prevmode = -1; /* reset previous mode */
./drivers/media/i2c/tvaudio.c:1835:		mod_timer(&chip->wt, jiffies+msecs_to_jiffies(2000));
./drivers/media/i2c/tvaudio.c:1843:	struct CHIPDESC *desc = chip->desc;
./drivers/media/i2c/tvaudio.c:1846:	v4l2_ctrl_handler_log_status(&chip->hdl, sd->name);
./drivers/media/i2c/tvaudio.c:1911:	sd = &chip->sd;
./drivers/media/i2c/tvaudio.c:1941:	chip->desc = desc;
./drivers/media/i2c/tvaudio.c:1942:	chip->shadow.count = desc->registers+1;
./drivers/media/i2c/tvaudio.c:1943:	chip->prevmode = -1;
./drivers/media/i2c/tvaudio.c:1944:	chip->audmode = V4L2_TUNER_MODE_LANG1;
./drivers/media/i2c/tvaudio.c:1952:	v4l2_ctrl_handler_init(&chip->hdl, 5);
./drivers/media/i2c/tvaudio.c:1954:		v4l2_ctrl_new_std(&chip->hdl, &tvaudio_ctrl_ops,
./drivers/media/i2c/tvaudio.c:1964:			chip->volume = v4l2_ctrl_new_std(&chip->hdl,
./drivers/media/i2c/tvaudio.c:1968:			chip->balance = v4l2_ctrl_new_std(&chip->hdl,
./drivers/media/i2c/tvaudio.c:1971:			v4l2_ctrl_cluster(2, &chip->volume);
./drivers/media/i2c/tvaudio.c:1982:			v4l2_ctrl_new_std(&chip->hdl,
./drivers/media/i2c/tvaudio.c:1986:			v4l2_ctrl_new_std(&chip->hdl,
./drivers/media/i2c/tvaudio.c:1993:	sd->ctrl_handler = &chip->hdl;
./drivers/media/i2c/tvaudio.c:1994:	if (chip->hdl.error) {
./drivers/media/i2c/tvaudio.c:1995:		int err = chip->hdl.error;
./drivers/media/i2c/tvaudio.c:1997:		v4l2_ctrl_handler_free(&chip->hdl);
./drivers/media/i2c/tvaudio.c:2001:	v4l2_ctrl_handler_setup(&chip->hdl);
./drivers/media/i2c/tvaudio.c:2003:	chip->thread = NULL;
./drivers/media/i2c/tvaudio.c:2004:	init_timer(&chip->wt);
./drivers/media/i2c/tvaudio.c:2014:		chip->wt.function = chip_thread_wake;
./drivers/media/i2c/tvaudio.c:2015:		chip->wt.data     = (unsigned long)chip;
./drivers/media/i2c/tvaudio.c:2016:		chip->thread = kthread_run(chip_thread, chip, "%s",
./drivers/media/i2c/tvaudio.c:2018:		if (IS_ERR(chip->thread)) {
./drivers/media/i2c/tvaudio.c:2020:			chip->thread = NULL;
./drivers/media/i2c/tvaudio.c:2031:	del_timer_sync(&chip->wt);
./drivers/media/i2c/tvaudio.c:2032:	if (chip->thread) {
./drivers/media/i2c/tvaudio.c:2034:		kthread_stop(chip->thread);
./drivers/media/i2c/tvaudio.c:2035:		chip->thread = NULL;
./drivers/media/i2c/tvaudio.c:2039:	v4l2_ctrl_handler_free(&chip->hdl);
./drivers/pinctrl/samsung/pinctrl-s3c24xx.c:210:	parent_chip->irq_ack(irq_get_irq_data(parent_irq));
./drivers/pinctrl/samsung/pinctrl-s3c24xx.c:221:	parent_chip->irq_mask(irq_get_irq_data(parent_irq));
./drivers/pinctrl/samsung/pinctrl-s3c24xx.c:232:	parent_chip->irq_unmask(irq_get_irq_data(parent_irq));
./drivers/pinctrl/samsung/pinctrl-exynos.c:65:	unsigned long reg_mask = our_chip->eint_mask + bank->eint_offset;
./drivers/pinctrl/samsung/pinctrl-exynos.c:84:	unsigned long reg_pend = our_chip->eint_pend + bank->eint_offset;
./drivers/pinctrl/samsung/pinctrl-exynos.c:95:	unsigned long reg_mask = our_chip->eint_mask + bank->eint_offset;
./drivers/pinctrl/samsung/pinctrl-exynos.c:127:	unsigned long reg_con = our_chip->eint_con + bank->eint_offset;
./drivers/pinctrl/samsung/pinctrl-exynos.c:171:	unsigned long reg_con = our_chip->eint_con + bank->eint_offset;
./drivers/pinctrl/samsung/pinctrl-exynos.c:211:	unsigned long reg_con = our_chip->eint_con + bank->eint_offset;
./drivers/pinctrl/samsung/pinctrl-exynos.c:258:	irq_set_chip_and_handler(virq, &b->irq_chip->chip,
./drivers/pinctrl/samsung/pinctrl-exynos.c:431:	chip->irq_mask(&desc->irq_data);
./drivers/pinctrl/samsung/pinctrl-exynos.c:433:	if (chip->irq_ack)
./drivers/pinctrl/samsung/pinctrl-exynos.c:434:		chip->irq_ack(&desc->irq_data);
./drivers/pinctrl/samsung/pinctrl-exynos.c:438:	chip->irq_unmask(&desc->irq_data);
./drivers/pinctrl/samsung/pinctrl-exynos.c:468:		pend = readl(d->virt_base + b->irq_chip->eint_pend
./drivers/pinctrl/samsung/pinctrl-exynos.c:470:		mask = readl(d->virt_base + b->irq_chip->eint_mask
./drivers/pinctrl/pinctrl-st.c:757:	pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/pinctrl-st.c:768:	pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/pinctrl-at91.c:816:	mask = 1 << (offset - chip->base);
./drivers/pinctrl/pinctrl-at91.c:819:		offset, 'A' + range->id, offset - chip->base, mask);
./drivers/pinctrl/pinctrl-at91.c:821:	writel_relaxed(mask, at91_chip->regbase + PIO_PER);
./drivers/pinctrl/pinctrl-at91.c:1323:	uint32_t set_mask = (*mask & *bits) & BITS_MASK(chip->ngpio);
./drivers/pinctrl/pinctrl-at91.c:1324:	uint32_t clear_mask = (*mask & ~(*bits)) & BITS_MASK(chip->ngpio);
./drivers/pinctrl/pinctrl-at91.c:1351:	for (i = 0; i < chip->ngpio; i++) {
./drivers/pinctrl/pinctrl-at91.c:1360:			   gpio_label, chip->label, i);
./drivers/pinctrl/pinctrl-at91.c:1586:					   gpio_chip->irqdomain, n));
./drivers/pinctrl/pinctrl-at91.c:1707:	at91_chip->regbase = devm_ioremap_resource(&pdev->dev, res);
./drivers/pinctrl/pinctrl-at91.c:1708:	if (IS_ERR(at91_chip->regbase)) {
./drivers/pinctrl/pinctrl-at91.c:1709:		ret = PTR_ERR(at91_chip->regbase);
./drivers/pinctrl/pinctrl-at91.c:1713:	at91_chip->ops = (struct at91_pinctrl_mux_ops *)
./drivers/pinctrl/pinctrl-at91.c:1715:	at91_chip->pioc_virq = irq;
./drivers/pinctrl/pinctrl-at91.c:1716:	at91_chip->pioc_idx = alias_idx;
./drivers/pinctrl/pinctrl-at91.c:1718:	at91_chip->clock = devm_clk_get(&pdev->dev, NULL);
./drivers/pinctrl/pinctrl-at91.c:1719:	if (IS_ERR(at91_chip->clock)) {
./drivers/pinctrl/pinctrl-at91.c:1721:		ret = PTR_ERR(at91_chip->clock);
./drivers/pinctrl/pinctrl-at91.c:1725:	ret = clk_prepare_enable(at91_chip->clock);
./drivers/pinctrl/pinctrl-at91.c:1731:	at91_chip->chip = at91_gpio_template;
./drivers/pinctrl/pinctrl-at91.c:1733:	chip = &at91_chip->chip;
./drivers/pinctrl/pinctrl-at91.c:1734:	chip->of_node = np;
./drivers/pinctrl/pinctrl-at91.c:1735:	chip->label = dev_name(&pdev->dev);
./drivers/pinctrl/pinctrl-at91.c:1736:	chip->parent = &pdev->dev;
./drivers/pinctrl/pinctrl-at91.c:1737:	chip->owner = THIS_MODULE;
./drivers/pinctrl/pinctrl-at91.c:1738:	chip->base = alias_idx * MAX_NB_GPIO_PER_BANK;
./drivers/pinctrl/pinctrl-at91.c:1745:			chip->ngpio = ngpio;
./drivers/pinctrl/pinctrl-at91.c:1748:	names = devm_kzalloc(&pdev->dev, sizeof(char *) * chip->ngpio,
./drivers/pinctrl/pinctrl-at91.c:1756:	for (i = 0; i < chip->ngpio; i++)
./drivers/pinctrl/pinctrl-at91.c:1759:	chip->names = (const char *const *)names;
./drivers/pinctrl/pinctrl-at91.c:1761:	range = &at91_chip->range;
./drivers/pinctrl/pinctrl-at91.c:1762:	range->name = chip->label;
./drivers/pinctrl/pinctrl-at91.c:1766:	range->npins = chip->ngpio;
./drivers/pinctrl/pinctrl-at91.c:1780:	dev_info(&pdev->dev, "at address %p\n", at91_chip->regbase);
./drivers/pinctrl/pinctrl-at91.c:1788:	clk_disable_unprepare(at91_chip->clock);
./drivers/pinctrl/pinctrl-xway.c:1538:	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
./drivers/pinctrl/pinctrl-xway.c:1548:	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
./drivers/pinctrl/pinctrl-xway.c:1555:	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
./drivers/pinctrl/pinctrl-xway.c:1564:	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
./drivers/pinctrl/pinctrl-xway.c:1582:	struct ltq_pinmux_info *info = dev_get_drvdata(chip->parent);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:125:	val = readl(chip->base + offset);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:130:	writel(val, chip->base + offset);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:139:	return !!(readl(chip->base + offset) & BIT(shift));
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:152:	for (i = 0; i < chip->num_banks; i++) {
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:153:		unsigned long val = readl(chip->base + (i * GPIO_BANK_SIZE) +
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:164:			writel(BIT(bit), chip->base + (i * GPIO_BANK_SIZE) +
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:185:	writel(val, chip->base + offset);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:209:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:211:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:220:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:222:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:257:		dev_err(chip->dev, "invalid GPIO IRQ type 0x%x\n",
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:262:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:268:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:270:	dev_dbg(chip->dev,
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:294:	if (!chip->pinmux_is_supported)
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:305:	if (!chip->pinmux_is_supported)
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:316:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:318:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:320:	dev_dbg(chip->dev, "gpio:%u set input\n", gpio);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:331:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:334:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:336:	dev_dbg(chip->dev, "gpio:%u set output, value:%d\n", gpio, val);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:346:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:348:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:350:	dev_dbg(chip->dev, "gpio:%u set, value:%d\n", gpio, val);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:360:	return !!(readl(chip->base + offset) & BIT(shift));
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:390:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:400:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:402:	dev_dbg(chip->dev, "gpio:%u set pullup:%d\n", gpio, pull_up);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:412:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:415:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:430:	if (chip->io_ctrl) {
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:431:		base = chip->io_ctrl;
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:434:		base = chip->base;
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:441:	dev_dbg(chip->dev, "gpio:%u set drive strength:%d mA\n", gpio,
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:444:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:453:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:466:	if (chip->io_ctrl) {
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:467:		base = chip->io_ctrl;
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:470:		base = chip->base;
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:477:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:488:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:579:			dev_err(chip->dev, "invalid configuration\n");
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:603:	struct pinctrl_desc *pctldesc = &chip->pctldesc;
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:605:	struct gpio_chip *gc = &chip->gc;
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:608:	pins = devm_kcalloc(chip->dev, gc->ngpio, sizeof(*pins), GFP_KERNEL);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:614:		pins[i].name = devm_kasprintf(chip->dev, GFP_KERNEL,
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:620:	pctldesc->name = dev_name(chip->dev);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:626:	chip->pctl = devm_pinctrl_register(chip->dev, pctldesc, chip);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:627:	if (IS_ERR(chip->pctl)) {
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:628:		dev_err(chip->dev, "unable to register pinctrl device\n");
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:629:		return PTR_ERR(chip->pctl);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:656:	chip->dev = dev;
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:660:	chip->base = devm_ioremap_resource(dev, res);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:661:	if (IS_ERR(chip->base)) {
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:663:		return PTR_ERR(chip->base);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:668:		chip->io_ctrl = devm_ioremap_resource(dev, res);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:669:		if (IS_ERR(chip->io_ctrl)) {
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:671:			return PTR_ERR(chip->io_ctrl);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:680:	spin_lock_init(&chip->lock);
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:682:	gc = &chip->gc;
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:685:	chip->num_banks = (ngpios + NGPIOS_PER_BANK - 1) / NGPIOS_PER_BANK;
./drivers/pinctrl/bcm/pinctrl-iproc-gpio.c:696:	chip->pinmux_is_supported = of_property_read_bool(dev->of_node,
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:109:		base_address = chip->io_ctrl;
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:111:		base_address = chip->base;
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:130:		return !!(readl(chip->io_ctrl + reg) & BIT(gpio));
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:132:		return !!(readl(chip->base + reg) & BIT(gpio));
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:138:	struct gpio_chip gc = chip->gc;
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:144:	int_status = readl(chip->base + NSP_CHIP_A_INT_STATUS);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:149:		event = readl(chip->base + NSP_GPIO_EVENT_INT_MASK) &
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:150:			      readl(chip->base + NSP_GPIO_EVENT);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:151:		level = readl(chip->base + NSP_GPIO_DATA_IN) ^
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:152:			      readl(chip->base + NSP_GPIO_INT_POLARITY);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:153:		level &= readl(chip->base + NSP_GPIO_INT_MASK);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:161:			writel(BIT(bit), chip->base + NSP_GPIO_EVENT);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:163:				irq_linear_revmap(chip->irq_domain, bit));
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:206:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:208:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:216:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:218:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:229:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:251:		dev_err(chip->dev, "invalid GPIO IRQ type 0x%x\n",
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:253:		spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:259:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:261:	dev_dbg(chip->dev, "gpio:%u level_low:%s falling:%s\n", gpio,
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:298:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:300:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:302:	dev_dbg(chip->dev, "gpio:%u set input\n", gpio);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:312:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:315:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:317:	dev_dbg(chip->dev, "gpio:%u set output, value:%d\n", gpio, val);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:326:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:328:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:330:	dev_dbg(chip->dev, "gpio:%u set, value:%d\n", gpio, val);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:337:	return !!(readl(chip->base + NSP_GPIO_DATA_IN) & BIT(gpio));
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:344:	return irq_linear_revmap(chip->irq_domain, offset);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:384:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:387:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:389:	dev_dbg(chip->dev, "gpio:%u set pullup:%d pulldown: %d\n",
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:399:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:402:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:418:	dev_dbg(chip->dev, "gpio:%u set drive strength:%d mA\n", gpio,
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:420:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:423:		val = readl(chip->io_ctrl + offset);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:426:		writel(val, chip->io_ctrl + offset);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:429:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:445:	spin_lock_irqsave(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:448:		val = readl(chip->io_ctrl + offset) & BIT(shift);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:456:	spin_unlock_irqrestore(&chip->lock, flags);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:564:			dev_err(chip->dev, "invalid configuration\n");
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:591:	struct pinctrl_desc *pctldesc = &chip->pctldesc;
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:593:	struct gpio_chip *gc = &chip->gc;
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:596:	pins = devm_kcalloc(chip->dev, gc->ngpio, sizeof(*pins), GFP_KERNEL);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:601:		pins[i].name = devm_kasprintf(chip->dev, GFP_KERNEL,
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:606:	pctldesc->name = dev_name(chip->dev);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:612:	chip->pctl = devm_pinctrl_register(chip->dev, pctldesc, chip);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:613:	if (IS_ERR(chip->pctl)) {
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:614:		dev_err(chip->dev, "unable to register pinctrl device\n");
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:615:		return PTR_ERR(chip->pctl);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:644:	chip->dev = dev;
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:648:	chip->base = devm_ioremap_resource(dev, res);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:649:	if (IS_ERR(chip->base)) {
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:651:		return PTR_ERR(chip->base);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:655:	chip->io_ctrl = devm_ioremap_resource(dev, res);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:656:	if (IS_ERR(chip->io_ctrl)) {
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:658:		return PTR_ERR(chip->io_ctrl);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:661:	spin_lock_init(&chip->lock);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:662:	gc = &chip->gc;
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:681:		chip->irq_domain = irq_domain_add_linear(gc->of_node, gc->ngpio,
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:684:		if (!chip->irq_domain) {
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:691:			int irq = irq_create_mapping(chip->irq_domain, count);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:707:		val = readl(chip->base + NSP_CHIP_A_INT_MASK);
./drivers/pinctrl/bcm/pinctrl-nsp-gpio.c:709:		writel(val, (chip->base + NSP_CHIP_A_INT_MASK));
./drivers/pinctrl/bcm/pinctrl-bcm2835.c:335:	return pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/bcm/pinctrl-bcm2835.c:368:	return pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/sh-pfc/gpio.c:44:	return chip->pfc;
./drivers/pinctrl/sh-pfc/gpio.c:51:	int idx = sh_pfc_get_pin_index(chip->pfc, offset);
./drivers/pinctrl/sh-pfc/gpio.c:52:	struct sh_pfc_gpio_pin *gpio_pin = &chip->pins[idx];
./drivers/pinctrl/sh-pfc/gpio.c:54:	*reg = &chip->regs[gpio_pin->dreg];
./drivers/pinctrl/sh-pfc/gpio.c:62:	void __iomem *mem = address - chip->mem->phys + chip->mem->virt;
./drivers/pinctrl/sh-pfc/gpio.c:71:	void __iomem *mem = address - chip->mem->phys + chip->mem->virt;
./drivers/pinctrl/sh-pfc/gpio.c:78:	struct sh_pfc *pfc = chip->pfc;
./drivers/pinctrl/sh-pfc/gpio.c:79:	struct sh_pfc_gpio_pin *gpio_pin = &chip->pins[idx];
./drivers/pinctrl/sh-pfc/gpio.c:100:	struct sh_pfc *pfc = chip->pfc;
./drivers/pinctrl/sh-pfc/gpio.c:110:	chip->regs = devm_kzalloc(pfc->dev, i * sizeof(*chip->regs),
./drivers/pinctrl/sh-pfc/gpio.c:112:	if (chip->regs == NULL)
./drivers/pinctrl/sh-pfc/gpio.c:116:		chip->regs[i].info = dreg;
./drivers/pinctrl/sh-pfc/gpio.c:117:		chip->regs[i].shadow = gpio_read_data_reg(chip, dreg);
./drivers/pinctrl/sh-pfc/gpio.c:223:	struct sh_pfc *pfc = chip->pfc;
./drivers/pinctrl/sh-pfc/gpio.c:224:	struct gpio_chip *gc = &chip->gpio_chip;
./drivers/pinctrl/sh-pfc/gpio.c:227:	chip->pins = devm_kzalloc(pfc->dev, pfc->info->nr_pins *
./drivers/pinctrl/sh-pfc/gpio.c:228:				  sizeof(*chip->pins), GFP_KERNEL);
./drivers/pinctrl/sh-pfc/gpio.c:229:	if (chip->pins == NULL)
./drivers/pinctrl/sh-pfc/gpio.c:285:	struct sh_pfc *pfc = chip->pfc;
./drivers/pinctrl/sh-pfc/gpio.c:286:	struct gpio_chip *gc = &chip->gpio_chip;
./drivers/pinctrl/sh-pfc/gpio.c:314:	chip->mem = mem;
./drivers/pinctrl/sh-pfc/gpio.c:315:	chip->pfc = pfc;
./drivers/pinctrl/sh-pfc/gpio.c:321:	ret = gpiochip_add_data(&chip->gpio_chip, chip);
./drivers/pinctrl/sh-pfc/gpio.c:326:		 chip->gpio_chip.label, chip->gpio_chip.base,
./drivers/pinctrl/sh-pfc/gpio.c:327:		 chip->gpio_chip.base + chip->gpio_chip.ngpio - 1);
./drivers/pinctrl/sh-pfc/gpio.c:388:		ret = gpiochip_add_pin_range(&chip->gpio_chip,
./drivers/pinctrl/vt8500/pinctrl-wmt.c:540:	return pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/vt8500/pinctrl-wmt.c:547:	return pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/pinctrl-as3722.c:517:	return pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/pinctrl-as3722.c:524:	return pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/sirf/pinctrl-atlas7.c:5859:	if (pinctrl_request_gpio(chip->base + gpio))
./drivers/pinctrl/sirf/pinctrl-atlas7.c:5889:	pinctrl_free_gpio(chip->base + gpio);
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6039:	chip->request = atlas7_gpio_request;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6040:	chip->free = atlas7_gpio_free;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6041:	chip->direction_input = atlas7_gpio_direction_input;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6042:	chip->get = atlas7_gpio_get_value;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6043:	chip->direction_output = atlas7_gpio_direction_output;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6044:	chip->set = atlas7_gpio_set_value;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6045:	chip->base = -1;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6047:	chip->ngpio = NGPIO_OF_BANK * nbank;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6048:	chip->label = kstrdup(np->name, GFP_KERNEL);
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6049:	chip->of_node = np;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6050:	chip->of_gpio_n_cells = 2;
./drivers/pinctrl/sirf/pinctrl-atlas7.c:6051:	chip->parent = &pdev->dev;
./drivers/pinctrl/sirf/pinctrl-sirf.c:613:	if (pinctrl_request_gpio(chip->base + offset))
./drivers/pinctrl/sirf/pinctrl-sirf.c:643:	pinctrl_free_gpio(chip->base + offset);
./drivers/pinctrl/nomadik/pinctrl-abx500.c:614:		seq_printf(s, " %-9s", chip->get(chip, offset) ? "hi" : "lo");
./drivers/pinctrl/nomadik/pinctrl-abx500.c:628:	unsigned gpio = chip->base;
./drivers/pinctrl/nomadik/pinctrl-abx500.c:632:	for (i = 0; i < chip->ngpio; i++, gpio++) {
./drivers/pinctrl/nomadik/pinctrl-abx500.c:805:				 chip->base + offset - 1);
./drivers/pinctrl/nomadik/pinctrl-abx500.c:981:		dev_dbg(chip->parent, "pin %d [%#lx]: %s %s\n",
./drivers/pinctrl/nomadik/pinctrl-abx500.c:1072:			dev_err(chip->parent,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:298:	afunc = readl(nmk_chip->addr + NMK_GPIO_AFSLA) & ~BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:299:	bfunc = readl(nmk_chip->addr + NMK_GPIO_AFSLB) & ~BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:304:	writel(afunc, nmk_chip->addr + NMK_GPIO_AFSLA);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:305:	writel(bfunc, nmk_chip->addr + NMK_GPIO_AFSLB);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:313:	slpm = readl(nmk_chip->addr + NMK_GPIO_SLPC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:318:	writel(slpm, nmk_chip->addr + NMK_GPIO_SLPC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:326:	pdis = readl(nmk_chip->addr + NMK_GPIO_PDIS);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:329:		nmk_chip->pull_up &= ~BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:334:	writel(pdis, nmk_chip->addr + NMK_GPIO_PDIS);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:337:		nmk_chip->pull_up |= BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:338:		writel(BIT(offset), nmk_chip->addr + NMK_GPIO_DATS);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:340:		nmk_chip->pull_up &= ~BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:341:		writel(BIT(offset), nmk_chip->addr + NMK_GPIO_DATC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:348:	bool enabled = nmk_chip->lowemi & BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:354:		nmk_chip->lowemi |= BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:356:		nmk_chip->lowemi &= ~BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:358:	writel_relaxed(nmk_chip->lowemi,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:359:		       nmk_chip->addr + NMK_GPIO_LOWEMI);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:365:	writel(BIT(offset), nmk_chip->addr + NMK_GPIO_DIRC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:372:		writel(BIT(offset), nmk_chip->addr + NMK_GPIO_DATS);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:374:		writel(BIT(offset), nmk_chip->addr + NMK_GPIO_DATC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:380:	writel(BIT(offset), nmk_chip->addr + NMK_GPIO_DIRS);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:388:	u32 rwimsc = nmk_chip->rwimsc;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:389:	u32 fwimsc = nmk_chip->fwimsc;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:391:	if (glitch && nmk_chip->set_ioforce) {
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:395:		writel(rwimsc & ~bit, nmk_chip->addr + NMK_GPIO_RWIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:396:		writel(fwimsc & ~bit, nmk_chip->addr + NMK_GPIO_FWIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:398:		nmk_chip->set_ioforce(true);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:403:	if (glitch && nmk_chip->set_ioforce) {
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:404:		nmk_chip->set_ioforce(false);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:406:		writel(rwimsc, nmk_chip->addr + NMK_GPIO_RWIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:407:		writel(fwimsc, nmk_chip->addr + NMK_GPIO_FWIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:414:	u32 falling = nmk_chip->fimsc & BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:415:	u32 rising = nmk_chip->rimsc & BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:416:	int gpio = nmk_chip->chip.base + offset;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:417:	int irq = irq_find_mapping(nmk_chip->chip.irqdomain, offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:427:		nmk_chip->rimsc &= ~BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:428:		writel_relaxed(nmk_chip->rimsc,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:429:			       nmk_chip->addr + NMK_GPIO_RIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:433:		nmk_chip->fimsc &= ~BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:434:		writel_relaxed(nmk_chip->fimsc,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:435:			       nmk_chip->addr + NMK_GPIO_FIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:438:	dev_dbg(nmk_chip->chip.parent, "%d: clearing interrupt mask\n", gpio);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:559:		clk_enable(chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:561:		slpm[i] = readl(chip->addr + NMK_GPIO_SLPC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:562:		writel(temp, chip->addr + NMK_GPIO_SLPC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:576:		writel(slpm[i], chip->addr + NMK_GPIO_SLPC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:578:		clk_disable(chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:621:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:622:	writel(BIT(d->hwirq), nmk_chip->addr + NMK_GPIO_IC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:623:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:643:		rimscval = &nmk_chip->rimsc;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:644:		fimscval = &nmk_chip->fimsc;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:648:		rimscval = &nmk_chip->rwimsc;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:649:		fimscval = &nmk_chip->fwimsc;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:653:	if (nmk_chip->edge_rising & BIT(offset)) {
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:658:		writel(*rimscval, nmk_chip->addr + rimscreg);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:660:	if (nmk_chip->edge_falling & BIT(offset)) {
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:665:		writel(*fimscval, nmk_chip->addr + fimscreg);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:677:	if (nmk_chip->sleepmode && on) {
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:694:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:696:	spin_lock(&nmk_chip->lock);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:700:	if (!(nmk_chip->real_wake & BIT(d->hwirq)))
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:703:	spin_unlock(&nmk_chip->lock);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:705:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:729:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:731:	spin_lock(&nmk_chip->lock);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:737:		nmk_chip->real_wake |= BIT(d->hwirq);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:739:		nmk_chip->real_wake &= ~BIT(d->hwirq);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:741:	spin_unlock(&nmk_chip->lock);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:743:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:763:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:764:	spin_lock_irqsave(&nmk_chip->lock, flags);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:772:	nmk_chip->edge_rising &= ~BIT(d->hwirq);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:774:		nmk_chip->edge_rising |= BIT(d->hwirq);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:776:	nmk_chip->edge_falling &= ~BIT(d->hwirq);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:778:		nmk_chip->edge_falling |= BIT(d->hwirq);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:786:	spin_unlock_irqrestore(&nmk_chip->lock, flags);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:787:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:796:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:806:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:819:		generic_handle_irq(irq_find_mapping(chip->irqdomain, bit));
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:832:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:833:	status = readl(nmk_chip->addr + NMK_GPIO_IS);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:834:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:843:	u32 status = nmk_chip->get_latent_status(nmk_chip->bank);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:855:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:857:	dir = !(readl(nmk_chip->addr + NMK_GPIO_DIR) & BIT(offset));
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:859:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:868:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:870:	writel(BIT(offset), nmk_chip->addr + NMK_GPIO_DIRC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:872:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:882:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:884:	value = !!(readl(nmk_chip->addr + NMK_GPIO_DAT) & BIT(offset));
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:886:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:896:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:900:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:908:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:912:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:922:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:924:	afunc = readl(nmk_chip->addr + NMK_GPIO_AFSLA) & BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:925:	bfunc = readl(nmk_chip->addr + NMK_GPIO_AFSLB) & BIT(offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:927:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:960:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:961:	is_out = !!(readl(nmk_chip->addr + NMK_GPIO_DIR) & BIT(offset));
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:962:	pull = !(readl(nmk_chip->addr + NMK_GPIO_PDIS) & BIT(offset));
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:963:	data_out = !!(readl(nmk_chip->addr + NMK_GPIO_DAT) & BIT(offset));
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:999:			if (nmk_chip->edge_rising & BIT(offset))
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1001:			else if (nmk_chip->edge_falling & BIT(offset))
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1012:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1018:	unsigned		gpio = chip->base;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1020:	for (i = 0; i < chip->ngpio; i++, gpio++) {
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1046:		clk_enable(chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1060:		clk_disable(chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1083:		clk_enable(chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1085:		writel(chip->rwimsc & chip->real_wake,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1086:		       chip->addr + NMK_GPIO_RWIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1087:		writel(chip->fwimsc & chip->real_wake,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1088:		       chip->addr + NMK_GPIO_FWIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1090:		clk_disable(chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1104:		clk_enable(chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1106:		writel(chip->rwimsc, chip->addr + NMK_GPIO_RWIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1107:		writel(chip->fwimsc, chip->addr + NMK_GPIO_FWIMSC);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1109:		clk_disable(chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1128:		*pull_up = chip->pull_up;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1168:	nmk_chip->bank = id;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1169:	chip = &nmk_chip->chip;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1170:	chip->base = id * NMK_GPIO_PER_CHIP;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1171:	chip->ngpio = NMK_GPIO_PER_CHIP;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1172:	chip->label = dev_name(&gpio_pdev->dev);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1173:	chip->parent = &gpio_pdev->dev;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1179:	nmk_chip->addr = base;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1185:	nmk_chip->clk = clk;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1187:	BUG_ON(nmk_chip->bank >= ARRAY_SIZE(nmk_gpio_chips));
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1215:	dev->id = nmk_chip->bank;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1225:	 * The virt address in nmk_chip->addr is in the nomadik register space,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1228:	nmk_chip->parent_irq = irq;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1229:	nmk_chip->latent_parent_irq = latent_irq;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1230:	nmk_chip->sleepmode = supports_sleepmode;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1231:	spin_lock_init(&nmk_chip->lock);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1233:	chip = &nmk_chip->chip;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1234:	chip->request = gpiochip_generic_request;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1235:	chip->free = gpiochip_generic_free;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1236:	chip->get_direction = nmk_gpio_get_dir;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1237:	chip->direction_input = nmk_gpio_make_input;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1238:	chip->get = nmk_gpio_get_input;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1239:	chip->direction_output = nmk_gpio_make_output;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1240:	chip->set = nmk_gpio_set_output;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1241:	chip->dbg_show = nmk_gpio_dbg_show;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1242:	chip->can_sleep = false;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1243:	chip->owner = THIS_MODULE;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1245:	irqchip = &nmk_chip->irqchip;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1246:	irqchip->irq_ack = nmk_gpio_irq_ack;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1247:	irqchip->irq_mask = nmk_gpio_irq_mask;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1248:	irqchip->irq_unmask = nmk_gpio_irq_unmask;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1249:	irqchip->irq_set_type = nmk_gpio_irq_set_type;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1250:	irqchip->irq_set_wake = nmk_gpio_irq_set_wake;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1251:	irqchip->irq_startup = nmk_gpio_irq_startup;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1252:	irqchip->irq_shutdown = nmk_gpio_irq_shutdown;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1253:	irqchip->flags = IRQCHIP_MASK_ON_SUSPEND;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1254:	irqchip->name = kasprintf(GFP_KERNEL, "nmk%u-%u-%u",
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1256:				  chip->base,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1257:				  chip->base + chip->ngpio - 1);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1259:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1260:	nmk_chip->lowemi = readl_relaxed(nmk_chip->addr + NMK_GPIO_LOWEMI);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1261:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1262:	chip->of_node = np;
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1282:		gpiochip_remove(&nmk_chip->chip);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1288:				     nmk_chip->parent_irq,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1290:	if (nmk_chip->latent_parent_irq > 0)
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1293:					     nmk_chip->latent_parent_irq,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1296:	dev_info(&dev->dev, "at address %p\n", nmk_chip->addr);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1361:	nmk_gpio_dbg_show_one(s, pctldev, chip, offset - chip->base, offset);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1717:		clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1730:		clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1779:	clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1783:	clk_disable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1876:			dev_dbg(nmk_chip->chip.parent,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1885:		dev_dbg(nmk_chip->chip.parent,
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1892:		clk_enable(nmk_chip->clk);
./drivers/pinctrl/nomadik/pinctrl-nomadik.c:1907:		clk_disable(nmk_chip->clk);
./drivers/pinctrl/stm32/pinctrl-stm32.c:132:	return pinctrl_request_gpio(chip->base + offset);
./drivers/pinctrl/stm32/pinctrl-stm32.c:137:	pinctrl_free_gpio(chip->base + offset);
./drivers/pinctrl/stm32/pinctrl-stm32.c:163:	return pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/stm32/pinctrl-stm32.c:172:	pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:452:	return pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:462:	u32 pin = offset + chip->base;
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:503:	return pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:531:	if (offset >= chip->ngpio)
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:540:	dev_dbg(chip->parent, "%s: request IRQ for GPIO %d, return %d\n",
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:541:		chip->label, offset + chip->base, irqnum);
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:947:	pctl->chip->owner = THIS_MODULE;
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:948:	pctl->chip->request = gpiochip_generic_request,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:949:	pctl->chip->free = gpiochip_generic_free,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:950:	pctl->chip->direction_input = sunxi_pinctrl_gpio_direction_input,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:951:	pctl->chip->direction_output = sunxi_pinctrl_gpio_direction_output,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:952:	pctl->chip->get = sunxi_pinctrl_gpio_get,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:953:	pctl->chip->set = sunxi_pinctrl_gpio_set,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:954:	pctl->chip->of_xlate = sunxi_pinctrl_gpio_of_xlate,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:955:	pctl->chip->to_irq = sunxi_pinctrl_gpio_to_irq,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:956:	pctl->chip->of_gpio_n_cells = 3,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:957:	pctl->chip->can_sleep = false,
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:958:	pctl->chip->ngpio = round_up(last_pin, PINS_PER_BANK) -
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:960:	pctl->chip->label = dev_name(&pdev->dev);
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:961:	pctl->chip->parent = &pdev->dev;
./drivers/pinctrl/sunxi/pinctrl-sunxi.c:962:	pctl->chip->base = pctl->desc->pin_base;
./drivers/pinctrl/qcom/pinctrl-spmi-gpio.c:549:	if (chip->of_gpio_n_cells < 2)
./drivers/pinctrl/qcom/pinctrl-spmi-gpio.c:573:	for (i = 0; i < chip->ngpio; i++) {
./drivers/pinctrl/qcom/pinctrl-ssbi-mpp.c:529:	if (chip->of_gpio_n_cells < 2)
./drivers/pinctrl/qcom/pinctrl-ssbi-mpp.c:633:	unsigned gpio = chip->base;
./drivers/pinctrl/qcom/pinctrl-ssbi-mpp.c:636:	for (i = 0; i < chip->ngpio; i++, gpio++) {
./drivers/pinctrl/qcom/pinctrl-msm.c:495:	unsigned gpio = chip->base;
./drivers/pinctrl/qcom/pinctrl-msm.c:498:	for (i = 0; i < chip->ngpio; i++, gpio++) {
./drivers/pinctrl/qcom/pinctrl-msm.c:795:	chip->base = 0;
./drivers/pinctrl/qcom/pinctrl-msm.c:796:	chip->ngpio = ngpio;
./drivers/pinctrl/qcom/pinctrl-msm.c:797:	chip->label = dev_name(pctrl->dev);
./drivers/pinctrl/qcom/pinctrl-msm.c:798:	chip->parent = pctrl->dev;
./drivers/pinctrl/qcom/pinctrl-msm.c:799:	chip->owner = THIS_MODULE;
./drivers/pinctrl/qcom/pinctrl-msm.c:800:	chip->of_node = pctrl->dev->of_node;
./drivers/pinctrl/qcom/pinctrl-msm.c:808:	ret = gpiochip_add_pin_range(&pctrl->chip, dev_name(pctrl->dev), 0, 0, chip->ngpio);
./drivers/pinctrl/qcom/pinctrl-ssbi-gpio.c:516:	if (chip->of_gpio_n_cells < 2)
./drivers/pinctrl/qcom/pinctrl-ssbi-gpio.c:578:	unsigned gpio = chip->base;
./drivers/pinctrl/qcom/pinctrl-ssbi-gpio.c:581:	for (i = 0; i < chip->ngpio; i++, gpio++) {
./drivers/pinctrl/qcom/pinctrl-spmi-mpp.c:613:	if (chip->of_gpio_n_cells < 2)
./drivers/pinctrl/qcom/pinctrl-spmi-mpp.c:637:	for (i = 0; i < chip->ngpio; i++) {
./drivers/pinctrl/uniphier/pinctrl-uniphier-ld6b.c:1219:	UNIPHIER_PINMUX_FUNCTION(adinter), /* Achip-Dchip interconnect */
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:786:	return pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:793:	return pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1004:	struct mtk_pinctrl *pctl = dev_get_drvdata(chip->parent);
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1139:	for (port = 0; port < chip->ports; port++) {
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1141:		writel_relaxed(~buf[port], reg + chip->mask_set);
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1142:		writel_relaxed(buf[port], reg + chip->mask_clr);
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1152:	for (port = 0; port < chip->ports; port++) {
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1153:		reg = eint_reg_base + chip->mask + (port << 2);
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1412:	pctl->chip->ngpio = pctl->devdata->npins;
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1413:	pctl->chip->label = dev_name(&pdev->dev);
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1414:	pctl->chip->parent = &pdev->dev;
./drivers/pinctrl/mediatek/pinctrl-mtk-common.c:1415:	pctl->chip->base = -1;
./drivers/pinctrl/meson/pinctrl-meson.c:450:	return pinctrl_request_gpio(chip->base + gpio);
./drivers/pinctrl/spear/pinctrl-plgpio.c:164:	if (offset >= chip->ngpio)
./drivers/pinctrl/spear/pinctrl-plgpio.c:181:	if (offset >= chip->ngpio)
./drivers/pinctrl/spear/pinctrl-plgpio.c:200:	int gpio = chip->base + offset;
./drivers/pinctrl/spear/pinctrl-plgpio.c:204:	if (offset >= chip->ngpio)
./drivers/pinctrl/spear/pinctrl-plgpio.c:252:	int gpio = chip->base + offset;
./drivers/pinctrl/spear/pinctrl-plgpio.c:255:	if (offset >= chip->ngpio)
./drivers/pinctrl/core.c:363:			if (range->base + range->npins - 1 < chip->base ||
./drivers/pinctrl/core.c:364:			    range->base > chip->base + chip->ngpio - 1)
./drivers/pinctrl/intel/pinctrl-cherryview.c:1226:	return pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/intel/pinctrl-cherryview.c:1233:	return pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/intel/pinctrl-cherryview.c:1444:	chip->ngpio = pctrl->community->ngpios;
./drivers/pinctrl/intel/pinctrl-cherryview.c:1445:	chip->label = dev_name(pctrl->dev);
./drivers/pinctrl/intel/pinctrl-cherryview.c:1446:	chip->parent = pctrl->dev;
./drivers/pinctrl/intel/pinctrl-cherryview.c:1447:	chip->base = -1;
./drivers/pinctrl/intel/pinctrl-intel.c:627:	return pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/intel/pinctrl-intel.c:634:	return pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/intel/pinctrl-baytrail.c:1359:	return pinctrl_gpio_direction_input(chip->base + offset);
./drivers/pinctrl/intel/pinctrl-baytrail.c:1365:	int ret = pinctrl_gpio_direction_output(chip->base + offset);
./drivers/pinctrl/intel/pinctrl-baytrail.c:1616:	chip->irq_eoi(data);
./drivers/pinctrl/pinctrl-coh901.c:501:	struct u300_gpio_port *port = &gpio->ports[irq - chip->base];
./drivers/pinctrl/pinctrl-coh901.c:520:			int pin_irq = irq_find_mapping(chip->irqdomain, offset);
./drivers/pinctrl/pinctrl-digicolor.c:246:	chip->label		= DRIVER_NAME;
./drivers/pinctrl/pinctrl-digicolor.c:247:	chip->parent		= pmap->dev;
./drivers/pinctrl/pinctrl-digicolor.c:248:	chip->request		= gpiochip_generic_request;
./drivers/pinctrl/pinctrl-digicolor.c:249:	chip->free		= gpiochip_generic_free;
./drivers/pinctrl/pinctrl-digicolor.c:250:	chip->direction_input	= dc_gpio_direction_input;
./drivers/pinctrl/pinctrl-digicolor.c:251:	chip->direction_output	= dc_gpio_direction_output;
./drivers/pinctrl/pinctrl-digicolor.c:252:	chip->get		= dc_gpio_get;
./drivers/pinctrl/pinctrl-digicolor.c:253:	chip->set		= dc_gpio_set;
./drivers/pinctrl/pinctrl-digicolor.c:254:	chip->base		= -1;
./drivers/pinctrl/pinctrl-digicolor.c:255:	chip->ngpio		= PINS_COUNT;
./drivers/pinctrl/pinctrl-digicolor.c:256:	chip->of_node		= np;
./drivers/pinctrl/pinctrl-digicolor.c:257:	chip->of_gpio_n_cells	= 2;
./drivers/pinctrl/pinctrl-rockchip.c:1332:	pin = offset - chip->base;
./drivers/pinctrl/pinctrl-rockchip.c:1336:	return _rockchip_pmx_gpio_set_direction(chip, offset - chip->base,
./drivers/pinctrl/pinctrl-rockchip.c:1685:	ctrldesc->name = "rockchip-pinctrl";
./drivers/pinctrl/pinctrl-rockchip.c:2712:		.name	= "rockchip-pinctrl",
./drivers/pinctrl/pinctrl-at91-pio4.c:976:	atmel_pioctrl->gpio_chip->of_node = dev->of_node;
./drivers/pinctrl/pinctrl-at91-pio4.c:977:	atmel_pioctrl->gpio_chip->ngpio = atmel_pioctrl->npins;
./drivers/pinctrl/pinctrl-at91-pio4.c:978:	atmel_pioctrl->gpio_chip->label = dev_name(dev);
./drivers/pinctrl/pinctrl-at91-pio4.c:979:	atmel_pioctrl->gpio_chip->parent = dev;
./drivers/pinctrl/pinctrl-at91-pio4.c:980:	atmel_pioctrl->gpio_chip->names = atmel_pioctrl->group_names;
./drivers/pinctrl/pinctrl-at91-pio4.c:1014:			atmel_pioctrl->gpio_chip->ngpio,
./drivers/pinctrl/pinctrl-at91-pio4.c:1055:				     0, 0, atmel_pioctrl->gpio_chip->ngpio);
./drivers/irqchip/irq-alpine-msi.c:140:	d->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);
./drivers/irqchip/irq-mtk-sysirq.c:55:	ret = data->chip->irq_set_type(data, type);
./drivers/irqchip/irq-metag-ext.c:137:	if (data->chip->irq_ack)
./drivers/irqchip/irq-metag-ext.c:138:		data->chip->irq_ack(data);
./drivers/irqchip/irq-metag-ext.c:144:	data->chip->irq_unmask(data);
./drivers/irqchip/irq-metag-ext.c:161:	data->chip->irq_mask(data);
./drivers/irqchip/irq-tango.c:51:	return readl_relaxed(chip->base + reg);
./drivers/irqchip/irq-tango.c:56:	writel_relaxed(val, chip->base + reg);
./drivers/irqchip/irq-tango.c:83:	status_lo = intc_readl(chip, chip->ctl + IRQ_STATUS);
./drivers/irqchip/irq-tango.c:84:	status_hi = intc_readl(chip, chip->ctl + IRQ_CTL_HI + IRQ_STATUS);
./drivers/irqchip/irq-tango.c:134:	unsigned long ctl_base = chip->ctl + ctl_offs;
./drivers/irqchip/irq-tango.c:138:	gc->reg_base = chip->base;
./drivers/irqchip/irq-tango.c:194:	chip->ctl = res.start - baseres->start;
./drivers/irqchip/irq-tango.c:195:	chip->base = base;
./drivers/irqchip/exynos-combiner.c:105:	if (chip && chip->irq_set_affinity)
./drivers/irqchip/exynos-combiner.c:106:		return chip->irq_set_affinity(data, mask_val, force);
./drivers/irqchip/irq-mbigen.c:228:				      &mbigen_irq_chip, mgn_chip->base);
./drivers/irqchip/irq-mbigen.c:253:	mgn_chip->pdev = pdev;
./drivers/irqchip/irq-mbigen.c:256:	mgn_chip->base = devm_ioremap_resource(&pdev->dev, res);
./drivers/irqchip/irq-mbigen.c:257:	if (IS_ERR(mgn_chip->base))
./drivers/irqchip/irq-mbigen.c:258:		return PTR_ERR(mgn_chip->base);
./drivers/irqchip/irq-gic.c:1349:IRQCHIP_DECLARE(arm1176jzf_dc_gic, "arm,arm1176jzf-devchip-gic", gic_of_init);
./drivers/irqchip/irq-gic-v2m.c:150:	d->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);
./drivers/irqchip/irq-renesas-intc-irqpin.c:545:	irq_chip->name = name;
./drivers/irqchip/irq-renesas-intc-irqpin.c:546:	irq_chip->irq_mask = disable_fn;
./drivers/irqchip/irq-renesas-intc-irqpin.c:547:	irq_chip->irq_unmask = enable_fn;
./drivers/irqchip/irq-renesas-intc-irqpin.c:548:	irq_chip->irq_set_type = intc_irqpin_irq_set_type;
./drivers/irqchip/irq-renesas-intc-irqpin.c:549:	irq_chip->irq_set_wake = intc_irqpin_irq_set_wake;
./drivers/irqchip/irq-renesas-intc-irqpin.c:550:	irq_chip->flags	= IRQCHIP_MASK_ON_SUSPEND;
./drivers/irqchip/irq-ts4800.c:118:	irq_chip->name = dev_name(&pdev->dev);
./drivers/irqchip/irq-ts4800.c:119:	irq_chip->irq_mask = ts4800_irq_mask;
./drivers/irqchip/irq-ts4800.c:120:	irq_chip->irq_unmask = ts4800_irq_unmask;
./drivers/irqchip/irq-partition-percpu.c:49:	    chip->irq_mask)
./drivers/irqchip/irq-partition-percpu.c:50:		chip->irq_mask(data);
./drivers/irqchip/irq-partition-percpu.c:60:	    chip->irq_unmask)
./drivers/irqchip/irq-partition-percpu.c:61:		chip->irq_unmask(data);
./drivers/irqchip/irq-partition-percpu.c:73:	    chip->irq_set_irqchip_state)
./drivers/irqchip/irq-partition-percpu.c:74:		return chip->irq_set_irqchip_state(data, which, val);
./drivers/irqchip/irq-partition-percpu.c:88:	    chip->irq_get_irqchip_state)
./drivers/irqchip/irq-partition-percpu.c:89:		return chip->irq_get_irqchip_state(data, which, val);
./drivers/irqchip/irq-partition-percpu.c:100:	if (chip->irq_set_type)
./drivers/irqchip/irq-partition-percpu.c:101:		return chip->irq_set_type(data, type);
./drivers/irqchip/irq-partition-percpu.c:112:	seq_printf(p, " %5s-%lu", chip->name, data->hwirq);
./drivers/irqchip/irq-mvebu-odmi.c:117:	d->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);
./drivers/mailbox/rockchip-mailbox.c:273:		.name = "rockchip-mailbox",
./drivers/edac/amd76x_edac.c:65:					 * 31:23 chip-select base
./drivers/edac/amd76x_edac.c:67:					 * 15:7  chip-select mask
./drivers/edac/amd76x_edac.c:70:					 *  0    chip-select enable
./drivers/edac/i5100_edac.c:13: * can not reflect this configuration so instead the chip-select
./drivers/edac/tile_edac.c:137:	/* A TILE MC has a single channel and one chip-select row. */
./drivers/mfd/88pm805.c:138:	struct regmap *map = chip->regmap;
./drivers/mfd/88pm805.c:142:	if (!map || !chip->irq) {
./drivers/mfd/88pm805.c:143:		dev_err(chip->dev, "incorrect parameters\n");
./drivers/mfd/88pm805.c:167:	    regmap_add_irq_chip(chip->regmap, chip->irq, flags, -1,
./drivers/mfd/88pm805.c:168:				chip->regmap_irq_chip, &chip->irq_data);
./drivers/mfd/88pm805.c:176:	regmap_del_irq_chip(chip->irq, chip->irq_data);
./drivers/mfd/88pm805.c:193:	struct regmap *map = chip->regmap;
./drivers/mfd/88pm805.c:196:		dev_err(chip->dev, "regmap is invalid\n");
./drivers/mfd/88pm805.c:200:	chip->regmap_irq_chip = &pm805_irq_chip;
./drivers/mfd/88pm805.c:204:		dev_err(chip->dev, "Failed to init pm805 irq!\n");
./drivers/mfd/88pm805.c:208:	ret = mfd_add_devices(chip->dev, 0, &codec_devs[0],
./drivers/mfd/88pm805.c:212:		dev_err(chip->dev, "Failed to add codec subdev\n");
./drivers/mfd/88pm805.c:215:		dev_info(chip->dev, "[%s]:Added mfd codec_devs\n", __func__);
./drivers/mfd/88pm805.c:242:		dev_err(chip->dev, "Failed to initialize 88pm805 devices\n");
./drivers/mfd/88pm805.c:259:	mfd_remove_devices(chip->dev);
./drivers/mfd/da9062-core.c:172:	ret = regmap_read(chip->regmap, DA9062AA_FAULT_LOG, &fault_log);
./drivers/mfd/da9062-core.c:178:			dev_dbg(chip->dev, "Fault log entry detected: TWD_ERROR\n");
./drivers/mfd/da9062-core.c:180:			dev_dbg(chip->dev, "Fault log entry detected: POR\n");
./drivers/mfd/da9062-core.c:182:			dev_dbg(chip->dev, "Fault log entry detected: VDD_FAULT\n");
./drivers/mfd/da9062-core.c:184:			dev_dbg(chip->dev, "Fault log entry detected: VDD_START\n");
./drivers/mfd/da9062-core.c:186:			dev_dbg(chip->dev, "Fault log entry detected: TEMP_CRIT\n");
./drivers/mfd/da9062-core.c:188:			dev_dbg(chip->dev, "Fault log entry detected: KEY_RESET\n");
./drivers/mfd/da9062-core.c:190:			dev_dbg(chip->dev, "Fault log entry detected: NSHUTDOWN\n");
./drivers/mfd/da9062-core.c:192:			dev_dbg(chip->dev, "Fault log entry detected: WAIT_SHUT\n");
./drivers/mfd/da9062-core.c:194:		ret = regmap_write(chip->regmap, DA9062AA_FAULT_LOG,
./drivers/mfd/da9062-core.c:206:	ret = regmap_read(chip->regmap, DA9062AA_DEVICE_ID, &device_id);
./drivers/mfd/da9062-core.c:208:		dev_err(chip->dev, "Cannot read chip ID.\n");
./drivers/mfd/da9062-core.c:212:		dev_err(chip->dev, "Invalid device ID: 0x%02x\n", device_id);
./drivers/mfd/da9062-core.c:216:	ret = regmap_read(chip->regmap, DA9062AA_VARIANT_ID, &variant_id);
./drivers/mfd/da9062-core.c:218:		dev_err(chip->dev, "Cannot read chip variant id.\n");
./drivers/mfd/da9062-core.c:222:	dev_info(chip->dev,
./drivers/mfd/da9062-core.c:229:		dev_err(chip->dev,
./drivers/mfd/da9062-core.c:471:	chip->dev = &i2c->dev;
./drivers/mfd/da9062-core.c:474:		dev_err(chip->dev, "No IRQ configured\n");
./drivers/mfd/da9062-core.c:478:	chip->regmap = devm_regmap_init_i2c(i2c, &da9062_regmap_config);
./drivers/mfd/da9062-core.c:479:	if (IS_ERR(chip->regmap)) {
./drivers/mfd/da9062-core.c:480:		ret = PTR_ERR(chip->regmap);
./drivers/mfd/da9062-core.c:481:		dev_err(chip->dev, "Failed to allocate register map: %d\n",
./drivers/mfd/da9062-core.c:488:		dev_warn(chip->dev, "Cannot clear fault log\n");
./drivers/mfd/da9062-core.c:494:	ret = regmap_add_irq_chip(chip->regmap, i2c->irq,
./drivers/mfd/da9062-core.c:497:			&chip->regmap_irq);
./drivers/mfd/da9062-core.c:499:		dev_err(chip->dev, "Failed to request IRQ %d: %d\n",
./drivers/mfd/da9062-core.c:504:	irq_base = regmap_irq_chip_get_base(chip->regmap_irq);
./drivers/mfd/da9062-core.c:506:	ret = mfd_add_devices(chip->dev, PLATFORM_DEVID_NONE, da9062_devs,
./drivers/mfd/da9062-core.c:510:		dev_err(chip->dev, "Cannot register child devices\n");
./drivers/mfd/da9062-core.c:511:		regmap_del_irq_chip(i2c->irq, chip->regmap_irq);
./drivers/mfd/da9062-core.c:522:	mfd_remove_devices(chip->dev);
./drivers/mfd/da9062-core.c:523:	regmap_del_irq_chip(i2c->irq, chip->regmap_irq);
./drivers/mfd/max77620.c:200:	switch (chip->chip_id) {
./drivers/mfd/max77620.c:226:	struct device *dev = chip->dev;
./drivers/mfd/max77620.c:234:	switch (chip->chip_id) {
./drivers/mfd/max77620.c:260:		chip->shutdown_fps_period[fps_id] = min(param_val,
./drivers/mfd/max77620.c:263:				chip->shutdown_fps_period[fps_id]);
./drivers/mfd/max77620.c:270:		chip->suspend_fps_period[fps_id] = min(param_val,
./drivers/mfd/max77620.c:288:	if (!chip->sleep_enable && !chip->enable_global_lpm) {
./drivers/mfd/max77620.c:294:				chip->sleep_enable = true;
./drivers/mfd/max77620.c:296:				chip->enable_global_lpm = true;
./drivers/mfd/max77620.c:300:	ret = regmap_update_bits(chip->rmap, MAX77620_REG_FPS_CFG0 + fps_id,
./drivers/mfd/max77620.c:312:	struct device *dev = chip->dev;
./drivers/mfd/max77620.c:319:		chip->shutdown_fps_period[fps_id] = -1;
./drivers/mfd/max77620.c:320:		chip->suspend_fps_period[fps_id] = -1;
./drivers/mfd/max77620.c:333:	config = chip->enable_global_lpm ? MAX77620_ONOFFCNFG2_SLP_LPM_MSK : 0;
./drivers/mfd/max77620.c:334:	ret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,
./drivers/mfd/max77620.c:343:	ret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,
./drivers/mfd/max77620.c:352:	if ((chip->chip_id == MAX20024) && chip->sleep_enable) {
./drivers/mfd/max77620.c:354:		ret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG1,
./drivers/mfd/max77620.c:373:		ret = regmap_read(chip->rmap, i, &val);
./drivers/mfd/max77620.c:375:			dev_err(chip->dev, "Failed to read CID: %d\n", ret);
./drivers/mfd/max77620.c:378:		dev_dbg(chip->dev, "CID%d: 0x%02x\n",
./drivers/mfd/max77620.c:384:	dev_info(chip->dev, "PMIC Version OTP:0x%02X and ES:0x%X\n",
./drivers/mfd/max77620.c:404:	chip->dev = &client->dev;
./drivers/mfd/max77620.c:405:	chip->irq_base = -1;
./drivers/mfd/max77620.c:406:	chip->chip_irq = client->irq;
./drivers/mfd/max77620.c:407:	chip->chip_id = (enum max77620_chip_id)id->driver_data;
./drivers/mfd/max77620.c:409:	switch (chip->chip_id) {
./drivers/mfd/max77620.c:421:		dev_err(chip->dev, "ChipID is invalid %d\n", chip->chip_id);
./drivers/mfd/max77620.c:425:	chip->rmap = devm_regmap_init_i2c(client, rmap_config);
./drivers/mfd/max77620.c:426:	if (IS_ERR(chip->rmap)) {
./drivers/mfd/max77620.c:427:		ret = PTR_ERR(chip->rmap);
./drivers/mfd/max77620.c:428:		dev_err(chip->dev, "Failed to intialise regmap: %d\n", ret);
./drivers/mfd/max77620.c:436:	ret = devm_regmap_add_irq_chip(chip->dev, chip->rmap, client->irq,
./drivers/mfd/max77620.c:438:				       chip->irq_base, &max77620_top_irq_chip,
./drivers/mfd/max77620.c:439:				       &chip->top_irq_data);
./drivers/mfd/max77620.c:441:		dev_err(chip->dev, "Failed to add regmap irq: %d\n", ret);
./drivers/mfd/max77620.c:449:	ret =  devm_mfd_add_devices(chip->dev, PLATFORM_DEVID_NONE,
./drivers/mfd/max77620.c:451:				    regmap_irq_get_domain(chip->top_irq_data));
./drivers/mfd/max77620.c:453:		dev_err(chip->dev, "Failed to add MFD children: %d\n", ret);
./drivers/mfd/max77620.c:467:	ret = regmap_update_bits(chip->rmap, MAX77620_REG_FPS_CFG0 + fps_id,
./drivers/mfd/max77620.c:471:		dev_err(chip->dev, "Failed to update FPS period: %d\n", ret);
./drivers/mfd/max77620.c:487:		if (chip->suspend_fps_period[fps] < 0)
./drivers/mfd/max77620.c:491:					      chip->suspend_fps_period[fps]);
./drivers/mfd/max77620.c:500:	if (chip->chip_id == MAX20024)
./drivers/mfd/max77620.c:503:	config = (chip->sleep_enable) ? MAX77620_ONOFFCNFG1_SLPEN : 0;
./drivers/mfd/max77620.c:504:	ret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG1,
./drivers/mfd/max77620.c:513:	ret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,
./drivers/mfd/max77620.c:534:		if (chip->shutdown_fps_period[fps] < 0)
./drivers/mfd/max77620.c:538:					      chip->shutdown_fps_period[fps]);
./drivers/mfd/max77620.c:547:	if (chip->chip_id == MAX20024)
./drivers/mfd/max77620.c:551:	ret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,
./drivers/mfd/88pm80x.c:74:	chip->client = client;
./drivers/mfd/88pm80x.c:75:	chip->regmap = map;
./drivers/mfd/88pm80x.c:77:	chip->irq = client->irq;
./drivers/mfd/88pm80x.c:79:	chip->dev = &client->dev;
./drivers/mfd/88pm80x.c:80:	dev_set_drvdata(chip->dev, chip);
./drivers/mfd/88pm80x.c:81:	i2c_set_clientdata(chip->client, chip);
./drivers/mfd/88pm80x.c:83:	ret = regmap_read(chip->regmap, PM80X_CHIP_ID, &val);
./drivers/mfd/88pm80x.c:85:		dev_err(chip->dev, "Failed to read CHIP ID: %d\n", ret);
./drivers/mfd/88pm80x.c:91:			chip->type = chip_mapping[i].type;
./drivers/mfd/88pm80x.c:97:		dev_err(chip->dev,
./drivers/mfd/88pm80x.c:113:		chip->companion = g_pm80x_chip->client;
./drivers/mfd/88pm80x.c:114:		g_pm80x_chip->companion = chip->client;
./drivers/mfd/88pm80x.c:127:	if (g_pm80x_chip->companion)
./drivers/mfd/88pm80x.c:128:		g_pm80x_chip->companion = NULL;
./drivers/mfd/88pm80x.c:141:	if (chip && chip->wu_flag)
./drivers/mfd/88pm80x.c:142:		if (device_may_wakeup(chip->dev))
./drivers/mfd/88pm80x.c:143:			enable_irq_wake(chip->irq);
./drivers/mfd/88pm80x.c:153:	if (chip && chip->wu_flag)
./drivers/mfd/88pm80x.c:154:		if (device_may_wakeup(chip->dev))
./drivers/mfd/88pm80x.c:155:			disable_irq_wake(chip->irq);
./drivers/mfd/pm8921-core.c:73:	spin_lock(&chip->pm_irq_lock);
./drivers/mfd/pm8921-core.c:74:	rc = regmap_write(chip->regmap, SSBI_REG_ADDR_IRQ_BLK_SEL, bp);
./drivers/mfd/pm8921-core.c:80:	rc = regmap_read(chip->regmap, SSBI_REG_ADDR_IRQ_IT_STATUS, ip);
./drivers/mfd/pm8921-core.c:84:	spin_unlock(&chip->pm_irq_lock);
./drivers/mfd/pm8921-core.c:93:	spin_lock(&chip->pm_irq_lock);
./drivers/mfd/pm8921-core.c:94:	rc = regmap_write(chip->regmap, SSBI_REG_ADDR_IRQ_BLK_SEL, bp);
./drivers/mfd/pm8921-core.c:101:	rc = regmap_write(chip->regmap, SSBI_REG_ADDR_IRQ_CONFIG, cp);
./drivers/mfd/pm8921-core.c:105:	spin_unlock(&chip->pm_irq_lock);
./drivers/mfd/pm8921-core.c:128:			irq = irq_find_mapping(chip->irqdomain, pmirq);
./drivers/mfd/pm8921-core.c:140:	ret = regmap_read(chip->regmap, SSBI_REG_ADDR_IRQ_M_STATUS1 + master,
./drivers/mfd/pm8921-core.c:168:	ret = regmap_read(chip->regmap, SSBI_REG_ADDR_IRQ_ROOT, &root);
./drivers/mfd/pm8921-core.c:178:	for (i = 0; i < chip->num_masters; i++)
./drivers/mfd/pm8921-core.c:193:	config = chip->config[pmirq] | PM_IRQF_MASK_ALL | PM_IRQF_CLR;
./drivers/mfd/pm8921-core.c:205:	config = chip->config[pmirq];
./drivers/mfd/pm8921-core.c:219:	chip->config[pmirq] = (irq_bit << PM_IRQF_BITS_SHIFT)
./drivers/mfd/pm8921-core.c:223:			chip->config[pmirq] &= ~PM_IRQF_MASK_RE;
./drivers/mfd/pm8921-core.c:225:			chip->config[pmirq] &= ~PM_IRQF_MASK_FE;
./drivers/mfd/pm8921-core.c:227:		chip->config[pmirq] |= PM_IRQF_LVL_SEL;
./drivers/mfd/pm8921-core.c:230:			chip->config[pmirq] &= ~PM_IRQF_MASK_RE;
./drivers/mfd/pm8921-core.c:232:			chip->config[pmirq] &= ~PM_IRQF_MASK_FE;
./drivers/mfd/pm8921-core.c:235:	config = chip->config[pmirq] | PM_IRQF_CLR;
./drivers/mfd/pm8921-core.c:256:	spin_lock(&chip->pm_irq_lock);
./drivers/mfd/pm8921-core.c:257:	rc = regmap_write(chip->regmap, SSBI_REG_ADDR_IRQ_BLK_SEL, block);
./drivers/mfd/pm8921-core.c:263:	rc = regmap_read(chip->regmap, SSBI_REG_ADDR_IRQ_RT_STATUS, &bits);
./drivers/mfd/pm8921-core.c:271:	spin_unlock(&chip->pm_irq_lock);
./drivers/mfd/pm8921-core.c:356:					sizeof(chip->config[0]) * nirqs,
./drivers/mfd/pm8921-core.c:362:	chip->regmap = regmap;
./drivers/mfd/pm8921-core.c:363:	chip->num_irqs = nirqs;
./drivers/mfd/pm8921-core.c:364:	chip->num_blocks = DIV_ROUND_UP(chip->num_irqs, 8);
./drivers/mfd/pm8921-core.c:365:	chip->num_masters = DIV_ROUND_UP(chip->num_blocks, 8);
./drivers/mfd/pm8921-core.c:366:	spin_lock_init(&chip->pm_irq_lock);
./drivers/mfd/pm8921-core.c:368:	chip->irqdomain = irq_domain_add_linear(pdev->dev.of_node, nirqs,
./drivers/mfd/pm8921-core.c:371:	if (!chip->irqdomain)
./drivers/mfd/pm8921-core.c:380:		irq_domain_remove(chip->irqdomain);
./drivers/mfd/pm8921-core.c:399:	irq_domain_remove(chip->irqdomain);
./drivers/mfd/da903x.c:134:	chip->ops->unmask_events(chip, events);
./drivers/mfd/da903x.c:135:	return blocking_notifier_chain_register(&chip->notifier_list, nb);
./drivers/mfd/da903x.c:144:	chip->ops->mask_events(chip, events);
./drivers/mfd/da903x.c:145:	return blocking_notifier_chain_unregister(&chip->notifier_list, nb);
./drivers/mfd/da903x.c:179:	mutex_lock(&chip->lock);
./drivers/mfd/da903x.c:181:	ret = __da903x_read(chip->client, reg, &reg_val);
./drivers/mfd/da903x.c:187:		ret = __da903x_write(chip->client, reg, reg_val);
./drivers/mfd/da903x.c:190:	mutex_unlock(&chip->lock);
./drivers/mfd/da903x.c:201:	mutex_lock(&chip->lock);
./drivers/mfd/da903x.c:203:	ret = __da903x_read(chip->client, reg, &reg_val);
./drivers/mfd/da903x.c:209:		ret = __da903x_write(chip->client, reg, reg_val);
./drivers/mfd/da903x.c:212:	mutex_unlock(&chip->lock);
./drivers/mfd/da903x.c:223:	mutex_lock(&chip->lock);
./drivers/mfd/da903x.c:225:	ret = __da903x_read(chip->client, reg, &reg_val);
./drivers/mfd/da903x.c:231:		ret = __da903x_write(chip->client, reg, reg_val);
./drivers/mfd/da903x.c:234:	mutex_unlock(&chip->lock);
./drivers/mfd/da903x.c:244:	chip->ops->read_status(chip, &status);
./drivers/mfd/da903x.c:254:	err = __da903x_read(chip->client, DA9030_CHIP_ID, &chip_id);
./drivers/mfd/da903x.c:258:	err = __da903x_write(chip->client, DA9030_SYS_CTRL_A, 0xE8);
./drivers/mfd/da903x.c:262:	dev_info(chip->dev, "DA9030 (CHIP ID: 0x%02x) detected\n", chip_id);
./drivers/mfd/da903x.c:270:	chip->events_mask &= ~events;
./drivers/mfd/da903x.c:272:	v[0] = (chip->events_mask & 0xff);
./drivers/mfd/da903x.c:273:	v[1] = (chip->events_mask >> 8) & 0xff;
./drivers/mfd/da903x.c:274:	v[2] = (chip->events_mask >> 16) & 0xff;
./drivers/mfd/da903x.c:276:	return __da903x_writes(chip->client, DA9030_IRQ_MASK_A, 3, v);
./drivers/mfd/da903x.c:283:	chip->events_mask |= events;
./drivers/mfd/da903x.c:285:	v[0] = (chip->events_mask & 0xff);
./drivers/mfd/da903x.c:286:	v[1] = (chip->events_mask >> 8) & 0xff;
./drivers/mfd/da903x.c:287:	v[2] = (chip->events_mask >> 16) & 0xff;
./drivers/mfd/da903x.c:289:	return __da903x_writes(chip->client, DA9030_IRQ_MASK_A, 3, v);
./drivers/mfd/da903x.c:297:	ret = __da903x_reads(chip->client, DA9030_EVENT_A, 3, v);
./drivers/mfd/da903x.c:307:	return __da903x_read(chip->client, DA9030_STATUS, (uint8_t *)status);
./drivers/mfd/da903x.c:315:	err = __da903x_read(chip->client, DA9034_CHIP_ID, &chip_id);
./drivers/mfd/da903x.c:319:	err = __da903x_write(chip->client, DA9034_SYS_CTRL_A, 0xE8);
./drivers/mfd/da903x.c:324:	__da903x_write(chip->client, 0x10, 0x07);
./drivers/mfd/da903x.c:325:	__da903x_write(chip->client, 0x11, 0xff);
./drivers/mfd/da903x.c:326:	__da903x_write(chip->client, 0x12, 0xff);
./drivers/mfd/da903x.c:329:	__da903x_write(chip->client, DA9034_SYS_CTRL_B, 0x20);
./drivers/mfd/da903x.c:330:	__da903x_write(chip->client, DA9034_SYS_CTRL_A, 0x60);
./drivers/mfd/da903x.c:333:	__da903x_write(chip->client, 0x90, 0x01);
./drivers/mfd/da903x.c:334:	__da903x_write(chip->client, 0xB0, 0x08);
./drivers/mfd/da903x.c:337:	__da903x_write(chip->client, 0x20, 0x00);
./drivers/mfd/da903x.c:339:	dev_info(chip->dev, "DA9034 (CHIP ID: 0x%02x) detected\n", chip_id);
./drivers/mfd/da903x.c:347:	chip->events_mask &= ~events;
./drivers/mfd/da903x.c:349:	v[0] = (chip->events_mask & 0xff);
./drivers/mfd/da903x.c:350:	v[1] = (chip->events_mask >> 8) & 0xff;
./drivers/mfd/da903x.c:351:	v[2] = (chip->events_mask >> 16) & 0xff;
./drivers/mfd/da903x.c:352:	v[3] = (chip->events_mask >> 24) & 0xff;
./drivers/mfd/da903x.c:354:	return __da903x_writes(chip->client, DA9034_IRQ_MASK_A, 4, v);
./drivers/mfd/da903x.c:361:	chip->events_mask |= events;
./drivers/mfd/da903x.c:363:	v[0] = (chip->events_mask & 0xff);
./drivers/mfd/da903x.c:364:	v[1] = (chip->events_mask >> 8) & 0xff;
./drivers/mfd/da903x.c:365:	v[2] = (chip->events_mask >> 16) & 0xff;
./drivers/mfd/da903x.c:366:	v[3] = (chip->events_mask >> 24) & 0xff;
./drivers/mfd/da903x.c:368:	return __da903x_writes(chip->client, DA9034_IRQ_MASK_A, 4, v);
./drivers/mfd/da903x.c:376:	ret = __da903x_reads(chip->client, DA9034_EVENT_A, 4, v);
./drivers/mfd/da903x.c:389:	ret = __da903x_reads(chip->client, DA9034_STATUS_A, 2, v);
./drivers/mfd/da903x.c:404:		if (chip->ops->read_events(chip, &events))
./drivers/mfd/da903x.c:407:		events &= ~chip->events_mask;
./drivers/mfd/da903x.c:412:				&chip->notifier_list, events, NULL);
./drivers/mfd/da903x.c:414:	enable_irq(chip->client->irq);
./drivers/mfd/da903x.c:422:	(void)schedule_work(&chip->irq_work);
./drivers/mfd/da903x.c:459:	return device_for_each_child(chip->dev, NULL, __remove_subdev);
./drivers/mfd/da903x.c:478:		pdev->dev.parent = chip->dev;
./drivers/mfd/da903x.c:507:	chip->client = client;
./drivers/mfd/da903x.c:508:	chip->dev = &client->dev;
./drivers/mfd/da903x.c:509:	chip->ops = &da903x_ops[id->driver_data];
./drivers/mfd/da903x.c:511:	mutex_init(&chip->lock);
./drivers/mfd/da903x.c:512:	INIT_WORK(&chip->irq_work, da903x_irq_work);
./drivers/mfd/da903x.c:513:	BLOCKING_INIT_NOTIFIER_HEAD(&chip->notifier_list);
./drivers/mfd/da903x.c:517:	ret = chip->ops->init_chip(chip);
./drivers/mfd/da903x.c:522:	chip->events_mask = 0xffffffff;
./drivers/mfd/da903x.c:523:	chip->ops->mask_events(chip, chip->events_mask);
./drivers/mfd/da903x.c:524:	chip->ops->read_events(chip, &tmp);
./drivers/mfd/htc-egpio.c:156:	pr_debug("egpio_get_value(%d)\n", chip->base + offset);
./drivers/mfd/htc-egpio.c:193:			chip->label, offset, offset+chip->base, value);
./drivers/mfd/htc-egpio.c:323:		chip->label           = "htc-egpio";
./drivers/mfd/htc-egpio.c:324:		chip->parent          = &pdev->dev;
./drivers/mfd/htc-egpio.c:325:		chip->owner           = THIS_MODULE;
./drivers/mfd/htc-egpio.c:326:		chip->get             = egpio_get;
./drivers/mfd/htc-egpio.c:327:		chip->set             = egpio_set;
./drivers/mfd/htc-egpio.c:328:		chip->direction_input = egpio_direction_input;
./drivers/mfd/htc-egpio.c:329:		chip->direction_output = egpio_direction_output;
./drivers/mfd/htc-egpio.c:330:		chip->base            = pdata->chip[i].gpio_base;
./drivers/mfd/htc-egpio.c:331:		chip->ngpio           = pdata->chip[i].num_gpios;
./drivers/mfd/max8925-i2c.c:58:	mutex_lock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:60:	mutex_unlock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:75:	mutex_lock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:77:	mutex_unlock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:89:	mutex_lock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:91:	mutex_unlock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:103:	mutex_lock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:105:	mutex_unlock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:118:	mutex_lock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:126:	mutex_unlock(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:177:	chip->i2c = client;
./drivers/mfd/max8925-i2c.c:178:	chip->dev = &client->dev;
./drivers/mfd/max8925-i2c.c:180:	dev_set_drvdata(chip->dev, chip);
./drivers/mfd/max8925-i2c.c:181:	mutex_init(&chip->io_lock);
./drivers/mfd/max8925-i2c.c:183:	chip->rtc = i2c_new_dummy(chip->i2c->adapter, RTC_I2C_ADDR);
./drivers/mfd/max8925-i2c.c:184:	if (!chip->rtc) {
./drivers/mfd/max8925-i2c.c:185:		dev_err(chip->dev, "Failed to allocate I2C device for RTC\n");
./drivers/mfd/max8925-i2c.c:188:	i2c_set_clientdata(chip->rtc, chip);
./drivers/mfd/max8925-i2c.c:190:	chip->adc = i2c_new_dummy(chip->i2c->adapter, ADC_I2C_ADDR);
./drivers/mfd/max8925-i2c.c:191:	if (!chip->adc) {
./drivers/mfd/max8925-i2c.c:192:		dev_err(chip->dev, "Failed to allocate I2C device for ADC\n");
./drivers/mfd/max8925-i2c.c:193:		i2c_unregister_device(chip->rtc);
./drivers/mfd/max8925-i2c.c:196:	i2c_set_clientdata(chip->adc, chip);
./drivers/mfd/max8925-i2c.c:210:	i2c_unregister_device(chip->adc);
./drivers/mfd/max8925-i2c.c:211:	i2c_unregister_device(chip->rtc);
./drivers/mfd/max8925-i2c.c:221:	if (device_may_wakeup(dev) && chip->wakeup_flag)
./drivers/mfd/max8925-i2c.c:222:		enable_irq_wake(chip->core_irq);
./drivers/mfd/max8925-i2c.c:231:	if (device_may_wakeup(dev) && chip->wakeup_flag)
./drivers/mfd/max8925-i2c.c:232:		disable_irq_wake(chip->core_irq);
./drivers/mfd/ezx-pcap.c:212:	desc->irq_data.chip->irq_ack(&desc->irq_data);
./drivers/mfd/adp5520.c:77:	mutex_lock(&chip->lock);
./drivers/mfd/adp5520.c:86:	mutex_unlock(&chip->lock);
./drivers/mfd/adp5520.c:108:	mutex_lock(&chip->lock);
./drivers/mfd/adp5520.c:110:	ret = __adp5520_read(chip->client, reg, &reg_val);
./drivers/mfd/adp5520.c:114:		ret = __adp5520_write(chip->client, reg, reg_val);
./drivers/mfd/adp5520.c:117:	mutex_unlock(&chip->lock);
./drivers/mfd/adp5520.c:128:	mutex_lock(&chip->lock);
./drivers/mfd/adp5520.c:130:	ret = __adp5520_read(chip->client, reg, &reg_val);
./drivers/mfd/adp5520.c:134:		ret = __adp5520_write(chip->client, reg, reg_val);
./drivers/mfd/adp5520.c:137:	mutex_unlock(&chip->lock);
./drivers/mfd/adp5520.c:147:	if (chip->irq) {
./drivers/mfd/adp5520.c:148:		adp5520_set_bits(chip->dev, ADP5520_INTERRUPT_ENABLE,
./drivers/mfd/adp5520.c:152:		return blocking_notifier_chain_register(&chip->notifier_list,
./drivers/mfd/adp5520.c:165:	adp5520_clr_bits(chip->dev, ADP5520_INTERRUPT_ENABLE,
./drivers/mfd/adp5520.c:169:	return blocking_notifier_chain_unregister(&chip->notifier_list, nb);
./drivers/mfd/adp5520.c:180:	ret = __adp5520_read(chip->client, ADP5520_MODE_STATUS, &reg_val);
./drivers/mfd/adp5520.c:187:	blocking_notifier_call_chain(&chip->notifier_list, events, NULL);
./drivers/mfd/adp5520.c:189:	__adp5520_ack_bits(chip->client, ADP5520_MODE_STATUS, events);
./drivers/mfd/adp5520.c:203:	return device_for_each_child(chip->dev, NULL, __remove_subdev);
./drivers/mfd/adp5520.c:230:	chip->client = client;
./drivers/mfd/adp5520.c:232:	chip->dev = &client->dev;
./drivers/mfd/adp5520.c:233:	chip->irq = client->irq;
./drivers/mfd/adp5520.c:234:	chip->id = id->driver_data;
./drivers/mfd/adp5520.c:235:	mutex_init(&chip->lock);
./drivers/mfd/adp5520.c:237:	if (chip->irq) {
./drivers/mfd/adp5520.c:238:		BLOCKING_INIT_NOTIFIER_HEAD(&chip->notifier_list);
./drivers/mfd/adp5520.c:240:		ret = request_threaded_irq(chip->irq, NULL, adp5520_irq_thread,
./drivers/mfd/adp5520.c:245:					chip->irq);
./drivers/mfd/adp5520.c:250:	ret = adp5520_write(chip->dev, ADP5520_MODE_STATUS, ADP5520_nSTNBY);
./drivers/mfd/adp5520.c:257:		pdev = platform_device_register_data(chip->dev, "adp5520-keys",
./drivers/mfd/adp5520.c:258:				chip->id, pdata->keys, sizeof(*pdata->keys));
./drivers/mfd/adp5520.c:266:		pdev = platform_device_register_data(chip->dev, "adp5520-gpio",
./drivers/mfd/adp5520.c:267:				chip->id, pdata->gpio, sizeof(*pdata->gpio));
./drivers/mfd/adp5520.c:275:		pdev = platform_device_register_data(chip->dev, "adp5520-led",
./drivers/mfd/adp5520.c:276:				chip->id, pdata->leds, sizeof(*pdata->leds));
./drivers/mfd/adp5520.c:284:		pdev = platform_device_register_data(chip->dev,
./drivers/mfd/adp5520.c:286:						chip->id,
./drivers/mfd/adp5520.c:301:	if (chip->irq)
./drivers/mfd/adp5520.c:302:		free_irq(chip->irq, chip);
./drivers/mfd/adp5520.c:311:	if (chip->irq)
./drivers/mfd/adp5520.c:312:		free_irq(chip->irq, chip);
./drivers/mfd/adp5520.c:315:	adp5520_write(chip->dev, ADP5520_MODE_STATUS, 0);
./drivers/mfd/adp5520.c:325:	adp5520_read(chip->dev, ADP5520_MODE_STATUS, &chip->mode);
./drivers/mfd/adp5520.c:327:	chip->mode &= ADP5520_BL_EN | ADP5520_DIM_EN | ADP5520_nSTNBY;
./drivers/mfd/adp5520.c:328:	adp5520_write(chip->dev, ADP5520_MODE_STATUS, 0);
./drivers/mfd/adp5520.c:337:	adp5520_write(chip->dev, ADP5520_MODE_STATUS, chip->mode);
./drivers/mfd/88pm860x-i2c.c:21:	struct regmap *map = (i2c == chip->client) ? chip->regmap
./drivers/mfd/88pm860x-i2c.c:22:				: chip->regmap_companion;
./drivers/mfd/88pm860x-i2c.c:38:	struct regmap *map = (i2c == chip->client) ? chip->regmap
./drivers/mfd/88pm860x-i2c.c:39:				: chip->regmap_companion;
./drivers/mfd/88pm860x-i2c.c:51:	struct regmap *map = (i2c == chip->client) ? chip->regmap
./drivers/mfd/88pm860x-i2c.c:52:				: chip->regmap_companion;
./drivers/mfd/88pm860x-i2c.c:64:	struct regmap *map = (i2c == chip->client) ? chip->regmap
./drivers/mfd/88pm860x-i2c.c:65:				: chip->regmap_companion;
./drivers/mfd/88pm860x-i2c.c:77:	struct regmap *map = (i2c == chip->client) ? chip->regmap
./drivers/mfd/88pm860x-i2c.c:78:				: chip->regmap_companion;
./drivers/mfd/retu-mfd.c:265:	ret = retu_write(rdev, rdat->irq_chip->mask_base, 0xffff);
./drivers/mfd/88pm800.c:251:	struct pm80x_subchip *subchip = chip->subchip;
./drivers/mfd/88pm800.c:252:	struct regmap *map = subchip->regmap_gpadc;
./drivers/mfd/88pm800.c:256:		dev_warn(chip->dev,
./drivers/mfd/88pm800.c:307:	dev_info(chip->dev, "pm800 device_gpadc_init: Done\n");
./drivers/mfd/88pm800.c:311:	dev_info(chip->dev, "pm800 device_gpadc_init: Failed!\n");
./drivers/mfd/88pm800.c:320:	ret = mfd_add_devices(chip->dev, 0, &onkey_devs[0],
./drivers/mfd/88pm800.c:324:		dev_err(chip->dev, "Failed to add onkey subdev\n");
./drivers/mfd/88pm800.c:341:	ret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],
./drivers/mfd/88pm800.c:344:		dev_err(chip->dev, "Failed to add rtc subdev\n");
./drivers/mfd/88pm800.c:356:	ret = mfd_add_devices(chip->dev, 0, &regulator_devs[0],
./drivers/mfd/88pm800.c:359:		dev_err(chip->dev, "Failed to add regulator subdev\n");
./drivers/mfd/88pm800.c:368:	struct regmap *map = chip->regmap;
./drivers/mfd/88pm800.c:372:	if (!map || !chip->irq) {
./drivers/mfd/88pm800.c:373:		dev_err(chip->dev, "incorrect parameters\n");
./drivers/mfd/88pm800.c:392:	    regmap_add_irq_chip(chip->regmap, chip->irq, flags, -1,
./drivers/mfd/88pm800.c:393:				chip->regmap_irq_chip, &chip->irq_data);
./drivers/mfd/88pm800.c:401:	regmap_del_irq_chip(chip->irq, chip->irq_data);
./drivers/mfd/88pm800.c:419:	struct i2c_client *client = chip->client;
./drivers/mfd/88pm800.c:423:	subchip = chip->subchip;
./drivers/mfd/88pm800.c:424:	if (!subchip || !subchip->power_page_addr || !subchip->gpadc_page_addr)
./drivers/mfd/88pm800.c:428:	subchip->power_page = i2c_new_dummy(client->adapter,
./drivers/mfd/88pm800.c:429:					    subchip->power_page_addr);
./drivers/mfd/88pm800.c:430:	if (subchip->power_page == NULL) {
./drivers/mfd/88pm800.c:435:	subchip->regmap_power = devm_regmap_init_i2c(subchip->power_page,
./drivers/mfd/88pm800.c:437:	if (IS_ERR(subchip->regmap_power)) {
./drivers/mfd/88pm800.c:438:		ret = PTR_ERR(subchip->regmap_power);
./drivers/mfd/88pm800.c:439:		dev_err(chip->dev,
./drivers/mfd/88pm800.c:444:	i2c_set_clientdata(subchip->power_page, chip);
./drivers/mfd/88pm800.c:447:	subchip->gpadc_page = i2c_new_dummy(client->adapter,
./drivers/mfd/88pm800.c:448:					    subchip->gpadc_page_addr);
./drivers/mfd/88pm800.c:449:	if (subchip->gpadc_page == NULL) {
./drivers/mfd/88pm800.c:454:	subchip->regmap_gpadc = devm_regmap_init_i2c(subchip->gpadc_page,
./drivers/mfd/88pm800.c:456:	if (IS_ERR(subchip->regmap_gpadc)) {
./drivers/mfd/88pm800.c:457:		ret = PTR_ERR(subchip->regmap_gpadc);
./drivers/mfd/88pm800.c:458:		dev_err(chip->dev,
./drivers/mfd/88pm800.c:462:	i2c_set_clientdata(subchip->gpadc_page, chip);
./drivers/mfd/88pm800.c:472:	subchip = chip->subchip;
./drivers/mfd/88pm800.c:474:	if (subchip && subchip->power_page)
./drivers/mfd/88pm800.c:475:		i2c_unregister_device(subchip->power_page);
./drivers/mfd/88pm800.c:477:	if (subchip && subchip->gpadc_page)
./drivers/mfd/88pm800.c:478:		i2c_unregister_device(subchip->gpadc_page);
./drivers/mfd/88pm800.c:491:	ret = regmap_read(chip->regmap, PM800_RTC_CONTROL, &val);
./drivers/mfd/88pm800.c:493:		dev_err(chip->dev, "Failed to read RTC register: %d\n", ret);
./drivers/mfd/88pm800.c:503:		dev_err(chip->dev, "[%s]Failed to init gpadc\n", __func__);
./drivers/mfd/88pm800.c:507:	chip->regmap_irq_chip = &pm800_irq_chip;
./drivers/mfd/88pm800.c:511:		dev_err(chip->dev, "[%s]Failed to init pm800 irq\n", __func__);
./drivers/mfd/88pm800.c:517:		dev_err(chip->dev, "Failed to add onkey subdev\n");
./drivers/mfd/88pm800.c:523:		dev_err(chip->dev, "Failed to add rtc subdev\n");
./drivers/mfd/88pm800.c:529:		dev_err(chip->dev, "Failed to add regulators subdev\n");
./drivers/mfd/88pm800.c:535:	mfd_remove_devices(chip->dev);
./drivers/mfd/88pm800.c:567:	subchip->power_page_addr = client->addr + 1;
./drivers/mfd/88pm800.c:568:	subchip->gpadc_page_addr = client->addr + 2;
./drivers/mfd/88pm800.c:569:	chip->subchip = subchip;
./drivers/mfd/88pm800.c:579:		dev_err(chip->dev, "Failed to initialize 88pm800 devices\n");
./drivers/mfd/88pm800.c:600:	mfd_remove_devices(chip->dev);
./drivers/mfd/htc-i2cpld.c:89:	chip->irqs_enabled &= ~(1 << (data->irq - chip->irq_start));
./drivers/mfd/htc-i2cpld.c:90:	pr_debug("HTCPLD mask %d %04x\n", data->irq, chip->irqs_enabled);
./drivers/mfd/htc-i2cpld.c:95:	chip->irqs_enabled |= 1 << (data->irq - chip->irq_start);
./drivers/mfd/htc-i2cpld.c:96:	pr_debug("HTCPLD unmask %d %04x\n", data->irq, chip->irqs_enabled);
./drivers/mfd/htc-i2cpld.c:110:	chip->flow_type = flags;
./drivers/mfd/htc-i2cpld.c:156:		if (chip->nirqs == 0)
./drivers/mfd/htc-i2cpld.c:159:		client = chip->client;
./drivers/mfd/htc-i2cpld.c:166:		val = i2c_smbus_read_byte_data(client, chip->cache_out);
./drivers/mfd/htc-i2cpld.c:169:			dev_warn(chip->dev, "Unable to read from chip: %d\n",
./drivers/mfd/htc-i2cpld.c:176:		spin_lock_irqsave(&chip->lock, flags);
./drivers/mfd/htc-i2cpld.c:179:		old_val = chip->cache_in;
./drivers/mfd/htc-i2cpld.c:182:		chip->cache_in = uval;
./drivers/mfd/htc-i2cpld.c:184:		spin_unlock_irqrestore(&chip->lock, flags);
./drivers/mfd/htc-i2cpld.c:190:		for (irqpin = 0; irqpin < chip->nirqs; irqpin++) {
./drivers/mfd/htc-i2cpld.c:191:			unsigned oldb, newb, type = chip->flow_type;
./drivers/mfd/htc-i2cpld.c:193:			irq = chip->irq_start + irqpin;
./drivers/mfd/htc-i2cpld.c:262:	if (!strncmp(chip->label, "htcpld-out", 10)) {
./drivers/mfd/htc-i2cpld.c:264:	} else if (!strncmp(chip->label, "htcpld-in", 9)) {
./drivers/mfd/htc-i2cpld.c:286:	return (offset < chip->ngpio) ? 0 : -EINVAL;
./drivers/mfd/htc-i2cpld.c:322:	irq_end = chip->irq_start + chip->nirqs;
./drivers/mfd/htc-i2cpld.c:323:	for (irq = chip->irq_start; irq < irq_end; irq++) {
./drivers/mfd/htc-i2cpld.c:382:	chip->client = client;
./drivers/mfd/htc-i2cpld.c:386:	chip->cache_in = i2c_smbus_read_byte_data(client, chip->cache_out);
./drivers/mfd/htc-i2cpld.c:402:	if (chip->client)
./drivers/mfd/htc-i2cpld.c:403:		i2c_unregister_device(chip->client);
./drivers/mfd/htc-i2cpld.c:425:	gpio_chip = &(chip->chip_out);
./drivers/mfd/htc-i2cpld.c:426:	gpio_chip->label           = "htcpld-out";
./drivers/mfd/htc-i2cpld.c:427:	gpio_chip->parent             = dev;
./drivers/mfd/htc-i2cpld.c:428:	gpio_chip->owner           = THIS_MODULE;
./drivers/mfd/htc-i2cpld.c:429:	gpio_chip->get             = htcpld_chip_get;
./drivers/mfd/htc-i2cpld.c:430:	gpio_chip->set             = htcpld_chip_set;
./drivers/mfd/htc-i2cpld.c:431:	gpio_chip->direction_input = NULL;
./drivers/mfd/htc-i2cpld.c:432:	gpio_chip->direction_output = htcpld_direction_output;
./drivers/mfd/htc-i2cpld.c:433:	gpio_chip->base            = plat_chip_data->gpio_out_base;
./drivers/mfd/htc-i2cpld.c:434:	gpio_chip->ngpio           = plat_chip_data->num_gpios;
./drivers/mfd/htc-i2cpld.c:436:	gpio_chip = &(chip->chip_in);
./drivers/mfd/htc-i2cpld.c:437:	gpio_chip->label           = "htcpld-in";
./drivers/mfd/htc-i2cpld.c:438:	gpio_chip->parent             = dev;
./drivers/mfd/htc-i2cpld.c:439:	gpio_chip->owner           = THIS_MODULE;
./drivers/mfd/htc-i2cpld.c:440:	gpio_chip->get             = htcpld_chip_get;
./drivers/mfd/htc-i2cpld.c:441:	gpio_chip->set             = NULL;
./drivers/mfd/htc-i2cpld.c:442:	gpio_chip->direction_input = htcpld_direction_input;
./drivers/mfd/htc-i2cpld.c:443:	gpio_chip->direction_output = NULL;
./drivers/mfd/htc-i2cpld.c:444:	gpio_chip->to_irq          = htcpld_chip_to_irq;
./drivers/mfd/htc-i2cpld.c:445:	gpio_chip->base            = plat_chip_data->gpio_in_base;
./drivers/mfd/htc-i2cpld.c:446:	gpio_chip->ngpio           = plat_chip_data->num_gpios;
./drivers/mfd/htc-i2cpld.c:449:	ret = gpiochip_add_data(&(chip->chip_out), chip);
./drivers/mfd/htc-i2cpld.c:456:	ret = gpiochip_add_data(&(chip->chip_in), chip);
./drivers/mfd/htc-i2cpld.c:460:		gpiochip_remove(&(chip->chip_out));
./drivers/mfd/mt6397-core.c:221:	regmap_write(chip->regmap, chip->int_con[0], chip->wake_mask[0]);
./drivers/mfd/mt6397-core.c:222:	regmap_write(chip->regmap, chip->int_con[1], chip->wake_mask[1]);
./drivers/mfd/mt6397-core.c:224:	enable_irq_wake(chip->irq);
./drivers/mfd/mt6397-core.c:233:	regmap_write(chip->regmap, chip->int_con[0], chip->irq_masks_cur[0]);
./drivers/mfd/mt6397-core.c:234:	regmap_write(chip->regmap, chip->int_con[1], chip->irq_masks_cur[1]);
./drivers/mfd/mt6397-core.c:236:	disable_irq_wake(chip->irq);
./drivers/mfd/88pm860x-core.c:473:	i2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;
./drivers/mfd/88pm860x-core.c:481:			handle_nested_irq(chip->irq_base + i);
./drivers/mfd/88pm860x-core.c:490:	mutex_lock(&chip->irq_lock);
./drivers/mfd/88pm860x-core.c:502:	i2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;
./drivers/mfd/88pm860x-core.c:522:			dev_err(chip->dev, "wrong IRQ\n");
./drivers/mfd/88pm860x-core.c:534:	mutex_unlock(&chip->irq_lock);
./drivers/mfd/88pm860x-core.c:573:	struct i2c_client *i2c = (chip->id == CHIP_PM8607) ?
./drivers/mfd/88pm860x-core.c:574:		chip->client : chip->companion;
./drivers/mfd/88pm860x-core.c:584:	chip->irq_mode = 0;
./drivers/mfd/88pm860x-core.c:592:		chip->irq_mode = 1;
./drivers/mfd/88pm860x-core.c:605:	if (chip->irq_mode) {
./drivers/mfd/88pm860x-core.c:618:	mutex_init(&chip->irq_lock);
./drivers/mfd/88pm860x-core.c:623:	chip->irq_base = irq_alloc_descs(irq_base, 0, nr_irqs, 0);
./drivers/mfd/88pm860x-core.c:624:	if (chip->irq_base < 0) {
./drivers/mfd/88pm860x-core.c:626:			chip->irq_base);
./drivers/mfd/88pm860x-core.c:630:	irq_domain_add_legacy(node, nr_irqs, chip->irq_base, 0,
./drivers/mfd/88pm860x-core.c:632:	chip->core_irq = i2c->irq;
./drivers/mfd/88pm860x-core.c:633:	if (!chip->core_irq)
./drivers/mfd/88pm860x-core.c:636:	ret = request_threaded_irq(chip->core_irq, NULL, pm860x_irq,
./drivers/mfd/88pm860x-core.c:639:		dev_err(chip->dev, "Failed to request IRQ: %d\n", ret);
./drivers/mfd/88pm860x-core.c:640:		chip->core_irq = 0;
./drivers/mfd/88pm860x-core.c:645:	chip->core_irq = 0;
./drivers/mfd/88pm860x-core.c:651:	if (chip->core_irq)
./drivers/mfd/88pm860x-core.c:652:		free_irq(chip->core_irq, chip);
./drivers/mfd/88pm860x-core.c:658:	struct i2c_client *i2c = (chip->id == CHIP_PM8606) ?
./drivers/mfd/88pm860x-core.c:659:		chip->client : chip->companion;
./drivers/mfd/88pm860x-core.c:661:	dev_dbg(chip->dev, "%s(B): client=0x%x\n", __func__, client);
./drivers/mfd/88pm860x-core.c:662:	dev_dbg(chip->dev, "%s(B): vote=0x%x status=%d\n",
./drivers/mfd/88pm860x-core.c:663:			__func__, chip->osc_vote,
./drivers/mfd/88pm860x-core.c:664:			chip->osc_status);
./drivers/mfd/88pm860x-core.c:666:	mutex_lock(&chip->osc_lock);
./drivers/mfd/88pm860x-core.c:668:	chip->osc_vote |= client;
./drivers/mfd/88pm860x-core.c:670:	if (chip->osc_status != PM8606_REF_GP_OSC_ON) {
./drivers/mfd/88pm860x-core.c:671:		chip->osc_status = PM8606_REF_GP_OSC_UNKNOWN;
./drivers/mfd/88pm860x-core.c:682:		chip->osc_status = PM8606_REF_GP_OSC_ON;
./drivers/mfd/88pm860x-core.c:684:	mutex_unlock(&chip->osc_lock);
./drivers/mfd/88pm860x-core.c:686:	dev_dbg(chip->dev, "%s(A): vote=0x%x status=%d ret=%d\n",
./drivers/mfd/88pm860x-core.c:687:			__func__, chip->osc_vote,
./drivers/mfd/88pm860x-core.c:688:			chip->osc_status, ret);
./drivers/mfd/88pm860x-core.c:691:	mutex_unlock(&chip->osc_lock);
./drivers/mfd/88pm860x-core.c:699:	struct i2c_client *i2c = (chip->id == CHIP_PM8606) ?
./drivers/mfd/88pm860x-core.c:700:		chip->client : chip->companion;
./drivers/mfd/88pm860x-core.c:702:	dev_dbg(chip->dev, "%s(B): client=0x%x\n", __func__, client);
./drivers/mfd/88pm860x-core.c:703:	dev_dbg(chip->dev, "%s(B): vote=0x%x status=%d\n",
./drivers/mfd/88pm860x-core.c:704:			__func__, chip->osc_vote,
./drivers/mfd/88pm860x-core.c:705:			chip->osc_status);
./drivers/mfd/88pm860x-core.c:707:	mutex_lock(&chip->osc_lock);
./drivers/mfd/88pm860x-core.c:709:	chip->osc_vote &= ~(client);
./drivers/mfd/88pm860x-core.c:714:	if ((chip->osc_status != PM8606_REF_GP_OSC_OFF) &&
./drivers/mfd/88pm860x-core.c:715:			(chip->osc_vote == REF_GP_NO_CLIENTS)) {
./drivers/mfd/88pm860x-core.c:716:		chip->osc_status = PM8606_REF_GP_OSC_UNKNOWN;
./drivers/mfd/88pm860x-core.c:723:		chip->osc_status = PM8606_REF_GP_OSC_OFF;
./drivers/mfd/88pm860x-core.c:725:	mutex_unlock(&chip->osc_lock);
./drivers/mfd/88pm860x-core.c:727:	dev_dbg(chip->dev, "%s(A): vote=0x%x status=%d ret=%d\n",
./drivers/mfd/88pm860x-core.c:728:			__func__, chip->osc_vote,
./drivers/mfd/88pm860x-core.c:729:			chip->osc_status, ret);
./drivers/mfd/88pm860x-core.c:732:	mutex_unlock(&chip->osc_lock);
./drivers/mfd/88pm860x-core.c:741:	mutex_init(&chip->osc_lock);
./drivers/mfd/88pm860x-core.c:748:	chip->osc_vote = REF_GP_NO_CLIENTS;
./drivers/mfd/88pm860x-core.c:749:	chip->osc_status = PM8606_REF_GP_OSC_OFF;
./drivers/mfd/88pm860x-core.c:766:	ret = mfd_add_devices(chip->dev, 0, bk_devs,
./drivers/mfd/88pm860x-core.c:769:		dev_err(chip->dev, "Failed to add backlight subdev\n");
./drivers/mfd/88pm860x-core.c:786:	ret = mfd_add_devices(chip->dev, 0, led_devs,
./drivers/mfd/88pm860x-core.c:789:		dev_err(chip->dev, "Failed to add led subdev\n");
./drivers/mfd/88pm860x-core.c:865:	ret = mfd_add_devices(chip->dev, 0, reg_devs,
./drivers/mfd/88pm860x-core.c:868:		dev_err(chip->dev, "Failed to add regulator subdev\n");
./drivers/mfd/88pm860x-core.c:885:	ret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],
./drivers/mfd/88pm860x-core.c:887:			      chip->irq_base, NULL);
./drivers/mfd/88pm860x-core.c:889:		dev_err(chip->dev, "Failed to add rtc subdev\n");
./drivers/mfd/88pm860x-core.c:904:	ret = mfd_add_devices(chip->dev, 0, &touch_devs[0],
./drivers/mfd/88pm860x-core.c:906:			      chip->irq_base, NULL);
./drivers/mfd/88pm860x-core.c:908:		dev_err(chip->dev, "Failed to add touch subdev\n");
./drivers/mfd/88pm860x-core.c:923:	ret = mfd_add_devices(chip->dev, 0, &power_devs[0], 1,
./drivers/mfd/88pm860x-core.c:924:			      &battery_resources[0], chip->irq_base, NULL);
./drivers/mfd/88pm860x-core.c:926:		dev_err(chip->dev, "Failed to add battery subdev\n");
./drivers/mfd/88pm860x-core.c:932:	ret = mfd_add_devices(chip->dev, 0, &power_devs[1], 1,
./drivers/mfd/88pm860x-core.c:933:			      &charger_resources[0], chip->irq_base, NULL);
./drivers/mfd/88pm860x-core.c:935:		dev_err(chip->dev, "Failed to add charger subdev\n");
./drivers/mfd/88pm860x-core.c:939:	ret = mfd_add_devices(chip->dev, 0, &power_devs[2], 1,
./drivers/mfd/88pm860x-core.c:940:			      NULL, chip->irq_base, NULL);
./drivers/mfd/88pm860x-core.c:942:		dev_err(chip->dev, "Failed to add preg subdev\n");
./drivers/mfd/88pm860x-core.c:951:		ret = mfd_add_devices(chip->dev, 0, &power_devs[3], 1,
./drivers/mfd/88pm860x-core.c:952:				      NULL, chip->irq_base, NULL);
./drivers/mfd/88pm860x-core.c:954:			dev_err(chip->dev, "Failed to add chg-manager subdev\n");
./drivers/mfd/88pm860x-core.c:965:	ret = mfd_add_devices(chip->dev, 0, &onkey_devs[0],
./drivers/mfd/88pm860x-core.c:967:			      chip->irq_base, NULL);
./drivers/mfd/88pm860x-core.c:969:		dev_err(chip->dev, "Failed to add onkey subdev\n");
./drivers/mfd/88pm860x-core.c:979:	ret = mfd_add_devices(chip->dev, 0, &codec_devs[0],
./drivers/mfd/88pm860x-core.c:983:		dev_err(chip->dev, "Failed to add codec subdev\n");
./drivers/mfd/88pm860x-core.c:994:		dev_err(chip->dev, "Failed to read CHIP ID: %d\n", ret);
./drivers/mfd/88pm860x-core.c:1000:		dev_info(chip->dev, "Marvell 88PM8607 (ID: %02x) detected\n",
./drivers/mfd/88pm860x-core.c:1004:		dev_err(chip->dev,
./drivers/mfd/88pm860x-core.c:1012:		dev_err(chip->dev, "Failed to read BUCK3 register: %d\n", ret);
./drivers/mfd/88pm860x-core.c:1016:		chip->buck3_double = 1;
./drivers/mfd/88pm860x-core.c:1020:		dev_err(chip->dev, "Failed to read MISC1 register: %d\n", ret);
./drivers/mfd/88pm860x-core.c:1030:		dev_err(chip->dev, "Failed to access MISC1:%d\n", ret);
./drivers/mfd/88pm860x-core.c:1060:	chip->core_irq = 0;
./drivers/mfd/88pm860x-core.c:1062:	switch (chip->id) {
./drivers/mfd/88pm860x-core.c:1064:		device_8606_init(chip, chip->client, pdata);
./drivers/mfd/88pm860x-core.c:1067:		device_8607_init(chip, chip->client, pdata);
./drivers/mfd/88pm860x-core.c:1071:	if (chip->companion) {
./drivers/mfd/88pm860x-core.c:1072:		switch (chip->id) {
./drivers/mfd/88pm860x-core.c:1074:			device_8606_init(chip, chip->companion, pdata);
./drivers/mfd/88pm860x-core.c:1077:			device_8607_init(chip, chip->companion, pdata);
./drivers/mfd/88pm860x-core.c:1088:	mfd_remove_devices(chip->dev);
./drivers/mfd/88pm860x-core.c:1163:	chip->id = verify_addr(client);
./drivers/mfd/88pm860x-core.c:1164:	chip->regmap = devm_regmap_init_i2c(client, &pm860x_regmap_config);
./drivers/mfd/88pm860x-core.c:1165:	if (IS_ERR(chip->regmap)) {
./drivers/mfd/88pm860x-core.c:1166:		ret = PTR_ERR(chip->regmap);
./drivers/mfd/88pm860x-core.c:1171:	chip->client = client;
./drivers/mfd/88pm860x-core.c:1173:	chip->dev = &client->dev;
./drivers/mfd/88pm860x-core.c:1174:	dev_set_drvdata(chip->dev, chip);
./drivers/mfd/88pm860x-core.c:1184:		chip->companion_addr = pdata->companion_addr;
./drivers/mfd/88pm860x-core.c:1185:		chip->companion = i2c_new_dummy(chip->client->adapter,
./drivers/mfd/88pm860x-core.c:1186:						chip->companion_addr);
./drivers/mfd/88pm860x-core.c:1187:		if (!chip->companion) {
./drivers/mfd/88pm860x-core.c:1192:		chip->regmap_companion = regmap_init_i2c(chip->companion,
./drivers/mfd/88pm860x-core.c:1194:		if (IS_ERR(chip->regmap_companion)) {
./drivers/mfd/88pm860x-core.c:1195:			ret = PTR_ERR(chip->regmap_companion);
./drivers/mfd/88pm860x-core.c:1196:			dev_err(&chip->companion->dev,
./drivers/mfd/88pm860x-core.c:1198:			i2c_unregister_device(chip->companion);
./drivers/mfd/88pm860x-core.c:1201:		i2c_set_clientdata(chip->companion, chip);
./drivers/mfd/88pm860x-core.c:1213:	if (chip->companion) {
./drivers/mfd/88pm860x-core.c:1214:		regmap_exit(chip->regmap_companion);
./drivers/mfd/88pm860x-core.c:1215:		i2c_unregister_device(chip->companion);
./drivers/mfd/88pm860x-core.c:1226:	if (device_may_wakeup(dev) && chip->wakeup_flag)
./drivers/mfd/88pm860x-core.c:1227:		enable_irq_wake(chip->core_irq);
./drivers/mfd/88pm860x-core.c:1236:	if (device_may_wakeup(dev) && chip->wakeup_flag)
./drivers/mfd/88pm860x-core.c:1237:		disable_irq_wake(chip->core_irq);
./drivers/mfd/ab3100-core.c:5: * and some basic chip-configuration.
./drivers/mfd/asic3.c:148:	data->chip->irq_ack(data);
./drivers/mfd/vexpress-sysreg.c:204:	mmc_gpio_chip->ngpio = 2;
./drivers/mfd/da9063-core.c:209:		 "Device detected (chip-ID: 0x%02X, var-ID: 0x%02X)\n",
./drivers/mfd/sm501.c:906:	if (smc501_readl(smchip->control) & bit) {
./drivers/mfd/sm501.c:907:		dev_info(sm501_gpio_to_dev(smchip->ourgpio)->dev,
./drivers/mfd/sm501.c:910:		ctrl = smc501_readl(smchip->control);
./drivers/mfd/sm501.c:912:		smc501_writel(ctrl, smchip->control);
./drivers/mfd/sm501.c:914:		sm501_sync_regs(sm501_gpio_to_dev(smchip->ourgpio));
./drivers/mfd/sm501.c:922:	struct sm501_gpio *smgpio = smchip->ourgpio;
./drivers/mfd/sm501.c:924:	void __iomem *regs = smchip->regbase;
./drivers/mfd/sm501.c:947:	struct sm501_gpio *smgpio = smchip->ourgpio;
./drivers/mfd/sm501.c:948:	void __iomem *regs = smchip->regbase;
./drivers/mfd/sm501.c:973:	struct sm501_gpio *smgpio = smchip->ourgpio;
./drivers/mfd/sm501.c:975:	void __iomem *regs = smchip->regbase;
./drivers/mfd/sm501.c:1017:	struct gpio_chip *gchip = &chip->gpio;
./drivers/mfd/sm501.c:1020:	chip->gpio = gpio_chip_template;
./drivers/mfd/sm501.c:1025:		chip->regbase = gpio->regs + SM501_GPIO_DATA_HIGH;
./drivers/mfd/sm501.c:1026:		chip->control = sm->regs + SM501_GPIO63_32_CONTROL;
./drivers/mfd/sm501.c:1027:		gchip->label  = "SM501-HIGH";
./drivers/mfd/sm501.c:1029:		chip->regbase = gpio->regs + SM501_GPIO_DATA_LOW;
./drivers/mfd/sm501.c:1030:		chip->control = sm->regs + SM501_GPIO31_0_CONTROL;
./drivers/mfd/sm501.c:1031:		gchip->label  = "SM501-LOW";
./drivers/mfd/sm501.c:1034:	gchip->base   = base;
./drivers/mfd/sm501.c:1035:	chip->ourgpio = gpio;
./drivers/mfd/max8925-core.c:478:	return &max8925_irqs[irq - chip->irq_base];
./drivers/mfd/max8925-core.c:495:			i2c = chip->rtc;
./drivers/mfd/max8925-core.c:497:			i2c = chip->adc;
./drivers/mfd/max8925-core.c:499:			i2c = chip->i2c;
./drivers/mfd/max8925-core.c:505:			handle_nested_irq(chip->irq_base + i);
./drivers/mfd/max8925-core.c:524:			i2c = chip->rtc;
./drivers/mfd/max8925-core.c:526:			i2c = chip->adc;
./drivers/mfd/max8925-core.c:528:			i2c = chip->i2c;
./drivers/mfd/max8925-core.c:534:			handle_nested_irq(chip->irq_base + i);
./drivers/mfd/max8925-core.c:543:	mutex_lock(&chip->irq_lock);
./drivers/mfd/max8925-core.c:587:			dev_err(chip->dev, "wrong IRQ\n");
./drivers/mfd/max8925-core.c:594:		max8925_reg_write(chip->i2c, MAX8925_CHG_IRQ1_MASK,
./drivers/mfd/max8925-core.c:599:		max8925_reg_write(chip->i2c, MAX8925_CHG_IRQ2_MASK,
./drivers/mfd/max8925-core.c:604:		max8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ1_MASK,
./drivers/mfd/max8925-core.c:609:		max8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ2_MASK,
./drivers/mfd/max8925-core.c:614:		max8925_reg_write(chip->rtc, MAX8925_RTC_IRQ_MASK, irq_rtc);
./drivers/mfd/max8925-core.c:618:		max8925_reg_write(chip->adc, MAX8925_TSC_IRQ_MASK, irq_tsc);
./drivers/mfd/max8925-core.c:621:	mutex_unlock(&chip->irq_lock);
./drivers/mfd/max8925-core.c:628:	max8925_irqs[data->irq - chip->irq_base].enable
./drivers/mfd/max8925-core.c:629:		= max8925_irqs[data->irq - chip->irq_base].offs;
./drivers/mfd/max8925-core.c:636:	max8925_irqs[data->irq - chip->irq_base].enable = 0;
./drivers/mfd/max8925-core.c:669:	struct device_node *node = chip->dev->of_node;
./drivers/mfd/max8925-core.c:672:	max8925_reg_read(chip->i2c, MAX8925_CHG_IRQ1);
./drivers/mfd/max8925-core.c:673:	max8925_reg_read(chip->i2c, MAX8925_CHG_IRQ2);
./drivers/mfd/max8925-core.c:674:	max8925_reg_read(chip->i2c, MAX8925_ON_OFF_IRQ1);
./drivers/mfd/max8925-core.c:675:	max8925_reg_read(chip->i2c, MAX8925_ON_OFF_IRQ2);
./drivers/mfd/max8925-core.c:676:	max8925_reg_read(chip->rtc, MAX8925_RTC_IRQ);
./drivers/mfd/max8925-core.c:677:	max8925_reg_read(chip->adc, MAX8925_TSC_IRQ);
./drivers/mfd/max8925-core.c:679:	max8925_reg_write(chip->rtc, MAX8925_ALARM0_CNTL, 0);
./drivers/mfd/max8925-core.c:680:	max8925_reg_write(chip->rtc, MAX8925_ALARM1_CNTL, 0);
./drivers/mfd/max8925-core.c:681:	max8925_reg_write(chip->i2c, MAX8925_CHG_IRQ1_MASK, 0xff);
./drivers/mfd/max8925-core.c:682:	max8925_reg_write(chip->i2c, MAX8925_CHG_IRQ2_MASK, 0xff);
./drivers/mfd/max8925-core.c:683:	max8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ1_MASK, 0xff);
./drivers/mfd/max8925-core.c:684:	max8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ2_MASK, 0xff);
./drivers/mfd/max8925-core.c:685:	max8925_reg_write(chip->rtc, MAX8925_RTC_IRQ_MASK, 0xff);
./drivers/mfd/max8925-core.c:687:	mutex_init(&chip->irq_lock);
./drivers/mfd/max8925-core.c:688:	chip->irq_base = irq_alloc_descs(-1, 0, MAX8925_NR_IRQS, 0);
./drivers/mfd/max8925-core.c:689:	if (chip->irq_base < 0) {
./drivers/mfd/max8925-core.c:690:		dev_err(chip->dev, "Failed to allocate interrupts, ret:%d\n",
./drivers/mfd/max8925-core.c:691:			chip->irq_base);
./drivers/mfd/max8925-core.c:695:	irq_domain_add_legacy(node, MAX8925_NR_IRQS, chip->irq_base, 0,
./drivers/mfd/max8925-core.c:699:	chip->core_irq = irq;
./drivers/mfd/max8925-core.c:700:	if (!chip->core_irq)
./drivers/mfd/max8925-core.c:705:		dev_err(chip->dev, "Failed to request core IRQ: %d\n", ret);
./drivers/mfd/max8925-core.c:706:		chip->core_irq = 0;
./drivers/mfd/max8925-core.c:713:	max8925_reg_write(chip->adc, MAX8925_TSC_IRQ_MASK, 0x0f);
./drivers/mfd/max8925-core.c:716:		dev_warn(chip->dev, "No interrupt support on TSC IRQ\n");
./drivers/mfd/max8925-core.c:719:	chip->tsc_irq = pdata->tsc_irq;
./drivers/mfd/max8925-core.c:720:	ret = request_threaded_irq(chip->tsc_irq, NULL, max8925_tsc_irq,
./drivers/mfd/max8925-core.c:723:		dev_err(chip->dev, "Failed to request TSC IRQ: %d\n", ret);
./drivers/mfd/max8925-core.c:724:		chip->tsc_irq = 0;
./drivers/mfd/max8925-core.c:828:	ret = mfd_add_devices(chip->dev, 0, reg_devs, ARRAY_SIZE(reg_devs),
./drivers/mfd/max8925-core.c:831:		dev_err(chip->dev, "Failed to add regulator subdev\n");
./drivers/mfd/max8925-core.c:841:	max8925_irq_init(chip, chip->i2c->irq, pdata);
./drivers/mfd/max8925-core.c:845:		max8925_set_bits(chip->i2c, MAX8925_RESET_CNFG, 1, 1);
./drivers/mfd/max8925-core.c:847:		max8925_set_bits(chip->adc, MAX8925_TSC_CNFG1, 3, 2);
./drivers/mfd/max8925-core.c:850:			ret = max8925_reg_read(chip->adc, MAX8925_TSC_IRQ);
./drivers/mfd/max8925-core.c:853:		max8925_set_bits(chip->adc, MAX8925_ADC_SCHED, 3, 2);
./drivers/mfd/max8925-core.c:857:	max8925_set_bits(chip->rtc, MAX8925_MPL_CNTL, 1 << 4, 1 << 4);
./drivers/mfd/max8925-core.c:859:	ret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],
./drivers/mfd/max8925-core.c:861:			      NULL, chip->irq_base, NULL);
./drivers/mfd/max8925-core.c:863:		dev_err(chip->dev, "Failed to add rtc subdev\n");
./drivers/mfd/max8925-core.c:867:	ret = mfd_add_devices(chip->dev, 0, &onkey_devs[0],
./drivers/mfd/max8925-core.c:869:			      NULL, chip->irq_base, NULL);
./drivers/mfd/max8925-core.c:871:		dev_err(chip->dev, "Failed to add onkey subdev\n");
./drivers/mfd/max8925-core.c:881:	ret = mfd_add_devices(chip->dev, 0, bk_devs, ARRAY_SIZE(bk_devs),
./drivers/mfd/max8925-core.c:884:		dev_err(chip->dev, "Failed to add backlight subdev\n");
./drivers/mfd/max8925-core.c:888:	ret = mfd_add_devices(chip->dev, 0, &power_devs[0],
./drivers/mfd/max8925-core.c:892:		dev_err(chip->dev,
./drivers/mfd/max8925-core.c:898:		ret = mfd_add_devices(chip->dev, 0, &touch_devs[0],
./drivers/mfd/max8925-core.c:900:				      NULL, chip->tsc_irq, NULL);
./drivers/mfd/max8925-core.c:902:			dev_err(chip->dev, "Failed to add touch subdev\n");
./drivers/mfd/max8925-core.c:909:	mfd_remove_devices(chip->dev);
./drivers/mfd/max8925-core.c:916:	if (chip->core_irq)
./drivers/mfd/max8925-core.c:917:		free_irq(chip->core_irq, chip);
./drivers/mfd/max8925-core.c:918:	if (chip->tsc_irq)
./drivers/mfd/max8925-core.c:919:		free_irq(chip->tsc_irq, chip);
./drivers/mfd/max8925-core.c:920:	mfd_remove_devices(chip->dev);
./drivers/phy/phy-rockchip-dp.c:145:		.name	= "rockchip-dp-phy",
./drivers/phy/phy-rockchip-usb.c:431:		.name	= "rockchip-usb-phy",
./drivers/phy/phy-rockchip-emmc.c:223:		.name	= "rockchip-emmc-phy",
./drivers/message/fusion/mptbase.c:566:	CHIPREG_WRITE32(&ioc->chip->ReplyFifo, pa);
./drivers/message/fusion/mptbase.c:594:	u32 pa = CHIPREG_READ32_dmasync(&ioc->chip->ReplyFifo);
./drivers/message/fusion/mptbase.c:607:		pa = CHIPREG_READ32_dmasync(&ioc->chip->ReplyFifo);
./drivers/message/fusion/mptbase.c:977:	CHIPREG_WRITE32(&ioc->chip->RequestFifo, mf_dma_addr);
./drivers/message/fusion/mptbase.c:1011:	CHIPREG_WRITE32(&ioc->chip->RequestHiPriFifo, mf_dma_addr);
./drivers/message/fusion/mptbase.c:1206:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:1208:	CHIPREG_WRITE32(&ioc->chip->Doorbell,
./drivers/message/fusion/mptbase.c:1218:	if (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))
./drivers/message/fusion/mptbase.c:1224:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:1239:		CHIPREG_WRITE32(&ioc->chip->Doorbell, word);
./drivers/message/fusion/mptbase.c:1252:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:1282:	if (CHIPREG_READ32(&ioc->chip->Doorbell)
./drivers/message/fusion/mptbase.c:1286:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:1288:	CHIPREG_WRITE32(&ioc->chip->Doorbell,
./drivers/message/fusion/mptbase.c:1978:	CHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);
./drivers/message/fusion/mptbase.c:1980:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:2118:	CHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);
./drivers/message/fusion/mptbase.c:2124:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:2126:	CHIPREG_READ32(&ioc->chip->IntStatus);
./drivers/message/fusion/mptbase.c:2160:	CHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);
./drivers/message/fusion/mptbase.c:2164:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:2219:	    CHIPREG_READ32(&ioc->chip->Doorbell));
./drivers/message/fusion/mptbase.c:2308:	CHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);
./drivers/message/fusion/mptbase.c:2318:			CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask,
./drivers/message/fusion/mptbase.c:2337:				CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask, MPI_HIM_DIM);
./drivers/message/fusion/mptbase.c:2524:		CHIPREG_WRITE32(&ioc->chip->IntMask, MPI_HIM_DIM);
./drivers/message/fusion/mptbase.c:2533:			CHIPREG_WRITE32(&ioc->alt_ioc->chip->IntMask,
./drivers/message/fusion/mptbase.c:2729:	CHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);
./drivers/message/fusion/mptbase.c:2733:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:2734:	CHIPREG_READ32(&ioc->chip->IntStatus);
./drivers/message/fusion/mptbase.c:3057:	s = CHIPREG_READ32(&ioc->chip->Doorbell);
./drivers/message/fusion/mptbase.c:3690:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
./drivers/message/fusion/mptbase.c:3691:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3692:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3693:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3694:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3695:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3697:	CHIPREG_WRITE32(&ioc->chip->Diagnostic, (MPI_DIAG_PREVENT_IOC_BOOT | MPI_DIAG_DISABLE_ARM));
./drivers/message/fusion/mptbase.c:3706:	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:3707:	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);
./drivers/message/fusion/mptbase.c:3710:		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:3731:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
./drivers/message/fusion/mptbase.c:3732:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3733:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3734:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3735:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3736:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
./drivers/message/fusion/mptbase.c:3739:	CHIPREG_WRITE32(&ioc->chip->Diagnostic, (MPI_DIAG_RW_ENABLE | MPI_DIAG_DISABLE_ARM));
./drivers/message/fusion/mptbase.c:3750:	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, pFwHeader->LoadStartAddress);
./drivers/message/fusion/mptbase.c:3757:		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);
./drivers/message/fusion/mptbase.c:3771:		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, load_addr);
./drivers/message/fusion/mptbase.c:3774:			CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, *ptrFw++);
./drivers/message/fusion/mptbase.c:3781:	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, pFwHeader->IopResetRegAddr);
./drivers/message/fusion/mptbase.c:3785:	CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, pFwHeader->IopResetVectorValue);
./drivers/message/fusion/mptbase.c:3795:		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
./drivers/message/fusion/mptbase.c:3796:		diagRwData = CHIPREG_PIO_READ32(&ioc->pio_chip->DiagRwData);
./drivers/message/fusion/mptbase.c:3798:		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwAddress, 0x3F000000);
./drivers/message/fusion/mptbase.c:3799:		CHIPREG_PIO_WRITE32(&ioc->pio_chip->DiagRwData, diagRwData);
./drivers/message/fusion/mptbase.c:3802:		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:3803:		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val |
./drivers/message/fusion/mptbase.c:3817:	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:3824:	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
./drivers/message/fusion/mptbase.c:3827:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
./drivers/message/fusion/mptbase.c:3974:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:3983:			&ioc->chip->Doorbell, &ioc->chip->Reset_1078));
./drivers/message/fusion/mptbase.c:3984:		CHIPREG_WRITE32(&ioc->chip->Reset_1078, 0x07);
./drivers/message/fusion/mptbase.c:4003:			doorbell = CHIPREG_READ32(&ioc->chip->Doorbell);
./drivers/message/fusion/mptbase.c:4025:	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4029:			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4042:			CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
./drivers/message/fusion/mptbase.c:4043:			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4044:			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4045:			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4046:			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4047:			CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4064:			diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4072:				diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4080:		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_DISABLE_ARM);
./drivers/message/fusion/mptbase.c:4087:		CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val | MPI_DIAG_RESET_ADAPTER);
./drivers/message/fusion/mptbase.c:4121:				diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4148:				doorbell = CHIPREG_READ32(&ioc->chip->Doorbell);
./drivers/message/fusion/mptbase.c:4174:	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4177:			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4185:	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4191:		CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFF);
./drivers/message/fusion/mptbase.c:4192:		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_1ST_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4193:		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_2ND_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4194:		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_3RD_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4195:		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_4TH_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4196:		CHIPREG_WRITE32(&ioc->chip->WriteSequence, MPI_WRSEQ_5TH_KEY_VALUE);
./drivers/message/fusion/mptbase.c:4211:		diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4214:	CHIPREG_WRITE32(&ioc->chip->Diagnostic, diag0val);
./drivers/message/fusion/mptbase.c:4215:	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4223:	CHIPREG_WRITE32(&ioc->chip->WriteSequence, 0xFFFFFFFF);
./drivers/message/fusion/mptbase.c:4227:	diag0val = CHIPREG_READ32(&ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4236:			diag1val = CHIPREG_READ32(&ioc->alt_ioc->chip->Diagnostic);
./drivers/message/fusion/mptbase.c:4273:	CHIPREG_WRITE32(&ioc->chip->Doorbell, reset_type<<MPI_DOORBELL_FUNCTION_SHIFT);
./drivers/message/fusion/mptbase.c:4596:		CHIPREG_WRITE32(&ioc->chip->ReplyFifo, alloc_dma);
./drivers/message/fusion/mptbase.c:4675:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:4676:	CHIPREG_WRITE32(&ioc->chip->Doorbell,
./drivers/message/fusion/mptbase.c:4690:	if (!(CHIPREG_READ32(&ioc->chip->Doorbell) & MPI_DOORBELL_ACTIVE))
./drivers/message/fusion/mptbase.c:4698:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:4716:			CHIPREG_WRITE32(&ioc->chip->Doorbell, word);
./drivers/message/fusion/mptbase.c:4773:			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
./drivers/message/fusion/mptbase.c:4781:			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
./drivers/message/fusion/mptbase.c:4821:			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
./drivers/message/fusion/mptbase.c:4829:			intstat = CHIPREG_READ32(&ioc->chip->IntStatus);
./drivers/message/fusion/mptbase.c:4880:		hs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
./drivers/message/fusion/mptbase.c:4881:		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:4885:			hs_reply[u16cnt++] = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
./drivers/message/fusion/mptbase.c:4886:			CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:4901:		hword = le16_to_cpu(CHIPREG_READ32(&ioc->chip->Doorbell) & 0x0000FFFF);
./drivers/message/fusion/mptbase.c:4905:		CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:4910:	CHIPREG_WRITE32(&ioc->chip->IntStatus, 0);
./drivers/message/fusion/mptbase.c:6985:		CHIPREG_WRITE32(&ioc->chip->Doorbell, 0xC0FFEE00);
./drivers/message/fusion/mptbase.c:7059:	CHIPREG_WRITE32(&ioc->chip->IntMask, 0xFFFFFFFF);
./drivers/message/fusion/mptbase.c:7111:	CHIPREG_WRITE32(&ioc->chip->IntMask, MPI_HIM_DIM);
./drivers/pwm/pwm-atmel-hlcdc.c:57:	struct atmel_hlcdc *hlcdc = chip->hlcdc;
./drivers/pwm/pwm-atmel-hlcdc.c:65:	if (!chip->errata || !chip->errata->slow_clk_erratum) {
./drivers/pwm/pwm-atmel-hlcdc.c:75:	if ((chip->errata && chip->errata->slow_clk_erratum) ||
./drivers/pwm/pwm-atmel-hlcdc.c:88:		if (!pres && chip->errata && chip->errata->div1_clk_erratum)
./drivers/pwm/pwm-atmel-hlcdc.c:100:	if (new_clk != chip->cur_clk) {
./drivers/pwm/pwm-atmel-hlcdc.c:108:		clk_disable_unprepare(chip->cur_clk);
./drivers/pwm/pwm-atmel-hlcdc.c:109:		chip->cur_clk = new_clk;
./drivers/pwm/pwm-atmel-hlcdc.c:144:	struct atmel_hlcdc *hlcdc = chip->hlcdc;
./drivers/pwm/pwm-atmel-hlcdc.c:157:	struct atmel_hlcdc *hlcdc = chip->hlcdc;
./drivers/pwm/pwm-atmel-hlcdc.c:183:	struct atmel_hlcdc *hlcdc = chip->hlcdc;
./drivers/pwm/pwm-atmel-hlcdc.c:264:		chip->errata = match->data;
./drivers/pwm/pwm-atmel-hlcdc.c:266:	chip->hlcdc = hlcdc;
./drivers/pwm/pwm-atmel-hlcdc.c:267:	chip->chip.ops = &atmel_hlcdc_pwm_ops;
./drivers/pwm/pwm-atmel-hlcdc.c:268:	chip->chip.dev = dev;
./drivers/pwm/pwm-atmel-hlcdc.c:269:	chip->chip.base = -1;
./drivers/pwm/pwm-atmel-hlcdc.c:270:	chip->chip.npwm = 1;
./drivers/pwm/pwm-atmel-hlcdc.c:271:	chip->chip.of_xlate = of_pwm_xlate_with_flags;
./drivers/pwm/pwm-atmel-hlcdc.c:272:	chip->chip.of_pwm_n_cells = 3;
./drivers/pwm/pwm-atmel-hlcdc.c:273:	chip->chip.can_sleep = 1;
./drivers/pwm/pwm-atmel-hlcdc.c:275:	ret = pwmchip_add_with_polarity(&chip->chip, PWM_POLARITY_INVERSED);
./drivers/pwm/pwm-atmel-hlcdc.c:291:	ret = pwmchip_remove(&chip->chip);
./drivers/pwm/pwm-atmel-hlcdc.c:295:	clk_disable_unprepare(chip->hlcdc->periph_clk);
./drivers/pwm/pwm-jz4740.c:64:		dev_err(chip->dev, "Failed to request GPIO#%u for PWM: %d\n",
./drivers/pwm/pwm-samsung.c:142:	struct samsung_pwm_variant *variant = &chip->variant;
./drivers/pwm/pwm-samsung.c:145:	reg = readl(chip->base + REG_TCFG1);
./drivers/pwm/pwm-samsung.c:158:	rate = clk_get_rate(chip->base_clk);
./drivers/pwm/pwm-samsung.c:160:	reg = readl(chip->base + REG_TCFG0);
./drivers/pwm/pwm-samsung.c:171:	struct samsung_pwm_variant *variant = &chip->variant;
./drivers/pwm/pwm-samsung.c:177:		clk = (chan < 2) ? chip->tclk0 : chip->tclk1;
./drivers/pwm/pwm-samsung.c:184:		dev_warn(chip->chip.dev,
./drivers/pwm/pwm-samsung.c:189:	dev_dbg(chip->chip.dev, "tin parent at %lu\n", rate);
./drivers/pwm/pwm-samsung.c:210:	if (!(our_chip->variant.output_mask & BIT(pwm->hwpwm))) {
./drivers/pwm/pwm-samsung.c:211:		dev_warn(chip->dev,
./drivers/pwm/pwm-samsung.c:217:	our_chan = devm_kzalloc(chip->dev, sizeof(*our_chan), GFP_KERNEL);
./drivers/pwm/pwm-samsung.c:228:	devm_kfree(chip->dev, pwm_get_chip_data(pwm));
./drivers/pwm/pwm-samsung.c:241:	tcon = readl(our_chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:245:	writel(tcon, our_chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:249:	writel(tcon, our_chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:265:	tcon = readl(our_chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:267:	writel(tcon, our_chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:281:	tcon = readl(chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:283:	writel(tcon, chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:286:	writel(tcon, chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:309:	tcnt = readl(our_chip->base + REG_TCNTB(pwm->hwpwm));
./drivers/pwm/pwm-samsung.c:310:	oldtcmp = readl(our_chip->base + REG_TCMPB(pwm->hwpwm));
./drivers/pwm/pwm-samsung.c:322:		dev_dbg(our_chip->chip.dev, "duty_ns=%d, period_ns=%d (%u)\n",
./drivers/pwm/pwm-samsung.c:327:		dev_dbg(our_chip->chip.dev, "tin_rate=%lu\n", tin_rate);
./drivers/pwm/pwm-samsung.c:351:	dev_dbg(our_chip->chip.dev,
./drivers/pwm/pwm-samsung.c:355:	writel(tcnt, our_chip->base + REG_TCNTB(pwm->hwpwm));
./drivers/pwm/pwm-samsung.c:356:	writel(tcmp, our_chip->base + REG_TCMPB(pwm->hwpwm));
./drivers/pwm/pwm-samsung.c:364:		dev_dbg(our_chip->chip.dev, "Forcing manual update");
./drivers/pwm/pwm-samsung.c:384:	tcon = readl(chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:387:		chip->inverter_mask |= BIT(channel);
./drivers/pwm/pwm-samsung.c:390:		chip->inverter_mask &= ~BIT(channel);
./drivers/pwm/pwm-samsung.c:394:	writel(tcon, chip->base + REG_TCON);
./drivers/pwm/pwm-samsung.c:463:	struct device_node *np = chip->chip.dev->of_node;
./drivers/pwm/pwm-samsung.c:473:	memcpy(&chip->variant, match->data, sizeof(chip->variant));
./drivers/pwm/pwm-samsung.c:477:			dev_err(chip->chip.dev,
./drivers/pwm/pwm-samsung.c:482:		chip->variant.output_mask |= BIT(val);
./drivers/pwm/pwm-samsung.c:506:	chip->chip.dev = &pdev->dev;
./drivers/pwm/pwm-samsung.c:507:	chip->chip.ops = &pwm_samsung_ops;
./drivers/pwm/pwm-samsung.c:508:	chip->chip.base = -1;
./drivers/pwm/pwm-samsung.c:509:	chip->chip.npwm = SAMSUNG_PWM_NUM;
./drivers/pwm/pwm-samsung.c:510:	chip->inverter_mask = BIT(SAMSUNG_PWM_NUM) - 1;
./drivers/pwm/pwm-samsung.c:517:		chip->chip.of_xlate = of_pwm_xlate_with_flags;
./drivers/pwm/pwm-samsung.c:518:		chip->chip.of_pwm_n_cells = 3;
./drivers/pwm/pwm-samsung.c:525:		memcpy(&chip->variant, pdev->dev.platform_data,
./drivers/pwm/pwm-samsung.c:526:							sizeof(chip->variant));
./drivers/pwm/pwm-samsung.c:530:	chip->base = devm_ioremap_resource(&pdev->dev, res);
./drivers/pwm/pwm-samsung.c:531:	if (IS_ERR(chip->base))
./drivers/pwm/pwm-samsung.c:532:		return PTR_ERR(chip->base);
./drivers/pwm/pwm-samsung.c:534:	chip->base_clk = devm_clk_get(&pdev->dev, "timers");
./drivers/pwm/pwm-samsung.c:535:	if (IS_ERR(chip->base_clk)) {
./drivers/pwm/pwm-samsung.c:537:		return PTR_ERR(chip->base_clk);
./drivers/pwm/pwm-samsung.c:540:	ret = clk_prepare_enable(chip->base_clk);
./drivers/pwm/pwm-samsung.c:547:		if (chip->variant.output_mask & BIT(chan))
./drivers/pwm/pwm-samsung.c:551:	chip->tclk0 = devm_clk_get(&pdev->dev, "pwm-tclk0");
./drivers/pwm/pwm-samsung.c:552:	chip->tclk1 = devm_clk_get(&pdev->dev, "pwm-tclk1");
./drivers/pwm/pwm-samsung.c:556:	ret = pwmchip_add(&chip->chip);
./drivers/pwm/pwm-samsung.c:559:		clk_disable_unprepare(chip->base_clk);
./drivers/pwm/pwm-samsung.c:564:		clk_get_rate(chip->base_clk),
./drivers/pwm/pwm-samsung.c:565:		!IS_ERR(chip->tclk0) ? clk_get_rate(chip->tclk0) : 0,
./drivers/pwm/pwm-samsung.c:566:		!IS_ERR(chip->tclk1) ? clk_get_rate(chip->tclk1) : 0);
./drivers/pwm/pwm-samsung.c:576:	ret = pwmchip_remove(&chip->chip);
./drivers/pwm/pwm-samsung.c:580:	clk_disable_unprepare(chip->base_clk);
./drivers/pwm/pwm-samsung.c:597:		struct pwm_device *pwm = &chip->chip.pwms[i];
./drivers/pwm/pwm-samsung.c:620:		if (chip->variant.output_mask & BIT(chan))
./drivers/pwm/pwm-samsung.c:622:					chip->inverter_mask & BIT(chan));
./drivers/pwm/pwm-clps711x.c:112:	if (args->args[0] >= chip->npwm)
./drivers/pwm/pwm-tegra.c:57:	return readl(chip->mmio_base + (num << 4));
./drivers/pwm/pwm-tegra.c:63:	writel(val, chip->mmio_base + (num << 4));
./drivers/pwm/pwm-berlin.c:48:	return readl_relaxed(chip->base + channel * 0x10 + offset);
./drivers/pwm/pwm-berlin.c:55:	writel_relaxed(value, chip->base + channel * 0x10 + offset);
./drivers/pwm/pwm-tiecap.c:183:		dev_warn(chip->dev, "Removing PWM device without disabling\n");
./drivers/pwm/pwm-tiecap.c:184:		pm_runtime_put_sync(chip->dev);
./drivers/pwm/pwm-twl-led.c:98:		dev_err(chip->dev, "%s: Failed to configure PWM\n", pwm->label);
./drivers/pwm/pwm-twl-led.c:112:		dev_err(chip->dev, "%s: Failed to read LEDEN\n", pwm->label);
./drivers/pwm/pwm-twl-led.c:120:		dev_err(chip->dev, "%s: Failed to enable PWM\n", pwm->label);
./drivers/pwm/pwm-twl-led.c:137:		dev_err(chip->dev, "%s: Failed to read LEDEN\n", pwm->label);
./drivers/pwm/pwm-twl-led.c:145:		dev_err(chip->dev, "%s: Failed to disable PWM\n", pwm->label);
./drivers/pwm/pwm-twl-led.c:163:		dev_err(chip->dev, "%s: Failed to configure PWM\n", pwm->label);
./drivers/pwm/pwm-twl-led.c:177:		dev_err(chip->dev, "%s: Failed to read PWM_CTRL2\n",
./drivers/pwm/pwm-twl-led.c:187:		dev_err(chip->dev, "%s: Failed to enable PWM\n", pwm->label);
./drivers/pwm/pwm-twl-led.c:204:		dev_err(chip->dev, "%s: Failed to read PWM_CTRL2\n",
./drivers/pwm/pwm-twl-led.c:214:		dev_err(chip->dev, "%s: Failed to disable PWM\n", pwm->label);
./drivers/pwm/pwm-twl-led.c:229:		dev_err(chip->dev, "%s: Failed to read PWM_CTRL2\n",
./drivers/pwm/pwm-twl-led.c:239:		dev_err(chip->dev, "%s: Failed to request PWM\n", pwm->label);
./drivers/pwm/pwm-twl-led.c:255:		dev_err(chip->dev, "%s: Failed to read PWM_CTRL2\n",
./drivers/pwm/pwm-twl-led.c:265:		dev_err(chip->dev, "%s: Failed to free PWM\n", pwm->label);
./drivers/pwm/pwm-lpc18xx-sct.c:192:		dev_err(chip->dev, "period %d not in range\n", period_ns);
./drivers/pwm/pwm-lpc18xx-sct.c:208:		dev_err(chip->dev, "conflicting period requested for PWM %u\n",
./drivers/pwm/pwm-lpc18xx-sct.c:217:		for (i = 0; i < chip->npwm; i++)
./drivers/pwm/pwm-lpc18xx-sct.c:218:			pwm_set_period(&chip->pwms[i], period_ns);
./drivers/pwm/pwm-rockchip.c:293:		.name = "rockchip-pwm",
./drivers/pwm/pwm-pca9685.c:35: * However, the ratio between each configured duty cycle and the chip-wide
./drivers/pwm/pwm-pca9685.c:109:			/* Change the chip-wide output frequency */
./drivers/pwm/pwm-pca9685.c:131:			dev_err(chip->dev,
./drivers/pwm/pwm-imx.c:113:	struct device *dev = chip->dev;
./drivers/pwm/pwm-img.c:79:	writel(val, chip->base + reg);
./drivers/pwm/pwm-img.c:85:	return readl(chip->base + reg);
./drivers/pwm/pwm-img.c:94:	unsigned int max_timebase = pwm_chip->data->max_timebase;
./drivers/pwm/pwm-img.c:96:	if (period_ns < pwm_chip->min_period_ns ||
./drivers/pwm/pwm-img.c:97:	    period_ns > pwm_chip->max_period_ns) {
./drivers/pwm/pwm-img.c:98:		dev_err(chip->dev, "configured period not in range\n");
./drivers/pwm/pwm-img.c:102:	input_clk_hz = clk_get_rate(pwm_chip->pwm_clk);
./drivers/pwm/pwm-img.c:119:		dev_err(chip->dev,
./drivers/pwm/pwm-img.c:148:	regmap_update_bits(pwm_chip->periph_regs, PERIP_PWM_PDM_CONTROL,
./drivers/pwm/pwm-img.c:282:	for (i = 0; i < pwm_chip->chip.npwm; i++) {
./drivers/pwm/pwm-img.c:288:	clk_disable_unprepare(pwm_chip->pwm_clk);
./drivers/pwm/pwm-img.c:289:	clk_disable_unprepare(pwm_chip->sys_clk);
./drivers/pwm/pwm-img.c:291:	return pwmchip_remove(&pwm_chip->chip);
./drivers/pwm/pwm-lpss.c:120:	pm_runtime_get_sync(chip->dev);
./drivers/pwm/pwm-lpss.c:137:	pm_runtime_put(chip->dev);
./drivers/pwm/pwm-lpss.c:144:	pm_runtime_get_sync(chip->dev);
./drivers/pwm/pwm-lpss.c:158:	pm_runtime_put(chip->dev);
./drivers/pwm/sysfs.c:302:	if (hwpwm >= chip->npwm)
./drivers/pwm/sysfs.c:329:	if (hwpwm >= chip->npwm)
./drivers/pwm/sysfs.c:332:	ret = pwm_unexport_child(parent, &chip->pwms[hwpwm]);
./drivers/pwm/sysfs.c:343:	return sprintf(buf, "%u\n", chip->npwm);
./drivers/pwm/sysfs.c:374:	parent = device_create(&pwm_class, chip->dev, MKDEV(0, 0), chip,
./drivers/pwm/sysfs.c:375:			       "pwmchip%d", chip->base);
./drivers/pwm/sysfs.c:377:		dev_warn(chip->dev,
./drivers/pwm/pwm-bcm-kona.c:186:		dev_err(chip->dev, "failed to enable clock: %d\n", ret);
./drivers/pwm/pwm-bcm-kona.c:215:		dev_err(chip->dev, "failed to enable clock: %d\n", ret);
./drivers/pwm/pwm-spear.c:67:	return readl_relaxed(chip->mmio_base + (num << 4) + offset);
./drivers/pwm/pwm-spear.c:74:	writel_relaxed(val, chip->mmio_base + (num << 4) + offset);
./drivers/pwm/pwm-pxa.c:222:	return pwmchip_remove(&chip->chip);
./drivers/pwm/core.c:76:	for (i = 0; i < chip->npwm; i++) {
./drivers/pwm/core.c:77:		struct pwm_device *pwm = &chip->pwms[i];
./drivers/pwm/core.c:82:	bitmap_clear(allocated_pwms, chip->base, chip->npwm);
./drivers/pwm/core.c:84:	kfree(chip->pwms);
./drivers/pwm/core.c:85:	chip->pwms = NULL;
./drivers/pwm/core.c:98:		const char *chip_name = dev_name(chip->dev);
./drivers/pwm/core.c:118:	if (!try_module_get(pwm->chip->ops->owner))
./drivers/pwm/core.c:121:	if (pwm->chip->ops->request) {
./drivers/pwm/core.c:122:		err = pwm->chip->ops->request(pwm->chip, pwm);
./drivers/pwm/core.c:124:			module_put(pwm->chip->ops->owner);
./drivers/pwm/core.c:183:	if (!chip->dev || !chip->dev->of_node)
./drivers/pwm/core.c:186:	if (!chip->of_xlate) {
./drivers/pwm/core.c:187:		chip->of_xlate = of_pwm_simple_xlate;
./drivers/pwm/core.c:188:		chip->of_pwm_n_cells = 2;
./drivers/pwm/core.c:191:	of_node_get(chip->dev->of_node);
./drivers/pwm/core.c:196:	if (chip->dev)
./drivers/pwm/core.c:197:		of_node_put(chip->dev->of_node);
./drivers/pwm/core.c:203: * @data: pointer to chip-specific data
./drivers/pwm/core.c:222: * Returns: A pointer to the chip-private data for the PWM device.
./drivers/pwm/core.c:248: * Register a new PWM chip. If chip->base < 0 then a dynamically assigned base
./drivers/pwm/core.c:261:	if (!chip || !chip->dev || !chip->ops || !chip->npwm)
./drivers/pwm/core.c:264:	if (!pwm_ops_check(chip->ops))
./drivers/pwm/core.c:269:	ret = alloc_pwms(chip->base, chip->npwm);
./drivers/pwm/core.c:273:	chip->pwms = kcalloc(chip->npwm, sizeof(*pwm), GFP_KERNEL);
./drivers/pwm/core.c:274:	if (!chip->pwms) {
./drivers/pwm/core.c:279:	chip->base = ret;
./drivers/pwm/core.c:281:	for (i = 0; i < chip->npwm; i++) {
./drivers/pwm/core.c:282:		pwm = &chip->pwms[i];
./drivers/pwm/core.c:285:		pwm->pwm = chip->base + i;
./drivers/pwm/core.c:289:		if (chip->ops->get_state)
./drivers/pwm/core.c:290:			chip->ops->get_state(chip, pwm, &pwm->state);
./drivers/pwm/core.c:295:	bitmap_set(allocated_pwms, chip->base, chip->npwm);
./drivers/pwm/core.c:297:	INIT_LIST_HEAD(&chip->list);
./drivers/pwm/core.c:298:	list_add(&chip->list, &pwm_chips);
./drivers/pwm/core.c:317: * Register a new PWM chip. If chip->base < 0 then a dynamically assigned base
./drivers/pwm/core.c:344:	for (i = 0; i < chip->npwm; i++) {
./drivers/pwm/core.c:345:		struct pwm_device *pwm = &chip->pwms[i];
./drivers/pwm/core.c:353:	list_del_init(&chip->list);
./drivers/pwm/core.c:422:	if (!chip || index >= chip->npwm)
./drivers/pwm/core.c:426:	pwm = &chip->pwms[index];
./drivers/pwm/core.c:467:	if (pwm->chip->ops->apply) {
./drivers/pwm/core.c:468:		err = pwm->chip->ops->apply(pwm->chip, pwm, state);
./drivers/pwm/core.c:478:			if (!pwm->chip->ops->set_polarity)
./drivers/pwm/core.c:487:				pwm->chip->ops->disable(pwm->chip, pwm);
./drivers/pwm/core.c:491:			err = pwm->chip->ops->set_polarity(pwm->chip, pwm,
./drivers/pwm/core.c:501:			err = pwm->chip->ops->config(pwm->chip, pwm,
./drivers/pwm/core.c:513:				err = pwm->chip->ops->enable(pwm->chip, pwm);
./drivers/pwm/core.c:517:				pwm->chip->ops->disable(pwm->chip, pwm);
./drivers/pwm/core.c:591:		if (chip->dev && chip->dev->of_node == np) {
./drivers/pwm/core.c:829:	if (pwm->chip->ops->free)
./drivers/pwm/core.c:830:		pwm->chip->ops->free(pwm->chip, pwm);
./drivers/pwm/core.c:834:	module_put(pwm->chip->ops->owner);
./drivers/pwm/core.c:951:	for (i = 0; i < chip->npwm; i++) {
./drivers/pwm/core.c:952:		struct pwm_device *pwm = &chip->pwms[i];
./drivers/pwm/core.c:999:		   chip->dev->bus ? chip->dev->bus->name : "no-bus",
./drivers/pwm/core.c:1000:		   dev_name(chip->dev), chip->npwm,
./drivers/pwm/core.c:1001:		   (chip->npwm != 1) ? "s" : "");
./drivers/pwm/core.c:1003:	if (chip->ops->dbg_show)
./drivers/pwm/core.c:1004:		chip->ops->dbg_show(chip, s);
./drivers/pwm/pwm-atmel-tcb.c:75:	tcbpwm = devm_kzalloc(chip->dev, sizeof(*tcbpwm), GFP_KERNEL);
./drivers/pwm/pwm-atmel-tcb.c:81:		devm_kfree(chip->dev, tcbpwm);
./drivers/pwm/pwm-atmel-tcb.c:129:	devm_kfree(chip->dev, tcbpwm);
./drivers/pwm/pwm-atmel-tcb.c:340:		dev_err(chip->dev,
./drivers/pwm/pwm-ab8500.c:45:	reg = AB8500_PWM_OUT_CTRL1_REG + ((chip->base - 1) * 2);
./drivers/pwm/pwm-ab8500.c:47:	ret = abx500_set_register_interruptible(chip->dev, AB8500_MISC,
./drivers/pwm/pwm-ab8500.c:51:	ret = abx500_set_register_interruptible(chip->dev, AB8500_MISC,
./drivers/pwm/pwm-ab8500.c:61:	ret = abx500_mask_and_set_register_interruptible(chip->dev,
./drivers/pwm/pwm-ab8500.c:63:				1 << (chip->base - 1), 1 << (chip->base - 1));
./drivers/pwm/pwm-ab8500.c:65:		dev_err(chip->dev, "%s: Failed to enable PWM, Error %d\n",
./drivers/pwm/pwm-ab8500.c:74:	ret = abx500_mask_and_set_register_interruptible(chip->dev,
./drivers/pwm/pwm-ab8500.c:76:				1 << (chip->base - 1), 0);
./drivers/pwm/pwm-ab8500.c:78:		dev_err(chip->dev, "%s: Failed to disable PWM, Error %d\n",
./drivers/pwm/pwm-omap-dmtimer.c:105:	dev_dbg(chip->dev, "requested duty cycle: %d ns, period: %d ns\n",
./drivers/pwm/pwm-omap-dmtimer.c:118:		dev_err(chip->dev, "invalid pmtimer fclk\n");
./drivers/pwm/pwm-omap-dmtimer.c:124:		dev_err(chip->dev, "invalid pmtimer fclk rate\n");
./drivers/pwm/pwm-omap-dmtimer.c:128:	dev_dbg(chip->dev, "clk rate: %luHz\n", clk_rate);
./drivers/pwm/pwm-omap-dmtimer.c:150:		dev_info(chip->dev,
./drivers/pwm/pwm-omap-dmtimer.c:157:		dev_dbg(chip->dev,
./drivers/pwm/pwm-omap-dmtimer.c:160:		dev_dbg(chip->dev, "using minimum of 1 clock cycle\n");
./drivers/pwm/pwm-omap-dmtimer.c:163:		dev_dbg(chip->dev,
./drivers/pwm/pwm-omap-dmtimer.c:166:		dev_dbg(chip->dev, "using maximum of 1 clock cycle less than period\n");
./drivers/pwm/pwm-omap-dmtimer.c:170:	dev_dbg(chip->dev, "effective duty cycle: %lld ns, period: %lld ns\n",
./drivers/pwm/pwm-omap-dmtimer.c:191:	dev_dbg(chip->dev, "load value: %#08x (%d), match value: %#08x (%d)\n",
./drivers/pwm/pwm-ep93xx.c:58:	struct platform_device *pdev = to_platform_device(chip->dev);
./drivers/pwm/pwm-ep93xx.c:65:	struct platform_device *pdev = to_platform_device(chip->dev);
./drivers/pwm/pwm-sun4i.c:90:	return readl(chip->base + offset);
./drivers/pwm/pwm-sun4i.c:96:	writel(val, chip->base + offset);
./drivers/pwm/pwm-sun4i.c:138:			dev_err(chip->dev, "period exceeds the maximum value\n");
./drivers/pwm/pwm-sun4i.c:150:		dev_err(chip->dev, "failed to enable PWM clock\n");
./drivers/pwm/pwm-sun4i.c:198:		dev_err(chip->dev, "failed to enable PWM clock\n");
./drivers/pwm/pwm-sun4i.c:226:		dev_err(chip->dev, "failed to enable PWM clock\n");
./drivers/pwm/pwm-vt8500.c:91:		dev_err(chip->dev, "failed to enable clock\n");
./drivers/pwm/pwm-vt8500.c:142:		dev_err(chip->dev, "failed to enable clock\n");
./drivers/pwm/pwm-vt8500.c:217:	chip->chip.dev = &pdev->dev;
./drivers/pwm/pwm-vt8500.c:218:	chip->chip.ops = &vt8500_pwm_ops;
./drivers/pwm/pwm-vt8500.c:219:	chip->chip.of_xlate = of_pwm_xlate_with_flags;
./drivers/pwm/pwm-vt8500.c:220:	chip->chip.of_pwm_n_cells = 3;
./drivers/pwm/pwm-vt8500.c:221:	chip->chip.base = -1;
./drivers/pwm/pwm-vt8500.c:222:	chip->chip.npwm = VT8500_NR_PWMS;
./drivers/pwm/pwm-vt8500.c:224:	chip->clk = devm_clk_get(&pdev->dev, NULL);
./drivers/pwm/pwm-vt8500.c:225:	if (IS_ERR(chip->clk)) {
./drivers/pwm/pwm-vt8500.c:227:		return PTR_ERR(chip->clk);
./drivers/pwm/pwm-vt8500.c:231:	chip->base = devm_ioremap_resource(&pdev->dev, r);
./drivers/pwm/pwm-vt8500.c:232:	if (IS_ERR(chip->base))
./drivers/pwm/pwm-vt8500.c:233:		return PTR_ERR(chip->base);
./drivers/pwm/pwm-vt8500.c:235:	ret = clk_prepare(chip->clk);
./drivers/pwm/pwm-vt8500.c:241:	ret = pwmchip_add(&chip->chip);
./drivers/pwm/pwm-vt8500.c:259:	clk_unprepare(chip->clk);
./drivers/pwm/pwm-vt8500.c:261:	return pwmchip_remove(&chip->chip);
./drivers/pwm/pwm-twl.c:100:		dev_err(chip->dev, "%s: Failed to configure PWM\n", pwm->label);
./drivers/pwm/pwm-twl.c:114:		dev_err(chip->dev, "%s: Failed to read GPBR1\n", pwm->label);
./drivers/pwm/pwm-twl.c:122:		dev_err(chip->dev, "%s: Failed to enable PWM\n", pwm->label);
./drivers/pwm/pwm-twl.c:128:		dev_err(chip->dev, "%s: Failed to enable PWM\n", pwm->label);
./drivers/pwm/pwm-twl.c:144:		dev_err(chip->dev, "%s: Failed to read GPBR1\n", pwm->label);
./drivers/pwm/pwm-twl.c:152:		dev_err(chip->dev, "%s: Failed to disable PWM\n", pwm->label);
./drivers/pwm/pwm-twl.c:158:		dev_err(chip->dev, "%s: Failed to disable PWM\n", pwm->label);
./drivers/pwm/pwm-twl.c:181:		dev_err(chip->dev, "%s: Failed to read PMBR1\n", pwm->label);
./drivers/pwm/pwm-twl.c:195:		dev_err(chip->dev, "%s: Failed to request PWM\n", pwm->label);
./drivers/pwm/pwm-twl.c:216:		dev_err(chip->dev, "%s: Failed to read PMBR1\n", pwm->label);
./drivers/pwm/pwm-twl.c:226:		dev_err(chip->dev, "%s: Failed to free PWM\n", pwm->label);
./drivers/pwm/pwm-twl.c:245:		dev_err(chip->dev, "%s: Failed to enable PWM\n", pwm->label);
./drivers/pwm/pwm-twl.c:268:		dev_err(chip->dev, "%s: Failed to disable PWM\n", pwm->label);
./drivers/pwm/pwm-atmel.c:81:	return readl_relaxed(chip->base + offset);
./drivers/pwm/pwm-atmel.c:87:	writel_relaxed(val, chip->base + offset);
./drivers/pwm/pwm-atmel.c:95:	return readl_relaxed(chip->base + base + offset);
./drivers/pwm/pwm-atmel.c:104:	writel_relaxed(val, chip->base + base + offset);
./drivers/pwm/pwm-atmel.c:118:		dev_err(chip->dev, "cannot change PWM period while enabled\n");
./drivers/pwm/pwm-atmel.c:132:		dev_err(chip->dev, "pres exceeds the maximum value\n");
./drivers/pwm/pwm-atmel.c:144:		dev_err(chip->dev, "failed to enable PWM clock\n");
./drivers/pwm/pwm-atmel.c:226:		dev_err(chip->dev, "failed to enable PWM clock\n");
./drivers/pwm/pwm-atmel.c:244:		dev_err(chip->dev, "failed to enable PWM clock\n");
./drivers/pwm/pwm-tiehrpwm.c:277:			dev_err(chip->dev, "Period value conflicts with channel %d\n",
./drivers/pwm/pwm-tiehrpwm.c:288:		dev_err(chip->dev, "Unsupported values\n");
./drivers/pwm/pwm-tiehrpwm.c:292:	pm_runtime_get_sync(chip->dev);
./drivers/pwm/pwm-tiehrpwm.c:319:	pm_runtime_put_sync(chip->dev);
./drivers/pwm/pwm-tiehrpwm.c:340:	pm_runtime_get_sync(chip->dev);
./drivers/pwm/pwm-tiehrpwm.c:363:		dev_err(chip->dev, "Failed to enable TBCLK for %s\n",
./drivers/pwm/pwm-tiehrpwm.c:403:	pm_runtime_put_sync(chip->dev);
./drivers/pwm/pwm-tiehrpwm.c:411:		dev_warn(chip->dev, "Removing PWM device without disabling\n");
./drivers/pwm/pwm-tiehrpwm.c:412:		pm_runtime_put_sync(chip->dev);
./drivers/thermal/qcom-spmi-temp-alarm.c:74:	ret = regmap_read(chip->map, chip->base + addr, &val);
./drivers/thermal/qcom-spmi-temp-alarm.c:84:	return regmap_write(chip->map, chip->base + addr, data);
./drivers/thermal/qcom-spmi-temp-alarm.c:103:	if (stage > chip->stage) {
./drivers/thermal/qcom-spmi-temp-alarm.c:105:		chip->temp = (stage - 1) * TEMP_STAGE_STEP +
./drivers/thermal/qcom-spmi-temp-alarm.c:106:			     chip->thresh * TEMP_THRESH_STEP +
./drivers/thermal/qcom-spmi-temp-alarm.c:108:	} else if (stage < chip->stage) {
./drivers/thermal/qcom-spmi-temp-alarm.c:110:		chip->temp = stage * TEMP_STAGE_STEP +
./drivers/thermal/qcom-spmi-temp-alarm.c:111:			     chip->thresh * TEMP_THRESH_STEP -
./drivers/thermal/qcom-spmi-temp-alarm.c:115:	chip->stage = stage;
./drivers/thermal/qcom-spmi-temp-alarm.c:128:	if (IS_ERR(chip->adc)) {
./drivers/thermal/qcom-spmi-temp-alarm.c:133:		ret = iio_read_channel_processed(chip->adc, &mili_celsius);
./drivers/thermal/qcom-spmi-temp-alarm.c:137:		chip->temp = mili_celsius;
./drivers/thermal/qcom-spmi-temp-alarm.c:140:	*temp = chip->temp < 0 ? 0 : chip->temp;
./drivers/thermal/qcom-spmi-temp-alarm.c:153:	thermal_zone_device_update(chip->tz_dev);
./drivers/thermal/qcom-spmi-temp-alarm.c:168:	chip->thresh = THRESH_MIN;
./drivers/thermal/qcom-spmi-temp-alarm.c:169:	chip->temp = DEFAULT_TEMP;
./drivers/thermal/qcom-spmi-temp-alarm.c:175:	chip->stage = reg & STATUS_STAGE_MASK;
./drivers/thermal/qcom-spmi-temp-alarm.c:177:	if (chip->stage)
./drivers/thermal/qcom-spmi-temp-alarm.c:178:		chip->temp = chip->thresh * TEMP_THRESH_STEP +
./drivers/thermal/qcom-spmi-temp-alarm.c:179:			     (chip->stage - 1) * TEMP_STAGE_STEP +
./drivers/thermal/qcom-spmi-temp-alarm.c:186:	reg = chip->thresh & SHUTDOWN_CTRL1_THRESHOLD_MASK;
./drivers/thermal/qcom-spmi-temp-alarm.c:214:	chip->map = dev_get_regmap(pdev->dev.parent, NULL);
./drivers/thermal/qcom-spmi-temp-alarm.c:215:	if (!chip->map)
./drivers/thermal/qcom-spmi-temp-alarm.c:227:	chip->adc = iio_channel_get(&pdev->dev, "thermal");
./drivers/thermal/qcom-spmi-temp-alarm.c:228:	if (PTR_ERR(chip->adc) == -EPROBE_DEFER)
./drivers/thermal/qcom-spmi-temp-alarm.c:229:		return PTR_ERR(chip->adc);
./drivers/thermal/qcom-spmi-temp-alarm.c:231:	chip->base = res[0];
./drivers/thermal/qcom-spmi-temp-alarm.c:263:	chip->tz_dev = devm_thermal_zone_of_sensor_register(&pdev->dev, 0, chip,
./drivers/thermal/qcom-spmi-temp-alarm.c:265:	if (IS_ERR(chip->tz_dev)) {
./drivers/thermal/qcom-spmi-temp-alarm.c:267:		ret = PTR_ERR(chip->tz_dev);
./drivers/thermal/qcom-spmi-temp-alarm.c:274:	if (!IS_ERR(chip->adc))
./drivers/thermal/qcom-spmi-temp-alarm.c:275:		iio_channel_release(chip->adc);
./drivers/thermal/qcom-spmi-temp-alarm.c:284:	if (!IS_ERR(chip->adc))
./drivers/thermal/qcom-spmi-temp-alarm.c:285:		iio_channel_release(chip->adc);
./drivers/thermal/rockchip_thermal.c:76: * struct chip_tsadc_table - hold information about chip-specific differences
./drivers/thermal/rockchip_thermal.c:101: * @table: the chip-specific conversion table
./drivers/thermal/rockchip_thermal.c:821:	thermal->chip->irq_ack(thermal->regs);
./drivers/thermal/rockchip_thermal.c:823:	for (i = 0; i < thermal->chip->chn_num; i++)
./drivers/thermal/rockchip_thermal.c:857:			 thermal->chip->tshut_temp);
./drivers/thermal/rockchip_thermal.c:858:		thermal->tshut_temp = thermal->chip->tshut_temp;
./drivers/thermal/rockchip_thermal.c:871:			 thermal->chip->tshut_mode == TSHUT_MODE_GPIO ?
./drivers/thermal/rockchip_thermal.c:873:		thermal->tshut_mode = thermal->chip->tshut_mode;
./drivers/thermal/rockchip_thermal.c:888:			 thermal->chip->tshut_polarity == TSHUT_LOW_ACTIVE ?
./drivers/thermal/rockchip_thermal.c:890:		thermal->tshut_polarity = thermal->chip->tshut_polarity;
./drivers/thermal/rockchip_thermal.c:1026:	thermal->chip->initialize(thermal->grf, thermal->regs,
./drivers/thermal/rockchip_thermal.c:1029:	for (i = 0; i < thermal->chip->chn_num; i++) {
./drivers/thermal/rockchip_thermal.c:1032:						thermal->chip->chn_id[i]);
./drivers/thermal/rockchip_thermal.c:1051:	thermal->chip->control(thermal->regs, true);
./drivers/thermal/rockchip_thermal.c:1053:	for (i = 0; i < thermal->chip->chn_num; i++)
./drivers/thermal/rockchip_thermal.c:1073:	for (i = 0; i < thermal->chip->chn_num; i++) {
./drivers/thermal/rockchip_thermal.c:1079:	thermal->chip->control(thermal->regs, false);
./drivers/thermal/rockchip_thermal.c:1093:	for (i = 0; i < thermal->chip->chn_num; i++)
./drivers/thermal/rockchip_thermal.c:1096:	thermal->chip->control(thermal->regs, false);
./drivers/thermal/rockchip_thermal.c:1125:	thermal->chip->initialize(thermal->grf, thermal->regs,
./drivers/thermal/rockchip_thermal.c:1128:	for (i = 0; i < thermal->chip->chn_num; i++) {
./drivers/thermal/rockchip_thermal.c:1131:		thermal->chip->set_tshut_mode(id, thermal->regs,
./drivers/thermal/rockchip_thermal.c:1133:		thermal->chip->set_tshut_temp(thermal->chip->table,
./drivers/thermal/rockchip_thermal.c:1138:	thermal->chip->control(thermal->regs, true);
./drivers/thermal/rockchip_thermal.c:1140:	for (i = 0; i < thermal->chip->chn_num; i++)
./drivers/thermal/rockchip_thermal.c:1153:		.name = "rockchip-thermal",
./drivers/thermal/rockchip_thermal.c:1166:MODULE_ALIAS("platform:rockchip-thermal");
./drivers/regulator/pv88090-regulator.c:273:	err = regmap_read(chip->regmap, PV88090_REG_EVENT_A, &reg_val);
./drivers/regulator/pv88090-regulator.c:279:			if (chip->rdev[i] != NULL) {
./drivers/regulator/pv88090-regulator.c:280:				regulator_notifier_call_chain(chip->rdev[i],
./drivers/regulator/pv88090-regulator.c:286:		err = regmap_write(chip->regmap, PV88090_REG_EVENT_A,
./drivers/regulator/pv88090-regulator.c:296:			if (chip->rdev[i] != NULL) {
./drivers/regulator/pv88090-regulator.c:297:				regulator_notifier_call_chain(chip->rdev[i],
./drivers/regulator/pv88090-regulator.c:303:		err = regmap_write(chip->regmap, PV88090_REG_EVENT_A,
./drivers/regulator/pv88090-regulator.c:314:	dev_err(chip->dev, "I2C error : %d\n", err);
./drivers/regulator/pv88090-regulator.c:334:	chip->dev = &i2c->dev;
./drivers/regulator/pv88090-regulator.c:335:	chip->regmap = devm_regmap_init_i2c(i2c, &pv88090_regmap_config);
./drivers/regulator/pv88090-regulator.c:336:	if (IS_ERR(chip->regmap)) {
./drivers/regulator/pv88090-regulator.c:337:		error = PTR_ERR(chip->regmap);
./drivers/regulator/pv88090-regulator.c:338:		dev_err(chip->dev, "Failed to allocate register map: %d\n",
./drivers/regulator/pv88090-regulator.c:346:		ret = regmap_write(chip->regmap, PV88090_REG_MASK_A, 0xFF);
./drivers/regulator/pv88090-regulator.c:348:			dev_err(chip->dev,
./drivers/regulator/pv88090-regulator.c:353:		ret = regmap_write(chip->regmap, PV88090_REG_MASK_B, 0xFF);
./drivers/regulator/pv88090-regulator.c:355:			dev_err(chip->dev,
./drivers/regulator/pv88090-regulator.c:365:			dev_err(chip->dev, "Failed to request IRQ: %d\n",
./drivers/regulator/pv88090-regulator.c:370:		ret = regmap_update_bits(chip->regmap, PV88090_REG_MASK_A,
./drivers/regulator/pv88090-regulator.c:373:			dev_err(chip->dev,
./drivers/regulator/pv88090-regulator.c:379:		dev_warn(chip->dev, "No IRQ configured\n");
./drivers/regulator/pv88090-regulator.c:382:	config.dev = chip->dev;
./drivers/regulator/pv88090-regulator.c:383:	config.regmap = chip->regmap;
./drivers/regulator/pv88090-regulator.c:390:			ret = regmap_read(chip->regmap,
./drivers/regulator/pv88090-regulator.c:398:			ret = regmap_read(chip->regmap,
./drivers/regulator/pv88090-regulator.c:419:		chip->rdev[i] = devm_regulator_register(chip->dev,
./drivers/regulator/pv88090-regulator.c:421:		if (IS_ERR(chip->rdev[i])) {
./drivers/regulator/pv88090-regulator.c:422:			dev_err(chip->dev,
./drivers/regulator/pv88090-regulator.c:424:			return PTR_ERR(chip->rdev[i]);
./drivers/regulator/max77620-regulator.c:735:	pmic->rmap = max77620_chip->rmap;
./drivers/regulator/max77620-regulator.c:739:	switch (max77620_chip->chip_id) {
./drivers/regulator/max77620-regulator.c:756:		if ((max77620_chip->chip_id == MAX77620) &&
./drivers/regulator/da9211-regulator.c:109:	ret = regmap_read(chip->regmap, DA9211_REG_BUCKA_CONF+id, &data);
./drivers/regulator/da9211-regulator.c:147:	return regmap_update_bits(chip->regmap, DA9211_REG_BUCKA_CONF+id,
./drivers/regulator/da9211-regulator.c:159:	switch (chip->chip_id) {
./drivers/regulator/da9211-regulator.c:180:				return regmap_update_bits(chip->regmap,
./drivers/regulator/da9211-regulator.c:197:	switch (chip->chip_id) {
./drivers/regulator/da9211-regulator.c:211:	ret = regmap_read(chip->regmap, DA9211_REG_BUCK_ILIM, &data);
./drivers/regulator/da9211-regulator.c:317:	err = regmap_read(chip->regmap, DA9211_REG_EVENT_B, &reg_val);
./drivers/regulator/da9211-regulator.c:322:		regulator_notifier_call_chain(chip->rdev[0],
./drivers/regulator/da9211-regulator.c:325:		err = regmap_write(chip->regmap, DA9211_REG_EVENT_B,
./drivers/regulator/da9211-regulator.c:334:		regulator_notifier_call_chain(chip->rdev[1],
./drivers/regulator/da9211-regulator.c:337:		err = regmap_write(chip->regmap, DA9211_REG_EVENT_B,
./drivers/regulator/da9211-regulator.c:348:	dev_err(chip->dev, "I2C error : %d\n", err);
./drivers/regulator/da9211-regulator.c:358:	ret = regmap_read(chip->regmap, DA9211_REG_CONFIG_E, &data);
./drivers/regulator/da9211-regulator.c:360:		dev_err(chip->dev, "Failed to read CONFIG_E reg: %d\n", ret);
./drivers/regulator/da9211-regulator.c:368:	if (chip->pdata->num_buck == 1 && data == 0x00)
./drivers/regulator/da9211-regulator.c:369:		chip->num_regulator = 1;
./drivers/regulator/da9211-regulator.c:370:	else if (chip->pdata->num_buck == 2 && data != 0x00)
./drivers/regulator/da9211-regulator.c:371:		chip->num_regulator = 2;
./drivers/regulator/da9211-regulator.c:373:		dev_err(chip->dev, "Configuration is mismatched\n");
./drivers/regulator/da9211-regulator.c:377:	for (i = 0; i < chip->num_regulator; i++) {
./drivers/regulator/da9211-regulator.c:378:		config.init_data = chip->pdata->init_data[i];
./drivers/regulator/da9211-regulator.c:379:		config.dev = chip->dev;
./drivers/regulator/da9211-regulator.c:381:		config.regmap = chip->regmap;
./drivers/regulator/da9211-regulator.c:382:		config.of_node = chip->pdata->reg_node[i];
./drivers/regulator/da9211-regulator.c:384:		if (gpio_is_valid(chip->pdata->gpio_ren[i])) {
./drivers/regulator/da9211-regulator.c:385:			config.ena_gpio = chip->pdata->gpio_ren[i];
./drivers/regulator/da9211-regulator.c:392:		chip->rdev[i] = devm_regulator_register(chip->dev,
./drivers/regulator/da9211-regulator.c:394:		if (IS_ERR(chip->rdev[i])) {
./drivers/regulator/da9211-regulator.c:395:			dev_err(chip->dev,
./drivers/regulator/da9211-regulator.c:397:			return PTR_ERR(chip->rdev[i]);
./drivers/regulator/da9211-regulator.c:400:		if (chip->chip_irq != 0) {
./drivers/regulator/da9211-regulator.c:401:			ret = regmap_update_bits(chip->regmap,
./drivers/regulator/da9211-regulator.c:404:				dev_err(chip->dev,
./drivers/regulator/da9211-regulator.c:428:	chip->dev = &i2c->dev;
./drivers/regulator/da9211-regulator.c:429:	chip->regmap = devm_regmap_init_i2c(i2c, &da9211_regmap_config);
./drivers/regulator/da9211-regulator.c:430:	if (IS_ERR(chip->regmap)) {
./drivers/regulator/da9211-regulator.c:431:		error = PTR_ERR(chip->regmap);
./drivers/regulator/da9211-regulator.c:432:		dev_err(chip->dev, "Failed to allocate register map: %d\n",
./drivers/regulator/da9211-regulator.c:439:	chip->pdata = i2c->dev.platform_data;
./drivers/regulator/da9211-regulator.c:441:	ret = regmap_read(chip->regmap, DA9211_REG_DEVICE_ID, &data);
./drivers/regulator/da9211-regulator.c:443:		dev_err(chip->dev, "Failed to read DEVICE_ID reg: %d\n", ret);
./drivers/regulator/da9211-regulator.c:449:		chip->chip_id = DA9211;
./drivers/regulator/da9211-regulator.c:452:		chip->chip_id = DA9213;
./drivers/regulator/da9211-regulator.c:455:		chip->chip_id = DA9215;
./drivers/regulator/da9211-regulator.c:458:		dev_err(chip->dev, "Unsupported device id = 0x%x.\n", data);
./drivers/regulator/da9211-regulator.c:462:	if (!chip->pdata)
./drivers/regulator/da9211-regulator.c:463:		chip->pdata = da9211_parse_regulators_dt(chip->dev);
./drivers/regulator/da9211-regulator.c:465:	if (IS_ERR(chip->pdata)) {
./drivers/regulator/da9211-regulator.c:466:		dev_err(chip->dev, "No regulators defined for the platform\n");
./drivers/regulator/da9211-regulator.c:467:		return PTR_ERR(chip->pdata);
./drivers/regulator/da9211-regulator.c:470:	chip->chip_irq = i2c->irq;
./drivers/regulator/da9211-regulator.c:472:	if (chip->chip_irq != 0) {
./drivers/regulator/da9211-regulator.c:473:		ret = devm_request_threaded_irq(chip->dev, chip->chip_irq, NULL,
./drivers/regulator/da9211-regulator.c:478:			dev_err(chip->dev, "Failed to request IRQ: %d\n",
./drivers/regulator/da9211-regulator.c:479:				chip->chip_irq);
./drivers/regulator/da9211-regulator.c:483:		dev_warn(chip->dev, "No IRQ configured\n");
./drivers/regulator/da9211-regulator.c:489:		dev_err(chip->dev, "Failed to initialize regulator: %d\n", ret);
./drivers/regulator/da9062-regulator.c:756:					chip->regmap,
./drivers/regulator/da9062-regulator.c:761:					chip->regmap,
./drivers/regulator/da9062-regulator.c:766:					chip->regmap,
./drivers/regulator/da9062-regulator.c:771:					chip->regmap,
./drivers/regulator/da9062-regulator.c:776:					chip->regmap,
./drivers/regulator/da9062-regulator.c:781:		config.dev = chip->dev;
./drivers/regulator/da9062-regulator.c:783:		config.regmap = chip->regmap;
./drivers/regulator/ad5398.c:34:	unsigned range_uA = chip->max_uA - chip->min_uA;
./drivers/regulator/ad5398.c:36:	return chip->min_uA + (selector * range_uA / chip->current_level);
./drivers/regulator/ad5398.c:72:	struct i2c_client *client = chip->client;
./drivers/regulator/ad5398.c:80:	ret = (data & chip->current_mask) >> chip->current_offset;
./drivers/regulator/ad5398.c:88:	struct i2c_client *client = chip->client;
./drivers/regulator/ad5398.c:89:	unsigned range_uA = chip->max_uA - chip->min_uA;
./drivers/regulator/ad5398.c:94:	if (min_uA < chip->min_uA)
./drivers/regulator/ad5398.c:95:		min_uA = chip->min_uA;
./drivers/regulator/ad5398.c:96:	if (max_uA > chip->max_uA)
./drivers/regulator/ad5398.c:97:		max_uA = chip->max_uA;
./drivers/regulator/ad5398.c:99:	if (min_uA > chip->max_uA || max_uA < chip->min_uA)
./drivers/regulator/ad5398.c:102:	selector = DIV_ROUND_UP((min_uA - chip->min_uA) * chip->current_level,
./drivers/regulator/ad5398.c:116:	selector = (selector << chip->current_offset) & chip->current_mask;
./drivers/regulator/ad5398.c:128:	struct i2c_client *client = chip->client;
./drivers/regulator/ad5398.c:145:	struct i2c_client *client = chip->client;
./drivers/regulator/ad5398.c:166:	struct i2c_client *client = chip->client;
./drivers/regulator/ad5398.c:236:	chip->client = client;
./drivers/regulator/ad5398.c:238:	chip->min_uA = df->min_uA;
./drivers/regulator/ad5398.c:239:	chip->max_uA = df->max_uA;
./drivers/regulator/ad5398.c:240:	chip->current_level = 1 << df->current_bits;
./drivers/regulator/ad5398.c:241:	chip->current_offset = df->current_offset;
./drivers/regulator/ad5398.c:242:	chip->current_mask = (chip->current_level - 1) << chip->current_offset;
./drivers/regulator/ad5398.c:244:	chip->rdev = devm_regulator_register(&client->dev, &ad5398_reg,
./drivers/regulator/ad5398.c:246:	if (IS_ERR(chip->rdev)) {
./drivers/regulator/ad5398.c:249:		return PTR_ERR(chip->rdev);
./drivers/regulator/lp8755.c:65:	return regmap_read(pchip->regmap, reg, val);
./drivers/regulator/lp8755.c:77:	return regmap_write(pchip->regmap, reg, val);
./drivers/regulator/lp8755.c:90:	return regmap_update_bits(pchip->regmap, reg, mask, val);
./drivers/regulator/lp8755.c:102:		dev_err(pchip->dev, "i2c acceess error %s\n", __func__);
./drivers/regulator/lp8755.c:137:		dev_err(pchip->dev, "Not supported buck mode %s\n", __func__);
./drivers/regulator/lp8755.c:147:	dev_err(pchip->dev, "i2c acceess error %s\n", __func__);
./drivers/regulator/lp8755.c:178:	dev_err(pchip->dev, "i2c acceess error %s\n", __func__);
./drivers/regulator/lp8755.c:216:		dev_err(pchip->dev,
./drivers/regulator/lp8755.c:226:	dev_err(pchip->dev, "i2c acceess error %s\n", __func__);
./drivers/regulator/lp8755.c:282:	struct lp8755_platform_data *pdata = pchip->pdata;
./drivers/regulator/lp8755.c:288:	pchip->mphase = regval & 0x0F;
./drivers/regulator/lp8755.c:291:	for (icnt = 0; icnt < mphase_buck[pchip->mphase].nreg; icnt++) {
./drivers/regulator/lp8755.c:292:		buck_num = mphase_buck[pchip->mphase].buck_num[icnt];
./drivers/regulator/lp8755.c:298:	dev_err(pchip->dev, "i2c acceess error %s\n", __func__);
./drivers/regulator/lp8755.c:330:	struct lp8755_platform_data *pdata = pchip->pdata;
./drivers/regulator/lp8755.c:333:	rconfig.regmap = pchip->regmap;
./drivers/regulator/lp8755.c:334:	rconfig.dev = pchip->dev;
./drivers/regulator/lp8755.c:337:	for (icnt = 0; icnt < mphase_buck[pchip->mphase].nreg; icnt++) {
./drivers/regulator/lp8755.c:338:		buck_num = mphase_buck[pchip->mphase].buck_num[icnt];
./drivers/regulator/lp8755.c:340:		rconfig.of_node = pchip->dev->of_node;
./drivers/regulator/lp8755.c:341:		pchip->rdev[buck_num] =
./drivers/regulator/lp8755.c:342:		    devm_regulator_register(pchip->dev,
./drivers/regulator/lp8755.c:344:		if (IS_ERR(pchip->rdev[buck_num])) {
./drivers/regulator/lp8755.c:345:			ret = PTR_ERR(pchip->rdev[buck_num]);
./drivers/regulator/lp8755.c:346:			pchip->rdev[buck_num] = NULL;
./drivers/regulator/lp8755.c:347:			dev_err(pchip->dev, "regulator init failed: buck %d\n",
./drivers/regulator/lp8755.c:374:		    && (pchip->irqmask & (0x04 << icnt))
./drivers/regulator/lp8755.c:375:		    && (pchip->rdev[icnt] != NULL))
./drivers/regulator/lp8755.c:376:			regulator_notifier_call_chain(pchip->rdev[icnt],
./drivers/regulator/lp8755.c:390:	if ((flag1 & 0x01) && (pchip->irqmask & 0x01))
./drivers/regulator/lp8755.c:392:			if (pchip->rdev[icnt] != NULL)
./drivers/regulator/lp8755.c:393:				regulator_notifier_call_chain(pchip->rdev[icnt],
./drivers/regulator/lp8755.c:398:	if ((flag1 & 0x02) && (pchip->irqmask & 0x02))
./drivers/regulator/lp8755.c:400:			if (pchip->rdev[icnt] != NULL)
./drivers/regulator/lp8755.c:401:				regulator_notifier_call_chain(pchip->rdev[icnt],
./drivers/regulator/lp8755.c:407:	dev_err(pchip->dev, "i2c acceess error %s\n", __func__);
./drivers/regulator/lp8755.c:416:	if (pchip->irq == 0) {
./drivers/regulator/lp8755.c:417:		dev_warn(pchip->dev, "not use interrupt : %s\n", __func__);
./drivers/regulator/lp8755.c:423:		dev_err(pchip->dev, "i2c acceess error %s\n", __func__);
./drivers/regulator/lp8755.c:427:	pchip->irqmask = regval;
./drivers/regulator/lp8755.c:428:	return devm_request_threaded_irq(pchip->dev, pchip->irq, NULL,
./drivers/regulator/lp8755.c:457:	pchip->dev = &client->dev;
./drivers/regulator/lp8755.c:458:	pchip->regmap = devm_regmap_init_i2c(client, &lp8755_regmap);
./drivers/regulator/lp8755.c:459:	if (IS_ERR(pchip->regmap)) {
./drivers/regulator/lp8755.c:460:		ret = PTR_ERR(pchip->regmap);
./drivers/regulator/lp8755.c:467:		pchip->pdata = pdata;
./drivers/regulator/lp8755.c:468:		pchip->mphase = pdata->mphase;
./drivers/regulator/lp8755.c:470:		pchip->pdata = devm_kzalloc(pchip->dev,
./drivers/regulator/lp8755.c:473:		if (!pchip->pdata)
./drivers/regulator/lp8755.c:488:	pchip->irq = client->irq;
./drivers/regulator/pfuze100-regulator.c:399:	struct device *dev = chip->dev;
./drivers/regulator/pfuze100-regulator.c:413:	switch (chip->chip_id) {
./drivers/regulator/pfuze100-regulator.c:474:	ret = regmap_read(pfuze_chip->regmap, PFUZE100_DEVICEID, &value);
./drivers/regulator/pfuze100-regulator.c:478:	if (((value & 0x0f) == 0x8) && (pfuze_chip->chip_id == PFUZE100)) {
./drivers/regulator/pfuze100-regulator.c:483:		dev_info(pfuze_chip->dev, "Assuming misprogrammed ID=0x8");
./drivers/regulator/pfuze100-regulator.c:484:	} else if ((value & 0x0f) != pfuze_chip->chip_id &&
./drivers/regulator/pfuze100-regulator.c:485:		   (value & 0xf0) >> 4 != pfuze_chip->chip_id) {
./drivers/regulator/pfuze100-regulator.c:487:		dev_warn(pfuze_chip->dev, "Illegal ID: %x\n", value);
./drivers/regulator/pfuze100-regulator.c:491:	ret = regmap_read(pfuze_chip->regmap, PFUZE100_REVID, &value);
./drivers/regulator/pfuze100-regulator.c:494:	dev_info(pfuze_chip->dev,
./drivers/regulator/pfuze100-regulator.c:498:	ret = regmap_read(pfuze_chip->regmap, PFUZE100_FABID, &value);
./drivers/regulator/pfuze100-regulator.c:501:	dev_info(pfuze_chip->dev, "FAB: %x, FIN: %x\n",
./drivers/regulator/pfuze100-regulator.c:538:		pfuze_chip->chip_id = (int)(long)match->data;
./drivers/regulator/pfuze100-regulator.c:540:		pfuze_chip->chip_id = id->driver_data;
./drivers/regulator/pfuze100-regulator.c:547:	pfuze_chip->dev = &client->dev;
./drivers/regulator/pfuze100-regulator.c:549:	pfuze_chip->regmap = devm_regmap_init_i2c(client, &pfuze_regmap_config);
./drivers/regulator/pfuze100-regulator.c:550:	if (IS_ERR(pfuze_chip->regmap)) {
./drivers/regulator/pfuze100-regulator.c:551:		ret = PTR_ERR(pfuze_chip->regmap);
./drivers/regulator/pfuze100-regulator.c:564:	switch (pfuze_chip->chip_id) {
./drivers/regulator/pfuze100-regulator.c:587:		(pfuze_chip->chip_id == PFUZE100) ? "100" :
./drivers/regulator/pfuze100-regulator.c:588:		((pfuze_chip->chip_id == PFUZE200) ? "200" : "3000"));
./drivers/regulator/pfuze100-regulator.c:590:	memcpy(pfuze_chip->regulator_descs, pfuze_regulators,
./drivers/regulator/pfuze100-regulator.c:591:		sizeof(pfuze_chip->regulator_descs));
./drivers/regulator/pfuze100-regulator.c:602:		desc = &pfuze_chip->regulator_descs[i].desc;
./drivers/regulator/pfuze100-regulator.c:611:			regmap_read(pfuze_chip->regmap, desc->vsel_reg, &val);
./drivers/regulator/pfuze100-regulator.c:613:				if (pfuze_chip->chip_id == PFUZE3000) {
./drivers/regulator/pfuze100-regulator.c:630:		pfuze_chip->regulators[i] =
./drivers/regulator/pfuze100-regulator.c:632:		if (IS_ERR(pfuze_chip->regulators[i])) {
./drivers/regulator/pfuze100-regulator.c:635:			return PTR_ERR(pfuze_chip->regulators[i]);
./drivers/regulator/max8973-regulator.c:483:	ret = regmap_read(mchip->regmap, MAX8973_CHIPID1, &val);
./drivers/regulator/max8973-regulator.c:485:		dev_err(mchip->dev, "Failed to read register CHIPID1, %d", ret);
./drivers/regulator/max8973-regulator.c:491:		*temp = mchip->junction_temp_warning + 1000;
./drivers/regulator/max8973-regulator.c:502:	thermal_zone_device_update(mchip->tz_device);
./drivers/regulator/max8973-regulator.c:518:	if (mchip->id != MAX77621)
./drivers/regulator/max8973-regulator.c:521:	tzd = devm_thermal_zone_of_sensor_register(mchip->dev, 0, mchip,
./drivers/regulator/max8973-regulator.c:525:		dev_err(mchip->dev, "Failed to register thermal sensor: %d\n",
./drivers/regulator/max8973-regulator.c:530:	if (mchip->irq <= 0)
./drivers/regulator/max8973-regulator.c:533:	irq_data = irq_get_irq_data(mchip->irq);
./drivers/regulator/max8973-regulator.c:537:	ret = devm_request_threaded_irq(mchip->dev, mchip->irq, NULL,
./drivers/regulator/max8973-regulator.c:540:					dev_name(mchip->dev), mchip);
./drivers/regulator/max8973-regulator.c:542:		dev_err(mchip->dev, "Failed to request irq %d, %d\n",
./drivers/regulator/max8973-regulator.c:543:			mchip->irq, ret);
./drivers/regulator/pv88060-regulator.c:275:	err = regmap_read(chip->regmap, PV88060_REG_EVENT_A, &reg_val);
./drivers/regulator/pv88060-regulator.c:281:			if (chip->rdev[i] != NULL) {
./drivers/regulator/pv88060-regulator.c:282:				regulator_notifier_call_chain(chip->rdev[i],
./drivers/regulator/pv88060-regulator.c:288:		err = regmap_write(chip->regmap, PV88060_REG_EVENT_A,
./drivers/regulator/pv88060-regulator.c:298:			if (chip->rdev[i] != NULL) {
./drivers/regulator/pv88060-regulator.c:299:				regulator_notifier_call_chain(chip->rdev[i],
./drivers/regulator/pv88060-regulator.c:305:		err = regmap_write(chip->regmap, PV88060_REG_EVENT_A,
./drivers/regulator/pv88060-regulator.c:316:	dev_err(chip->dev, "I2C error : %d\n", err);
./drivers/regulator/pv88060-regulator.c:335:	chip->dev = &i2c->dev;
./drivers/regulator/pv88060-regulator.c:336:	chip->regmap = devm_regmap_init_i2c(i2c, &pv88060_regmap_config);
./drivers/regulator/pv88060-regulator.c:337:	if (IS_ERR(chip->regmap)) {
./drivers/regulator/pv88060-regulator.c:338:		error = PTR_ERR(chip->regmap);
./drivers/regulator/pv88060-regulator.c:339:		dev_err(chip->dev, "Failed to allocate register map: %d\n",
./drivers/regulator/pv88060-regulator.c:347:		ret = regmap_write(chip->regmap, PV88060_REG_MASK_A, 0xFF);
./drivers/regulator/pv88060-regulator.c:349:			dev_err(chip->dev,
./drivers/regulator/pv88060-regulator.c:354:		ret = regmap_write(chip->regmap, PV88060_REG_MASK_B, 0xFF);
./drivers/regulator/pv88060-regulator.c:356:			dev_err(chip->dev,
./drivers/regulator/pv88060-regulator.c:361:		ret = regmap_write(chip->regmap, PV88060_REG_MASK_C, 0xFF);
./drivers/regulator/pv88060-regulator.c:363:			dev_err(chip->dev,
./drivers/regulator/pv88060-regulator.c:373:			dev_err(chip->dev, "Failed to request IRQ: %d\n",
./drivers/regulator/pv88060-regulator.c:378:		ret = regmap_update_bits(chip->regmap, PV88060_REG_MASK_A,
./drivers/regulator/pv88060-regulator.c:381:			dev_err(chip->dev,
./drivers/regulator/pv88060-regulator.c:387:		dev_warn(chip->dev, "No IRQ configured\n");
./drivers/regulator/pv88060-regulator.c:390:	config.dev = chip->dev;
./drivers/regulator/pv88060-regulator.c:391:	config.regmap = chip->regmap;
./drivers/regulator/pv88060-regulator.c:398:		chip->rdev[i] = devm_regulator_register(chip->dev,
./drivers/regulator/pv88060-regulator.c:400:		if (IS_ERR(chip->rdev[i])) {
./drivers/regulator/pv88060-regulator.c:401:			dev_err(chip->dev,
./drivers/regulator/pv88060-regulator.c:403:			return PTR_ERR(chip->rdev[i]);
./drivers/regulator/pv88080-regulator.c:233:	err = regmap_read(chip->regmap, PV88080_REG_EVENT_A, &reg_val);
./drivers/regulator/pv88080-regulator.c:239:			if (chip->rdev[i] != NULL) {
./drivers/regulator/pv88080-regulator.c:240:				regulator_notifier_call_chain(chip->rdev[i],
./drivers/regulator/pv88080-regulator.c:246:		err = regmap_write(chip->regmap, PV88080_REG_EVENT_A,
./drivers/regulator/pv88080-regulator.c:256:			if (chip->rdev[i] != NULL) {
./drivers/regulator/pv88080-regulator.c:257:				regulator_notifier_call_chain(chip->rdev[i],
./drivers/regulator/pv88080-regulator.c:263:		err = regmap_write(chip->regmap, PV88080_REG_EVENT_A,
./drivers/regulator/pv88080-regulator.c:274:	dev_err(chip->dev, "I2C error : %d\n", err);
./drivers/regulator/pv88080-regulator.c:294:	chip->dev = &i2c->dev;
./drivers/regulator/pv88080-regulator.c:295:	chip->regmap = devm_regmap_init_i2c(i2c, &pv88080_regmap_config);
./drivers/regulator/pv88080-regulator.c:296:	if (IS_ERR(chip->regmap)) {
./drivers/regulator/pv88080-regulator.c:297:		error = PTR_ERR(chip->regmap);
./drivers/regulator/pv88080-regulator.c:298:		dev_err(chip->dev, "Failed to allocate register map: %d\n",
./drivers/regulator/pv88080-regulator.c:306:		ret = regmap_write(chip->regmap, PV88080_REG_MASK_A, 0xFF);
./drivers/regulator/pv88080-regulator.c:308:			dev_err(chip->dev,
./drivers/regulator/pv88080-regulator.c:312:		ret = regmap_write(chip->regmap, PV88080_REG_MASK_B, 0xFF);
./drivers/regulator/pv88080-regulator.c:314:			dev_err(chip->dev,
./drivers/regulator/pv88080-regulator.c:318:		ret = regmap_write(chip->regmap, PV88080_REG_MASK_C, 0xFF);
./drivers/regulator/pv88080-regulator.c:320:			dev_err(chip->dev,
./drivers/regulator/pv88080-regulator.c:330:			dev_err(chip->dev, "Failed to request IRQ: %d\n",
./drivers/regulator/pv88080-regulator.c:335:		ret = regmap_update_bits(chip->regmap, PV88080_REG_MASK_A,
./drivers/regulator/pv88080-regulator.c:338:			dev_err(chip->dev,
./drivers/regulator/pv88080-regulator.c:344:		dev_warn(chip->dev, "No IRQ configured\n");
./drivers/regulator/pv88080-regulator.c:347:	config.dev = chip->dev;
./drivers/regulator/pv88080-regulator.c:348:	config.regmap = chip->regmap;
./drivers/regulator/pv88080-regulator.c:354:		ret = regmap_read(chip->regmap,
./drivers/regulator/pv88080-regulator.c:362:		ret = regmap_read(chip->regmap,
./drivers/regulator/pv88080-regulator.c:380:		chip->rdev[i] = devm_regulator_register(chip->dev,
./drivers/regulator/pv88080-regulator.c:382:		if (IS_ERR(chip->rdev[i])) {
./drivers/regulator/pv88080-regulator.c:383:			dev_err(chip->dev,
./drivers/regulator/pv88080-regulator.c:385:			return PTR_ERR(chip->rdev[i]);
./drivers/regulator/88pm8607.c:374:	info->i2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;
./drivers/regulator/88pm8607.c:375:	info->i2c_8606 = (chip->id == CHIP_PM8607) ? chip->companion :
./drivers/regulator/88pm8607.c:376:			chip->client;
./drivers/regulator/88pm8607.c:380:	if ((i == PM8607_ID_BUCK3) && info->chip->buck3_double)
./drivers/regulator/88pm8607.c:390:	if (chip->id == CHIP_PM8607)
./drivers/regulator/88pm8607.c:391:		config.regmap = chip->regmap;
./drivers/regulator/88pm8607.c:393:		config.regmap = chip->regmap_companion;
./drivers/regulator/88pm800.c:260:	pm800_data->map = chip->subchip->regmap_power;
./drivers/regulator/88pm800.c:265:	config.dev = chip->dev;
./drivers/regulator/max8925-regulator.c:304:	ri->i2c = chip->i2c;
./drivers/regulator/da9210-regulator.c:99:			return regmap_update_bits(chip->regmap,
./drivers/regulator/da9210-regulator.c:115:	ret = regmap_read(chip->regmap, DA9210_REG_BUCK_ILIM, &data);
./drivers/regulator/da9210-regulator.c:131:	error = regmap_read(chip->regmap, DA9210_REG_EVENT_B, &val);
./drivers/regulator/da9210-regulator.c:135:	mutex_lock(&chip->rdev->mutex);
./drivers/regulator/da9210-regulator.c:138:		regulator_notifier_call_chain(chip->rdev,
./drivers/regulator/da9210-regulator.c:144:		regulator_notifier_call_chain(chip->rdev,
./drivers/regulator/da9210-regulator.c:150:		regulator_notifier_call_chain(chip->rdev,
./drivers/regulator/da9210-regulator.c:155:		regulator_notifier_call_chain(chip->rdev,
./drivers/regulator/da9210-regulator.c:161:	mutex_unlock(&chip->rdev->mutex);
./drivers/regulator/da9210-regulator.c:165:		error = regmap_write(chip->regmap, DA9210_REG_EVENT_B, handled);
./drivers/regulator/da9210-regulator.c:175:	dev_err(regmap_get_device(chip->regmap), "I2C error : %d\n", error);
./drivers/regulator/da9210-regulator.c:196:	chip->regmap = devm_regmap_init_i2c(i2c, &da9210_regmap_config);
./drivers/regulator/da9210-regulator.c:197:	if (IS_ERR(chip->regmap)) {
./drivers/regulator/da9210-regulator.c:198:		error = PTR_ERR(chip->regmap);
./drivers/regulator/da9210-regulator.c:208:	config.regmap = chip->regmap;
./drivers/regulator/da9210-regulator.c:212:	error = regmap_write(chip->regmap, DA9210_REG_MASK_A, ~0);
./drivers/regulator/da9210-regulator.c:214:		error = regmap_write(chip->regmap, DA9210_REG_MASK_B, ~0);
./drivers/regulator/da9210-regulator.c:226:	chip->rdev = rdev;
./drivers/regulator/da9210-regulator.c:239:		error = regmap_update_bits(chip->regmap, DA9210_REG_MASK_B,
./drivers/leds/leds-is31fl32xx.c:55: * struct is31fl32xx_chipdef - chip-specific attributes
./drivers/leds/leds-lp5523.c:170:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp5523.c:190:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp5523.c:210:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp5523.c:306:		chip->engine_idx = i;
./drivers/leds/leds-lp5523.c:325:		dev_err(&chip->cl->dev,
./drivers/leds/leds-lp5523.c:375:	dev_err(&chip->cl->dev, "wrong pattern format\n");
./drivers/leds/leds-lp5523.c:381:	const struct firmware *fw = chip->fw;
./drivers/leds/leds-lp5523.c:384:		dev_err(&chip->cl->dev, "firmware data size overflow: %zu\n",
./drivers/leds/leds-lp5523.c:405:	enum lp55xx_engine_mode mode = chip->engines[nr - 1].mode;
./drivers/leds/leds-lp5523.c:427:	struct lp55xx_engine *engine = &chip->engines[nr - 1];
./drivers/leds/leds-lp5523.c:429:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5523.c:431:	chip->engine_idx = nr;
./drivers/leds/leds-lp5523.c:445:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5523.c:496:	lp5523_mux_to_array(chip->engines[nr - 1].led_mux, mux);
./drivers/leds/leds-lp5523.c:506:	struct lp55xx_engine *engine = &chip->engines[nr - 1];
./drivers/leds/leds-lp5523.c:538:	struct lp55xx_engine *engine = &chip->engines[nr - 1];
./drivers/leds/leds-lp5523.c:545:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5523.c:547:	chip->engine_idx = nr;
./drivers/leds/leds-lp5523.c:558:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5523.c:573:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5523.c:575:	chip->engine_idx = nr;
./drivers/leds/leds-lp5523.c:579:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5523.c:593:	struct lp55xx_platform_data *pdata = chip->pdata;
./drivers/leds/leds-lp5523.c:597:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5523.c:669:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5523.c:699:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5523.c:701:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5523.c:727:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5523.c:730:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5523.c:750:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5523.c:768:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5523.c:783:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5523.c:801:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5523.c:810:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5523.c:813:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5523.c:906:	chip->cl = client;
./drivers/leds/leds-lp5523.c:907:	chip->pdata = pdata;
./drivers/leds/leds-lp5523.c:908:	chip->cfg = &lp5523_cfg;
./drivers/leds/leds-lp5523.c:910:	mutex_init(&chip->lock);
./drivers/leds/leds-pca963x.c:119:	u8 ledout_addr = pca963x->chip->chipdef->ledout_base
./drivers/leds/leds-pca963x.c:126:	mutex_lock(&pca963x->chip->mutex);
./drivers/leds/leds-pca963x.c:127:	ledout = i2c_smbus_read_byte_data(pca963x->chip->client, ledout_addr);
./drivers/leds/leds-pca963x.c:130:		ret = i2c_smbus_write_byte_data(pca963x->chip->client,
./drivers/leds/leds-pca963x.c:135:		ret = i2c_smbus_write_byte_data(pca963x->chip->client,
./drivers/leds/leds-pca963x.c:139:		ret = i2c_smbus_write_byte_data(pca963x->chip->client,
./drivers/leds/leds-pca963x.c:144:		ret = i2c_smbus_write_byte_data(pca963x->chip->client,
./drivers/leds/leds-pca963x.c:150:	mutex_unlock(&pca963x->chip->mutex);
./drivers/leds/leds-pca963x.c:156:	u8 ledout_addr = pca963x->chip->chipdef->ledout_base +
./drivers/leds/leds-pca963x.c:159:	u8 mode2 = i2c_smbus_read_byte_data(pca963x->chip->client,
./drivers/leds/leds-pca963x.c:164:	i2c_smbus_write_byte_data(pca963x->chip->client,
./drivers/leds/leds-pca963x.c:165:			pca963x->chip->chipdef->grppwm,	pca963x->gdc);
./drivers/leds/leds-pca963x.c:167:	i2c_smbus_write_byte_data(pca963x->chip->client,
./drivers/leds/leds-pca963x.c:168:			pca963x->chip->chipdef->grpfreq, pca963x->gfrq);
./drivers/leds/leds-pca963x.c:171:		i2c_smbus_write_byte_data(pca963x->chip->client, PCA963X_MODE2,
./drivers/leds/leds-pca963x.c:174:	mutex_lock(&pca963x->chip->mutex);
./drivers/leds/leds-pca963x.c:175:	ledout = i2c_smbus_read_byte_data(pca963x->chip->client, ledout_addr);
./drivers/leds/leds-pca963x.c:177:		i2c_smbus_write_byte_data(pca963x->chip->client, ledout_addr,
./drivers/leds/leds-pca963x.c:179:	mutex_unlock(&pca963x->chip->mutex);
./drivers/leds/leds-pca963x.c:255:	if (!count || count > chip->n_leds)
./drivers/leds/leds-pca963x.c:259:			sizeof(struct led_info) * chip->n_leds, GFP_KERNEL);
./drivers/leds/leds-pca963x.c:269:		if ((res != 0) || (reg >= chip->n_leds))
./drivers/leds/leds-pca963x.c:283:	pdata->leds.num_leds = chip->n_leds;
./drivers/leds/leds-pca963x.c:337:				 pdata->leds.num_leds > chip->n_leds)) {
./drivers/leds/leds-pca963x.c:339:								chip->n_leds);
./drivers/leds/leds-pca963x.c:347:	pca963x = devm_kzalloc(&client->dev, chip->n_leds * sizeof(*pca963x),
./drivers/leds/leds-pca963x.c:354:	mutex_init(&pca963x_chip->mutex);
./drivers/leds/leds-pca963x.c:355:	pca963x_chip->chipdef = chip;
./drivers/leds/leds-pca963x.c:356:	pca963x_chip->client = client;
./drivers/leds/leds-pca963x.c:357:	pca963x_chip->leds = pca963x;
./drivers/leds/leds-pca963x.c:360:	for (i = 0; i < chip->n_leds / 4; i++)
./drivers/leds/leds-pca963x.c:361:		i2c_smbus_write_byte_data(client, chip->ledout_base + i, 0x00);
./drivers/leds/leds-pca963x.c:363:	for (i = 0; i < chip->n_leds; i++) {
./drivers/leds/leds-lp55xx-common.c:43:	struct lp55xx_device_config *cfg = chip->cfg;
./drivers/leds/leds-lp55xx-common.c:53:	struct lp55xx_device_config *cfg = chip->cfg;
./drivers/leds/leds-lp55xx-common.c:76:	struct lp55xx_device_config *cfg = chip->cfg;
./drivers/leds/leds-lp55xx-common.c:107:	if (!chip->cfg->set_led_current)
./drivers/leds/leds-lp55xx-common.c:110:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp55xx-common.c:111:	chip->cfg->set_led_current(led, (u8)curr);
./drivers/leds/leds-lp55xx-common.c:112:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp55xx-common.c:141:	struct lp55xx_device_config *cfg = led->chip->cfg;
./drivers/leds/leds-lp55xx-common.c:150:	struct lp55xx_platform_data *pdata = chip->pdata;
./drivers/leds/leds-lp55xx-common.c:151:	struct lp55xx_device_config *cfg = chip->cfg;
./drivers/leds/leds-lp55xx-common.c:152:	struct device *dev = &chip->cl->dev;
./drivers/leds/leds-lp55xx-common.c:183:			pdata->label ? : chip->cl->name, chan);
./drivers/leds/leds-lp55xx-common.c:199:	struct device *dev = &chip->cl->dev;
./drivers/leds/leds-lp55xx-common.c:200:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp55xx-common.c:208:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp55xx-common.c:210:	chip->engines[idx - 1].mode = LP55XX_ENGINE_LOAD;
./drivers/leds/leds-lp55xx-common.c:211:	chip->fw = fw;
./drivers/leds/leds-lp55xx-common.c:212:	if (chip->cfg->firmware_cb)
./drivers/leds/leds-lp55xx-common.c:213:		chip->cfg->firmware_cb(chip);
./drivers/leds/leds-lp55xx-common.c:215:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp55xx-common.c:219:	release_firmware(chip->fw);
./drivers/leds/leds-lp55xx-common.c:224:	const char *name = chip->cl->name;
./drivers/leds/leds-lp55xx-common.c:225:	struct device *dev = &chip->cl->dev;
./drivers/leds/leds-lp55xx-common.c:238:	return sprintf(buf, "%d\n", chip->engine_idx);
./drivers/leds/leds-lp55xx-common.c:259:		mutex_lock(&chip->lock);
./drivers/leds/leds-lp55xx-common.c:260:		chip->engine_idx = val;
./drivers/leds/leds-lp55xx-common.c:262:		mutex_unlock(&chip->lock);
./drivers/leds/leds-lp55xx-common.c:279:	if (chip->cfg->run_engine)
./drivers/leds/leds-lp55xx-common.c:280:		chip->cfg->run_engine(chip, start);
./drivers/leds/leds-lp55xx-common.c:301:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp55xx-common.c:303:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp55xx-common.c:324:	return i2c_smbus_write_byte_data(chip->cl, reg, val);
./drivers/leds/leds-lp55xx-common.c:332:	ret = i2c_smbus_read_byte_data(chip->cl, reg);
./drivers/leds/leds-lp55xx-common.c:362:	clk = devm_clk_get(&chip->cl->dev, "32k_clk");
./drivers/leds/leds-lp55xx-common.c:375:	dev_info(&chip->cl->dev, "%dHz external clock used\n",	LP55XX_CLK_32K);
./drivers/leds/leds-lp55xx-common.c:377:	chip->clk = clk;
./drivers/leds/leds-lp55xx-common.c:381:	dev_info(&chip->cl->dev, "internal clock used\n");
./drivers/leds/leds-lp55xx-common.c:390:	struct device *dev = &chip->cl->dev;
./drivers/leds/leds-lp55xx-common.c:395:	pdata = chip->pdata;
./drivers/leds/leds-lp55xx-common.c:396:	cfg = chip->cfg;
./drivers/leds/leds-lp55xx-common.c:448:	struct lp55xx_platform_data *pdata = chip->pdata;
./drivers/leds/leds-lp55xx-common.c:450:	if (chip->clk)
./drivers/leds/leds-lp55xx-common.c:451:		clk_disable_unprepare(chip->clk);
./drivers/leds/leds-lp55xx-common.c:460:	struct lp55xx_platform_data *pdata = chip->pdata;
./drivers/leds/leds-lp55xx-common.c:461:	struct lp55xx_device_config *cfg = chip->cfg;
./drivers/leds/leds-lp55xx-common.c:469:		dev_err(&chip->cl->dev, "empty brightness configuration\n");
./drivers/leds/leds-lp55xx-common.c:485:		chip->num_leds++;
./drivers/leds/leds-lp55xx-common.c:506:	for (i = 0; i < chip->num_leds; i++) {
./drivers/leds/leds-lp55xx-common.c:515:	struct device *dev = &chip->cl->dev;
./drivers/leds/leds-lp55xx-common.c:516:	struct lp55xx_device_config *cfg = chip->cfg;
./drivers/leds/leds-lp55xx-common.c:534:	struct device *dev = &chip->cl->dev;
./drivers/leds/leds-lp55xx-common.c:535:	struct lp55xx_device_config *cfg = chip->cfg;
./drivers/leds/leds-lm3642.c:94:	struct lm3642_platform_data *pdata = chip->pdata;
./drivers/leds/leds-lm3642.c:97:	ret = regmap_update_bits(chip->regmap, REG_ENABLE, EX_PIN_ENABLE_MASK,
./drivers/leds/leds-lm3642.c:100:		dev_err(chip->dev, "Failed to update REG_ENABLE Register\n");
./drivers/leds/leds-lm3642.c:110:	ret = regmap_read(chip->regmap, REG_FLAG, &chip->last_flag);
./drivers/leds/leds-lm3642.c:112:		dev_err(chip->dev, "Failed to read REG_FLAG Register\n");
./drivers/leds/leds-lm3642.c:116:	if (chip->last_flag)
./drivers/leds/leds-lm3642.c:117:		dev_info(chip->dev, "Last FLAG is 0x%x\n", chip->last_flag);
./drivers/leds/leds-lm3642.c:125:		ret = regmap_update_bits(chip->regmap, REG_I_CTRL,
./drivers/leds/leds-lm3642.c:129:		if (chip->torch_pin)
./drivers/leds/leds-lm3642.c:134:		ret = regmap_update_bits(chip->regmap, REG_I_CTRL,
./drivers/leds/leds-lm3642.c:138:		if (chip->strobe_pin)
./drivers/leds/leds-lm3642.c:143:		ret = regmap_update_bits(chip->regmap, REG_I_CTRL,
./drivers/leds/leds-lm3642.c:156:		dev_err(chip->dev, "Failed to write REG_I_CTRL Register\n");
./drivers/leds/leds-lm3642.c:160:	if (chip->tx_pin)
./drivers/leds/leds-lm3642.c:163:	ret = regmap_update_bits(chip->regmap, REG_ENABLE,
./drivers/leds/leds-lm3642.c:189:	chip->torch_pin = state;
./drivers/leds/leds-lm3642.c:190:	ret = regmap_update_bits(chip->regmap, REG_ENABLE,
./drivers/leds/leds-lm3642.c:198:	dev_err(chip->dev, "%s:i2c access fail to register\n", __func__);
./drivers/leds/leds-lm3642.c:201:	dev_err(chip->dev, "%s: fail to change str to int\n", __func__);
./drivers/leds/leds-lm3642.c:214:	mutex_lock(&chip->lock);
./drivers/leds/leds-lm3642.c:215:	chip->br_torch = brightness;
./drivers/leds/leds-lm3642.c:216:	ret = lm3642_control(chip, chip->br_torch, MODES_TORCH);
./drivers/leds/leds-lm3642.c:217:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lm3642.c:240:	chip->strobe_pin = state;
./drivers/leds/leds-lm3642.c:241:	ret = regmap_update_bits(chip->regmap, REG_ENABLE,
./drivers/leds/leds-lm3642.c:249:	dev_err(chip->dev, "%s:i2c access fail to register\n", __func__);
./drivers/leds/leds-lm3642.c:252:	dev_err(chip->dev, "%s: fail to change str to int\n", __func__);
./drivers/leds/leds-lm3642.c:265:	mutex_lock(&chip->lock);
./drivers/leds/leds-lm3642.c:266:	chip->br_flash = brightness;
./drivers/leds/leds-lm3642.c:267:	ret = lm3642_control(chip, chip->br_flash, MODES_FLASH);
./drivers/leds/leds-lm3642.c:268:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lm3642.c:280:	mutex_lock(&chip->lock);
./drivers/leds/leds-lm3642.c:281:	chip->br_indicator = brightness;
./drivers/leds/leds-lm3642.c:282:	ret = lm3642_control(chip, chip->br_indicator, MODES_INDIC);
./drivers/leds/leds-lm3642.c:283:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lm3642.c:328:	chip->dev = &client->dev;
./drivers/leds/leds-lm3642.c:329:	chip->pdata = pdata;
./drivers/leds/leds-lm3642.c:331:	chip->tx_pin = pdata->tx_pin;
./drivers/leds/leds-lm3642.c:332:	chip->torch_pin = pdata->torch_pin;
./drivers/leds/leds-lm3642.c:333:	chip->strobe_pin = pdata->strobe_pin;
./drivers/leds/leds-lm3642.c:335:	chip->regmap = devm_regmap_init_i2c(client, &lm3642_regmap);
./drivers/leds/leds-lm3642.c:336:	if (IS_ERR(chip->regmap)) {
./drivers/leds/leds-lm3642.c:337:		err = PTR_ERR(chip->regmap);
./drivers/leds/leds-lm3642.c:343:	mutex_init(&chip->lock);
./drivers/leds/leds-lm3642.c:351:	chip->cdev_flash.name = "flash";
./drivers/leds/leds-lm3642.c:352:	chip->cdev_flash.max_brightness = 16;
./drivers/leds/leds-lm3642.c:353:	chip->cdev_flash.brightness_set_blocking = lm3642_strobe_brightness_set;
./drivers/leds/leds-lm3642.c:354:	chip->cdev_flash.default_trigger = "flash";
./drivers/leds/leds-lm3642.c:355:	chip->cdev_flash.groups = lm3642_flash_groups,
./drivers/leds/leds-lm3642.c:357:				    &client->dev, &chip->cdev_flash);
./drivers/leds/leds-lm3642.c:359:		dev_err(chip->dev, "failed to register flash\n");
./drivers/leds/leds-lm3642.c:364:	chip->cdev_torch.name = "torch";
./drivers/leds/leds-lm3642.c:365:	chip->cdev_torch.max_brightness = 8;
./drivers/leds/leds-lm3642.c:366:	chip->cdev_torch.brightness_set_blocking = lm3642_torch_brightness_set;
./drivers/leds/leds-lm3642.c:367:	chip->cdev_torch.default_trigger = "torch";
./drivers/leds/leds-lm3642.c:368:	chip->cdev_torch.groups = lm3642_torch_groups,
./drivers/leds/leds-lm3642.c:370:				    &client->dev, &chip->cdev_torch);
./drivers/leds/leds-lm3642.c:372:		dev_err(chip->dev, "failed to register torch\n");
./drivers/leds/leds-lm3642.c:377:	chip->cdev_indicator.name = "indicator";
./drivers/leds/leds-lm3642.c:378:	chip->cdev_indicator.max_brightness = 8;
./drivers/leds/leds-lm3642.c:379:	chip->cdev_indicator.brightness_set_blocking =
./drivers/leds/leds-lm3642.c:382:				    &client->dev, &chip->cdev_indicator);
./drivers/leds/leds-lm3642.c:384:		dev_err(chip->dev, "failed to register indicator\n");
./drivers/leds/leds-lm3642.c:392:	led_classdev_unregister(&chip->cdev_torch);
./drivers/leds/leds-lm3642.c:394:	led_classdev_unregister(&chip->cdev_flash);
./drivers/leds/leds-lm3642.c:403:	led_classdev_unregister(&chip->cdev_indicator);
./drivers/leds/leds-lm3642.c:404:	led_classdev_unregister(&chip->cdev_torch);
./drivers/leds/leds-lm3642.c:405:	led_classdev_unregister(&chip->cdev_flash);
./drivers/leds/leds-lm3642.c:406:	regmap_write(chip->regmap, REG_ENABLE, 0);
./drivers/leds/leds-lp5521.c:136:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp5521.c:162:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp5521.c:227:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp5521.c:269:	dev_err(&chip->cl->dev, "wrong pattern format\n");
./drivers/leds/leds-lp5521.c:275:	const struct firmware *fw = chip->fw;
./drivers/leds/leds-lp5521.c:278:		dev_err(&chip->cl->dev, "firmware data size overflow: %zu\n",
./drivers/leds/leds-lp5521.c:306:		dev_err(&chip->cl->dev, "error in resetting chip\n");
./drivers/leds/leds-lp5521.c:310:		dev_err(&chip->cl->dev,
./drivers/leds/leds-lp5521.c:347:	struct lp55xx_platform_data *pdata = chip->pdata;
./drivers/leds/leds-lp5521.c:370:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5521.c:373:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5521.c:384:	enum lp55xx_engine_mode mode = chip->engines[nr - 1].mode;
./drivers/leds/leds-lp5521.c:406:	struct lp55xx_engine *engine = &chip->engines[nr - 1];
./drivers/leds/leds-lp5521.c:408:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5521.c:410:	chip->engine_idx = nr;
./drivers/leds/leds-lp5521.c:424:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5521.c:440:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5521.c:442:	chip->engine_idx = nr;
./drivers/leds/leds-lp5521.c:446:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5521.c:462:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5521.c:464:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5521.c:541:	chip->cl = client;
./drivers/leds/leds-lp5521.c:542:	chip->pdata = pdata;
./drivers/leds/leds-lp5521.c:543:	chip->cfg = &lp5521_cfg;
./drivers/leds/leds-lp5521.c:545:	mutex_init(&chip->lock);
./drivers/leds/leds-lp8501.c:106:	if (chip->pdata->clock_mode != LP55XX_CLOCK_EXT)
./drivers/leds/leds-lp8501.c:115:				LP8501_PWR_CONFIG_M, chip->pdata->pwr_sel);
./drivers/leds/leds-lp8501.c:120:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp8501.c:251:	dev_err(&chip->cl->dev, "wrong pattern format\n");
./drivers/leds/leds-lp8501.c:257:	const struct firmware *fw = chip->fw;
./drivers/leds/leds-lp8501.c:260:		dev_err(&chip->cl->dev, "firmware data size overflow: %zu\n",
./drivers/leds/leds-lp8501.c:280:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp8501.c:283:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp8501.c:335:	chip->cl = client;
./drivers/leds/leds-lp8501.c:336:	chip->pdata = pdata;
./drivers/leds/leds-lp8501.c:337:	chip->cfg = &lp8501_cfg;
./drivers/leds/leds-lp8501.c:339:	mutex_init(&chip->lock);
./drivers/leds/leds-88pm860x.c:111:	dev_dbg(chip->dev, "Update LED. (reg:%d, brightness:%d)\n",
./drivers/leds/leds-88pm860x.c:199:	data->i2c = (chip->id == CHIP_PM8606) ? chip->client : chip->companion;
./drivers/leds/leds-88pm860x.c:210:	ret = devm_led_classdev_register(chip->dev, &data->cdev);
./drivers/leds/leds-pca955x.c:258:	if ((client->addr & ~((1 << chip->slv_addr_shift) - 1)) !=
./drivers/leds/leds-pca955x.c:259:	    chip->slv_addr) {
./drivers/leds/leds-pca955x.c:267:			id->name, chip->bits, client->addr);
./drivers/leds/leds-pca955x.c:273:		if (pdata->num_leds != chip->bits) {
./drivers/leds/leds-pca955x.c:276:					pdata->num_leds, chip->bits);
./drivers/leds/leds-pca955x.c:286:			sizeof(*pca955x_led) * chip->bits, GFP_KERNEL);
./drivers/leds/leds-pca955x.c:296:	for (i = 0; i < chip->bits; i++) {
./drivers/leds/leds-pca955x.c:325:	for (i = 0; i < pca95xx_num_led_regs(chip->bits); i++)
./drivers/leds/leds-lm355x.c:166:	struct lm355x_platform_data *pdata = chip->pdata;
./drivers/leds/leds-lm355x.c:169:	switch (chip->type) {
./drivers/leds/leds-lm355x.c:172:		ret = regmap_update_bits(chip->regmap, 0xE0, 0x28, reg_val);
./drivers/leds/leds-lm355x.c:176:		ret = regmap_update_bits(chip->regmap, 0xA0, 0x04, reg_val);
./drivers/leds/leds-lm355x.c:183:		ret = regmap_update_bits(chip->regmap, 0x0A, 0xC4, reg_val);
./drivers/leds/leds-lm355x.c:193:	dev_err(chip->dev, "%s:i2c access fail to register\n", __func__);
./drivers/leds/leds-lm355x.c:203:	struct lm355x_platform_data *pdata = chip->pdata;
./drivers/leds/leds-lm355x.c:204:	struct lm355x_reg_data *preg = chip->regs;
./drivers/leds/leds-lm355x.c:206:	ret = regmap_read(chip->regmap, preg[REG_FLAG].regno, &chip->last_flag);
./drivers/leds/leds-lm355x.c:209:	if (chip->last_flag & preg[REG_FLAG].mask)
./drivers/leds/leds-lm355x.c:210:		dev_info(chip->dev, "%s Last FLAG is 0x%x\n",
./drivers/leds/leds-lm355x.c:211:			 lm355x_name[chip->type],
./drivers/leds/leds-lm355x.c:212:			 chip->last_flag & preg[REG_FLAG].mask);
./drivers/leds/leds-lm355x.c:220:		    regmap_update_bits(chip->regmap, preg[REG_TORCH_CTRL].regno,
./drivers/leds/leds-lm355x.c:229:			    regmap_update_bits(chip->regmap,
./drivers/leds/leds-lm355x.c:237:			dev_info(chip->dev,
./drivers/leds/leds-lm355x.c:245:		    regmap_update_bits(chip->regmap, preg[REG_FLASH_CTRL].regno,
./drivers/leds/leds-lm355x.c:253:			if (chip->type == CHIP_LM3554)
./drivers/leds/leds-lm355x.c:258:			    regmap_update_bits(chip->regmap,
./drivers/leds/leds-lm355x.c:266:			dev_info(chip->dev,
./drivers/leds/leds-lm355x.c:273:		    regmap_update_bits(chip->regmap, preg[REG_INDI_CTRL].regno,
./drivers/leds/leds-lm355x.c:282:			    regmap_update_bits(chip->regmap,
./drivers/leds/leds-lm355x.c:298:	ret = regmap_update_bits(chip->regmap, preg[REG_OPMODE].regno,
./drivers/leds/leds-lm355x.c:305:	dev_err(chip->dev, "%s:i2c access fail to register\n", __func__);
./drivers/leds/leds-lm355x.c:318:	mutex_lock(&chip->lock);
./drivers/leds/leds-lm355x.c:320:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lm355x.c:333:	mutex_lock(&chip->lock);
./drivers/leds/leds-lm355x.c:335:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lm355x.c:348:	mutex_lock(&chip->lock);
./drivers/leds/leds-lm355x.c:350:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lm355x.c:371:	ret = regmap_write(chip->regmap, 0x04,
./drivers/leds/leds-lm355x.c:376:	ret = regmap_write(chip->regmap, 0x05,
./drivers/leds/leds-lm355x.c:383:	dev_err(chip->dev, "%s:i2c access fail to register\n", __func__);
./drivers/leds/leds-lm355x.c:425:	chip->dev = &client->dev;
./drivers/leds/leds-lm355x.c:426:	chip->type = id->driver_data;
./drivers/leds/leds-lm355x.c:429:		chip->regs = lm3554_regs;
./drivers/leds/leds-lm355x.c:432:		chip->regs = lm3556_regs;
./drivers/leds/leds-lm355x.c:437:	chip->pdata = pdata;
./drivers/leds/leds-lm355x.c:439:	chip->regmap = devm_regmap_init_i2c(client, &lm355x_regmap);
./drivers/leds/leds-lm355x.c:440:	if (IS_ERR(chip->regmap)) {
./drivers/leds/leds-lm355x.c:441:		err = PTR_ERR(chip->regmap);
./drivers/leds/leds-lm355x.c:447:	mutex_init(&chip->lock);
./drivers/leds/leds-lm355x.c:455:	chip->cdev_flash.name = "flash";
./drivers/leds/leds-lm355x.c:456:	chip->cdev_flash.max_brightness = 16;
./drivers/leds/leds-lm355x.c:457:	chip->cdev_flash.brightness_set_blocking = lm355x_strobe_brightness_set;
./drivers/leds/leds-lm355x.c:458:	chip->cdev_flash.default_trigger = "flash";
./drivers/leds/leds-lm355x.c:460:				    &client->dev, &chip->cdev_flash);
./drivers/leds/leds-lm355x.c:464:	chip->cdev_torch.name = "torch";
./drivers/leds/leds-lm355x.c:465:	chip->cdev_torch.max_brightness = 8;
./drivers/leds/leds-lm355x.c:466:	chip->cdev_torch.brightness_set_blocking = lm355x_torch_brightness_set;
./drivers/leds/leds-lm355x.c:467:	chip->cdev_torch.default_trigger = "torch";
./drivers/leds/leds-lm355x.c:469:				    &client->dev, &chip->cdev_torch);
./drivers/leds/leds-lm355x.c:473:	chip->cdev_indicator.name = "indicator";
./drivers/leds/leds-lm355x.c:475:		chip->cdev_indicator.max_brightness = 4;
./drivers/leds/leds-lm355x.c:477:		chip->cdev_indicator.max_brightness = 8;
./drivers/leds/leds-lm355x.c:478:	chip->cdev_indicator.brightness_set_blocking =
./drivers/leds/leds-lm355x.c:482:		chip->cdev_indicator.groups = lm355x_indicator_groups;
./drivers/leds/leds-lm355x.c:484:				    &client->dev, &chip->cdev_indicator);
./drivers/leds/leds-lm355x.c:493:	led_classdev_unregister(&chip->cdev_torch);
./drivers/leds/leds-lm355x.c:495:	led_classdev_unregister(&chip->cdev_flash);
./drivers/leds/leds-lm355x.c:503:	struct lm355x_reg_data *preg = chip->regs;
./drivers/leds/leds-lm355x.c:505:	regmap_write(chip->regmap, preg[REG_OPMODE].regno, 0);
./drivers/leds/leds-lm355x.c:506:	led_classdev_unregister(&chip->cdev_indicator);
./drivers/leds/leds-lm355x.c:507:	led_classdev_unregister(&chip->cdev_torch);
./drivers/leds/leds-lm355x.c:508:	led_classdev_unregister(&chip->cdev_flash);
./drivers/leds/leds-lm355x.c:509:	dev_info(&client->dev, "%s is removed\n", lm355x_name[chip->type]);
./drivers/leds/leds-lp5562.c:132:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp5562.c:212:	enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp5562.c:258:	dev_err(&chip->cl->dev, "wrong pattern format\n");
./drivers/leds/leds-lp5562.c:264:	const struct firmware *fw = chip->fw;
./drivers/leds/leds-lp5562.c:267:		dev_err(&chip->cl->dev, "firmware data size overflow: %zu\n",
./drivers/leds/leds-lp5562.c:325:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5562.c:327:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5562.c:365:	ptn = chip->pdata->patterns + (mode - 1);
./drivers/leds/leds-lp5562.c:367:		dev_err(&chip->cl->dev, "invalid pattern data\n");
./drivers/leds/leds-lp5562.c:378:		chip->engine_idx = i;
./drivers/leds/leds-lp5562.c:410:	struct lp55xx_predef_pattern *ptn = chip->pdata->patterns;
./drivers/leds/leds-lp5562.c:411:	int num_patterns = chip->pdata->num_patterns;
./drivers/leds/leds-lp5562.c:422:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5562.c:424:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5562.c:452:		enum lp55xx_engine_index idx = chip->engine_idx;
./drivers/leds/leds-lp5562.c:474:	mutex_lock(&chip->lock);
./drivers/leds/leds-lp5562.c:476:	mutex_unlock(&chip->lock);
./drivers/leds/leds-lp5562.c:542:	chip->cl = client;
./drivers/leds/leds-lp5562.c:543:	chip->pdata = pdata;
./drivers/leds/leds-lp5562.c:544:	chip->cfg = &lp5562_cfg;
./drivers/leds/leds-lp5562.c:546:	mutex_init(&chip->lock);
./drivers/pci/host/pcie-rcar.c:596:	mutex_lock(&chip->lock);
./drivers/pci/host/pcie-rcar.c:598:	msi = find_first_zero_bit(chip->used, INT_PCI_MSI_NR);
./drivers/pci/host/pcie-rcar.c:600:		set_bit(msi, chip->used);
./drivers/pci/host/pcie-rcar.c:604:	mutex_unlock(&chip->lock);
./drivers/pci/host/pcie-rcar.c:611:	mutex_lock(&chip->lock);
./drivers/pci/host/pcie-rcar.c:612:	clear_bit(irq, chip->used);
./drivers/pci/host/pcie-rcar.c:613:	mutex_unlock(&chip->lock);
./drivers/pci/host/pci-hyperv.c:753:	return parent->chip->irq_set_affinity(parent, dest, force);
./drivers/pci/host/pci-tegra.c:1368:	mutex_lock(&chip->lock);
./drivers/pci/host/pci-tegra.c:1370:	msi = find_first_zero_bit(chip->used, INT_PCI_MSI_NR);
./drivers/pci/host/pci-tegra.c:1372:		set_bit(msi, chip->used);
./drivers/pci/host/pci-tegra.c:1376:	mutex_unlock(&chip->lock);
./drivers/pci/host/pci-tegra.c:1383:	struct device *dev = chip->chip.dev;
./drivers/pci/host/pci-tegra.c:1385:	mutex_lock(&chip->lock);
./drivers/pci/host/pci-tegra.c:1387:	if (!test_bit(irq, chip->used))
./drivers/pci/host/pci-tegra.c:1390:		clear_bit(irq, chip->used);
./drivers/pci/host/pci-tegra.c:1392:	mutex_unlock(&chip->lock);
./drivers/pci/msi.c:85:	if (!chip || !chip->setup_irq)
./drivers/pci/msi.c:88:	err = chip->setup_irq(chip, dev, desc);
./drivers/pci/msi.c:101:	if (!chip || !chip->teardown_irq)
./drivers/pci/msi.c:104:	chip->teardown_irq(chip, irq);
./drivers/pci/msi.c:113:	if (chip && chip->setup_irqs)
./drivers/pci/msi.c:114:		return chip->setup_irqs(chip, dev, nvec, type);
./drivers/pci/msi.c:1250:	if (!chip->irq_write_msi_msg)
./drivers/pci/msi.c:1251:		chip->irq_write_msi_msg = pci_msi_domain_write_msg;
./drivers/pci/msi.c:1252:	if (!chip->irq_mask)
./drivers/pci/msi.c:1253:		chip->irq_mask = pci_msi_mask_irq;
./drivers/pci/msi.c:1254:	if (!chip->irq_unmask)
./drivers/pci/msi.c:1255:		chip->irq_unmask = pci_msi_unmask_irq;
./drivers/ssb/driver_gpio.c:150:	bus->irq_domain = irq_domain_add_linear(NULL, chip->ngpio,
./drivers/ssb/driver_gpio.c:156:	for (gpio = 0; gpio < chip->ngpio; gpio++) {
./drivers/ssb/driver_gpio.c:176:	for (gpio = 0; gpio < chip->ngpio; gpio++) {
./drivers/ssb/driver_gpio.c:197:	for (gpio = 0; gpio < chip->ngpio; gpio++) {
./drivers/ssb/driver_gpio.c:220:	chip->label		= "ssb_chipco_gpio";
./drivers/ssb/driver_gpio.c:221:	chip->owner		= THIS_MODULE;
./drivers/ssb/driver_gpio.c:222:	chip->request		= ssb_gpio_chipco_request;
./drivers/ssb/driver_gpio.c:223:	chip->free		= ssb_gpio_chipco_free;
./drivers/ssb/driver_gpio.c:224:	chip->get		= ssb_gpio_chipco_get_value;
./drivers/ssb/driver_gpio.c:225:	chip->set		= ssb_gpio_chipco_set_value;
./drivers/ssb/driver_gpio.c:226:	chip->direction_input	= ssb_gpio_chipco_direction_input;
./drivers/ssb/driver_gpio.c:227:	chip->direction_output	= ssb_gpio_chipco_direction_output;
./drivers/ssb/driver_gpio.c:229:	chip->to_irq		= ssb_gpio_to_irq;
./drivers/ssb/driver_gpio.c:231:	chip->ngpio		= 16;
./drivers/ssb/driver_gpio.c:236:		chip->base		= 0;
./drivers/ssb/driver_gpio.c:238:		chip->base		= -1;
./drivers/ssb/driver_gpio.c:347:	bus->irq_domain = irq_domain_add_linear(NULL, chip->ngpio,
./drivers/ssb/driver_gpio.c:353:	for (gpio = 0; gpio < chip->ngpio; gpio++) {
./drivers/ssb/driver_gpio.c:372:	for (gpio = 0; gpio < chip->ngpio; gpio++) {
./drivers/ssb/driver_gpio.c:392:	for (gpio = 0; gpio < chip->ngpio; gpio++) {
./drivers/ssb/driver_gpio.c:415:	chip->label		= "ssb_extif_gpio";
./drivers/ssb/driver_gpio.c:416:	chip->owner		= THIS_MODULE;
./drivers/ssb/driver_gpio.c:417:	chip->get		= ssb_gpio_extif_get_value;
./drivers/ssb/driver_gpio.c:418:	chip->set		= ssb_gpio_extif_set_value;
./drivers/ssb/driver_gpio.c:419:	chip->direction_input	= ssb_gpio_extif_direction_input;
./drivers/ssb/driver_gpio.c:420:	chip->direction_output	= ssb_gpio_extif_direction_output;
./drivers/ssb/driver_gpio.c:422:	chip->to_irq		= ssb_gpio_to_irq;
./drivers/ssb/driver_gpio.c:424:	chip->ngpio		= 5;
./drivers/ssb/driver_gpio.c:429:		chip->base		= 0;
./drivers/ssb/driver_gpio.c:431:		chip->base		= -1;
./drivers/usb/storage/realtek_cr.c:465:	retval = rts51x_read_status(us, lun, buf, 16, &(chip->status_len));
./drivers/usb/storage/realtek_cr.c:469:	usb_stor_dbg(us, "chip->status_len = %d\n", chip->status_len);
./drivers/usb/storage/realtek_cr.c:471:	chip->status[lun].vid = ((u16) buf[0] << 8) | buf[1];
./drivers/usb/storage/realtek_cr.c:472:	chip->status[lun].pid = ((u16) buf[2] << 8) | buf[3];
./drivers/usb/storage/realtek_cr.c:473:	chip->status[lun].cur_lun = buf[4];
./drivers/usb/storage/realtek_cr.c:474:	chip->status[lun].card_type = buf[5];
./drivers/usb/storage/realtek_cr.c:475:	chip->status[lun].total_lun = buf[6];
./drivers/usb/storage/realtek_cr.c:476:	chip->status[lun].fw_ver = ((u16) buf[7] << 8) | buf[8];
./drivers/usb/storage/realtek_cr.c:477:	chip->status[lun].phy_exist = buf[9];
./drivers/usb/storage/realtek_cr.c:478:	chip->status[lun].multi_flag = buf[10];
./drivers/usb/storage/realtek_cr.c:479:	chip->status[lun].multi_card = buf[11];
./drivers/usb/storage/realtek_cr.c:480:	chip->status[lun].log_exist = buf[12];
./drivers/usb/storage/realtek_cr.c:481:	if (chip->status_len == 16) {
./drivers/usb/storage/realtek_cr.c:482:		chip->status[lun].detailed_type.detailed_type1 = buf[13];
./drivers/usb/storage/realtek_cr.c:483:		chip->status[lun].function[0] = buf[14];
./drivers/usb/storage/realtek_cr.c:484:		chip->status[lun].function[1] = buf[15];
./drivers/usb/storage/realtek_cr.c:759:	struct us_data *us = chip->us;
./drivers/usb/storage/realtek_cr.c:763:	chip->timer_expires = jiffies + msecs_to_jiffies(1000*ss_delay);
./drivers/usb/storage/realtek_cr.c:764:	mod_timer(&chip->rts51x_suspend_timer, chip->timer_expires);
./drivers/usb/storage/realtek_cr.c:770:	struct us_data *us = chip->us;
./drivers/usb/storage/realtek_cr.c:833:		chip->proto_handler_backup(srb, us);
./drivers/usb/storage/realtek_cr.c:838:			    (chip->pwr_state == US_SUSPEND)) {
./drivers/usb/storage/realtek_cr.c:865:			chip->proto_handler_backup(srb, us);
./drivers/usb/storage/realtek_cr.c:897:	chip->support_auto_delink = 0;
./drivers/usb/storage/realtek_cr.c:898:	chip->pwr_state = US_RESUME;
./drivers/usb/storage/realtek_cr.c:899:	chip->lun_ready = 0;
./drivers/usb/storage/realtek_cr.c:902:	retval = rts51x_read_status(us, 0, buf, 16, &(chip->status_len));
./drivers/usb/storage/realtek_cr.c:907:	status = chip->status;
./drivers/usb/storage/realtek_cr.c:918:	if (chip->status_len == 16) {
./drivers/usb/storage/realtek_cr.c:926:	chip->proto_handler_backup = us->proto_handler;
./drivers/usb/storage/realtek_cr.c:932:	chip->timer_expires = 0;
./drivers/usb/storage/realtek_cr.c:933:	setup_timer(&chip->rts51x_suspend_timer, rts51x_suspend_timer_fn,
./drivers/usb/storage/realtek_cr.c:953:		del_timer(&chip->rts51x_suspend_timer);
./drivers/usb/storage/realtek_cr.c:954:		chip->timer_expires = 0;
./drivers/usb/storage/realtek_cr.c:957:	kfree(chip->status);
./drivers/usb/storage/realtek_cr.c:1000:	us->max_lun = chip->max_lun = rts51x_get_max_lun(us);
./drivers/usb/storage/realtek_cr.c:1001:	chip->us = us;
./drivers/usb/storage/realtek_cr.c:1003:	usb_stor_dbg(us, "chip->max_lun = %d\n", chip->max_lun);
./drivers/usb/storage/realtek_cr.c:1005:	size = (chip->max_lun + 1) * sizeof(struct rts51x_status);
./drivers/usb/storage/realtek_cr.c:1006:	chip->status = kzalloc(size, GFP_KERNEL);
./drivers/usb/storage/realtek_cr.c:1007:	if (!chip->status)
./drivers/usb/storage/realtek_cr.c:1010:	for (i = 0; i <= (int)(chip->max_lun); i++) {
./drivers/usb/storage/realtek_cr.c:1028:	usb_stor_dbg(us, "chip->flag = 0x%x\n", chip->flag);
./drivers/usb/storage/realtek_cr.c:1036:		kfree(chip->status);
./drivers/cpufreq/powernv-cpufreq.c:272:	return sprintf(buf, "%u\n", chip->member);			\
./drivers/cpufreq/powernv-cpufreq.c:445:		if (chip->throttled)
./drivers/cpufreq/powernv-cpufreq.c:447:		chip->throttled = true;
./drivers/cpufreq/powernv-cpufreq.c:450:				     cpu, chip->id, pmsr_pmax,
./drivers/cpufreq/powernv-cpufreq.c:452:			chip->throttle_sub_turbo++;
./drivers/cpufreq/powernv-cpufreq.c:454:			chip->throttle_turbo++;
./drivers/cpufreq/powernv-cpufreq.c:456:		trace_powernv_throttle(chip->id,
./drivers/cpufreq/powernv-cpufreq.c:457:				      throttle_reason[chip->throttle_reason],
./drivers/cpufreq/powernv-cpufreq.c:459:	} else if (chip->throttled) {
./drivers/cpufreq/powernv-cpufreq.c:460:		chip->throttled = false;
./drivers/cpufreq/powernv-cpufreq.c:461:		trace_powernv_throttle(chip->id,
./drivers/cpufreq/powernv-cpufreq.c:462:				      throttle_reason[chip->throttle_reason],
./drivers/cpufreq/powernv-cpufreq.c:750:	cpumask_and(&mask, &chip->mask, cpu_online_mask);
./drivers/cpufreq/powernv-cpufreq.c:754:	if (!chip->restore)
./drivers/cpufreq/powernv-cpufreq.c:757:	chip->restore = false;
./drivers/nvmem/rockchip-efuse.c:84:	.name = "rockchip-efuse",
./drivers/nvmem/rockchip-efuse.c:92:	{ .compatible = "rockchip,rockchip-efuse", },
./drivers/nvmem/rockchip-efuse.c:142:		.name = "rockchip-efuse",
./drivers/ptp/ptp_pch.c:153:	val = ioread32(&chip->regs->ts_sel) | (PCH_ECS_ETH);
./drivers/ptp/ptp_pch.c:154:	iowrite32(val, (&chip->regs->ts_sel));
./drivers/ptp/ptp_pch.c:188:	val = ioread32(&chip->regs->control) | PCH_TSC_RESET;
./drivers/ptp/ptp_pch.c:189:	iowrite32(val, (&chip->regs->control));
./drivers/ptp/ptp_pch.c:191:	iowrite32(val, (&chip->regs->control));
./drivers/ptp/ptp_pch.c:199:	val = ioread32(&chip->regs->ch_control);
./drivers/ptp/ptp_pch.c:209:	iowrite32(val, (&chip->regs->ch_control));
./drivers/ptp/ptp_pch.c:218:	val = ioread32(&chip->regs->ch_event);
./drivers/ptp/ptp_pch.c:228:	iowrite32(val, (&chip->regs->ch_event));
./drivers/ptp/ptp_pch.c:237:	val = ioread32(&chip->regs->src_uuid_lo);
./drivers/ptp/ptp_pch.c:248:	val = ioread32(&chip->regs->src_uuid_hi);
./drivers/ptp/ptp_pch.c:260:	lo = ioread32(&chip->regs->rx_snap_lo);
./drivers/ptp/ptp_pch.c:261:	hi = ioread32(&chip->regs->rx_snap_hi);
./drivers/ptp/ptp_pch.c:277:	lo = ioread32(&chip->regs->tx_snap_lo);
./drivers/ptp/ptp_pch.c:278:	hi = ioread32(&chip->regs->tx_snap_hi);
./drivers/ptp/ptp_pch.c:292:	iowrite32(0x01, &chip->regs->stl_max_set_en);
./drivers/ptp/ptp_pch.c:293:	iowrite32(0xFFFFFFFF, &chip->regs->stl_max_set);
./drivers/ptp/ptp_pch.c:294:	iowrite32(0x00, &chip->regs->stl_max_set_en);
./drivers/ptp/ptp_pch.c:318:	if ((chip->regs == NULL) || addr == (u8 *)NULL) {
./drivers/ptp/ptp_pch.c:352:		iowrite32(val, &chip->regs->ts_st[i]);
./drivers/ptp/ptp_pch.c:565:	ptp_clock_unregister(chip->ptp_clock);
./drivers/ptp/ptp_pch.c:571:	if (chip->regs != NULL) {
./drivers/ptp/ptp_pch.c:572:		iounmap(chip->regs);
./drivers/ptp/ptp_pch.c:573:		chip->regs = NULL;
./drivers/ptp/ptp_pch.c:576:	if (chip->mem_base != 0) {
./drivers/ptp/ptp_pch.c:577:		release_mem_region(chip->mem_base, chip->mem_size);
./drivers/ptp/ptp_pch.c:578:		chip->mem_base = 0;
./drivers/ptp/ptp_pch.c:603:	chip->mem_base = pci_resource_start(pdev, IO_MEM_BAR);
./drivers/ptp/ptp_pch.c:604:	if (!chip->mem_base) {
./drivers/ptp/ptp_pch.c:611:	chip->mem_size = pci_resource_len(pdev, IO_MEM_BAR);
./drivers/ptp/ptp_pch.c:614:	if (!request_mem_region(chip->mem_base, chip->mem_size, "1588_regs")) {
./drivers/ptp/ptp_pch.c:622:	chip->regs = ioremap(chip->mem_base, chip->mem_size);
./drivers/ptp/ptp_pch.c:624:	if (!chip->regs) {
./drivers/ptp/ptp_pch.c:630:	chip->caps = ptp_pch_caps;
./drivers/ptp/ptp_pch.c:631:	chip->ptp_clock = ptp_clock_register(&chip->caps, &pdev->dev);
./drivers/ptp/ptp_pch.c:632:	if (IS_ERR(chip->ptp_clock)) {
./drivers/ptp/ptp_pch.c:633:		ret = PTR_ERR(chip->ptp_clock);
./drivers/ptp/ptp_pch.c:637:	spin_lock_init(&chip->register_lock);
./drivers/ptp/ptp_pch.c:646:	chip->irq = pdev->irq;
./drivers/ptp/ptp_pch.c:647:	chip->pdev = pdev;
./drivers/ptp/ptp_pch.c:650:	spin_lock_irqsave(&chip->register_lock, flags);
./drivers/ptp/ptp_pch.c:654:	iowrite32(DEFAULT_ADDEND, &chip->regs->addend);
./drivers/ptp/ptp_pch.c:655:	iowrite32(1, &chip->regs->trgt_lo);
./drivers/ptp/ptp_pch.c:656:	iowrite32(0, &chip->regs->trgt_hi);
./drivers/ptp/ptp_pch.c:657:	iowrite32(PCH_TSE_TTIPEND, &chip->regs->event);
./drivers/ptp/ptp_pch.c:669:	spin_unlock_irqrestore(&chip->register_lock, flags);
./drivers/ptp/ptp_pch.c:673:	ptp_clock_unregister(chip->ptp_clock);
./drivers/ptp/ptp_pch.c:675:	iounmap(chip->regs);
./drivers/ptp/ptp_pch.c:676:	chip->regs = NULL;
./drivers/ptp/ptp_pch.c:679:	release_mem_region(chip->mem_base, chip->mem_size);
./drivers/ptp/ptp_pch.c:682:	chip->mem_base = 0;
./drivers/sh/intc/virq.c:120:	chip->irq_mask_ack(data);
./drivers/sh/intc/virq.c:134:	chip->irq_unmask(data);
./drivers/sh/intc/core.c:428:				chip->irq_enable(data);
./drivers/sh/intc/core.c:457:				chip->irq_disable(data);
./drivers/sh/intc/core.c:459:				chip->irq_enable(data);
./drivers/misc/cxl/pci.c:366:	while (np && !(prop = of_get_property(np, "ibm,chip-id", NULL)))
./drivers/misc/apds990x.c:203:	struct i2c_client *client = chip->client;
./drivers/misc/apds990x.c:216:	struct i2c_client *client = chip->client;
./drivers/misc/apds990x.c:229:	struct i2c_client *client = chip->client;
./drivers/misc/apds990x.c:241:	struct i2c_client *client = chip->client;
./drivers/misc/apds990x.c:257:	if (chip->prox_en)
./drivers/misc/apds990x.c:289:	lux = lux * (APDS_CALIB_SCALER / 4) / (chip->lux_calib / 4);
./drivers/misc/apds990x.c:292:	cpl = ((u32)chip->atime * (u32)again[chip->again_next] *
./drivers/misc/apds990x.c:293:		APDS_PARAM_SCALE * 64) / (chip->cf.ga * chip->cf.df);
./drivers/misc/apds990x.c:301:	ir = (u32)chip->lux_ir * (u32)again[chip->again_next] /
./drivers/misc/apds990x.c:302:		(u32)again[chip->again_meas];
./drivers/misc/apds990x.c:308:	if (chip->lux_clear * APDS_PARAM_SCALE >=
./drivers/misc/apds990x.c:309:		chip->rcf.afactor * chip->lux_ir)
./drivers/misc/apds990x.c:310:		thres = (chip->rcf.cf1 * thres + chip->rcf.irf1 * ir) /
./drivers/misc/apds990x.c:313:		thres = (chip->rcf.cf2 * thres + chip->rcf.irf2 * ir) /
./drivers/misc/apds990x.c:316:	if (thres >= chip->a_max_result)
./drivers/misc/apds990x.c:317:		thres = chip->a_max_result - 1;
./drivers/misc/apds990x.c:325:	chip->atime = time_ms;
./drivers/misc/apds990x.c:329:	chip->a_max_result = (u16)(256 - reg_value) * APDS990X_TIME_TO_ADC;
./drivers/misc/apds990x.c:339:	if (pm_runtime_suspended(&chip->client->dev))
./drivers/misc/apds990x.c:342:	if (data < chip->prox_thres) {
./drivers/misc/apds990x.c:344:		hi = chip->prox_thres;
./drivers/misc/apds990x.c:346:		lo = chip->prox_thres - APDS_PROX_HYSTERESIS;
./drivers/misc/apds990x.c:347:		if (chip->prox_continuous_mode)
./drivers/misc/apds990x.c:348:			hi = chip->prox_thres;
./drivers/misc/apds990x.c:363:	if (pm_runtime_suspended(&chip->client->dev))
./drivers/misc/apds990x.c:367:			apds990x_lux_to_threshold(chip, chip->lux_thres_lo));
./drivers/misc/apds990x.c:369:			apds990x_lux_to_threshold(chip, chip->lux_thres_hi));
./drivers/misc/apds990x.c:393:	int curr_again = chip->again_meas;
./drivers/misc/apds990x.c:394:	int next_again = chip->again_meas;
./drivers/misc/apds990x.c:398:	if (chip->lux_clear == chip->a_max_result)
./drivers/misc/apds990x.c:400:	else if (chip->lux_clear > chip->a_max_result / 2)
./drivers/misc/apds990x.c:402:	else if (chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT_STRICT)
./drivers/misc/apds990x.c:404:	else if (chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT)
./drivers/misc/apds990x.c:414:	if (chip->lux_clear == chip->a_max_result)
./drivers/misc/apds990x.c:418:		chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT_STRICT)
./drivers/misc/apds990x.c:425:	chip->again_next = next_again;
./drivers/misc/apds990x.c:427:			(chip->pdrive << 6) |
./drivers/misc/apds990x.c:428:			(chip->pdiode << 4) |
./drivers/misc/apds990x.c:429:			(chip->pgain << 2) |
./drivers/misc/apds990x.c:430:			(chip->again_next << 0));
./drivers/misc/apds990x.c:455:	iac1 = (chip->cf.cf1 * clear - chip->cf.irf1 * ir) / APDS_PARAM_SCALE;
./drivers/misc/apds990x.c:456:	iac2 = (chip->cf.cf2 * clear - chip->cf.irf2 * ir) / APDS_PARAM_SCALE;
./drivers/misc/apds990x.c:461:	lpc = APDS990X_LUX_OUTPUT_SCALE * (chip->cf.df * chip->cf.ga) /
./drivers/misc/apds990x.c:462:		(u32)(again[chip->again_meas] * (u32)chip->atime);
./drivers/misc/apds990x.c:469:	struct i2c_client *client = chip->client;
./drivers/misc/apds990x.c:497:	mutex_lock(&chip->mutex);
./drivers/misc/apds990x.c:498:	if (!pm_runtime_suspended(&chip->client->dev)) {
./drivers/misc/apds990x.c:501:					&chip->lux_clear);
./drivers/misc/apds990x.c:503:					&chip->lux_ir);
./drivers/misc/apds990x.c:505:			chip->again_meas = chip->again_next;
./drivers/misc/apds990x.c:507:			chip->lux_raw = apds990x_get_lux(chip,
./drivers/misc/apds990x.c:508:							chip->lux_clear,
./drivers/misc/apds990x.c:509:							chip->lux_ir);
./drivers/misc/apds990x.c:513:				chip->lux = chip->lux_raw;
./drivers/misc/apds990x.c:514:				chip->lux_wait_fresh_res = false;
./drivers/misc/apds990x.c:515:				wake_up(&chip->wait);
./drivers/misc/apds990x.c:516:				sysfs_notify(&chip->client->dev.kobj,
./drivers/misc/apds990x.c:521:		if ((status & APDS990X_ST_PINT) && chip->prox_en) {
./drivers/misc/apds990x.c:530:			if (chip->again_meas == 0 &&
./drivers/misc/apds990x.c:531:				clr_ch == chip->a_max_result)
./drivers/misc/apds990x.c:532:				chip->prox_data = 0;
./drivers/misc/apds990x.c:536:						&chip->prox_data);
./drivers/misc/apds990x.c:538:			apds990x_refresh_pthres(chip, chip->prox_data);
./drivers/misc/apds990x.c:539:			if (chip->prox_data < chip->prox_thres)
./drivers/misc/apds990x.c:540:				chip->prox_data = 0;
./drivers/misc/apds990x.c:541:			else if (!chip->prox_continuous_mode)
./drivers/misc/apds990x.c:542:				chip->prox_data = APDS_PROX_RANGE;
./drivers/misc/apds990x.c:543:			sysfs_notify(&chip->client->dev.kobj,
./drivers/misc/apds990x.c:547:	mutex_unlock(&chip->mutex);
./drivers/misc/apds990x.c:565:			(chip->lux_persistence << APDS990X_APERS_SHIFT) |
./drivers/misc/apds990x.c:566:			(chip->prox_persistence << APDS990X_PPERS_SHIFT));
./drivers/misc/apds990x.c:568:	apds990x_write_byte(chip, APDS990X_PPCOUNT, chip->pdata->ppcount);
./drivers/misc/apds990x.c:571:	chip->again_meas = 1;
./drivers/misc/apds990x.c:572:	chip->again_next = 1;
./drivers/misc/apds990x.c:574:			(chip->pdrive << 6) |
./drivers/misc/apds990x.c:575:			(chip->pdiode << 4) |
./drivers/misc/apds990x.c:576:			(chip->pgain << 2) |
./drivers/misc/apds990x.c:577:			(chip->again_next << 0));
./drivers/misc/apds990x.c:583:	struct i2c_client *client = chip->client;
./drivers/misc/apds990x.c:593:	ret = apds990x_read_byte(chip, APDS990X_REV, &chip->revision);
./drivers/misc/apds990x.c:603:		snprintf(chip->chipname, sizeof(chip->chipname), "APDS-990x");
./drivers/misc/apds990x.c:615:	int err	 = regulator_bulk_enable(ARRAY_SIZE(chip->regs),
./drivers/misc/apds990x.c:616:					chip->regs);
./drivers/misc/apds990x.c:623:	chip->prox_data = 0;
./drivers/misc/apds990x.c:633:	regulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/apds990x.c:648:	timeout = wait_event_interruptible_timeout(chip->wait,
./drivers/misc/apds990x.c:649:						!chip->lux_wait_fresh_res,
./drivers/misc/apds990x.c:654:	mutex_lock(&chip->mutex);
./drivers/misc/apds990x.c:655:	result = (chip->lux * chip->lux_calib) / APDS_CALIB_SCALER;
./drivers/misc/apds990x.c:662:	mutex_unlock(&chip->mutex);
./drivers/misc/apds990x.c:690:	return sprintf(buf, "%u\n", chip->lux_calib);
./drivers/misc/apds990x.c:705:	chip->lux_calib = value;
./drivers/misc/apds990x.c:728:	return sprintf(buf, "%d\n", chip->arate);
./drivers/misc/apds990x.c:743:	chip->lux_persistence = apersis[i];
./drivers/misc/apds990x.c:744:	chip->arate = arates_hz[i];
./drivers/misc/apds990x.c:747:	if (pm_runtime_suspended(&chip->client->dev))
./drivers/misc/apds990x.c:752:			(chip->lux_persistence << APDS990X_APERS_SHIFT) |
./drivers/misc/apds990x.c:753:			(chip->prox_persistence << APDS990X_PPERS_SHIFT));
./drivers/misc/apds990x.c:768:	mutex_lock(&chip->mutex);
./drivers/misc/apds990x.c:770:	mutex_unlock(&chip->mutex);
./drivers/misc/apds990x.c:787:	if (pm_runtime_suspended(dev) || !chip->prox_en)
./drivers/misc/apds990x.c:790:	mutex_lock(&chip->mutex);
./drivers/misc/apds990x.c:791:	ret = sprintf(buf, "%d\n", chip->prox_data);
./drivers/misc/apds990x.c:792:	mutex_unlock(&chip->mutex);
./drivers/misc/apds990x.c:810:	return sprintf(buf, "%d\n", chip->prox_en);
./drivers/misc/apds990x.c:825:	mutex_lock(&chip->mutex);
./drivers/misc/apds990x.c:827:	if (!chip->prox_en)
./drivers/misc/apds990x.c:828:		chip->prox_data = 0;
./drivers/misc/apds990x.c:831:		chip->prox_en++;
./drivers/misc/apds990x.c:832:	else if (chip->prox_en > 0)
./drivers/misc/apds990x.c:833:		chip->prox_en--;
./drivers/misc/apds990x.c:837:	mutex_unlock(&chip->mutex);
./drivers/misc/apds990x.c:851:		reporting_modes[!!chip->prox_continuous_mode]);
./drivers/misc/apds990x.c:861:		chip->prox_continuous_mode = 0;
./drivers/misc/apds990x.c:863:		chip->prox_continuous_mode = 1;
./drivers/misc/apds990x.c:887:	return sprintf(buf, "%d\n", chip->lux_thres_hi);
./drivers/misc/apds990x.c:894:	return sprintf(buf, "%d\n", chip->lux_thres_lo);
./drivers/misc/apds990x.c:910:	mutex_lock(&chip->mutex);
./drivers/misc/apds990x.c:916:	if (!chip->lux_wait_fresh_res)
./drivers/misc/apds990x.c:918:	mutex_unlock(&chip->mutex);
./drivers/misc/apds990x.c:928:	int ret = apds990x_set_lux_thresh(chip, &chip->lux_thres_hi, buf);
./drivers/misc/apds990x.c:939:	int ret = apds990x_set_lux_thresh(chip, &chip->lux_thres_lo, buf);
./drivers/misc/apds990x.c:957:	return sprintf(buf, "%d\n", chip->prox_thres);
./drivers/misc/apds990x.c:976:	mutex_lock(&chip->mutex);
./drivers/misc/apds990x.c:977:	chip->prox_thres = value;
./drivers/misc/apds990x.c:980:	mutex_unlock(&chip->mutex);
./drivers/misc/apds990x.c:1009:		mutex_lock(&chip->mutex);
./drivers/misc/apds990x.c:1010:		chip->lux_wait_fresh_res = true;
./drivers/misc/apds990x.c:1013:		mutex_unlock(&chip->mutex);
./drivers/misc/apds990x.c:1029:	return sprintf(buf, "%s %d\n", chip->chipname, chip->revision);
./drivers/misc/apds990x.c:1069:	chip->client  = client;
./drivers/misc/apds990x.c:1071:	init_waitqueue_head(&chip->wait);
./drivers/misc/apds990x.c:1072:	mutex_init(&chip->mutex);
./drivers/misc/apds990x.c:1073:	chip->pdata	= client->dev.platform_data;
./drivers/misc/apds990x.c:1075:	if (chip->pdata == NULL) {
./drivers/misc/apds990x.c:1081:	if (chip->pdata->cf.ga == 0) {
./drivers/misc/apds990x.c:1083:		chip->cf.ga = 1966; /* 0.48 * APDS_PARAM_SCALE */
./drivers/misc/apds990x.c:1084:		chip->cf.cf1 = 4096; /* 1.00 * APDS_PARAM_SCALE */
./drivers/misc/apds990x.c:1085:		chip->cf.irf1 = 9134; /* 2.23 * APDS_PARAM_SCALE */
./drivers/misc/apds990x.c:1086:		chip->cf.cf2 = 2867; /* 0.70 * APDS_PARAM_SCALE */
./drivers/misc/apds990x.c:1087:		chip->cf.irf2 = 5816; /* 1.42 * APDS_PARAM_SCALE */
./drivers/misc/apds990x.c:1088:		chip->cf.df = 52;
./drivers/misc/apds990x.c:1090:		chip->cf = chip->pdata->cf;
./drivers/misc/apds990x.c:1094:	chip->rcf.afactor =
./drivers/misc/apds990x.c:1095:		(chip->cf.irf1 - chip->cf.irf2) * APDS_PARAM_SCALE /
./drivers/misc/apds990x.c:1096:		(chip->cf.cf1 - chip->cf.cf2);
./drivers/misc/apds990x.c:1097:	chip->rcf.cf1 = APDS_PARAM_SCALE * APDS_PARAM_SCALE /
./drivers/misc/apds990x.c:1098:		chip->cf.cf1;
./drivers/misc/apds990x.c:1099:	chip->rcf.irf1 = chip->cf.irf1 * APDS_PARAM_SCALE /
./drivers/misc/apds990x.c:1100:		chip->cf.cf1;
./drivers/misc/apds990x.c:1101:	chip->rcf.cf2 = APDS_PARAM_SCALE * APDS_PARAM_SCALE /
./drivers/misc/apds990x.c:1102:		chip->cf.cf2;
./drivers/misc/apds990x.c:1103:	chip->rcf.irf2 = chip->cf.irf2 * APDS_PARAM_SCALE /
./drivers/misc/apds990x.c:1104:		chip->cf.cf2;
./drivers/misc/apds990x.c:1107:	chip->lux_thres_hi = APDS_LUX_DEF_THRES_HI;
./drivers/misc/apds990x.c:1108:	chip->lux_thres_lo = APDS_LUX_DEF_THRES_LO;
./drivers/misc/apds990x.c:1109:	chip->lux_calib = APDS_LUX_NEUTRAL_CALIB_VALUE;
./drivers/misc/apds990x.c:1111:	chip->prox_thres = APDS_PROX_DEF_THRES;
./drivers/misc/apds990x.c:1112:	chip->pdrive = chip->pdata->pdrive;
./drivers/misc/apds990x.c:1113:	chip->pdiode = APDS_PDIODE_IR;
./drivers/misc/apds990x.c:1114:	chip->pgain = APDS_PGAIN_1X;
./drivers/misc/apds990x.c:1115:	chip->prox_calib = APDS_PROX_NEUTRAL_CALIB_VALUE;
./drivers/misc/apds990x.c:1116:	chip->prox_persistence = APDS_DEFAULT_PROX_PERS;
./drivers/misc/apds990x.c:1117:	chip->prox_continuous_mode = false;
./drivers/misc/apds990x.c:1119:	chip->regs[0].supply = reg_vcc;
./drivers/misc/apds990x.c:1120:	chip->regs[1].supply = reg_vled;
./drivers/misc/apds990x.c:1123:				 ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/apds990x.c:1129:	err = regulator_bulk_enable(ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/apds990x.c:1151:	if (chip->pdata->setup_resources) {
./drivers/misc/apds990x.c:1152:		err = chip->pdata->setup_resources();
./drivers/misc/apds990x.c:1159:	err = sysfs_create_group(&chip->client->dev.kobj,
./drivers/misc/apds990x.c:1162:		dev_err(&chip->client->dev, "Sysfs registration failed\n");
./drivers/misc/apds990x.c:1178:	sysfs_remove_group(&chip->client->dev.kobj,
./drivers/misc/apds990x.c:1181:	if (chip->pdata && chip->pdata->release_resources)
./drivers/misc/apds990x.c:1182:		chip->pdata->release_resources();
./drivers/misc/apds990x.c:1184:	regulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/apds990x.c:1186:	regulator_bulk_free(ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/apds990x.c:1197:	sysfs_remove_group(&chip->client->dev.kobj,
./drivers/misc/apds990x.c:1200:	if (chip->pdata && chip->pdata->release_resources)
./drivers/misc/apds990x.c:1201:		chip->pdata->release_resources();
./drivers/misc/apds990x.c:1209:	regulator_bulk_free(ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/bh1770glc.c:193: * interrupt control functions are called while keeping chip->mutex
./drivers/misc/bh1770glc.c:199:	chip->int_mode_lux = lux;
./drivers/misc/bh1770glc.c:201:	return i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:203:					(lux << 1) | chip->int_mode_prox);
./drivers/misc/bh1770glc.c:209:	chip->int_mode_prox = ps;
./drivers/misc/bh1770glc.c:210:	return i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:212:					(chip->int_mode_lux << 1) | (ps << 0));
./drivers/misc/bh1770glc.c:215:/* chip->mutex is always kept here */
./drivers/misc/bh1770glc.c:219:	if (pm_runtime_suspended(&chip->client->dev))
./drivers/misc/bh1770glc.c:223:	if (chip->prox_enable_count)
./drivers/misc/bh1770glc.c:226:	return i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:236:		chip->prox_rate_threshold : chip->prox_rate;
./drivers/misc/bh1770glc.c:238:	return i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:247:	return i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:251:					chip->prox_led);
./drivers/misc/bh1770glc.c:263:	adjusted = (u16)(((u32)(psraw + chip->prox_const) * chip->prox_coef) /
./drivers/misc/bh1770glc.c:274:	raw = (((u32)ps * BH1770_COEF_SCALER) / chip->prox_coef);
./drivers/misc/bh1770glc.c:275:	if (raw > chip->prox_const)
./drivers/misc/bh1770glc.c:276:		raw = raw - chip->prox_const;
./drivers/misc/bh1770glc.c:293:	if (pm_runtime_suspended(&chip->client->dev))
./drivers/misc/bh1770glc.c:296:	tmp = bh1770_psadjusted_to_raw(chip, chip->prox_threshold);
./drivers/misc/bh1770glc.c:297:	chip->prox_threshold_hw = tmp;
./drivers/misc/bh1770glc.c:299:	return	i2c_smbus_write_byte_data(chip->client, BH1770_PS_TH_LED1,
./drivers/misc/bh1770glc.c:306:	lux = ((u32)raw * chip->lux_corr) / BH1770_LUX_CORR_SCALE;
./drivers/misc/bh1770glc.c:313:	return (u32)adjusted * BH1770_LUX_CORR_SCALE / chip->lux_corr;
./drivers/misc/bh1770glc.c:316:/* chip->mutex is kept when this is called */
./drivers/misc/bh1770glc.c:324:	if (pm_runtime_suspended(&chip->client->dev))
./drivers/misc/bh1770glc.c:338:	if (chip->lux_thres_hi_onchip == threshold_hi &&
./drivers/misc/bh1770glc.c:339:	    chip->lux_thres_lo_onchip == threshold_lo)
./drivers/misc/bh1770glc.c:342:	chip->lux_thres_hi_onchip = threshold_hi;
./drivers/misc/bh1770glc.c:343:	chip->lux_thres_lo_onchip = threshold_lo;
./drivers/misc/bh1770glc.c:350:	ret = i2c_smbus_write_i2c_block_data(chip->client,
./drivers/misc/bh1770glc.c:362:	ret = i2c_smbus_read_byte_data(chip->client, BH1770_ALS_DATA_0);
./drivers/misc/bh1770glc.c:367:	ret = i2c_smbus_read_byte_data(chip->client, BH1770_ALS_DATA_1);
./drivers/misc/bh1770glc.c:371:	chip->lux_data_raw = data | ((ret & 0xff) << 8);
./drivers/misc/bh1770glc.c:381:	tmp = (BH1770_LUX_CORR_SCALE * chip->lux_ga) / BH1770_LUX_GA_SCALE;
./drivers/misc/bh1770glc.c:383:	tmp = (tmp * chip->lux_cf) / BH1770_LUX_CF_SCALE;
./drivers/misc/bh1770glc.c:385:	tmp = (tmp * chip->lux_calib) / BH1770_CALIB_SCALER;
./drivers/misc/bh1770glc.c:392:	return bh1770_lux_raw_to_adjusted(chip, chip->lux_data_raw);
./drivers/misc/bh1770glc.c:401:	int ret = regulator_bulk_enable(ARRAY_SIZE(chip->regs),
./drivers/misc/bh1770glc.c:402:					chip->regs);
./drivers/misc/bh1770glc.c:409:	i2c_smbus_write_byte_data(chip->client, BH1770_ALS_CONTROL,
./drivers/misc/bh1770glc.c:418:	chip->lux_data_raw = 0;
./drivers/misc/bh1770glc.c:419:	chip->prox_data = 0;
./drivers/misc/bh1770glc.c:420:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:424:	chip->lux_thres_hi_onchip = BH1770_LUX_RANGE;
./drivers/misc/bh1770glc.c:425:	chip->lux_thres_lo_onchip = 0;
./drivers/misc/bh1770glc.c:432:	i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:434:	i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:436:	i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:438:	regulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/bh1770glc.c:441:/* chip->mutex is kept when this is called */
./drivers/misc/bh1770glc.c:444:	if (chip->prox_enable_count) {
./drivers/misc/bh1770glc.c:445:		chip->prox_force_update = true; /* Force immediate update */
./drivers/misc/bh1770glc.c:447:		bh1770_lux_rate(chip, chip->lux_rate_index);
./drivers/misc/bh1770glc.c:452:		i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:455:		chip->prox_data = 0;
./drivers/misc/bh1770glc.c:456:		bh1770_lux_rate(chip, chip->lux_rate_index);
./drivers/misc/bh1770glc.c:458:		i2c_smbus_write_byte_data(chip->client,
./drivers/misc/bh1770glc.c:464:/* chip->mutex is kept when this is called */
./drivers/misc/bh1770glc.c:471:	ret = i2c_smbus_read_byte_data(chip->client, BH1770_PS_DATA_LED1);
./drivers/misc/bh1770glc.c:475:	if (ret > chip->prox_threshold_hw)
./drivers/misc/bh1770glc.c:485:	if (chip->lux_data_raw > PROX_IGNORE_LUX_LIMIT)
./drivers/misc/bh1770glc.c:488:	chip->prox_data = bh1770_psraw_to_adjusted(chip, ret);
./drivers/misc/bh1770glc.c:491:	if (chip->prox_data >= chip->prox_abs_thres ||
./drivers/misc/bh1770glc.c:492:	    chip->prox_force_update)
./drivers/misc/bh1770glc.c:493:		chip->prox_persistence_counter = chip->prox_persistence;
./drivers/misc/bh1770glc.c:495:	chip->prox_force_update = false;
./drivers/misc/bh1770glc.c:499:		if (chip->prox_persistence_counter < chip->prox_persistence) {
./drivers/misc/bh1770glc.c:500:			chip->prox_persistence_counter++;
./drivers/misc/bh1770glc.c:507:		chip->prox_persistence_counter = 0;
./drivers/misc/bh1770glc.c:509:		chip->prox_data = 0;
./drivers/misc/bh1770glc.c:516:		sysfs_notify(&chip->client->dev.kobj, NULL, "prox0_raw");
./drivers/misc/bh1770glc.c:524:	struct i2c_client *client = chip->client;
./drivers/misc/bh1770glc.c:538:	chip->revision = (part & BH1770_REV_MASK) >> BH1770_REV_SHIFT;
./drivers/misc/bh1770glc.c:539:	chip->prox_coef = BH1770_COEF_SCALER;
./drivers/misc/bh1770glc.c:540:	chip->prox_const = 0;
./drivers/misc/bh1770glc.c:541:	chip->lux_cf = BH1770_NEUTRAL_CF;
./drivers/misc/bh1770glc.c:545:		snprintf(chip->chipname, sizeof(chip->chipname), "BH1770GLC");
./drivers/misc/bh1770glc.c:551:		snprintf(chip->chipname, sizeof(chip->chipname), "SFH7770");
./drivers/misc/bh1770glc.c:553:		chip->prox_coef = 819; /* 0.8 * BH1770_COEF_SCALER */
./drivers/misc/bh1770glc.c:554:		chip->prox_const = 40;
./drivers/misc/bh1770glc.c:579:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:581:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:591:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:592:	status = i2c_smbus_read_byte_data(chip->client, BH1770_ALS_PS_STATUS);
./drivers/misc/bh1770glc.c:595:	i2c_smbus_read_byte_data(chip->client, BH1770_INTERRUPT);
./drivers/misc/bh1770glc.c:603:		if (unlikely(chip->lux_wait_result)) {
./drivers/misc/bh1770glc.c:604:			chip->lux_wait_result = false;
./drivers/misc/bh1770glc.c:605:			wake_up(&chip->wait);
./drivers/misc/bh1770glc.c:607:						chip->lux_threshold_hi,
./drivers/misc/bh1770glc.c:608:						chip->lux_threshold_lo);
./drivers/misc/bh1770glc.c:613:	i2c_smbus_write_byte_data(chip->client, BH1770_INTERRUPT,
./drivers/misc/bh1770glc.c:617:		sysfs_notify(&chip->client->dev.kobj, NULL, "lux0_input");
./drivers/misc/bh1770glc.c:619:	if (chip->int_mode_prox && (status & BH1770_INT_LEDS_INT)) {
./drivers/misc/bh1770glc.c:620:		rate = prox_rates_ms[chip->prox_rate_threshold];
./drivers/misc/bh1770glc.c:625:	i2c_smbus_write_byte_data(chip->client, BH1770_INTERRUPT,
./drivers/misc/bh1770glc.c:626:				  (chip->int_mode_lux << 1) |
./drivers/misc/bh1770glc.c:627:				  (chip->int_mode_prox << 0));
./drivers/misc/bh1770glc.c:628:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:639:		cancel_delayed_work_sync(&chip->prox_work);
./drivers/misc/bh1770glc.c:640:		schedule_delayed_work(&chip->prox_work,
./drivers/misc/bh1770glc.c:658:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:662:		ret = bh1770_lux_rate(chip, chip->lux_rate_index);
./drivers/misc/bh1770glc.c:678:		chip->lux_wait_result = true;
./drivers/misc/bh1770glc.c:685:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:705:	timeout = wait_event_interruptible_timeout(chip->wait,
./drivers/misc/bh1770glc.c:706:					!chip->lux_wait_result,
./drivers/misc/bh1770glc.c:711:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:713:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:736:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:738:	if (!chip->prox_enable_count)
./drivers/misc/bh1770glc.c:739:		chip->prox_data = 0;
./drivers/misc/bh1770glc.c:742:		chip->prox_enable_count++;
./drivers/misc/bh1770glc.c:743:	else if (chip->prox_enable_count > 0)
./drivers/misc/bh1770glc.c:744:		chip->prox_enable_count--;
./drivers/misc/bh1770glc.c:752:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:762:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:763:	len = sprintf(buf, "%d\n", chip->prox_enable_count);
./drivers/misc/bh1770glc.c:764:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:774:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:775:	if (chip->prox_enable_count && !pm_runtime_suspended(dev))
./drivers/misc/bh1770glc.c:776:		ret = sprintf(buf, "%d\n", chip->prox_data);
./drivers/misc/bh1770glc.c:779:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:804:	return sprintf(buf, "%d\n", prox_rates_hz[chip->prox_rate_threshold]);
./drivers/misc/bh1770glc.c:811:	return sprintf(buf, "%d\n", prox_rates_hz[chip->prox_rate]);
./drivers/misc/bh1770glc.c:836:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:837:	chip->prox_rate_threshold = bh1770_prox_rate_validate(value);
./drivers/misc/bh1770glc.c:838:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:854:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:855:	chip->prox_rate = bh1770_prox_rate_validate(value);
./drivers/misc/bh1770glc.c:856:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:864:	return sprintf(buf, "%d\n", chip->prox_threshold);
./drivers/misc/bh1770glc.c:882:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:883:	chip->prox_threshold = value;
./drivers/misc/bh1770glc.c:885:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:896:	return sprintf(buf, "%u\n", chip->prox_persistence);
./drivers/misc/bh1770glc.c:914:	chip->prox_persistence = value;
./drivers/misc/bh1770glc.c:923:	return sprintf(buf, "%u\n", chip->prox_abs_thres);
./drivers/misc/bh1770glc.c:941:	chip->prox_abs_thres = value;
./drivers/misc/bh1770glc.c:950:	return sprintf(buf, "%s rev %d\n", chip->chipname, chip->revision);
./drivers/misc/bh1770glc.c:965:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:966:	len = sprintf(buf, "%u\n", chip->lux_calib);
./drivers/misc/bh1770glc.c:967:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:985:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:986:	old_calib = chip->lux_calib;
./drivers/misc/bh1770glc.c:987:	chip->lux_calib = value;
./drivers/misc/bh1770glc.c:990:		chip->lux_calib = old_calib;
./drivers/misc/bh1770glc.c:991:		mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:994:	chip->lux_corr = new_corr;
./drivers/misc/bh1770glc.c:996:	bh1770_lux_update_thresholds(chip, chip->lux_threshold_hi,
./drivers/misc/bh1770glc.c:997:				chip->lux_threshold_lo);
./drivers/misc/bh1770glc.c:999:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:1019:	return sprintf(buf, "%d\n", lux_rates_hz[chip->lux_rate_index]);
./drivers/misc/bh1770glc.c:1038:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:1039:	chip->lux_rate_index = i;
./drivers/misc/bh1770glc.c:1041:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:1053:	return sprintf(buf, "%d\n", chip->lux_threshold_hi);
./drivers/misc/bh1770glc.c:1060:	return sprintf(buf, "%d\n", chip->lux_threshold_lo);
./drivers/misc/bh1770glc.c:1076:	mutex_lock(&chip->mutex);
./drivers/misc/bh1770glc.c:1082:	if (!chip->lux_wait_result)
./drivers/misc/bh1770glc.c:1084:						chip->lux_threshold_hi,
./drivers/misc/bh1770glc.c:1085:						chip->lux_threshold_lo);
./drivers/misc/bh1770glc.c:1086:	mutex_unlock(&chip->mutex);
./drivers/misc/bh1770glc.c:1096:	int ret = bh1770_set_lux_thresh(chip, &chip->lux_threshold_hi, buf);
./drivers/misc/bh1770glc.c:1107:	int ret = bh1770_set_lux_thresh(chip, &chip->lux_threshold_lo, buf);
./drivers/misc/bh1770glc.c:1193:	chip->client  = client;
./drivers/misc/bh1770glc.c:1195:	mutex_init(&chip->mutex);
./drivers/misc/bh1770glc.c:1196:	init_waitqueue_head(&chip->wait);
./drivers/misc/bh1770glc.c:1197:	INIT_DELAYED_WORK(&chip->prox_work, bh1770_prox_work);
./drivers/misc/bh1770glc.c:1204:	chip->pdata		= client->dev.platform_data;
./drivers/misc/bh1770glc.c:1205:	chip->lux_calib		= BH1770_LUX_NEUTRAL_CALIB_VALUE;
./drivers/misc/bh1770glc.c:1206:	chip->lux_rate_index	= BH1770_LUX_DEFAULT_RATE;
./drivers/misc/bh1770glc.c:1207:	chip->lux_threshold_lo	= BH1770_LUX_DEF_THRES;
./drivers/misc/bh1770glc.c:1208:	chip->lux_threshold_hi	= BH1770_LUX_DEF_THRES;
./drivers/misc/bh1770glc.c:1210:	if (chip->pdata->glass_attenuation == 0)
./drivers/misc/bh1770glc.c:1211:		chip->lux_ga = BH1770_NEUTRAL_GA;
./drivers/misc/bh1770glc.c:1213:		chip->lux_ga = chip->pdata->glass_attenuation;
./drivers/misc/bh1770glc.c:1215:	chip->prox_threshold	= BH1770_PROX_DEF_THRES;
./drivers/misc/bh1770glc.c:1216:	chip->prox_led		= chip->pdata->led_def_curr;
./drivers/misc/bh1770glc.c:1217:	chip->prox_abs_thres	= BH1770_PROX_DEF_ABS_THRES;
./drivers/misc/bh1770glc.c:1218:	chip->prox_persistence	= BH1770_DEFAULT_PERSISTENCE;
./drivers/misc/bh1770glc.c:1219:	chip->prox_rate_threshold = BH1770_PROX_DEF_RATE_THRESH;
./drivers/misc/bh1770glc.c:1220:	chip->prox_rate		= BH1770_PROX_DEFAULT_RATE;
./drivers/misc/bh1770glc.c:1221:	chip->prox_data		= 0;
./drivers/misc/bh1770glc.c:1223:	chip->regs[0].supply = reg_vcc;
./drivers/misc/bh1770glc.c:1224:	chip->regs[1].supply = reg_vleds;
./drivers/misc/bh1770glc.c:1227:				      ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/bh1770glc.c:1233:	err = regulator_bulk_enable(ARRAY_SIZE(chip->regs),
./drivers/misc/bh1770glc.c:1234:				chip->regs);
./drivers/misc/bh1770glc.c:1250:	chip->lux_corr = bh1770_get_corr_value(chip);
./drivers/misc/bh1770glc.c:1251:	if (chip->lux_corr == 0) {
./drivers/misc/bh1770glc.c:1257:	if (chip->pdata->setup_resources) {
./drivers/misc/bh1770glc.c:1258:		err = chip->pdata->setup_resources();
./drivers/misc/bh1770glc.c:1265:	err = sysfs_create_group(&chip->client->dev.kobj,
./drivers/misc/bh1770glc.c:1268:		dev_err(&chip->client->dev, "Sysfs registration failed\n");
./drivers/misc/bh1770glc.c:1287:	regulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/bh1770glc.c:1290:	sysfs_remove_group(&chip->client->dev.kobj,
./drivers/misc/bh1770glc.c:1293:	if (chip->pdata->release_resources)
./drivers/misc/bh1770glc.c:1294:		chip->pdata->release_resources();
./drivers/misc/bh1770glc.c:1296:	regulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);
./drivers/misc/bh1770glc.c:1306:	sysfs_remove_group(&chip->client->dev.kobj,
./drivers/misc/bh1770glc.c:1309:	if (chip->pdata->release_resources)
./drivers/misc/bh1770glc.c:1310:		chip->pdata->release_resources();
./drivers/misc/bh1770glc.c:1312:	cancel_delayed_work_sync(&chip->prox_work);
./drivers/misc/bh1770glc.c:1347:		ret = bh1770_lux_rate(chip, chip->lux_rate_index);
./drivers/misc/bh1770glc.c:1354:		chip->lux_wait_result = true;
./drivers/misc/fsa9480.c:447:	if (chip->pdata->reset_cb)
./drivers/misc/fsa9480.c:448:		chip->pdata->reset_cb();
./drivers/misc/bmp085.c:284: * This function sets the chip-internal oversampling. Valid values are 0..3.
./drivers/misc/bmp085.c:405:	if (!of_property_read_u32(np, "chip-id", &prop))
./drivers/misc/eeprom/at25.c:256:	strncpy(chip->name, "at25", sizeof(chip->name));
./drivers/misc/eeprom/at25.c:260:		chip->byte_len = val;
./drivers/misc/eeprom/at25.c:268:		chip->page_size = (u16)val;
./drivers/misc/eeprom/at25.c:275:		chip->flags = (u16)val;
./drivers/misc/eeprom/at25.c:284:			chip->flags |= EE_ADDR1;
./drivers/misc/eeprom/at25.c:287:			chip->flags |= EE_ADDR2;
./drivers/misc/eeprom/at25.c:290:			chip->flags |= EE_ADDR3;
./drivers/misc/eeprom/at25.c:299:			chip->flags |= EE_READONLY;
./drivers/misc/eeprom/at24.c:410:			chip->flags |= AT24_FLAG_READONLY;
./drivers/misc/eeprom/at24.c:413:			chip->page_size = be32_to_cpup(val);
./drivers/misc/cs5535-mfgpt.c:222:		spin_lock_irqsave(&timer->chip->lock, flags);
./drivers/misc/cs5535-mfgpt.c:223:		__set_bit(timer->nr, timer->chip->avail);
./drivers/misc/cs5535-mfgpt.c:224:		spin_unlock_irqrestore(&timer->chip->lock, flags);
./drivers/misc/cs5535-mfgpt.c:233:	return inw(timer->chip->base + reg + (timer->nr * 8));
./drivers/misc/cs5535-mfgpt.c:240:	outw(value, timer->chip->base + reg + (timer->nr * 8));
./drivers/misc/cb710/debug.c:90:	cb710_read_regs_##t(chip->iobase, regs, select);		\
./drivers/misc/cb710/core.c:71:	struct cb710_slot *slot = &chip->slot[0];
./drivers/misc/cb710/core.c:75:	spin_lock(&chip->irq_lock); /* incl. smp_rmb() */
./drivers/misc/cb710/core.c:77:	for (nr = chip->slots; nr; ++slot, --nr) {
./drivers/misc/cb710/core.c:83:	spin_unlock(&chip->irq_lock);
./drivers/misc/cb710/core.c:95:	atomic_dec(&chip->slot_refs_count);
./drivers/misc/cb710/core.c:102:	int nr = chip->slots;
./drivers/misc/cb710/core.c:103:	struct cb710_slot *slot = &chip->slot[nr];
./drivers/misc/cb710/core.c:108:		name, chip->platform_id, nr, slot_mask, io_offset);
./drivers/misc/cb710/core.c:112:	++chip->slots;
./drivers/misc/cb710/core.c:115:	slot->iobase = chip->iobase + io_offset;
./drivers/misc/cb710/core.c:117:	slot->pdev.id = chip->platform_id;
./drivers/misc/cb710/core.c:118:	slot->pdev.dev.parent = &chip->pdev->dev;
./drivers/misc/cb710/core.c:124:	atomic_inc(&chip->slot_refs_count);
./drivers/misc/cb710/core.c:133:		--chip->slots;
./drivers/misc/cb710/core.c:137:	chip->slot_mask |= slot_mask;
./drivers/misc/cb710/core.c:145:	int nr = chip->slots - 1;
./drivers/misc/cb710/core.c:147:	if (!(chip->slot_mask & slot_mask))
./drivers/misc/cb710/core.c:150:	platform_device_unregister(&chip->slot[nr].pdev);
./drivers/misc/cb710/core.c:154:	BUG_ON(chip->slot[nr].irq_handler != NULL);
./drivers/misc/cb710/core.c:157:	--chip->slots;
./drivers/misc/cb710/core.c:158:	chip->slot_mask &= ~slot_mask;
./drivers/misc/cb710/core.c:167:	spin_lock_irqsave(&chip->irq_lock, flags);
./drivers/misc/cb710/core.c:169:	spin_unlock_irqrestore(&chip->irq_lock, flags);
./drivers/misc/cb710/core.c:236:		sizeof(*chip) + n * sizeof(*chip->slot), GFP_KERNEL);
./drivers/misc/cb710/core.c:248:	spin_lock_init(&chip->irq_lock);
./drivers/misc/cb710/core.c:249:	chip->pdev = pdev;
./drivers/misc/cb710/core.c:250:	chip->iobase = pcim_iomap_table(pdev)[0];
./drivers/misc/cb710/core.c:264:		err = ida_get_new(&cb710_ida, &chip->platform_id);
./drivers/misc/cb710/core.c:273:		chip->platform_id, chip->iobase, pdev->irq);
./drivers/misc/cb710/core.c:303:	BUG_ON(atomic_read(&chip->slot_refs_count) != 0);
./drivers/misc/cb710/core.c:317:	BUG_ON(atomic_read(&chip->slot_refs_count) != 0);
./drivers/misc/cb710/core.c:321:	ida_remove(&cb710_ida, chip->platform_id);
./drivers/misc/pch_phub.c:157:	void __iomem *reg_addr = chip->pch_phub_base_address + reg_addr_offset;
./drivers/misc/pch_phub.c:168:	void __iomem *p = chip->pch_phub_base_address;
./drivers/misc/pch_phub.c:170:	chip->phub_id_reg = ioread32(p + PCH_PHUB_ID_REG);
./drivers/misc/pch_phub.c:171:	chip->q_pri_val_reg = ioread32(p + PCH_PHUB_QUEUE_PRI_VAL_REG);
./drivers/misc/pch_phub.c:172:	chip->rc_q_maxsize_reg = ioread32(p + PCH_PHUB_RC_QUEUE_MAXSIZE_REG);
./drivers/misc/pch_phub.c:173:	chip->bri_q_maxsize_reg = ioread32(p + PCH_PHUB_BRI_QUEUE_MAXSIZE_REG);
./drivers/misc/pch_phub.c:174:	chip->comp_resp_timeout_reg =
./drivers/misc/pch_phub.c:176:	chip->bus_slave_control_reg =
./drivers/misc/pch_phub.c:178:	chip->deadlock_avoid_type_reg =
./drivers/misc/pch_phub.c:180:	chip->intpin_reg_wpermit_reg0 =
./drivers/misc/pch_phub.c:182:	chip->intpin_reg_wpermit_reg1 =
./drivers/misc/pch_phub.c:184:	chip->intpin_reg_wpermit_reg2 =
./drivers/misc/pch_phub.c:186:	chip->intpin_reg_wpermit_reg3 =
./drivers/misc/pch_phub.c:189:		"chip->phub_id_reg=%x, "
./drivers/misc/pch_phub.c:190:		"chip->q_pri_val_reg=%x, "
./drivers/misc/pch_phub.c:191:		"chip->rc_q_maxsize_reg=%x, "
./drivers/misc/pch_phub.c:192:		"chip->bri_q_maxsize_reg=%x, "
./drivers/misc/pch_phub.c:193:		"chip->comp_resp_timeout_reg=%x, "
./drivers/misc/pch_phub.c:194:		"chip->bus_slave_control_reg=%x, "
./drivers/misc/pch_phub.c:195:		"chip->deadlock_avoid_type_reg=%x, "
./drivers/misc/pch_phub.c:196:		"chip->intpin_reg_wpermit_reg0=%x, "
./drivers/misc/pch_phub.c:197:		"chip->intpin_reg_wpermit_reg1=%x, "
./drivers/misc/pch_phub.c:198:		"chip->intpin_reg_wpermit_reg2=%x, "
./drivers/misc/pch_phub.c:199:		"chip->intpin_reg_wpermit_reg3=%x\n", __func__,
./drivers/misc/pch_phub.c:200:		chip->phub_id_reg,
./drivers/misc/pch_phub.c:201:		chip->q_pri_val_reg,
./drivers/misc/pch_phub.c:202:		chip->rc_q_maxsize_reg,
./drivers/misc/pch_phub.c:203:		chip->bri_q_maxsize_reg,
./drivers/misc/pch_phub.c:204:		chip->comp_resp_timeout_reg,
./drivers/misc/pch_phub.c:205:		chip->bus_slave_control_reg,
./drivers/misc/pch_phub.c:206:		chip->deadlock_avoid_type_reg,
./drivers/misc/pch_phub.c:207:		chip->intpin_reg_wpermit_reg0,
./drivers/misc/pch_phub.c:208:		chip->intpin_reg_wpermit_reg1,
./drivers/misc/pch_phub.c:209:		chip->intpin_reg_wpermit_reg2,
./drivers/misc/pch_phub.c:210:		chip->intpin_reg_wpermit_reg3);
./drivers/misc/pch_phub.c:212:		chip->int_reduce_control_reg[i] =
./drivers/misc/pch_phub.c:215:			"chip->int_reduce_control_reg[%d]=%x\n",
./drivers/misc/pch_phub.c:216:			__func__, i, chip->int_reduce_control_reg[i]);
./drivers/misc/pch_phub.c:218:	chip->clkcfg_reg = ioread32(p + CLKCFG_REG_OFFSET);
./drivers/misc/pch_phub.c:219:	if ((chip->ioh_type == 2) || (chip->ioh_type == 4))
./drivers/misc/pch_phub.c:220:		chip->funcsel_reg = ioread32(p + FUNCSEL_REG_OFFSET);
./drivers/misc/pch_phub.c:229:	p = chip->pch_phub_base_address;
./drivers/misc/pch_phub.c:231:	iowrite32(chip->phub_id_reg, p + PCH_PHUB_ID_REG);
./drivers/misc/pch_phub.c:232:	iowrite32(chip->q_pri_val_reg, p + PCH_PHUB_QUEUE_PRI_VAL_REG);
./drivers/misc/pch_phub.c:233:	iowrite32(chip->rc_q_maxsize_reg, p + PCH_PHUB_RC_QUEUE_MAXSIZE_REG);
./drivers/misc/pch_phub.c:234:	iowrite32(chip->bri_q_maxsize_reg, p + PCH_PHUB_BRI_QUEUE_MAXSIZE_REG);
./drivers/misc/pch_phub.c:235:	iowrite32(chip->comp_resp_timeout_reg,
./drivers/misc/pch_phub.c:237:	iowrite32(chip->bus_slave_control_reg,
./drivers/misc/pch_phub.c:239:	iowrite32(chip->deadlock_avoid_type_reg,
./drivers/misc/pch_phub.c:241:	iowrite32(chip->intpin_reg_wpermit_reg0,
./drivers/misc/pch_phub.c:243:	iowrite32(chip->intpin_reg_wpermit_reg1,
./drivers/misc/pch_phub.c:245:	iowrite32(chip->intpin_reg_wpermit_reg2,
./drivers/misc/pch_phub.c:247:	iowrite32(chip->intpin_reg_wpermit_reg3,
./drivers/misc/pch_phub.c:250:		"chip->phub_id_reg=%x, "
./drivers/misc/pch_phub.c:251:		"chip->q_pri_val_reg=%x, "
./drivers/misc/pch_phub.c:252:		"chip->rc_q_maxsize_reg=%x, "
./drivers/misc/pch_phub.c:253:		"chip->bri_q_maxsize_reg=%x, "
./drivers/misc/pch_phub.c:254:		"chip->comp_resp_timeout_reg=%x, "
./drivers/misc/pch_phub.c:255:		"chip->bus_slave_control_reg=%x, "
./drivers/misc/pch_phub.c:256:		"chip->deadlock_avoid_type_reg=%x, "
./drivers/misc/pch_phub.c:257:		"chip->intpin_reg_wpermit_reg0=%x, "
./drivers/misc/pch_phub.c:258:		"chip->intpin_reg_wpermit_reg1=%x, "
./drivers/misc/pch_phub.c:259:		"chip->intpin_reg_wpermit_reg2=%x, "
./drivers/misc/pch_phub.c:260:		"chip->intpin_reg_wpermit_reg3=%x\n", __func__,
./drivers/misc/pch_phub.c:261:		chip->phub_id_reg,
./drivers/misc/pch_phub.c:262:		chip->q_pri_val_reg,
./drivers/misc/pch_phub.c:263:		chip->rc_q_maxsize_reg,
./drivers/misc/pch_phub.c:264:		chip->bri_q_maxsize_reg,
./drivers/misc/pch_phub.c:265:		chip->comp_resp_timeout_reg,
./drivers/misc/pch_phub.c:266:		chip->bus_slave_control_reg,
./drivers/misc/pch_phub.c:267:		chip->deadlock_avoid_type_reg,
./drivers/misc/pch_phub.c:268:		chip->intpin_reg_wpermit_reg0,
./drivers/misc/pch_phub.c:269:		chip->intpin_reg_wpermit_reg1,
./drivers/misc/pch_phub.c:270:		chip->intpin_reg_wpermit_reg2,
./drivers/misc/pch_phub.c:271:		chip->intpin_reg_wpermit_reg3);
./drivers/misc/pch_phub.c:273:		iowrite32(chip->int_reduce_control_reg[i],
./drivers/misc/pch_phub.c:276:			"chip->int_reduce_control_reg[%d]=%x\n",
./drivers/misc/pch_phub.c:277:			__func__, i, chip->int_reduce_control_reg[i]);
./drivers/misc/pch_phub.c:280:	iowrite32(chip->clkcfg_reg, p + CLKCFG_REG_OFFSET);
./drivers/misc/pch_phub.c:281:	if ((chip->ioh_type == 2) || (chip->ioh_type == 4))
./drivers/misc/pch_phub.c:282:		iowrite32(chip->funcsel_reg, p + FUNCSEL_REG_OFFSET);
./drivers/misc/pch_phub.c:294:	void __iomem *mem_addr = chip->pch_phub_extrom_base_address +
./drivers/misc/pch_phub.c:308:	void __iomem *mem_addr = chip->pch_phub_extrom_base_address +
./drivers/misc/pch_phub.c:318:			chip->pch_phub_extrom_base_address + PHUB_CONTROL);
./drivers/misc/pch_phub.c:324:	while (ioread8(chip->pch_phub_extrom_base_address +
./drivers/misc/pch_phub.c:333:			chip->pch_phub_extrom_base_address + PHUB_CONTROL);
./drivers/misc/pch_phub.c:348:	mem_addr = chip->pch_mac_start_address +
./drivers/misc/pch_phub.c:365:	mem_addr = chip->pch_mac_start_address +
./drivers/misc/pch_phub.c:477:	if ((chip->ioh_type == 1) || (chip->ioh_type == 5)) /* EG20T or ML7831*/
./drivers/misc/pch_phub.c:515:	chip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);
./drivers/misc/pch_phub.c:516:	if (!chip->pch_phub_extrom_base_address) {
./drivers/misc/pch_phub.c:521:	pch_phub_read_serial_rom(chip, chip->pch_opt_rom_start_address,
./drivers/misc/pch_phub.c:524:	pch_phub_read_serial_rom(chip, chip->pch_opt_rom_start_address + 1,
./drivers/misc/pch_phub.c:529:					 chip->pch_opt_rom_start_address + 2,
./drivers/misc/pch_phub.c:543:			    chip->pch_opt_rom_start_address + addr_offset + off,
./drivers/misc/pch_phub.c:551:	pci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);
./drivers/misc/pch_phub.c:556:	pci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);
./drivers/misc/pch_phub.c:586:	chip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);
./drivers/misc/pch_phub.c:587:	if (!chip->pch_phub_extrom_base_address) {
./drivers/misc/pch_phub.c:597:			    chip->pch_opt_rom_start_address + addr_offset + off,
./drivers/misc/pch_phub.c:606:	pci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);
./drivers/misc/pch_phub.c:611:	pci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);
./drivers/misc/pch_phub.c:625:	chip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);
./drivers/misc/pch_phub.c:626:	if (!chip->pch_phub_extrom_base_address)
./drivers/misc/pch_phub.c:630:	pci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);
./drivers/misc/pch_phub.c:646:	chip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);
./drivers/misc/pch_phub.c:647:	if (!chip->pch_phub_extrom_base_address)
./drivers/misc/pch_phub.c:651:	pci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);
./drivers/misc/pch_phub.c:698:	chip->pch_phub_base_address = pci_iomap(pdev, 1, 0);
./drivers/misc/pch_phub.c:701:	if (chip->pch_phub_base_address == NULL) {
./drivers/misc/pch_phub.c:708:		chip->pch_phub_base_address);
./drivers/misc/pch_phub.c:710:	chip->pdev = pdev; /* Save pci device struct */
./drivers/misc/pch_phub.c:739:		iowrite32(0x000affaa, chip->pch_phub_base_address + 0x14);
./drivers/misc/pch_phub.c:741:		iowrite32(0x25, chip->pch_phub_base_address + 0x44);
./drivers/misc/pch_phub.c:742:		chip->pch_opt_rom_start_address = PCH_PHUB_ROM_START_ADDR_EG20T;
./drivers/misc/pch_phub.c:743:		chip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_EG20T;
./drivers/misc/pch_phub.c:754:		iowrite32(0x000affa0, chip->pch_phub_base_address + 0x14);
./drivers/misc/pch_phub.c:755:		chip->pch_opt_rom_start_address =\
./drivers/misc/pch_phub.c:761:		iowrite32(0x000a0000, chip->pch_phub_base_address + 0x14);
./drivers/misc/pch_phub.c:763:		iowrite32(0x25, chip->pch_phub_base_address + 0x140);
./drivers/misc/pch_phub.c:764:		chip->pch_opt_rom_start_address =\
./drivers/misc/pch_phub.c:766:		chip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_ML7223;
./drivers/misc/pch_phub.c:780:		iowrite32(0x0000ffa0, chip->pch_phub_base_address + 0x14);
./drivers/misc/pch_phub.c:781:		chip->pch_opt_rom_start_address =\
./drivers/misc/pch_phub.c:783:		chip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_ML7223;
./drivers/misc/pch_phub.c:795:		iowrite32(0x000affaa, chip->pch_phub_base_address + 0x14);
./drivers/misc/pch_phub.c:797:		iowrite32(0x25, chip->pch_phub_base_address + 0x44);
./drivers/misc/pch_phub.c:798:		chip->pch_opt_rom_start_address = PCH_PHUB_ROM_START_ADDR_EG20T;
./drivers/misc/pch_phub.c:799:		chip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_EG20T;
./drivers/misc/pch_phub.c:802:	chip->ioh_type = id->driver_data;
./drivers/misc/pch_phub.c:810:	pci_iounmap(pdev, chip->pch_phub_base_address);
./drivers/misc/pch_phub.c:827:	pci_iounmap(pdev, chip->pch_phub_base_address);
./drivers/scsi/mesh.c:1855:	switch (mdev->bus->chip->type) {
./drivers/scsi/bfa/bfa_core.c:1472: * Actions on chip-reset completion.
./drivers/scsi/bfa/bfa_hw_ct.c:26: * Dummy interrupt handler for handling spurious interrupt during chip-reinit.
./drivers/scsi/pmcraid.c:5205:	/* Initialize chip-specific details */
./drivers/scsi/ipr.c:8508:	if (ioa_cfg->ipr_chip->bist_method == IPR_MMIO)
./drivers/scsi/ipr.c:9998:	ioa_cfg->sis64 = ioa_cfg->ipr_chip->sis_type == IPR_SIS64 ? 1 : 0;
./drivers/scsi/ipr.c:9999:	ioa_cfg->chip_cfg = ioa_cfg->ipr_chip->cfg;
./drivers/scsi/ipr.c:10088:	if (ioa_cfg->ipr_chip->intr_type == IPR_USE_MSI &&
./drivers/scsi/ipr.c:10091:	else if (ioa_cfg->ipr_chip->intr_type == IPR_USE_MSI &&
./drivers/scsi/mpt3sas/mpt3sas_base.c:336:	doorbell = readl(&ioc->chip->Doorbell);
./drivers/scsi/mpt3sas/mpt3sas_base.c:340:		writel(0xC0FFEE00, &ioc->chip->Doorbell);
./drivers/scsi/mpt3sas/mpt3sas_base.c:907:	him_register = readl(&ioc->chip->HostInterruptMask);
./drivers/scsi/mpt3sas/mpt3sas_base.c:909:	writel(him_register, &ioc->chip->HostInterruptMask);
./drivers/scsi/mpt3sas/mpt3sas_base.c:910:	readl(&ioc->chip->HostInterruptMask);
./drivers/scsi/mpt3sas/mpt3sas_base.c:926:	him_register = readl(&ioc->chip->HostInterruptMask);
./drivers/scsi/mpt3sas/mpt3sas_base.c:928:	writel(him_register, &ioc->chip->HostInterruptMask);
./drivers/scsi/mpt3sas/mpt3sas_base.c:1031:				    &ioc->chip->ReplyFreeHostIndex);
./drivers/scsi/mpt3sas/mpt3sas_base.c:1089:			&ioc->chip->ReplyPostHostIndex);
./drivers/scsi/mpt3sas/mpt3sas_base.c:2184:			     ((u8 *)&ioc->chip->Doorbell +
./drivers/scsi/mpt3sas/mpt3sas_base.c:2193:		    &ioc->chip->ReplyPostHostIndex;
./drivers/scsi/mpt3sas/mpt3sas_base.c:2198:			((u8 __iomem *)&ioc->chip->Doorbell + (0x4000 + ((i - 1)
./drivers/scsi/mpt3sas/mpt3sas_base.c:2485:	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
./drivers/scsi/mpt3sas/mpt3sas_base.c:2510:	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
./drivers/scsi/mpt3sas/mpt3sas_base.c:2534:	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
./drivers/scsi/mpt3sas/mpt3sas_base.c:2556:	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
./drivers/scsi/mpt3sas/mpt3sas_base.c:3652:	s = readl(&ioc->chip->Doorbell);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3714:		int_status = readl(&ioc->chip->HostInterruptStatus);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3756:		int_status = readl(&ioc->chip->HostInterruptStatus);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3763:			doorbell = readl(&ioc->chip->Doorbell);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3805:		doorbell_reg = readl(&ioc->chip->Doorbell);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3854:	    &ioc->chip->Doorbell);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3897:	if ((readl(&ioc->chip->Doorbell) & MPI2_DOORBELL_USED)) {
./drivers/scsi/mpt3sas/mpt3sas_base.c:3905:	if (readl(&ioc->chip->HostInterruptStatus) &
./drivers/scsi/mpt3sas/mpt3sas_base.c:3907:		writel(0, &ioc->chip->HostInterruptStatus);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3912:	    &ioc->chip->Doorbell);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3920:	writel(0, &ioc->chip->HostInterruptStatus);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3931:		writel(cpu_to_le32(request[i]), &ioc->chip->Doorbell);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3952:	reply[0] = le16_to_cpu(readl(&ioc->chip->Doorbell)
./drivers/scsi/mpt3sas/mpt3sas_base.c:3954:	writel(0, &ioc->chip->HostInterruptStatus);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3961:	reply[1] = le16_to_cpu(readl(&ioc->chip->Doorbell)
./drivers/scsi/mpt3sas/mpt3sas_base.c:3963:	writel(0, &ioc->chip->HostInterruptStatus);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3973:			dummy = readl(&ioc->chip->Doorbell);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3975:			reply[i] = le16_to_cpu(readl(&ioc->chip->Doorbell)
./drivers/scsi/mpt3sas/mpt3sas_base.c:3977:		writel(0, &ioc->chip->HostInterruptStatus);
./drivers/scsi/mpt3sas/mpt3sas_base.c:3985:	writel(0, &ioc->chip->HostInterruptStatus);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4861:		writel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4862:		writel(MPI2_WRSEQ_1ST_KEY_VALUE, &ioc->chip->WriteSequence);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4863:		writel(MPI2_WRSEQ_2ND_KEY_VALUE, &ioc->chip->WriteSequence);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4864:		writel(MPI2_WRSEQ_3RD_KEY_VALUE, &ioc->chip->WriteSequence);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4865:		writel(MPI2_WRSEQ_4TH_KEY_VALUE, &ioc->chip->WriteSequence);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4866:		writel(MPI2_WRSEQ_5TH_KEY_VALUE, &ioc->chip->WriteSequence);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4867:		writel(MPI2_WRSEQ_6TH_KEY_VALUE, &ioc->chip->WriteSequence);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4878:		host_diagnostic = readl(&ioc->chip->HostDiagnostic);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4885:	hcb_size = readl(&ioc->chip->HCBSize);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4890:	     &ioc->chip->HostDiagnostic);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4902:		host_diagnostic = readl(&ioc->chip->HostDiagnostic);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4925:		writel(host_diagnostic, &ioc->chip->HostDiagnostic);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4930:		    &ioc->chip->HCBSize);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4936:	    &ioc->chip->HostDiagnostic);
./drivers/scsi/mpt3sas/mpt3sas_base.c:4940:	writel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);
./drivers/scsi/mpt3sas/mpt3sas_base.c:5169:	writel(ioc->reply_free_host_index, &ioc->chip->ReplyFreeHostIndex);
./drivers/scsi/mpt3sas/mpt3sas_base.c:5180:				&ioc->chip->ReplyPostHostIndex);
./drivers/scsi/sym53c8xx_2/sym_hipd.c:1299:		if (device_id != chip->device_id)
./drivers/scsi/sym53c8xx_2/sym_hipd.c:1301:		if (revision > chip->revision_id)
./drivers/scsi/sym53c8xx_2/sym_hipd.c:1815:	 *  regardless revision id (kind of post-chip-design feature. ;-))
./drivers/scsi/sym53c8xx_2/sym_fw.c:352:	if (chip->features & FE_LDSTR)
./drivers/scsi/sym53c8xx_2/sym_fw.c:355:	else if (!(chip->features & (FE_PFEN|FE_NOPM|FE_DAC)))
./drivers/scsi/sym53c8xx_2/sym_glue.c:1488:		chip->features	|= (FE_WRIE | FE_CLSE);
./drivers/scsi/sym53c8xx_2/sym_glue.c:1492:	if (chip->features & FE_WRIE) {
./drivers/scsi/sym53c8xx_2/sym_glue.c:1509:	if (chip->features & FE_66MHZ) {
./drivers/scsi/sym53c8xx_2/sym_glue.c:1511:			chip->features &= ~FE_66MHZ;
./drivers/scsi/sym53c8xx_2/sym_glue.c:1810:	if (!(chip->features & FE_66MHZ) && (status_reg & PCI_STATUS_66MHZ)) {
./drivers/scsi/mvsas/mv_94xx.c:476:	for (i = 0; i < mvi->chip->n_phy; i++) {
./drivers/scsi/mvsas/mv_94xx.c:502:	for (i = 0; i < mvi->chip->n_phy; i++) {
./drivers/scsi/mvsas/mv_94xx.c:847:			port_id + mvi->id * mvi->chip->n_phy, i, id_frame[i]);
./drivers/scsi/mvsas/mv_64xx.c:50:	if (mvi->chip->n_phy <= MVS_SOC_PORTS)
./drivers/scsi/mvsas/mv_64xx.c:72:		for (i = 0; i < mvi->chip->n_phy; i++) {
./drivers/scsi/mvsas/mv_64xx.c:337:	for (i = 0; i < mvi->chip->n_phy; i++) {
./drivers/scsi/mvsas/mv_64xx.c:360:	for (i = 0; i < mvi->chip->n_phy; i++) {
./drivers/scsi/mvsas/mv_64xx.c:546:	for (i = 0; i < mvi->chip->srs_sz; i++) {
./drivers/scsi/mvsas/mv_init.c:99:	sas_phy->enabled = (phy_id < mvi->chip->n_phy) ? 1 : 0;
./drivers/scsi/mvsas/mv_init.c:241:	for (i = 0; i < mvi->chip->n_phy; i++) {
./drivers/scsi/mvsas/mv_init.c:384:	((struct mvs_prv_info *)sha->lldd_ha)->n_phy = mvi->chip->n_phy;
./drivers/scsi/mvsas/mv_init.c:516:	for (i = 0; i < mvi->chip->n_phy; i++) {
./drivers/scsi/mvsas/mv_init.c:593:	} while (nhost < chip->n_host);
./drivers/scsi/mvsas/mv_sas.c:123:				phyno[n] = (j >= mvi->chip->n_phy) ?
./drivers/scsi/mvsas/mv_sas.c:124:					(j - mvi->chip->n_phy) : j;
./drivers/scsi/mvsas/mv_sas.c:277:	mv_dprintk("phy %d byte dmaded.\n", i + mvi->id * mvi->chip->n_phy);
./drivers/scsi/mvsas/mv_sas.c:297:		for (i = 0; i < mvi->chip->n_phy; ++i)
./drivers/scsi/mvsas/mv_sas.c:1041:					i + mvi->id * mvi->chip->n_phy;
./drivers/scsi/mvsas/mv_sas.c:1082:		i + mvi->id * mvi->chip->n_phy, phy->att_dev_info);
./drivers/scsi/mvsas/mv_sas.c:1084:		i + mvi->id * mvi->chip->n_phy, phy->att_dev_sas_addr);
./drivers/scsi/mvsas/mv_sas.c:1108:	if (i >= mvi->chip->n_phy)
./drivers/scsi/mvsas/mv_sas.c:1109:		port = &mvi->port[i - mvi->chip->n_phy];
./drivers/scsi/mvsas/mv_sas.c:1961:	for (phy_no = 0; phy_no < mvi->chip->n_phy; phy_no++) {
./drivers/scsi/mvsas/mv_sas.c:1964:				phy_no+mvi->id*mvi->chip->n_phy);
./drivers/scsi/mvsas/mv_sas.c:1977:	mv_dprintk("phy %d ctrl sts=0x%08X.\n", phy_no+mvi->id*mvi->chip->n_phy,
./drivers/scsi/mvsas/mv_sas.c:1979:	mv_dprintk("phy %d irq sts = 0x%08X\n", phy_no+mvi->id*mvi->chip->n_phy,
./drivers/scsi/mvsas/mv_sas.c:1989:		phy_no + mvi->id*mvi->chip->n_phy);
./drivers/scsi/mvsas/mv_sas.c:2054:				phy_no + mvi->id*mvi->chip->n_phy);
./drivers/scsi/mvsas/mv_sas.c:2058:			phy_no + mvi->id*mvi->chip->n_phy);
./drivers/scsi/qla2xxx/qla_os.c:5045:						 * Escalate to chip-reset
./drivers/scsi/pm8001/pm8001_init.c:126:	sas_phy->enabled = (phy_id < pm8001_ha->chip->n_phy) ? 1 : 0;
./drivers/scsi/pm8001/pm8001_init.c:254:				pm8001_ha->chip->n_phy));
./drivers/scsi/pm8001/pm8001_init.c:255:	for (i = 0; i < pm8001_ha->chip->n_phy; i++) {
./drivers/scsi/pm8001/pm8001_init.c:678:	for (i = 0; i < pm8001_ha->chip->n_phy; i++) {
./drivers/scsi/pm8001/pm8001_init.c:687:	for (i = 0; i < pm8001_ha->chip->n_phy; i++) {
./drivers/scsi/pm8001/pm8001_init.c:842:	for (i = 0; i < pm8001_ha->chip->n_phy; i++) {
./drivers/scsi/pm8001/pm8001_init.c:1263:	for (i = 0; i < pm8001_ha->chip->n_phy; i++) {
./drivers/scsi/pm8001/pm80xx_hwi.c:1129:	if (pm8001_ha->chip->encrypt) {
./drivers/scsi/pm8001/pm80xx_hwi.c:3310:		for (i = 0; i < pm8001_ha->chip->n_phy; i++) {
./drivers/scsi/pm8001/pm80xx_hwi.c:3977:	if (pm8001_ha->chip->encrypt &&
./drivers/scsi/pm8001/pm80xx_hwi.c:4156:	if (pm8001_ha->chip->encrypt &&
./drivers/scsi/pm8001/pm80xx_hwi.c:4574:	for (i = 0; i < pm8001_ha->chip->n_phy; i++) {
./drivers/scsi/pm8001/pm8001_sas.c:250:	for (i = 0; i < pm8001_ha->chip->n_phy; ++i)
./drivers/iommu/rockchip-iommu.c:1118:MODULE_ALIAS("platform:rockchip-iommu");
./drivers/iommu/amd_iommu.c:4183:	ret = parent->chip->irq_set_affinity(parent, mask, force);
./drivers/iommu/intel_irq_remapping.c:1141:	ret = parent->chip->irq_set_affinity(parent, mask, force);
./drivers/gpu/drm/nouveau/nvkm/engine/device/user.c:119:	strncpy(args->v0.chip, device->chip->name, sizeof(args->v0.chip));
./drivers/gpu/drm/nouveau/nvkm/engine/device/base.c:2585:			   device->chip->name, boot0);
./drivers/gpu/drm/nouveau/nvkm/engine/device/base.c:2605:		device->name = device->chip->name;
./drivers/gpu/drm/nouveau/nvkm/engine/device/base.c:2620:	if (device->chip->m && (subdev_mask & (1ULL << (s)))) {                \
./drivers/gpu/drm/nouveau/nvkm/engine/device/base.c:2621:		ret = device->chip->m(device, (s), &device->m);                \
./drivers/gpu/drm/nouveau/nvkm/core/firmware.c:42:	strncpy(cname, device->chip->name, sizeof(cname));
./drivers/gpu/drm/nouveau/nvkm/subdev/secboot/base.c:131: * This function is to be called after all chip-specific preparations have
./drivers/gpu/drm/nouveau/nvkm/subdev/secboot/base.c:210:	/* Call chip-specific init function */
./drivers/gpu/drm/rockchip/rockchip_drm_drv.c:572:		.name = "rockchip-drm",
./drivers/gpu/drm/rockchip/rockchip_vop_reg.c:306:		.name = "rockchip-vop",
./drivers/gpu/drm/rockchip/analogix_dp-rockchip.c:378:		   .name = "rockchip-dp",
./drivers/soc/rockchip/pm_domains.c:740:		.name   = "rockchip-pm-domain",
./drivers/crypto/nx/nx-842-powernv.c:537:		pr_err("ibm,chip-id missing\n");
./drivers/platform/chrome/cros_ec_sysfs.c:208:		r_chip->vendor[sizeof(r_chip->vendor) - 1] = '\0';
./drivers/platform/chrome/cros_ec_sysfs.c:209:		r_chip->name[sizeof(r_chip->name) - 1] = '\0';
./drivers/platform/chrome/cros_ec_sysfs.c:210:		r_chip->revision[sizeof(r_chip->revision) - 1] = '\0';
./drivers/platform/chrome/cros_ec_sysfs.c:212:				   "Chip vendor:   %s\n", r_chip->vendor);
./drivers/platform/chrome/cros_ec_sysfs.c:214:				   "Chip name:     %s\n", r_chip->name);
./drivers/platform/chrome/cros_ec_sysfs.c:216:				   "Chip revision: %s\n", r_chip->revision);
./drivers/watchdog/imx2_wdt.c:124:	/* Generate internal chip-level reset if WDOG times out */
./drivers/watchdog/da9062_wdt.c:103:	return regmap_update_bits(chip->regmap,
./drivers/spi/spi-topcliff-pch.c:547:	data->n_curnt_chip = data->current_chip->chip_select;
./drivers/spi/spi-ppc4xx.c:406:	 * A count of zero implies a single SPI device without any chip-select.
./drivers/spi/spi-dw.c:141:	if (chip && chip->cs_control)
./drivers/spi/spi-dw.c:142:		chip->cs_control(!enable);
./drivers/spi/spi-dw.c:301:	if (transfer->speed_hz != chip->speed_hz) {
./drivers/spi/spi-dw.c:305:		chip->speed_hz = transfer->speed_hz;
./drivers/spi/spi-dw.c:306:		chip->clk_div = clk_div;
./drivers/spi/spi-dw.c:308:		spi_set_clk(dws, chip->clk_div);
./drivers/spi/spi-dw.c:321:		| (chip->type << SPI_FRF_OFFSET)
./drivers/spi/spi-dw.c:323:		| (chip->tmode << SPI_TMOD_OFFSET);
./drivers/spi/spi-dw.c:329:	if (chip->cs_control) {
./drivers/spi/spi-dw.c:331:			chip->tmode = SPI_TMOD_TR;
./drivers/spi/spi-dw.c:333:			chip->tmode = SPI_TMOD_RO;
./drivers/spi/spi-dw.c:335:			chip->tmode = SPI_TMOD_TO;
./drivers/spi/spi-dw.c:338:		cr0 |= (chip->tmode << SPI_TMOD_OFFSET);
./drivers/spi/spi-dw.c:360:	} else if (!chip->poll_mode) {
./drivers/spi/spi-dw.c:380:	if (chip->poll_mode)
./drivers/spi/spi-dw.c:422:			chip->cs_control = chip_info->cs_control;
./drivers/spi/spi-dw.c:424:		chip->poll_mode = chip_info->poll_mode;
./drivers/spi/spi-dw.c:425:		chip->type = chip_info->type;
./drivers/spi/spi-dw.c:428:	chip->tmode = SPI_TMOD_TR;
./drivers/spi/spi-pxa2xx-dma.c:179:		cfg.dst_maxburst = chip->dma_burst_size;
./drivers/spi/spi-pxa2xx-dma.c:187:		cfg.src_maxburst = chip->dma_burst_size;
./drivers/spi/spi-pxa2xx-dma.c:214:	if (!chip->enable_dma)
./drivers/spi/spi-pxa2xx-dma.c:218:	if (drv_data->len < chip->dma_burst_size)
./drivers/spi/spi-bfin5xx.c:167:	if (likely(chip->chip_select_num < MAX_CTRL_CS))
./drivers/spi/spi-bfin5xx.c:168:		bfin_write_and(&drv_data->regs->flg, ~chip->flag);
./drivers/spi/spi-bfin5xx.c:170:		gpio_set_value(chip->cs_gpio, 0);
./drivers/spi/spi-bfin5xx.c:176:	if (likely(chip->chip_select_num < MAX_CTRL_CS))
./drivers/spi/spi-bfin5xx.c:177:		bfin_write_or(&drv_data->regs->flg, chip->flag);
./drivers/spi/spi-bfin5xx.c:179:		gpio_set_value(chip->cs_gpio, 1);
./drivers/spi/spi-bfin5xx.c:182:	if (chip->cs_chg_udelay)
./drivers/spi/spi-bfin5xx.c:183:		udelay(chip->cs_chg_udelay);
./drivers/spi/spi-bfin5xx.c:190:	if (chip->chip_select_num < MAX_CTRL_CS)
./drivers/spi/spi-bfin5xx.c:191:		bfin_write_or(&drv_data->regs->flg, chip->flag >> 8);
./drivers/spi/spi-bfin5xx.c:197:	if (chip->chip_select_num < MAX_CTRL_CS)
./drivers/spi/spi-bfin5xx.c:198:		bfin_write_and(&drv_data->regs->flg, ~(chip->flag >> 8));
./drivers/spi/spi-bfin5xx.c:214:	bfin_write(&drv_data->regs->ctl, chip->ctl_reg);
./drivers/spi/spi-bfin5xx.c:215:	bfin_write(&drv_data->regs->baud, chip->baud);
./drivers/spi/spi-bfin5xx.c:245:	u16 tx_val = drv_data->cur_chip->idle_tx_val;
./drivers/spi/spi-bfin5xx.c:296:	u16 tx_val = drv_data->cur_chip->idle_tx_val;
./drivers/spi/spi-bfin5xx.c:446:				bfin_write(&drv_data->regs->tdbr, chip->idle_tx_val);
./drivers/spi/spi-bfin5xx.c:452:				bfin_write(&drv_data->regs->tdbr, chip->idle_tx_val);
./drivers/spi/spi-bfin5xx.c:658:		"transfer: drv_data->ops is %p, chip->ops is %p, u8_ops is %p\n",
./drivers/spi/spi-bfin5xx.c:659:		drv_data->ops, chip->ops, &bfin_bfin_spi_transfer_ops_u8);
./drivers/spi/spi-bfin5xx.c:679:	if (!full_duplex && drv_data->cur_chip->enable_dma
./drivers/spi/spi-bfin5xx.c:787:	if (chip->pio_interrupt) {
./drivers/spi/spi-bfin5xx.c:795:			bfin_write(&drv_data->regs->tdbr, chip->idle_tx_val);
./drivers/spi/spi-bfin5xx.c:911:		drv_data->cur_chip->baud, drv_data->cur_chip->flag,
./drivers/spi/spi-bfin5xx.c:912:		drv_data->cur_chip->ctl_reg);
./drivers/spi/spi-bfin5xx.c:992:		chip->enable_dma = 0;
./drivers/spi/spi-bfin5xx.c:1013:		chip->enable_dma = chip_info->enable_dma != 0
./drivers/spi/spi-bfin5xx.c:1015:		chip->ctl_reg = chip_info->ctl_reg;
./drivers/spi/spi-bfin5xx.c:1016:		chip->cs_chg_udelay = chip_info->cs_chg_udelay;
./drivers/spi/spi-bfin5xx.c:1017:		chip->idle_tx_val = chip_info->idle_tx_val;
./drivers/spi/spi-bfin5xx.c:1018:		chip->pio_interrupt = chip_info->pio_interrupt;
./drivers/spi/spi-bfin5xx.c:1021:		chip->ctl_reg &= bfin_ctl_reg;
./drivers/spi/spi-bfin5xx.c:1026:		chip->ctl_reg |= BIT_CTL_CPOL;
./drivers/spi/spi-bfin5xx.c:1028:		chip->ctl_reg |= BIT_CTL_CPHA;
./drivers/spi/spi-bfin5xx.c:1030:		chip->ctl_reg |= BIT_CTL_LSBF;
./drivers/spi/spi-bfin5xx.c:1032:	chip->ctl_reg |= BIT_CTL_MASTER;
./drivers/spi/spi-bfin5xx.c:1038:	chip->baud = hz_to_spi_baud(spi->max_speed_hz);
./drivers/spi/spi-bfin5xx.c:1039:	chip->chip_select_num = spi->chip_select;
./drivers/spi/spi-bfin5xx.c:1040:	if (chip->chip_select_num < MAX_CTRL_CS) {
./drivers/spi/spi-bfin5xx.c:1046:		chip->flag = (1 << spi->chip_select) << 8;
./drivers/spi/spi-bfin5xx.c:1048:		chip->cs_gpio = chip->chip_select_num - MAX_CTRL_CS;
./drivers/spi/spi-bfin5xx.c:1050:	if (chip->enable_dma && chip->pio_interrupt) {
./drivers/spi/spi-bfin5xx.c:1059:	if (chip->enable_dma && !drv_data->dma_requested) {
./drivers/spi/spi-bfin5xx.c:1078:	if (chip->pio_interrupt && !drv_data->irq_requested) {
./drivers/spi/spi-bfin5xx.c:1090:	if (chip->chip_select_num >= MAX_CTRL_CS) {
./drivers/spi/spi-bfin5xx.c:1093:			ret = gpio_request(chip->cs_gpio, spi->modalias);
./drivers/spi/spi-bfin5xx.c:1098:			gpio_direction_output(chip->cs_gpio, 1);
./drivers/spi/spi-bfin5xx.c:1103:			spi->modalias, spi->bits_per_word, chip->enable_dma);
./drivers/spi/spi-bfin5xx.c:1105:			chip->ctl_reg, chip->flag);
./drivers/spi/spi-bfin5xx.c:1109:	dev_dbg(&spi->dev, "chip select number is %d\n", chip->chip_select_num);
./drivers/spi/spi-bfin5xx.c:1110:	if (chip->chip_select_num < MAX_CTRL_CS) {
./drivers/spi/spi-bfin5xx.c:1112:		                         [chip->chip_select_num-1], spi->modalias);
./drivers/spi/spi-bfin5xx.c:1125:	if (chip->chip_select_num >= MAX_CTRL_CS)
./drivers/spi/spi-bfin5xx.c:1126:		gpio_free(chip->cs_gpio);
./drivers/spi/spi-bfin5xx.c:1129:			[chip->chip_select_num - 1]);
./drivers/spi/spi-bfin5xx.c:1156:	if (chip->chip_select_num < MAX_CTRL_CS) {
./drivers/spi/spi-bfin5xx.c:1158:					[chip->chip_select_num-1]);
./drivers/spi/spi-bfin5xx.c:1161:		gpio_free(chip->cs_gpio);
./drivers/spi/spi-pl022.c:478:		pl022->cur_chip->cs_control(command);
./drivers/spi/spi-pl022.c:571:		writel(chip->cr0, SSP_CR0(pl022->virtbase));
./drivers/spi/spi-pl022.c:573:		writew(chip->cr0, SSP_CR0(pl022->virtbase));
./drivers/spi/spi-pl022.c:574:	writew(chip->cr1, SSP_CR1(pl022->virtbase));
./drivers/spi/spi-pl022.c:575:	writew(chip->dmacr, SSP_DMACR(pl022->virtbase));
./drivers/spi/spi-pl022.c:576:	writew(chip->cpsr, SSP_CPSR(pl022->virtbase));
./drivers/spi/spi-pl022.c:715:		pl022->rx += (pl022->cur_chip->n_bytes);
./drivers/spi/spi-pl022.c:737:		pl022->tx += (pl022->cur_chip->n_bytes);
./drivers/spi/spi-pl022.c:764:			pl022->rx += (pl022->cur_chip->n_bytes);
./drivers/spi/spi-pl022.c:1357:	residue = pl022->cur_transfer->len % pl022->cur_chip->n_bytes;
./drivers/spi/spi-pl022.c:1363:			pl022->cur_chip->n_bytes);
./drivers/spi/spi-pl022.c:1372:	    pl022->tx ? pl022->cur_chip->write : WRITING_NULL;
./drivers/spi/spi-pl022.c:1373:	pl022->read = pl022->rx ? pl022->cur_chip->read : READING_NULL;
./drivers/spi/spi-pl022.c:1437:	if (pl022->cur_chip->enable_dma) {
./drivers/spi/spi-pl022.c:1471:	if (pl022->cur_chip->enable_dma) {
./drivers/spi/spi-pl022.c:1584:	if (pl022->cur_chip->xfer_type == POLLING_TRANSFER)
./drivers/spi/spi-pl022.c:1922:	chip->xfer_type = chip_info->com_mode;
./drivers/spi/spi-pl022.c:1924:		chip->cs_control = null_cs_control;
./drivers/spi/spi-pl022.c:1929:		chip->cs_control = chip_info->cs_control;
./drivers/spi/spi-pl022.c:1940:		chip->n_bytes = 1;
./drivers/spi/spi-pl022.c:1941:		chip->read = READING_U8;
./drivers/spi/spi-pl022.c:1942:		chip->write = WRITING_U8;
./drivers/spi/spi-pl022.c:1945:		chip->n_bytes = 2;
./drivers/spi/spi-pl022.c:1946:		chip->read = READING_U16;
./drivers/spi/spi-pl022.c:1947:		chip->write = WRITING_U16;
./drivers/spi/spi-pl022.c:1950:		chip->n_bytes = 4;
./drivers/spi/spi-pl022.c:1951:		chip->read = READING_U32;
./drivers/spi/spi-pl022.c:1952:		chip->write = WRITING_U32;
./drivers/spi/spi-pl022.c:1956:	chip->cr0 = 0;
./drivers/spi/spi-pl022.c:1957:	chip->cr1 = 0;
./drivers/spi/spi-pl022.c:1958:	chip->dmacr = 0;
./drivers/spi/spi-pl022.c:1959:	chip->cpsr = 0;
./drivers/spi/spi-pl022.c:1962:		chip->enable_dma = true;
./drivers/spi/spi-pl022.c:1964:		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,
./drivers/spi/spi-pl022.c:1966:		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,
./drivers/spi/spi-pl022.c:1969:		chip->enable_dma = false;
./drivers/spi/spi-pl022.c:1971:		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,
./drivers/spi/spi-pl022.c:1973:		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,
./drivers/spi/spi-pl022.c:1977:	chip->cpsr = clk_freq.cpsdvsr;
./drivers/spi/spi-pl022.c:1985:			SSP_WRITE_BITS(chip->cr1, chip_info->clkdelay,
./drivers/spi/spi-pl022.c:1989:			SSP_WRITE_BITS(chip->cr0, chip_info->duplex,
./drivers/spi/spi-pl022.c:1991:			SSP_WRITE_BITS(chip->cr0, chip_info->ctrl_len,
./drivers/spi/spi-pl022.c:1993:			SSP_WRITE_BITS(chip->cr0, chip_info->iface,
./drivers/spi/spi-pl022.c:1995:			SSP_WRITE_BITS(chip->cr1, chip_info->wait_state,
./drivers/spi/spi-pl022.c:1998:		SSP_WRITE_BITS(chip->cr0, bits - 1,
./drivers/spi/spi-pl022.c:2008:		SSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_RENDN_ST, 4);
./drivers/spi/spi-pl022.c:2009:		SSP_WRITE_BITS(chip->cr1, etx, SSP_CR1_MASK_TENDN_ST, 5);
./drivers/spi/spi-pl022.c:2010:		SSP_WRITE_BITS(chip->cr1, chip_info->rx_lev_trig,
./drivers/spi/spi-pl022.c:2012:		SSP_WRITE_BITS(chip->cr1, chip_info->tx_lev_trig,
./drivers/spi/spi-pl022.c:2015:		SSP_WRITE_BITS(chip->cr0, bits - 1,
./drivers/spi/spi-pl022.c:2017:		SSP_WRITE_BITS(chip->cr0, chip_info->iface,
./drivers/spi/spi-pl022.c:2026:	SSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPO, 6);
./drivers/spi/spi-pl022.c:2032:	SSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPH, 7);
./drivers/spi/spi-pl022.c:2034:	SSP_WRITE_BITS(chip->cr0, clk_freq.scr, SSP_CR0_MASK_SCR, 8);
./drivers/spi/spi-pl022.c:2041:		SSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_LBM, 0);
./drivers/spi/spi-pl022.c:2043:	SSP_WRITE_BITS(chip->cr1, SSP_DISABLED, SSP_CR1_MASK_SSE, 1);
./drivers/spi/spi-pl022.c:2044:	SSP_WRITE_BITS(chip->cr1, chip_info->hierarchy, SSP_CR1_MASK_MS, 2);
./drivers/spi/spi-pl022.c:2045:	SSP_WRITE_BITS(chip->cr1, chip_info->slave_tx_disable, SSP_CR1_MASK_SOD,
./drivers/spi/spi-pic32-sqi.c:366:	 * can be handled at best during spi chip-select switch.
./drivers/spi/spi-fsl-spi.c:723:		 * SPI w/o chip-select line. One SPI device is still permitted
./drivers/spi/spi-rockchip.c:25:#define DRIVER_NAME "rockchip-spi"
./drivers/spi/spi-rockchip.c:551:		pr_warn_once("rockchip-spi: %u Hz are too slow to express %u ns delay\n",
./drivers/spi/spi-rockchip.c:555:		pr_warn_once("rockchip-spi: %u Hz are too fast to express %u ns delay, clamping at %u ns\n",
./drivers/spi/spi-adi-v3.c:155:	if (likely(chip->cs < MAX_CTRL_CS)) {
./drivers/spi/spi-adi-v3.c:158:		reg &= ~chip->ssel;
./drivers/spi/spi-adi-v3.c:161:		gpio_set_value(chip->cs_gpio, 0);
./drivers/spi/spi-adi-v3.c:168:	if (likely(chip->cs < MAX_CTRL_CS)) {
./drivers/spi/spi-adi-v3.c:171:		reg |= chip->ssel;
./drivers/spi/spi-adi-v3.c:174:		gpio_set_value(chip->cs_gpio, 1);
./drivers/spi/spi-adi-v3.c:178:	if (chip->cs_chg_udelay)
./drivers/spi/spi-adi-v3.c:179:		udelay(chip->cs_chg_udelay);
./drivers/spi/spi-adi-v3.c:186:	if (chip->cs < MAX_CTRL_CS) {
./drivers/spi/spi-adi-v3.c:189:		reg |= chip->ssel >> 8;
./drivers/spi/spi-adi-v3.c:197:	if (chip->cs < MAX_CTRL_CS) {
./drivers/spi/spi-adi-v3.c:200:		reg &= ~(chip->ssel >> 8);
./drivers/spi/spi-adi-v3.c:217:	iowrite32(chip->control, &drv_data->regs->control);
./drivers/spi/spi-adi-v3.c:218:	iowrite32(chip->clock, &drv_data->regs->clock);
./drivers/spi/spi-adi-v3.c:248:	u32 tx_val = drv_data->cur_chip->tx_dummy_val;
./drivers/spi/spi-adi-v3.c:290:	u32 tx_val = drv_data->cur_chip->tx_dummy_val;
./drivers/spi/spi-adi-v3.c:335:	u32 tx_val = drv_data->cur_chip->tx_dummy_val;
./drivers/spi/spi-adi-v3.c:474:		drv_data->dummy_buffer = chip->tx_dummy_val;
./drivers/spi/spi-adi-v3.c:609:	if (chip->enable_dma)
./drivers/spi/spi-adi-v3.c:672:			chip->control = chip_info->control;
./drivers/spi/spi-adi-v3.c:673:			chip->cs_chg_udelay = chip_info->cs_chg_udelay;
./drivers/spi/spi-adi-v3.c:674:			chip->tx_dummy_val = chip_info->tx_dummy_val;
./drivers/spi/spi-adi-v3.c:675:			chip->enable_dma = chip_info->enable_dma;
./drivers/spi/spi-adi-v3.c:677:		chip->cs = spi->chip_select;
./drivers/spi/spi-adi-v3.c:679:		if (chip->cs < MAX_CTRL_CS) {
./drivers/spi/spi-adi-v3.c:680:			chip->ssel = (1 << chip->cs) << 8;
./drivers/spi/spi-adi-v3.c:682:					[chip->cs-1], dev_name(&spi->dev));
./drivers/spi/spi-adi-v3.c:688:			chip->cs_gpio = chip->cs - MAX_CTRL_CS;
./drivers/spi/spi-adi-v3.c:689:			ret = gpio_request_one(chip->cs_gpio, GPIOF_OUT_INIT_HIGH,
./drivers/spi/spi-adi-v3.c:700:	chip->control &= ctl_reg;
./drivers/spi/spi-adi-v3.c:703:		chip->control |= SPI_CTL_CPOL;
./drivers/spi/spi-adi-v3.c:705:		chip->control |= SPI_CTL_CPHA;
./drivers/spi/spi-adi-v3.c:707:		chip->control |= SPI_CTL_LSBF;
./drivers/spi/spi-adi-v3.c:708:	chip->control |= SPI_CTL_MSTR;
./drivers/spi/spi-adi-v3.c:710:	chip->control &= ~SPI_CTL_ASSEL;
./drivers/spi/spi-adi-v3.c:712:	chip->clock = hz_to_spi_clock(drv_data->sclk, spi->max_speed_hz);
./drivers/spi/spi-adi-v3.c:735:	if (chip->cs < MAX_CTRL_CS) {
./drivers/spi/spi-adi-v3.c:737:					[chip->cs-1]);
./drivers/spi/spi-adi-v3.c:740:		gpio_free(chip->cs_gpio);
./drivers/spi/spi-ep93xx.c:237:	if (chip->ops && chip->ops->cs_control)
./drivers/spi/spi-ep93xx.c:238:		chip->ops->cs_control(spi, value);
./drivers/spi/spi-ep93xx.c:264:		chip->spi = spi;
./drivers/spi/spi-ep93xx.c:265:		chip->ops = spi->controller_data;
./drivers/spi/spi-ep93xx.c:267:		if (chip->ops && chip->ops->setup) {
./drivers/spi/spi-ep93xx.c:268:			int ret = chip->ops->setup(spi);
./drivers/spi/spi-ep93xx.c:296:		if (chip->ops && chip->ops->cleanup)
./drivers/spi/spi-ep93xx.c:297:			chip->ops->cleanup(spi);
./drivers/spi/spi-ep93xx.c:325:	cr0 |= (chip->spi->mode & (SPI_CPHA|SPI_CPOL)) << SSPCR0_MODE_SHIFT;
./drivers/spi/spi-ep93xx.c:329:		chip->spi->mode, div_cpsr, div_scr, dss);
./drivers/spi/spi.c:579:	/* NOTE:  caller did any chip->bus_num checks necessary.
./drivers/spi/spi.c:590:	WARN_ON(strlen(chip->modalias) >= sizeof(proxy->modalias));
./drivers/spi/spi.c:592:	proxy->chip_select = chip->chip_select;
./drivers/spi/spi.c:593:	proxy->max_speed_hz = chip->max_speed_hz;
./drivers/spi/spi.c:594:	proxy->mode = chip->mode;
./drivers/spi/spi.c:595:	proxy->irq = chip->irq;
./drivers/spi/spi.c:596:	strlcpy(proxy->modalias, chip->modalias, sizeof(proxy->modalias));
./drivers/spi/spi.c:597:	proxy->dev.platform_data = (void *) chip->platform_data;
./drivers/spi/spi.c:598:	proxy->controller_data = chip->controller_data;
./drivers/spi/spi-pxa2xx.c:361:		pxa2xx_spi_write(drv_data, SSSR, drv_data->cur_chip->frm);
./drivers/spi/spi-pxa2xx.c:365:	if (chip->cs_control) {
./drivers/spi/spi-pxa2xx.c:366:		chip->cs_control(PXA2XX_CS_ASSERT);
./drivers/spi/spi-pxa2xx.c:370:	if (gpio_is_valid(chip->gpio_cs)) {
./drivers/spi/spi-pxa2xx.c:371:		gpio_set_value(chip->gpio_cs, chip->gpio_cs_inverted);
./drivers/spi/spi-pxa2xx.c:386:	if (chip->cs_control) {
./drivers/spi/spi-pxa2xx.c:387:		chip->cs_control(PXA2XX_CS_DEASSERT);
./drivers/spi/spi-pxa2xx.c:391:	if (gpio_is_valid(chip->gpio_cs)) {
./drivers/spi/spi-pxa2xx.c:392:		gpio_set_value(chip->gpio_cs, !chip->gpio_cs_inverted);
./drivers/spi/spi-pxa2xx.c:596:	sccr1_reg |= chip->threshold;
./drivers/spi/spi-pxa2xx.c:913:		clk_div = quark_x1000_get_clk_div(rate, &chip->dds_rate);
./drivers/spi/spi-pxa2xx.c:934:	u32 dma_thresh = drv_data->cur_chip->dma_threshold;
./drivers/spi/spi-pxa2xx.c:935:	u32 dma_burst = drv_data->cur_chip->dma_burst_size;
./drivers/spi/spi-pxa2xx.c:972:	if (!pxa2xx_spi_dma_is_possible(transfer->len) && chip->enable_dma) {
./drivers/spi/spi-pxa2xx.c:1000:	drv_data->n_bytes = chip->n_bytes;
./drivers/spi/spi-pxa2xx.c:1006:	drv_data->write = drv_data->tx ? chip->write : null_writer;
./drivers/spi/spi-pxa2xx.c:1007:	drv_data->read = drv_data->rx ? chip->read : null_reader;
./drivers/spi/spi-pxa2xx.c:1038:	if (chip->enable_dma) {
./drivers/spi/spi-pxa2xx.c:1065:		cr1 = chip->cr1 | dma_thresh | drv_data->dma_cr1;
./drivers/spi/spi-pxa2xx.c:1074:		cr1 = chip->cr1 | chip->threshold | drv_data->int_cr1;
./drivers/spi/spi-pxa2xx.c:1093:		    != chip->lpss_rx_threshold)
./drivers/spi/spi-pxa2xx.c:1095:					 chip->lpss_rx_threshold);
./drivers/spi/spi-pxa2xx.c:1097:		    != chip->lpss_tx_threshold)
./drivers/spi/spi-pxa2xx.c:1099:					 chip->lpss_tx_threshold);
./drivers/spi/spi-pxa2xx.c:1103:	    (pxa2xx_spi_read(drv_data, DDS_RATE) != chip->dds_rate))
./drivers/spi/spi-pxa2xx.c:1104:		pxa2xx_spi_write(drv_data, DDS_RATE, chip->dds_rate);
./drivers/spi/spi-pxa2xx.c:1113:			pxa2xx_spi_write(drv_data, SSTO, chip->timeout);
./drivers/spi/spi-pxa2xx.c:1121:			pxa2xx_spi_write(drv_data, SSTO, chip->timeout);
./drivers/spi/spi-pxa2xx.c:1174:	if (gpio_is_valid(chip->gpio_cs))
./drivers/spi/spi-pxa2xx.c:1175:		gpio_free(chip->gpio_cs);
./drivers/spi/spi-pxa2xx.c:1179:		chip->cs_control = chip_info->cs_control;
./drivers/spi/spi-pxa2xx.c:1191:		chip->gpio_cs = chip_info->gpio_cs;
./drivers/spi/spi-pxa2xx.c:1192:		chip->gpio_cs_inverted = spi->mode & SPI_CS_HIGH;
./drivers/spi/spi-pxa2xx.c:1194:		err = gpio_direction_output(chip->gpio_cs,
./drivers/spi/spi-pxa2xx.c:1195:					!chip->gpio_cs_inverted);
./drivers/spi/spi-pxa2xx.c:1247:			chip->frm = spi->chip_select;
./drivers/spi/spi-pxa2xx.c:1249:			chip->gpio_cs = -1;
./drivers/spi/spi-pxa2xx.c:1250:		chip->enable_dma = 0;
./drivers/spi/spi-pxa2xx.c:1251:		chip->timeout = TIMOUT_DFLT;
./drivers/spi/spi-pxa2xx.c:1259:	chip->cr1 = 0;
./drivers/spi/spi-pxa2xx.c:1262:			chip->timeout = chip_info->timeout;
./drivers/spi/spi-pxa2xx.c:1269:		chip->enable_dma = drv_data->master_info->enable_dma;
./drivers/spi/spi-pxa2xx.c:1270:		chip->dma_threshold = 0;
./drivers/spi/spi-pxa2xx.c:1272:			chip->cr1 = SSCR1_LBM;
./drivers/spi/spi-pxa2xx.c:1279:		chip->enable_dma = drv_data->master_info->enable_dma;
./drivers/spi/spi-pxa2xx.c:1282:	chip->lpss_rx_threshold = SSIRF_RxThresh(rx_thres);
./drivers/spi/spi-pxa2xx.c:1283:	chip->lpss_tx_threshold = SSITF_TxLoThresh(tx_thres)
./drivers/spi/spi-pxa2xx.c:1287:	 * chip_info goes away after setting chip->enable_dma, the
./drivers/spi/spi-pxa2xx.c:1289:	if (chip->enable_dma) {
./drivers/spi/spi-pxa2xx.c:1293:						&chip->dma_burst_size,
./drivers/spi/spi-pxa2xx.c:1294:						&chip->dma_threshold)) {
./drivers/spi/spi-pxa2xx.c:1302:		chip->threshold = (QUARK_X1000_SSCR1_RxTresh(rx_thres)
./drivers/spi/spi-pxa2xx.c:1308:		chip->threshold = (SSCR1_RxTresh(rx_thres) & SSCR1_RFT) |
./drivers/spi/spi-pxa2xx.c:1313:	chip->cr1 &= ~(SSCR1_SPO | SSCR1_SPH);
./drivers/spi/spi-pxa2xx.c:1314:	chip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)
./drivers/spi/spi-pxa2xx.c:1318:		chip->cr1 |= SSCR1_LBM;
./drivers/spi/spi-pxa2xx.c:1321:		chip->n_bytes = 1;
./drivers/spi/spi-pxa2xx.c:1322:		chip->read = u8_reader;
./drivers/spi/spi-pxa2xx.c:1323:		chip->write = u8_writer;
./drivers/spi/spi-pxa2xx.c:1325:		chip->n_bytes = 2;
./drivers/spi/spi-pxa2xx.c:1326:		chip->read = u16_reader;
./drivers/spi/spi-pxa2xx.c:1327:		chip->write = u16_writer;
./drivers/spi/spi-pxa2xx.c:1329:		chip->n_bytes = 4;
./drivers/spi/spi-pxa2xx.c:1330:		chip->read = u32_reader;
./drivers/spi/spi-pxa2xx.c:1331:		chip->write = u32_writer;
./drivers/spi/spi-pxa2xx.c:1350:	if (drv_data->ssp_type != CE4100_SSP && gpio_is_valid(chip->gpio_cs))
./drivers/spi/spi-pxa2xx.c:1351:		gpio_free(chip->gpio_cs);
./drivers/spi/spi-pic32.c:778:	master->num_chipselect	= 1; /* single chip-select */
./drivers/spi/spi-bfin-sport.c:147:	gpio_direction_output(chip->cs_gpio, 0);
./drivers/spi/spi-bfin-sport.c:153:	gpio_direction_output(chip->cs_gpio, 1);
./drivers/spi/spi-bfin-sport.c:155:	if (chip->cs_chg_udelay)
./drivers/spi/spi-bfin-sport.c:156:		udelay(chip->cs_chg_udelay);
./drivers/spi/spi-bfin-sport.c:184:	u16 tx_val = drv_data->cur_chip->idle_tx_val;
./drivers/spi/spi-bfin-sport.c:224:	u16 tx_val = drv_data->cur_chip->idle_tx_val;
./drivers/spi/spi-bfin-sport.c:258:	bfin_write(&drv_data->regs->tcr1, chip->ctl_reg);
./drivers/spi/spi-bfin-sport.c:259:	bfin_write(&drv_data->regs->tclkdiv, chip->baud);
./drivers/spi/spi-bfin-sport.c:262:	bfin_write(&drv_data->regs->rcr1, chip->ctl_reg & ~(ITCLK | ITFS));
./drivers/spi/spi-bfin-sport.c:520:		drv_data->cur_chip->baud, drv_data->cur_chip->cs_gpio,
./drivers/spi/spi-bfin-sport.c:521:		drv_data->cur_chip->ctl_reg);
./drivers/spi/spi-bfin-sport.c:594:			chip->cs_chg_udelay = chip_info->cs_chg_udelay;
./drivers/spi/spi-bfin-sport.c:595:			chip->idle_tx_val = chip_info->idle_tx_val;
./drivers/spi/spi-bfin-sport.c:604:		chip->ctl_reg &= ~TCKFE;
./drivers/spi/spi-bfin-sport.c:606:		chip->ctl_reg |= TCKFE;
./drivers/spi/spi-bfin-sport.c:609:		chip->ctl_reg |= TLSBIT;
./drivers/spi/spi-bfin-sport.c:611:		chip->ctl_reg &= ~TLSBIT;
./drivers/spi/spi-bfin-sport.c:614:	chip->ctl_reg |= ITCLK | ITFS | TFSR | LATFS | LTFS;
./drivers/spi/spi-bfin-sport.c:616:	chip->baud = bfin_sport_hz_to_spi_baud(spi->max_speed_hz);
./drivers/spi/spi-bfin-sport.c:618:	chip->cs_gpio = spi->chip_select;
./drivers/spi/spi-bfin-sport.c:619:	ret = gpio_request(chip->cs_gpio, spi->modalias);
./drivers/spi/spi-bfin-sport.c:626:			chip->ctl_reg, spi->chip_select);
./drivers/spi/spi-bfin-sport.c:651:	gpio_free(chip->cs_gpio);
./drivers/spi/spi-mxs.c:123:	 * toggle the chip-select lines (nCS pins).
./drivers/spi/spi-bcm2835.c:664:			/* use the "undefined" chip-select */
./drivers/spi/spi-bcm2835.c:674:		/* use the "undefined" chip-select as precaution */
./drivers/spi/spi-bcm2835.c:684:	return !strcmp(chip->label, data);
./drivers/spi/spi-bcm2835.c:704:			"setup: only two native chip-selects are supported\n");
./drivers/spi/spi-bcm2835.c:715:	spi->cs_gpio = chip->base + 8 - spi->chip_select;
./drivers/spi/spi-fsl-dspi.c:395:		dspi->void_write_data = dspi->cur_chip->void_write_data;
./drivers/spi/spi-fsl-dspi.c:410:		regmap_write(dspi->regmap, SPI_MCR, dspi->cur_chip->mcr_val);
./drivers/spi/spi-fsl-dspi.c:415:				dspi->cur_chip->ctar_val);
./drivers/spi/spi-fsl-dspi.c:479:	chip->mcr_val = SPI_MCR_MASTER | SPI_MCR_PCSIS |
./drivers/spi/spi-fsl-dspi.c:482:	chip->void_write_data = 0;
./drivers/spi/spi-fsl-dspi.c:493:	chip->ctar_val =  SPI_CTAR_FMSZ(fmsz)
./drivers/dma/dw/pci.c:49:	chip->dev = &pdev->dev;
./drivers/dma/dw/pci.c:50:	chip->regs = pcim_iomap_table(pdev)[0];
./drivers/dma/dw/pci.c:51:	chip->irq = pdev->irq;
./drivers/dma/dw/pci.c:52:	chip->pdata = pdata;
./drivers/dma/dw/core.c:1451:	dw = devm_kzalloc(chip->dev, sizeof(*dw), GFP_KERNEL);
./drivers/dma/dw/core.c:1455:	dw->pdata = devm_kzalloc(chip->dev, sizeof(*dw->pdata), GFP_KERNEL);
./drivers/dma/dw/core.c:1459:	dw->regs = chip->regs;
./drivers/dma/dw/core.c:1460:	chip->dw = dw;
./drivers/dma/dw/core.c:1462:	pm_runtime_get_sync(chip->dev);
./drivers/dma/dw/core.c:1464:	if (!chip->pdata) {
./drivers/dma/dw/core.c:1466:		dev_dbg(chip->dev, "DW_PARAMS: 0x%08x\n", dw_params);
./drivers/dma/dw/core.c:1491:	} else if (chip->pdata->nr_channels > DW_DMA_MAX_NR_CHANNELS) {
./drivers/dma/dw/core.c:1495:		memcpy(dw->pdata, chip->pdata, sizeof(*dw->pdata));
./drivers/dma/dw/core.c:1501:	dw->chan = devm_kcalloc(chip->dev, pdata->nr_channels, sizeof(*dw->chan),
./drivers/dma/dw/core.c:1515:	dw->desc_pool = dmam_pool_create("dw_dmac_desc_pool", chip->dev,
./drivers/dma/dw/core.c:1518:		dev_err(chip->dev, "No memory for descriptors dma pool\n");
./drivers/dma/dw/core.c:1525:	err = request_irq(chip->irq, dw_dma_interrupt, IRQF_SHARED,
./drivers/dma/dw/core.c:1565:			dev_dbg(chip->dev, "DWC_PARAMS[%d]: 0x%08x\n", i,
./drivers/dma/dw/core.c:1601:	dw->dma.dev = chip->dev;
./drivers/dma/dw/core.c:1627:	dev_info(chip->dev, "DesignWare DMA Controller, %d channels\n",
./drivers/dma/dw/core.c:1630:	pm_runtime_put_sync_suspend(chip->dev);
./drivers/dma/dw/core.c:1635:	free_irq(chip->irq, dw);
./drivers/dma/dw/core.c:1637:	pm_runtime_put_sync_suspend(chip->dev);
./drivers/dma/dw/core.c:1644:	struct dw_dma		*dw = chip->dw;
./drivers/dma/dw/core.c:1647:	pm_runtime_get_sync(chip->dev);
./drivers/dma/dw/core.c:1652:	free_irq(chip->irq, dw);
./drivers/dma/dw/core.c:1661:	pm_runtime_put_sync_suspend(chip->dev);
./drivers/dma/dw/core.c:1668:	struct dw_dma *dw = chip->dw;
./drivers/dma/dw/core.c:1677:	struct dw_dma *dw = chip->dw;
./drivers/dma/dw/platform.c:171:	chip->irq = platform_get_irq(pdev, 0);
./drivers/dma/dw/platform.c:172:	if (chip->irq < 0)
./drivers/dma/dw/platform.c:173:		return chip->irq;
./drivers/dma/dw/platform.c:176:	chip->regs = devm_ioremap_resource(dev, mem);
./drivers/dma/dw/platform.c:177:	if (IS_ERR(chip->regs))
./drivers/dma/dw/platform.c:178:		return PTR_ERR(chip->regs);
./drivers/dma/dw/platform.c:188:	chip->dev = dev;
./drivers/dma/dw/platform.c:189:	chip->pdata = pdata;
./drivers/dma/dw/platform.c:191:	chip->clk = devm_clk_get(chip->dev, "hclk");
./drivers/dma/dw/platform.c:192:	if (IS_ERR(chip->clk))
./drivers/dma/dw/platform.c:193:		return PTR_ERR(chip->clk);
./drivers/dma/dw/platform.c:194:	err = clk_prepare_enable(chip->clk);
./drivers/dma/dw/platform.c:208:						 dw_dma_of_xlate, chip->dw);
./drivers/dma/dw/platform.c:215:		dw_dma_acpi_controller_register(chip->dw);
./drivers/dma/dw/platform.c:221:	clk_disable_unprepare(chip->clk);
./drivers/dma/dw/platform.c:234:	clk_disable_unprepare(chip->clk);
./drivers/dma/dw/platform.c:252:	pm_runtime_get_sync(chip->dev);
./drivers/dma/dw/platform.c:254:	pm_runtime_put_sync_suspend(chip->dev);
./drivers/dma/dw/platform.c:256:	clk_disable_unprepare(chip->clk);
./drivers/dma/dw/platform.c:283:	clk_disable_unprepare(chip->clk);
./drivers/dma/dw/platform.c:293:	clk_prepare_enable(chip->clk);
./drivers/dma/hsu/pci.c:33:	dmaisr = readl(chip->regs + HSU_PCI_DMAISR);
./drivers/dma/hsu/pci.c:34:	for (i = 0; i < chip->hsu->nr_channels; i++) {
./drivers/dma/hsu/pci.c:73:	chip->dev = &pdev->dev;
./drivers/dma/hsu/pci.c:74:	chip->regs = pcim_iomap_table(pdev)[0];
./drivers/dma/hsu/pci.c:75:	chip->length = pci_resource_len(pdev, 0);
./drivers/dma/hsu/pci.c:76:	chip->offset = HSU_PCI_CHAN_OFFSET;
./drivers/dma/hsu/pci.c:77:	chip->irq = pdev->irq;
./drivers/dma/hsu/pci.c:85:	ret = request_irq(chip->irq, hsu_pci_irq, 0, "hsu_dma_pci", chip);
./drivers/dma/hsu/pci.c:102:	free_irq(chip->irq, chip);
./drivers/dma/hsu/hsu.c:149:	if (nr >= chip->hsu->nr_channels)
./drivers/dma/hsu/hsu.c:152:	hsuc = &chip->hsu->chan[nr];
./drivers/dma/hsu/hsu.c:372:	void __iomem *addr = chip->regs + chip->offset;
./drivers/dma/hsu/hsu.c:376:	hsu = devm_kzalloc(chip->dev, sizeof(*hsu), GFP_KERNEL);
./drivers/dma/hsu/hsu.c:380:	chip->hsu = hsu;
./drivers/dma/hsu/hsu.c:383:	hsu->nr_channels = (chip->length - chip->offset) / HSU_DMA_CHAN_LENGTH;
./drivers/dma/hsu/hsu.c:385:	hsu->chan = devm_kcalloc(chip->dev, hsu->nr_channels,
./drivers/dma/hsu/hsu.c:421:	hsu->dma.dev = chip->dev;
./drivers/dma/hsu/hsu.c:429:	dev_info(chip->dev, "Found HSU DMA, %d channels\n", hsu->nr_channels);
./drivers/dma/hsu/hsu.c:436:	struct hsu_dma *hsu = chip->hsu;
./drivers/dma/idma64.c:538:	idma64 = devm_kzalloc(chip->dev, sizeof(*idma64), GFP_KERNEL);
./drivers/dma/idma64.c:542:	idma64->regs = chip->regs;
./drivers/dma/idma64.c:543:	chip->idma64 = idma64;
./drivers/dma/idma64.c:545:	idma64->chan = devm_kcalloc(chip->dev, nr_chan, sizeof(*idma64->chan),
./drivers/dma/idma64.c:555:	ret = devm_request_irq(chip->dev, chip->irq, idma64_irq, IRQF_SHARED,
./drivers/dma/idma64.c:556:			       dev_name(chip->dev), idma64);
./drivers/dma/idma64.c:592:	idma64->dma.dev = chip->dev;
./drivers/dma/idma64.c:600:	dev_info(chip->dev, "Found Intel integrated DMA 64-bit\n");
./drivers/dma/idma64.c:606:	struct idma64 *idma64 = chip->idma64;
./drivers/dma/idma64.c:615:	devm_free_irq(chip->dev, chip->irq, idma64);
./drivers/dma/idma64.c:639:	chip->irq = platform_get_irq(pdev, 0);
./drivers/dma/idma64.c:640:	if (chip->irq < 0)
./drivers/dma/idma64.c:641:		return chip->irq;
./drivers/dma/idma64.c:644:	chip->regs = devm_ioremap_resource(dev, mem);
./drivers/dma/idma64.c:645:	if (IS_ERR(chip->regs))
./drivers/dma/idma64.c:646:		return PTR_ERR(chip->regs);
./drivers/dma/idma64.c:652:	chip->dev = dev;
./drivers/dma/idma64.c:676:	idma64_off(chip->idma64);
./drivers/dma/idma64.c:685:	idma64_on(chip->idma64);
./drivers/power/max17040_battery.c:64:		val->intval = chip->status;
./drivers/power/max17040_battery.c:67:		val->intval = chip->online;
./drivers/power/max17040_battery.c:70:		val->intval = chip->vcell;
./drivers/power/max17040_battery.c:73:		val->intval = chip->soc;
./drivers/power/max17040_battery.c:120:	chip->vcell = (msb << 4) + (lsb >> 4);
./drivers/power/max17040_battery.c:132:	chip->soc = msb;
./drivers/power/max17040_battery.c:150:	if (chip->pdata && chip->pdata->battery_online)
./drivers/power/max17040_battery.c:151:		chip->online = chip->pdata->battery_online();
./drivers/power/max17040_battery.c:153:		chip->online = 1;
./drivers/power/max17040_battery.c:160:	if (!chip->pdata || !chip->pdata->charger_online
./drivers/power/max17040_battery.c:161:			|| !chip->pdata->charger_enable) {
./drivers/power/max17040_battery.c:162:		chip->status = POWER_SUPPLY_STATUS_UNKNOWN;
./drivers/power/max17040_battery.c:166:	if (chip->pdata->charger_online()) {
./drivers/power/max17040_battery.c:167:		if (chip->pdata->charger_enable())
./drivers/power/max17040_battery.c:168:			chip->status = POWER_SUPPLY_STATUS_CHARGING;
./drivers/power/max17040_battery.c:170:			chip->status = POWER_SUPPLY_STATUS_NOT_CHARGING;
./drivers/power/max17040_battery.c:172:		chip->status = POWER_SUPPLY_STATUS_DISCHARGING;
./drivers/power/max17040_battery.c:175:	if (chip->soc > MAX17040_BATTERY_FULL)
./drivers/power/max17040_battery.c:176:		chip->status = POWER_SUPPLY_STATUS_FULL;
./drivers/power/max17040_battery.c:185:	max17040_get_vcell(chip->client);
./drivers/power/max17040_battery.c:186:	max17040_get_soc(chip->client);
./drivers/power/max17040_battery.c:187:	max17040_get_online(chip->client);
./drivers/power/max17040_battery.c:188:	max17040_get_status(chip->client);
./drivers/power/max17040_battery.c:190:	queue_delayed_work(system_power_efficient_wq, &chip->work,
./drivers/power/max17040_battery.c:223:	chip->client = client;
./drivers/power/max17040_battery.c:224:	chip->pdata = client->dev.platform_data;
./drivers/power/max17040_battery.c:229:	chip->battery = power_supply_register(&client->dev,
./drivers/power/max17040_battery.c:231:	if (IS_ERR(chip->battery)) {
./drivers/power/max17040_battery.c:233:		return PTR_ERR(chip->battery);
./drivers/power/max17040_battery.c:239:	INIT_DEFERRABLE_WORK(&chip->work, max17040_work);
./drivers/power/max17040_battery.c:240:	queue_delayed_work(system_power_efficient_wq, &chip->work,
./drivers/power/max17040_battery.c:250:	power_supply_unregister(chip->battery);
./drivers/power/max17040_battery.c:251:	cancel_delayed_work(&chip->work);
./drivers/power/max17040_battery.c:262:	cancel_delayed_work(&chip->work);
./drivers/power/max17040_battery.c:271:	queue_delayed_work(system_power_efficient_wq, &chip->work,
./drivers/power/88pm860x_charger.c:691:	    (chip->id == CHIP_PM8607) ? chip->client : chip->companion;
./drivers/power/88pm860x_charger.c:693:	    (chip->id == CHIP_PM8607) ? chip->companion : chip->client;
./drivers/power/88pm860x_charger.c:724:			dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
./drivers/power/avs/rockchip-io-domain.c:467:		.name  = "rockchip-iodomain",
./drivers/power/sbs-battery.c:182:	if (chip->pdata)
./drivers/power/sbs-battery.c:183:		retries = max(chip->pdata->i2c_retry_count + 1, 1);
./drivers/power/sbs-battery.c:210:	if (chip->pdata) {
./drivers/power/sbs-battery.c:211:		retries_length = max(chip->pdata->i2c_retry_count + 1, 1);
./drivers/power/sbs-battery.c:212:		retries_block = max(chip->pdata->i2c_retry_count + 1, 1);
./drivers/power/sbs-battery.c:277:	if (chip->pdata)
./drivers/power/sbs-battery.c:278:		retries = max(chip->pdata->i2c_retry_count + 1, 1);
./drivers/power/sbs-battery.c:306:		chip->gpio_detect) {
./drivers/power/sbs-battery.c:307:		ret = gpio_get_value(chip->pdata->battery_detect);
./drivers/power/sbs-battery.c:308:		if (ret == chip->pdata->battery_detect_present)
./drivers/power/sbs-battery.c:312:		chip->is_present = val->intval;
./drivers/power/sbs-battery.c:390:		if (chip->poll_time == 0)
./drivers/power/sbs-battery.c:391:			chip->last_state = val->intval;
./drivers/power/sbs-battery.c:392:		else if (chip->last_state != val->intval) {
./drivers/power/sbs-battery.c:393:			cancel_delayed_work_sync(&chip->work);
./drivers/power/sbs-battery.c:394:			power_supply_changed(chip->power_supply);
./drivers/power/sbs-battery.c:395:			chip->poll_time = 0;
./drivers/power/sbs-battery.c:560:	struct i2c_client *client = chip->client;
./drivers/power/sbs-battery.c:634:	if (!chip->enable_detection)
./drivers/power/sbs-battery.c:637:	if (!chip->gpio_detect &&
./drivers/power/sbs-battery.c:638:		chip->is_present != (ret >= 0)) {
./drivers/power/sbs-battery.c:639:		chip->is_present = (ret >= 0);
./drivers/power/sbs-battery.c:640:		power_supply_changed(chip->power_supply);
./drivers/power/sbs-battery.c:652:	if (ret && chip->is_present)
./drivers/power/sbs-battery.c:675:	if (chip->ignore_changes > 0) {
./drivers/power/sbs-battery.c:676:		chip->ignore_changes--;
./drivers/power/sbs-battery.c:681:	cancel_delayed_work_sync(&chip->work);
./drivers/power/sbs-battery.c:683:	schedule_delayed_work(&chip->work, HZ);
./drivers/power/sbs-battery.c:684:	chip->poll_time = chip->pdata->poll_retry_count;
./drivers/power/sbs-battery.c:694:	ret = sbs_read_word_data(chip->client, sbs_data[REG_STATUS].addr);
./drivers/power/sbs-battery.c:697:		chip->poll_time = 0;
./drivers/power/sbs-battery.c:708:	if (chip->last_state != ret) {
./drivers/power/sbs-battery.c:709:		chip->poll_time = 0;
./drivers/power/sbs-battery.c:710:		power_supply_changed(chip->power_supply);
./drivers/power/sbs-battery.c:713:	if (chip->poll_time > 0) {
./drivers/power/sbs-battery.c:714:		schedule_delayed_work(&chip->work, HZ);
./drivers/power/sbs-battery.c:715:		chip->poll_time--;
./drivers/power/sbs-battery.c:826:	chip->client = client;
./drivers/power/sbs-battery.c:827:	chip->enable_detection = false;
./drivers/power/sbs-battery.c:828:	chip->gpio_detect = false;
./drivers/power/sbs-battery.c:834:	chip->ignore_changes = 1;
./drivers/power/sbs-battery.c:835:	chip->last_state = POWER_SUPPLY_STATUS_UNKNOWN;
./drivers/power/sbs-battery.c:840:		chip->gpio_detect = gpio_is_valid(pdata->battery_detect);
./drivers/power/sbs-battery.c:841:		chip->pdata = pdata;
./drivers/power/sbs-battery.c:846:	if (!chip->gpio_detect)
./drivers/power/sbs-battery.c:852:		chip->gpio_detect = false;
./drivers/power/sbs-battery.c:860:		chip->gpio_detect = false;
./drivers/power/sbs-battery.c:868:		chip->gpio_detect = false;
./drivers/power/sbs-battery.c:874:		dev_name(&client->dev), chip->power_supply);
./drivers/power/sbs-battery.c:878:		chip->gpio_detect = false;
./drivers/power/sbs-battery.c:882:	chip->irq = irq;
./drivers/power/sbs-battery.c:899:	chip->power_supply = power_supply_register(&client->dev, sbs_desc,
./drivers/power/sbs-battery.c:901:	if (IS_ERR(chip->power_supply)) {
./drivers/power/sbs-battery.c:904:		rc = PTR_ERR(chip->power_supply);
./drivers/power/sbs-battery.c:911:	INIT_DELAYED_WORK(&chip->work, sbs_delayed_work);
./drivers/power/sbs-battery.c:913:	chip->enable_detection = true;
./drivers/power/sbs-battery.c:918:	if (chip->irq)
./drivers/power/sbs-battery.c:919:		free_irq(chip->irq, chip->power_supply);
./drivers/power/sbs-battery.c:920:	if (chip->gpio_detect)
./drivers/power/sbs-battery.c:932:	if (chip->irq)
./drivers/power/sbs-battery.c:933:		free_irq(chip->irq, chip->power_supply);
./drivers/power/sbs-battery.c:934:	if (chip->gpio_detect)
./drivers/power/sbs-battery.c:935:		gpio_free(chip->pdata->battery_detect);
./drivers/power/sbs-battery.c:937:	power_supply_unregister(chip->power_supply);
./drivers/power/sbs-battery.c:939:	cancel_delayed_work_sync(&chip->work);
./drivers/power/sbs-battery.c:955:	if (chip->poll_time > 0)
./drivers/power/sbs-battery.c:956:		cancel_delayed_work_sync(&chip->work);
./drivers/power/sbs-battery.c:961:	if (chip->is_present && ret < 0)
./drivers/power/max17042_battery.c:103:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:127:	ret = regmap_read(chip->regmap, MAX17042_AvgVCELL, &val);
./drivers/power/max17042_battery.c:136:	ret = regmap_read(chip->regmap, MAX17042_VCELL, &val);
./drivers/power/max17042_battery.c:145:	if (vavg < chip->pdata->vmin) {
./drivers/power/max17042_battery.c:150:	if (vbatt > chip->pdata->vmax + MAX17042_VMAX_TOLERANCE) {
./drivers/power/max17042_battery.c:159:	if (temp <= chip->pdata->temp_min) {
./drivers/power/max17042_battery.c:164:	if (temp >= chip->pdata->temp_max) {
./drivers/power/max17042_battery.c:183:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:187:	if (!chip->init_complete)
./drivers/power/max17042_battery.c:217:		if (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17042)
./drivers/power/max17042_battery.c:289:		val->intval = chip->pdata->temp_min;
./drivers/power/max17042_battery.c:292:		val->intval = chip->pdata->temp_max;
./drivers/power/max17042_battery.c:300:		if (chip->pdata->enable_current_sense) {
./drivers/power/max17042_battery.c:312:			val->intval *= 1562500 / chip->pdata->r_sns;
./drivers/power/max17042_battery.c:318:		if (chip->pdata->enable_current_sense) {
./drivers/power/max17042_battery.c:330:			val->intval *= 1562500 / chip->pdata->r_sns;
./drivers/power/max17042_battery.c:346:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:434:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:442:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:451:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:456:			chip->pdata->config_data->cell_char_tbl[i]);
./drivers/power/max17042_battery.c:462:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:475:		dev_err(&chip->client->dev, "%s compare failed\n", __func__);
./drivers/power/max17042_battery.c:477:			dev_info(&chip->client->dev, "0x%x, 0x%x",
./drivers/power/max17042_battery.c:479:		dev_info(&chip->client->dev, "\n");
./drivers/power/max17042_battery.c:488:	int table_size = ARRAY_SIZE(chip->pdata->config_data->cell_char_tbl);
./drivers/power/max17042_battery.c:503:		chip->pdata->config_data->cell_char_tbl,
./drivers/power/max17042_battery.c:516:	int table_size = ARRAY_SIZE(chip->pdata->config_data->cell_char_tbl);
./drivers/power/max17042_battery.c:536:	struct max17042_config_data *config = chip->pdata->config_data;
./drivers/power/max17042_battery.c:537:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:544:	if (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17047 ||
./drivers/power/max17042_battery.c:545:			chip->chip_type == MAXIM_DEVICE_TYPE_MAX17050)
./drivers/power/max17042_battery.c:552:	struct max17042_config_data *config = chip->pdata->config_data;
./drivers/power/max17042_battery.c:553:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:558:	if (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17042) {
./drivers/power/max17042_battery.c:576:	struct max17042_config_data *config = chip->pdata->config_data;
./drivers/power/max17042_battery.c:577:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:589:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:602:	struct max17042_config_data *config = chip->pdata->config_data;
./drivers/power/max17042_battery.c:603:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:640:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:641:	struct max17042_config_data *config = chip->pdata->config_data;
./drivers/power/max17042_battery.c:667:	if (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17042)
./drivers/power/max17042_battery.c:674:	if (chip->chip_type == MAXIM_DEVICE_TYPE_MAX17042)
./drivers/power/max17042_battery.c:683:	if (chip->chip_type) {
./drivers/power/max17042_battery.c:693:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:708:		dev_err(&chip->client->dev, "%s init failed\n",
./drivers/power/max17042_battery.c:715:		dev_err(&chip->client->dev, "%s lock verify failed\n",
./drivers/power/max17042_battery.c:743:	struct regmap *map = chip->regmap;
./drivers/power/max17042_battery.c:761:	regmap_read(chip->regmap, MAX17042_STATUS, &val);
./drivers/power/max17042_battery.c:764:		dev_info(&chip->client->dev, "SOC threshold INTR\n");
./drivers/power/max17042_battery.c:768:	power_supply_changed(chip->battery);
./drivers/power/max17042_battery.c:779:	if (chip->pdata->enable_por_init && chip->pdata->config_data) {
./drivers/power/max17042_battery.c:785:	chip->init_complete = 1;
./drivers/power/max17042_battery.c:875:	chip->client = client;
./drivers/power/max17042_battery.c:876:	chip->regmap = devm_regmap_init_i2c(client, &max17042_regmap_config);
./drivers/power/max17042_battery.c:877:	if (IS_ERR(chip->regmap)) {
./drivers/power/max17042_battery.c:882:	chip->pdata = max17042_get_pdata(&client->dev);
./drivers/power/max17042_battery.c:883:	if (!chip->pdata) {
./drivers/power/max17042_battery.c:889:	chip->chip_type = id->driver_data;
./drivers/power/max17042_battery.c:894:	if (!chip->pdata->enable_current_sense)
./drivers/power/max17042_battery.c:897:	if (chip->pdata->r_sns == 0)
./drivers/power/max17042_battery.c:898:		chip->pdata->r_sns = MAX17042_DEFAULT_SNS_RESISTOR;
./drivers/power/max17042_battery.c:900:	if (chip->pdata->init_data)
./drivers/power/max17042_battery.c:901:		for (i = 0; i < chip->pdata->num_init_data; i++)
./drivers/power/max17042_battery.c:902:			regmap_write(chip->regmap,
./drivers/power/max17042_battery.c:903:					chip->pdata->init_data[i].addr,
./drivers/power/max17042_battery.c:904:					chip->pdata->init_data[i].data);
./drivers/power/max17042_battery.c:906:	if (!chip->pdata->enable_current_sense) {
./drivers/power/max17042_battery.c:907:		regmap_write(chip->regmap, MAX17042_CGAIN, 0x0000);
./drivers/power/max17042_battery.c:908:		regmap_write(chip->regmap, MAX17042_MiscCFG, 0x0003);
./drivers/power/max17042_battery.c:909:		regmap_write(chip->regmap, MAX17042_LearnCFG, 0x0007);
./drivers/power/max17042_battery.c:912:	chip->battery = devm_power_supply_register(&client->dev, max17042_desc,
./drivers/power/max17042_battery.c:914:	if (IS_ERR(chip->battery)) {
./drivers/power/max17042_battery.c:916:		return PTR_ERR(chip->battery);
./drivers/power/max17042_battery.c:925:						chip->battery->desc->name,
./drivers/power/max17042_battery.c:928:			regmap_update_bits(chip->regmap, MAX17042_CONFIG,
./drivers/power/max17042_battery.c:939:	regmap_read(chip->regmap, MAX17042_STATUS, &val);
./drivers/power/max17042_battery.c:941:		INIT_WORK(&chip->work, max17042_init_worker);
./drivers/power/max17042_battery.c:942:		schedule_work(&chip->work);
./drivers/power/max17042_battery.c:944:		chip->init_complete = 1;
./drivers/power/max17042_battery.c:959:	if (chip->client->irq) {
./drivers/power/max17042_battery.c:960:		disable_irq(chip->client->irq);
./drivers/power/max17042_battery.c:961:		enable_irq_wake(chip->client->irq);
./drivers/power/max17042_battery.c:971:	if (chip->client->irq) {
./drivers/power/max17042_battery.c:972:		disable_irq_wake(chip->client->irq);
./drivers/power/max17042_battery.c:973:		enable_irq(chip->client->irq);
./drivers/power/88pm860x_battery.c:938:	    (chip->id == CHIP_PM8607) ? chip->client : chip->companion;
./drivers/power/88pm860x_battery.c:964:	ret = devm_request_threaded_irq(chip->dev, info->irq_cc, NULL,
./drivers/power/88pm860x_battery.c:968:		dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
./drivers/power/88pm860x_battery.c:973:	ret = devm_request_threaded_irq(chip->dev, info->irq_batt, NULL,
./drivers/power/88pm860x_battery.c:977:		dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
./drivers/power/88pm860x_battery.c:993:		chip->wakeup_flag |= 1 << PM8607_IRQ_CC;
./drivers/power/88pm860x_battery.c:1003:		chip->wakeup_flag &= ~(1 << PM8607_IRQ_CC);
./drivers/power/max8925_power.c:103:	dev_dbg(chip->dev, "%s\n", (enable) ? "Enable charger"
./drivers/power/max8925_power.c:113:	switch (irq - chip->irq_base) {
./drivers/power/max8925_power.c:117:		dev_dbg(chip->dev, "Adapter inserted\n");
./drivers/power/max8925_power.c:122:		dev_dbg(chip->dev, "Adapter removed\n");
./drivers/power/max8925_power.c:126:		dev_dbg(chip->dev, "Battery temperature is out of range\n");
./drivers/power/max8925_power.c:128:		dev_dbg(chip->dev, "Error detection\n");
./drivers/power/max8925_power.c:133:		dev_dbg(chip->dev, "Battery temperature is in range\n");
./drivers/power/max8925_power.c:137:		dev_info(chip->dev, "Sys power is too low\n");
./drivers/power/max8925_power.c:140:		dev_dbg(chip->dev, "Sys power is above low threshold\n");
./drivers/power/max8925_power.c:144:		dev_dbg(chip->dev, "Charging is done\n");
./drivers/power/max8925_power.c:147:		dev_dbg(chip->dev, "Charging in top-off mode\n");
./drivers/power/max8925_power.c:151:		dev_dbg(chip->dev, "Safe timer is expired\n");
./drivers/power/max8925_power.c:155:		dev_dbg(chip->dev, "Charger is reset\n");
./drivers/power/max8925_power.c:376:	ret = request_threaded_irq(chip->irq_base + _irq, NULL,		\
./drivers/power/max8925_power.c:380:		dev_err(chip->dev, "Failed to request IRQ #%d: %d\n",	\
./drivers/power/max8925_power.c:447:	irq = chip->irq_base + MAX8925_IRQ_VCHG_DC_OVP;
./drivers/power/max8925_power.c:448:	for (; irq <= chip->irq_base + MAX8925_IRQ_VCHG_TMR_FAULT; irq++)
./drivers/power/max8925_power.c:526:	info->gpm = chip->i2c;
./drivers/power/max8925_power.c:527:	info->adc = chip->adc;
./drivers/rtc/rtc-v3020.c:75:	chip->leftshift = pdata->leftshift;
./drivers/rtc/rtc-v3020.c:76:	chip->ioaddress = ioremap(pdev->resource[0].start, 1);
./drivers/rtc/rtc-v3020.c:77:	if (chip->ioaddress == NULL)
./drivers/rtc/rtc-v3020.c:85:	iounmap(chip->ioaddress);
./drivers/rtc/rtc-v3020.c:90:	writel(bit << chip->leftshift, chip->ioaddress);
./drivers/rtc/rtc-v3020.c:95:	return !!(readl(chip->ioaddress) & (1 << chip->leftshift));
./drivers/rtc/rtc-v3020.c:125:		chip->gpio = v3020_gpio;
./drivers/rtc/rtc-v3020.c:137:	gpio_direction_output(chip->gpio[V3020_IO].gpio, bit);
./drivers/rtc/rtc-v3020.c:138:	gpio_set_value(chip->gpio[V3020_CS].gpio, 0);
./drivers/rtc/rtc-v3020.c:139:	gpio_set_value(chip->gpio[V3020_WR].gpio, 0);
./drivers/rtc/rtc-v3020.c:141:	gpio_set_value(chip->gpio[V3020_WR].gpio, 1);
./drivers/rtc/rtc-v3020.c:142:	gpio_set_value(chip->gpio[V3020_CS].gpio, 1);
./drivers/rtc/rtc-v3020.c:149:	gpio_direction_input(chip->gpio[V3020_IO].gpio);
./drivers/rtc/rtc-v3020.c:150:	gpio_set_value(chip->gpio[V3020_CS].gpio, 0);
./drivers/rtc/rtc-v3020.c:151:	gpio_set_value(chip->gpio[V3020_RD].gpio, 0);
./drivers/rtc/rtc-v3020.c:153:	bit = !!gpio_get_value(chip->gpio[V3020_IO].gpio);
./drivers/rtc/rtc-v3020.c:155:	gpio_set_value(chip->gpio[V3020_RD].gpio, 1);
./drivers/rtc/rtc-v3020.c:156:	gpio_set_value(chip->gpio[V3020_CS].gpio, 1);
./drivers/rtc/rtc-v3020.c:176:		chip->ops->write_bit(chip, (tmp & 1));
./drivers/rtc/rtc-v3020.c:184:			chip->ops->write_bit(chip, (data & 1));
./drivers/rtc/rtc-v3020.c:197:		chip->ops->write_bit(chip, (address & 1));
./drivers/rtc/rtc-v3020.c:204:		if (chip->ops->read_bit(chip))
./drivers/rtc/rtc-v3020.c:298:		chip->ops = &v3020_gpio_ops;
./drivers/rtc/rtc-v3020.c:300:		chip->ops = &v3020_mmio_ops;
./drivers/rtc/rtc-v3020.c:302:	retval = chip->ops->map_io(chip, pdev, pdata);
./drivers/rtc/rtc-v3020.c:309:		temp = chip->ops->read_bit(chip);
./drivers/rtc/rtc-v3020.c:326:			 chip->gpio[V3020_CS].gpio, chip->gpio[V3020_WR].gpio,
./drivers/rtc/rtc-v3020.c:327:			 chip->gpio[V3020_RD].gpio, chip->gpio[V3020_IO].gpio);
./drivers/rtc/rtc-v3020.c:333:			 chip->leftshift);
./drivers/rtc/rtc-v3020.c:337:	chip->rtc = devm_rtc_device_register(&pdev->dev, "v3020",
./drivers/rtc/rtc-v3020.c:339:	if (IS_ERR(chip->rtc)) {
./drivers/rtc/rtc-v3020.c:340:		retval = PTR_ERR(chip->rtc);
./drivers/rtc/rtc-v3020.c:347:	chip->ops->unmap_io(chip);
./drivers/rtc/rtc-v3020.c:356:	chip->ops->unmap_io(chip);
./drivers/rtc/rtc-ds1390.c:80:	chip->txrx_buf[0] = address & 0x7f;
./drivers/rtc/rtc-ds1390.c:82:	status = spi_write_then_read(spi, chip->txrx_buf, 1, chip->txrx_buf, 1);
./drivers/rtc/rtc-ds1390.c:86:	*data = chip->txrx_buf[0];
./drivers/rtc/rtc-ds1390.c:137:	chip->txrx_buf[0] = DS1390_REG_SECONDS;
./drivers/rtc/rtc-ds1390.c:140:	status = spi_write_then_read(spi, chip->txrx_buf, 1, chip->txrx_buf, 8);
./drivers/rtc/rtc-ds1390.c:146:	dt->tm_sec	= bcd2bin(chip->txrx_buf[0]);
./drivers/rtc/rtc-ds1390.c:147:	dt->tm_min	= bcd2bin(chip->txrx_buf[1]);
./drivers/rtc/rtc-ds1390.c:148:	dt->tm_hour	= bcd2bin(chip->txrx_buf[2]);
./drivers/rtc/rtc-ds1390.c:149:	dt->tm_wday	= bcd2bin(chip->txrx_buf[3]);
./drivers/rtc/rtc-ds1390.c:150:	dt->tm_mday	= bcd2bin(chip->txrx_buf[4]);
./drivers/rtc/rtc-ds1390.c:152:	dt->tm_mon	= bcd2bin(chip->txrx_buf[5] & 0x7f) - 1;
./drivers/rtc/rtc-ds1390.c:154:	dt->tm_year = bcd2bin(chip->txrx_buf[6]) + ((chip->txrx_buf[5] & 0x80) ? 100 : 0);
./drivers/rtc/rtc-ds1390.c:165:	chip->txrx_buf[0] = DS1390_REG_SECONDS | 0x80;
./drivers/rtc/rtc-ds1390.c:166:	chip->txrx_buf[1] = bin2bcd(dt->tm_sec);
./drivers/rtc/rtc-ds1390.c:167:	chip->txrx_buf[2] = bin2bcd(dt->tm_min);
./drivers/rtc/rtc-ds1390.c:168:	chip->txrx_buf[3] = bin2bcd(dt->tm_hour);
./drivers/rtc/rtc-ds1390.c:169:	chip->txrx_buf[4] = bin2bcd(dt->tm_wday);
./drivers/rtc/rtc-ds1390.c:170:	chip->txrx_buf[5] = bin2bcd(dt->tm_mday);
./drivers/rtc/rtc-ds1390.c:171:	chip->txrx_buf[6] = bin2bcd(dt->tm_mon + 1) |
./drivers/rtc/rtc-ds1390.c:173:	chip->txrx_buf[7] = bin2bcd(dt->tm_year % 100);
./drivers/rtc/rtc-ds1390.c:176:	return spi_write_then_read(spi, chip->txrx_buf, 8, NULL, 0);
./drivers/rtc/rtc-ds1390.c:209:	chip->rtc = devm_rtc_device_register(&spi->dev, "ds1390",
./drivers/rtc/rtc-ds1390.c:211:	if (IS_ERR(chip->rtc)) {
./drivers/rtc/rtc-ds1390.c:213:		res = PTR_ERR(chip->rtc);
./drivers/rtc/rtc-ds1307.c:847:	if (!chip->do_trickle_setup)
./drivers/rtc/rtc-ds1307.c:853:	chip->trickle_charger_setup = chip->do_trickle_setup(client,
./drivers/rtc/rtc-ds1307.c:1266:		chip->trickle_charger_setup = pdata->trickle_charger_setup;
./drivers/rtc/rtc-ds1307.c:1268:	if (chip->trickle_charger_setup && chip->trickle_charger_reg) {
./drivers/rtc/rtc-ds1307.c:1270:		    DS13XX_TRICKLE_CHARGER_MAGIC | chip->trickle_charger_setup,
./drivers/rtc/rtc-ds1307.c:1271:		    chip->trickle_charger_reg);
./drivers/rtc/rtc-ds1307.c:1272:		i2c_smbus_write_byte_data(client, chip->trickle_charger_reg,
./drivers/rtc/rtc-ds1307.c:1274:		    chip->trickle_charger_setup);
./drivers/rtc/rtc-ds1307.c:1323:		if (chip->alarm && (ds1307->client->irq > 0 ||
./drivers/rtc/rtc-ds1307.c:1413:		if (ds1307->client->irq > 0 && chip->alarm) {
./drivers/rtc/rtc-ds1307.c:1561:	if (chip->nvram_size) {
./drivers/rtc/rtc-ds1307.c:1577:			ds1307->nvram->size = chip->nvram_size;
./drivers/rtc/rtc-ds1307.c:1578:			ds1307->nvram_offset = chip->nvram_offset;
./drivers/rtc/rtc-mt6397.c:326:	rtc->irq = irq_create_mapping(mt6397_chip->irq_domain, res->start);
./drivers/rtc/rtc-mt6397.c:330:	rtc->regmap = mt6397_chip->regmap;
./drivers/rtc/rtc-88pm80x.c:287:	info->map = chip->regmap;
./drivers/rtc/rtc-88pm80x.c:300:		dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
./drivers/rtc/rtc-ds2404.c:81:	chip->gpio = ds2404_gpio;
./drivers/rtc/rtc-ds2404.c:235:	chip->ops = &ds2404_gpio_ops;
./drivers/rtc/rtc-ds2404.c:237:	retval = chip->ops->map_io(chip, pdev, pdata);
./drivers/rtc/rtc-ds2404.c:242:		 chip->gpio[DS2404_RST].gpio, chip->gpio[DS2404_CLK].gpio,
./drivers/rtc/rtc-ds2404.c:243:		 chip->gpio[DS2404_DQ].gpio);
./drivers/rtc/rtc-ds2404.c:247:	chip->rtc = devm_rtc_device_register(&pdev->dev, "ds2404",
./drivers/rtc/rtc-ds2404.c:249:	if (IS_ERR(chip->rtc)) {
./drivers/rtc/rtc-ds2404.c:250:		retval = PTR_ERR(chip->rtc);
./drivers/rtc/rtc-ds2404.c:258:	chip->ops->unmap_io(chip);
./drivers/rtc/rtc-ds2404.c:267:	chip->ops->unmap_io(chip);
./drivers/rtc/rtc-da9063.c:406:		if (chip->variant_code == PMIC_DA9063_AD)
./drivers/rtc/rtc-sunxi.c:164:	val = readl(chip->base + SUNXI_ALRM_IRQ_STA);
./drivers/rtc/rtc-sunxi.c:168:		writel(val, chip->base + SUNXI_ALRM_IRQ_STA);
./drivers/rtc/rtc-sunxi.c:170:		rtc_update_irq(chip->rtc, 1, RTC_AF | RTC_IRQF);
./drivers/rtc/rtc-sunxi.c:184:		alrm_val = readl(chip->base + SUNXI_ALRM_EN);
./drivers/rtc/rtc-sunxi.c:187:		alrm_irq_val = readl(chip->base + SUNXI_ALRM_IRQ_EN);
./drivers/rtc/rtc-sunxi.c:191:				chip->base + SUNXI_ALRM_IRQ_STA);
./drivers/rtc/rtc-sunxi.c:194:	writel(alrm_val, chip->base + SUNXI_ALRM_EN);
./drivers/rtc/rtc-sunxi.c:195:	writel(alrm_irq_val, chip->base + SUNXI_ALRM_IRQ_EN);
./drivers/rtc/rtc-sunxi.c:206:	alrm = readl(chip->base + SUNXI_ALRM_DHMS);
./drivers/rtc/rtc-sunxi.c:207:	date = readl(chip->base + SUNXI_RTC_YMD);
./drivers/rtc/rtc-sunxi.c:216:			chip->data_year->mask);
./drivers/rtc/rtc-sunxi.c:224:	alrm_tm->tm_year += SUNXI_YEAR_OFF(chip->data_year);
./drivers/rtc/rtc-sunxi.c:226:	alrm_en = readl(chip->base + SUNXI_ALRM_IRQ_EN);
./drivers/rtc/rtc-sunxi.c:242:		date = readl(chip->base + SUNXI_RTC_YMD);
./drivers/rtc/rtc-sunxi.c:243:		time = readl(chip->base + SUNXI_RTC_HMS);
./drivers/rtc/rtc-sunxi.c:244:	} while ((date != readl(chip->base + SUNXI_RTC_YMD)) ||
./drivers/rtc/rtc-sunxi.c:245:		 (time != readl(chip->base + SUNXI_RTC_HMS)));
./drivers/rtc/rtc-sunxi.c:254:					chip->data_year->mask);
./drivers/rtc/rtc-sunxi.c:262:	rtc_tm->tm_year += SUNXI_YEAR_OFF(chip->data_year);
./drivers/rtc/rtc-sunxi.c:306:	writel(0, chip->base + SUNXI_ALRM_DHMS);
./drivers/rtc/rtc-sunxi.c:313:	writel(alrm, chip->base + SUNXI_ALRM_DHMS);
./drivers/rtc/rtc-sunxi.c:315:	writel(0, chip->base + SUNXI_ALRM_IRQ_EN);
./drivers/rtc/rtc-sunxi.c:316:	writel(SUNXI_ALRM_IRQ_EN_CNT_IRQ_EN, chip->base + SUNXI_ALRM_IRQ_EN);
./drivers/rtc/rtc-sunxi.c:330:		reg = readl(chip->base + offset);
./drivers/rtc/rtc-sunxi.c:355:	if (year < chip->data_year->min || year > chip->data_year->max) {
./drivers/rtc/rtc-sunxi.c:357:			chip->data_year->min, chip->data_year->max);
./drivers/rtc/rtc-sunxi.c:361:	rtc_tm->tm_year -= SUNXI_YEAR_OFF(chip->data_year);
./drivers/rtc/rtc-sunxi.c:367:				chip->data_year->mask);
./drivers/rtc/rtc-sunxi.c:370:		date |= SUNXI_LEAP_SET_VALUE(1, chip->data_year->leap_shift);
./drivers/rtc/rtc-sunxi.c:376:	writel(0, chip->base + SUNXI_RTC_HMS);
./drivers/rtc/rtc-sunxi.c:377:	writel(0, chip->base + SUNXI_RTC_YMD);
./drivers/rtc/rtc-sunxi.c:379:	writel(time, chip->base + SUNXI_RTC_HMS);
./drivers/rtc/rtc-sunxi.c:393:	writel(date, chip->base + SUNXI_RTC_YMD);
./drivers/rtc/rtc-sunxi.c:446:	chip->dev = &pdev->dev;
./drivers/rtc/rtc-sunxi.c:449:	chip->base = devm_ioremap_resource(&pdev->dev, res);
./drivers/rtc/rtc-sunxi.c:450:	if (IS_ERR(chip->base))
./drivers/rtc/rtc-sunxi.c:451:		return PTR_ERR(chip->base);
./drivers/rtc/rtc-sunxi.c:453:	chip->irq = platform_get_irq(pdev, 0);
./drivers/rtc/rtc-sunxi.c:454:	if (chip->irq < 0) {
./drivers/rtc/rtc-sunxi.c:456:		return chip->irq;
./drivers/rtc/rtc-sunxi.c:458:	ret = devm_request_irq(&pdev->dev, chip->irq, sunxi_rtc_alarmirq,
./drivers/rtc/rtc-sunxi.c:465:	chip->data_year = of_device_get_match_data(&pdev->dev);
./drivers/rtc/rtc-sunxi.c:466:	if (!chip->data_year) {
./drivers/rtc/rtc-sunxi.c:472:	writel(0, chip->base + SUNXI_ALRM_DHMS);
./drivers/rtc/rtc-sunxi.c:475:	writel(0, chip->base + SUNXI_ALRM_EN);
./drivers/rtc/rtc-sunxi.c:478:	writel(0, chip->base + SUNXI_ALRM_IRQ_EN);
./drivers/rtc/rtc-sunxi.c:481:	writel(SUNXI_ALRM_IRQ_STA_CNT_IRQ_PEND, chip->base +
./drivers/rtc/rtc-sunxi.c:484:	chip->rtc = rtc_device_register("rtc-sunxi", &pdev->dev,
./drivers/rtc/rtc-sunxi.c:486:	if (IS_ERR(chip->rtc)) {
./drivers/rtc/rtc-sunxi.c:488:		return PTR_ERR(chip->rtc);
./drivers/rtc/rtc-sunxi.c:500:	rtc_device_unregister(chip->rtc);
./drivers/rtc/rtc-sun6i.c:124:	val = readl(chip->base + SUN6I_ALRM_IRQ_STA);
./drivers/rtc/rtc-sun6i.c:128:		writel(val, chip->base + SUN6I_ALRM_IRQ_STA);
./drivers/rtc/rtc-sun6i.c:130:		rtc_update_irq(chip->rtc, 1, RTC_AF | RTC_IRQF);
./drivers/rtc/rtc-sun6i.c:150:		       chip->base + SUN6I_ALRM_IRQ_STA);
./drivers/rtc/rtc-sun6i.c:153:	writel(alrm_val, chip->base + SUN6I_ALRM_EN);
./drivers/rtc/rtc-sun6i.c:154:	writel(alrm_irq_val, chip->base + SUN6I_ALRM_IRQ_EN);
./drivers/rtc/rtc-sun6i.c:155:	writel(alrm_wake_val, chip->base + SUN6I_ALARM_CONFIG);
./drivers/rtc/rtc-sun6i.c:167:		date = readl(chip->base + SUN6I_RTC_YMD);
./drivers/rtc/rtc-sun6i.c:168:		time = readl(chip->base + SUN6I_RTC_HMS);
./drivers/rtc/rtc-sun6i.c:169:	} while ((date != readl(chip->base + SUN6I_RTC_YMD)) ||
./drivers/rtc/rtc-sun6i.c:170:		 (time != readl(chip->base + SUN6I_RTC_HMS)));
./drivers/rtc/rtc-sun6i.c:197:	alrm_en = readl(chip->base + SUN6I_ALRM_IRQ_EN);
./drivers/rtc/rtc-sun6i.c:198:	alrm_st = readl(chip->base + SUN6I_ALRM_IRQ_STA);
./drivers/rtc/rtc-sun6i.c:201:	rtc_time_to_tm(chip->alarm, &wkalrm->time);
./drivers/rtc/rtc-sun6i.c:237:	writel(0, chip->base + SUN6I_ALRM_COUNTER);
./drivers/rtc/rtc-sun6i.c:240:	writel(time_gap, chip->base + SUN6I_ALRM_COUNTER);
./drivers/rtc/rtc-sun6i.c:241:	chip->alarm = time_set;
./drivers/rtc/rtc-sun6i.c:255:		reg = readl(chip->base + offset);
./drivers/rtc/rtc-sun6i.c:301:	writel(time, chip->base + SUN6I_RTC_HMS);
./drivers/rtc/rtc-sun6i.c:315:	writel(date, chip->base + SUN6I_RTC_YMD);
./drivers/rtc/rtc-sun6i.c:361:	chip->dev = &pdev->dev;
./drivers/rtc/rtc-sun6i.c:364:	chip->base = devm_ioremap_resource(&pdev->dev, res);
./drivers/rtc/rtc-sun6i.c:365:	if (IS_ERR(chip->base))
./drivers/rtc/rtc-sun6i.c:366:		return PTR_ERR(chip->base);
./drivers/rtc/rtc-sun6i.c:368:	chip->irq = platform_get_irq(pdev, 0);
./drivers/rtc/rtc-sun6i.c:369:	if (chip->irq < 0) {
./drivers/rtc/rtc-sun6i.c:371:		return chip->irq;
./drivers/rtc/rtc-sun6i.c:374:	ret = devm_request_irq(&pdev->dev, chip->irq, sun6i_rtc_alarmirq,
./drivers/rtc/rtc-sun6i.c:382:	writel(0, chip->base + SUN6I_ALRM_COUNTER);
./drivers/rtc/rtc-sun6i.c:385:	writel(0, chip->base + SUN6I_ALRM_EN);
./drivers/rtc/rtc-sun6i.c:388:	writel(0, chip->base + SUN6I_ALRM_IRQ_EN);
./drivers/rtc/rtc-sun6i.c:391:	writel(0, chip->base + SUN6I_ALRM1_EN);
./drivers/rtc/rtc-sun6i.c:394:	writel(0, chip->base + SUN6I_ALRM1_IRQ_EN);
./drivers/rtc/rtc-sun6i.c:398:	       chip->base + SUN6I_ALRM_IRQ_STA);
./drivers/rtc/rtc-sun6i.c:402:	       chip->base + SUN6I_ALRM1_IRQ_STA);
./drivers/rtc/rtc-sun6i.c:405:	writel(0, chip->base + SUN6I_ALARM_CONFIG);
./drivers/rtc/rtc-sun6i.c:407:	chip->rtc = rtc_device_register("rtc-sun6i", &pdev->dev,
./drivers/rtc/rtc-sun6i.c:409:	if (IS_ERR(chip->rtc)) {
./drivers/rtc/rtc-sun6i.c:411:		return PTR_ERR(chip->rtc);
./drivers/rtc/rtc-sun6i.c:423:	rtc_device_unregister(chip->rtc);
./drivers/rtc/rtc-max8925.c:261:	info->rtc = chip->rtc;
./drivers/rtc/rtc-max8925.c:269:		dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
./drivers/rtc/rtc-max8925.c:298:		chip->wakeup_flag |= 1 << MAX8925_IRQ_RTC_ALARM0;
./drivers/rtc/rtc-max8925.c:307:		chip->wakeup_flag &= ~(1 << MAX8925_IRQ_RTC_ALARM0);
./drivers/rtc/rtc-88pm860x.c:333:	info->i2c = (chip->id == CHIP_PM8607) ? chip->client : chip->companion;
./drivers/rtc/rtc-88pm860x.c:341:		dev_err(chip->dev, "Failed to request IRQ: #%d: %d\n",
./drivers/rtc/rtc-88pm860x.c:432:		chip->wakeup_flag |= 1 << PM8607_IRQ_RTC;
./drivers/rtc/rtc-88pm860x.c:441:		chip->wakeup_flag &= ~(1 << PM8607_IRQ_RTC);
./drivers/bcma/driver_gpio.c:177:	chip->label		= "bcma_gpio";
./drivers/bcma/driver_gpio.c:178:	chip->owner		= THIS_MODULE;
./drivers/bcma/driver_gpio.c:179:	chip->request		= bcma_gpio_request;
./drivers/bcma/driver_gpio.c:180:	chip->free		= bcma_gpio_free;
./drivers/bcma/driver_gpio.c:181:	chip->get		= bcma_gpio_get_value;
./drivers/bcma/driver_gpio.c:182:	chip->set		= bcma_gpio_set_value;
./drivers/bcma/driver_gpio.c:183:	chip->direction_input	= bcma_gpio_direction_input;
./drivers/bcma/driver_gpio.c:184:	chip->direction_output	= bcma_gpio_direction_output;
./drivers/bcma/driver_gpio.c:185:	chip->owner		= THIS_MODULE;
./drivers/bcma/driver_gpio.c:186:	chip->parent		= bcma_bus_get_host_dev(bus);
./drivers/bcma/driver_gpio.c:189:		chip->of_node	= cc->core->dev.of_node;
./drivers/bcma/driver_gpio.c:196:		chip->ngpio	= 32;
./drivers/bcma/driver_gpio.c:199:		chip->ngpio	= 16;
./drivers/bcma/driver_gpio.c:211:		chip->base		= bus->num * BCMA_GPIO_MAX_PINS;
./drivers/bcma/driver_gpio.c:213:		chip->base		= -1;
./drivers/pcmcia/at91_cf.c:332:	/* reserve chip-select regions */
./drivers/pcmcia/electra_cf.c:277:	/* reserve chip-select regions */
./drivers/staging/mt29f_spinand/mt29f_spinand.c:632:	int eccsize = chip->ecc.size;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:633:	int eccsteps = chip->ecc.steps;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:636:	chip->write_buf(mtd, p, eccsize * eccsteps);
./drivers/staging/mt29f_spinand/mt29f_spinand.c:646:	int eccsize = chip->ecc.size;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:647:	int eccsteps = chip->ecc.steps;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:652:	chip->read_buf(mtd, p, eccsize * eccsteps);
./drivers/staging/mt29f_spinand/mt29f_spinand.c:654:		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
./drivers/staging/mt29f_spinand/mt29f_spinand.c:697:	int retval, state = chip->state;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:892:	chip->ecc.mode	= NAND_ECC_HW;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:893:	chip->ecc.size	= 0x200;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:894:	chip->ecc.bytes	= 0x6;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:895:	chip->ecc.steps	= 0x4;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:897:	chip->ecc.strength = 1;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:898:	chip->ecc.total	= chip->ecc.steps * chip->ecc.bytes;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:899:	chip->ecc.read_page = spinand_read_page_hwecc;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:900:	chip->ecc.write_page = spinand_write_page_hwecc;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:902:	chip->ecc.mode	= NAND_ECC_SOFT;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:903:	chip->ecc.algo	= NAND_ECC_HAMMING;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:911:	chip->read_buf	= spinand_read_buf;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:912:	chip->write_buf	= spinand_write_buf;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:913:	chip->read_byte	= spinand_read_byte;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:914:	chip->cmdfunc	= spinand_cmdfunc;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:915:	chip->waitfunc	= spinand_wait;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:916:	chip->options	|= NAND_CACHEPRG;
./drivers/staging/mt29f_spinand/mt29f_spinand.c:917:	chip->select_chip = spinand_select_chip;
./drivers/staging/iio/addac/adt7316.c:226:	return sprintf(buf, "%d\n", !!(chip->config1 & ADT7316_EN));
./drivers/staging/iio/addac/adt7316.c:236:		config1 = chip->config1 | ADT7316_EN;
./drivers/staging/iio/addac/adt7316.c:238:		config1 = chip->config1 & ~ADT7316_EN;
./drivers/staging/iio/addac/adt7316.c:240:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG1, config1);
./drivers/staging/iio/addac/adt7316.c:244:	chip->config1 = config1;
./drivers/staging/iio/addac/adt7316.c:282:	if ((chip->id & ID_FAMILY_MASK) != ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:285:	return sprintf(buf, "%d\n", !!(chip->config1 & ADT7516_SEL_EX_TEMP));
./drivers/staging/iio/addac/adt7316.c:298:	if ((chip->id & ID_FAMILY_MASK) != ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:301:	config1 = chip->config1 & (~ADT7516_SEL_EX_TEMP);
./drivers/staging/iio/addac/adt7316.c:305:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG1, config1);
./drivers/staging/iio/addac/adt7316.c:309:	chip->config1 = config1;
./drivers/staging/iio/addac/adt7316.c:326:	if (chip->config2 & ADT7316_AD_SINGLE_CH_MODE)
./drivers/staging/iio/addac/adt7316.c:342:	config2 = chip->config2 & (~ADT7316_AD_SINGLE_CH_MODE);
./drivers/staging/iio/addac/adt7316.c:346:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG2, config2);
./drivers/staging/iio/addac/adt7316.c:350:	chip->config2 = config2;
./drivers/staging/iio/addac/adt7316.c:376:	if (!(chip->config2 & ADT7316_AD_SINGLE_CH_MODE))
./drivers/staging/iio/addac/adt7316.c:379:	switch (chip->config2 & ADT7516_AD_SINGLE_CH_MASK) {
./drivers/staging/iio/addac/adt7316.c:385:		if (((chip->id & ID_FAMILY_MASK) == ID_ADT75XX) &&
./drivers/staging/iio/addac/adt7316.c:386:			(chip->config1 & ADT7516_SEL_AIN1_2_EX_TEMP_MASK) == 0)
./drivers/staging/iio/addac/adt7316.c:391:		if ((chip->config1 & ADT7516_SEL_AIN1_2_EX_TEMP_MASK) == 0)
./drivers/staging/iio/addac/adt7316.c:396:		if (chip->config1 & ADT7516_SEL_AIN3)
./drivers/staging/iio/addac/adt7316.c:418:	if (!(chip->config2 & ADT7316_AD_SINGLE_CH_MODE))
./drivers/staging/iio/addac/adt7316.c:425:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX) {
./drivers/staging/iio/addac/adt7316.c:429:		config2 = chip->config2 & (~ADT7516_AD_SINGLE_CH_MASK);
./drivers/staging/iio/addac/adt7316.c:434:		config2 = chip->config2 & (~ADT7316_AD_SINGLE_CH_MASK);
./drivers/staging/iio/addac/adt7316.c:440:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG2, config2);
./drivers/staging/iio/addac/adt7316.c:444:	chip->config2 = config2;
./drivers/staging/iio/addac/adt7316.c:461:	if (!(chip->config2 & ADT7316_AD_SINGLE_CH_MODE))
./drivers/staging/iio/addac/adt7316.c:464:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:483:		!!(chip->config2 & ADT7316_DISABLE_AVERAGING));
./drivers/staging/iio/addac/adt7316.c:496:	config2 = chip->config2 & (~ADT7316_DISABLE_AVERAGING);
./drivers/staging/iio/addac/adt7316.c:500:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG2, config2);
./drivers/staging/iio/addac/adt7316.c:504:	chip->config2 = config2;
./drivers/staging/iio/addac/adt7316.c:522:		!!(chip->config2 & ADT7316_EN_SMBUS_TIMEOUT));
./drivers/staging/iio/addac/adt7316.c:535:	config2 = chip->config2 & (~ADT7316_EN_SMBUS_TIMEOUT);
./drivers/staging/iio/addac/adt7316.c:539:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG2, config2);
./drivers/staging/iio/addac/adt7316.c:543:	chip->config2 = config2;
./drivers/staging/iio/addac/adt7316.c:560:	return sprintf(buf, "%d\n", !!(chip->config1 & ADT7316_PD));
./drivers/staging/iio/addac/adt7316.c:573:	config1 = chip->config1 & (~ADT7316_PD);
./drivers/staging/iio/addac/adt7316.c:577:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG1, config1);
./drivers/staging/iio/addac/adt7316.c:581:	chip->config1 = config1;
./drivers/staging/iio/addac/adt7316.c:598:	return sprintf(buf, "%d\n", !!(chip->config3 & ADT7316_ADCLK_22_5));
./drivers/staging/iio/addac/adt7316.c:611:	config3 = chip->config3 & (~ADT7316_ADCLK_22_5);
./drivers/staging/iio/addac/adt7316.c:615:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG3, config3);
./drivers/staging/iio/addac/adt7316.c:619:	chip->config3 = config3;
./drivers/staging/iio/addac/adt7316.c:636:	if (chip->config3 & ADT7316_DA_HIGH_RESOLUTION) {
./drivers/staging/iio/addac/adt7316.c:637:		if (chip->id == ID_ADT7316 || chip->id == ID_ADT7516)
./drivers/staging/iio/addac/adt7316.c:639:		if (chip->id == ID_ADT7317 || chip->id == ID_ADT7517)
./drivers/staging/iio/addac/adt7316.c:656:	chip->dac_bits = 8;
./drivers/staging/iio/addac/adt7316.c:659:		config3 = chip->config3 | ADT7316_DA_HIGH_RESOLUTION;
./drivers/staging/iio/addac/adt7316.c:660:		if (chip->id == ID_ADT7316 || chip->id == ID_ADT7516)
./drivers/staging/iio/addac/adt7316.c:661:			chip->dac_bits = 12;
./drivers/staging/iio/addac/adt7316.c:662:		else if (chip->id == ID_ADT7317 || chip->id == ID_ADT7517)
./drivers/staging/iio/addac/adt7316.c:663:			chip->dac_bits = 10;
./drivers/staging/iio/addac/adt7316.c:665:		config3 = chip->config3 & (~ADT7316_DA_HIGH_RESOLUTION);
./drivers/staging/iio/addac/adt7316.c:667:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG3, config3);
./drivers/staging/iio/addac/adt7316.c:671:	chip->config3 = config3;
./drivers/staging/iio/addac/adt7316.c:688:	if ((chip->id & ID_FAMILY_MASK) != ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:692:		!!(chip->config3 & ADT7516_AIN_IN_VREF));
./drivers/staging/iio/addac/adt7316.c:705:	if ((chip->id & ID_FAMILY_MASK) != ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:709:		config3 = chip->config3 & (~ADT7516_AIN_IN_VREF);
./drivers/staging/iio/addac/adt7316.c:711:		config3 = chip->config3 | ADT7516_AIN_IN_VREF;
./drivers/staging/iio/addac/adt7316.c:713:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG3, config3);
./drivers/staging/iio/addac/adt7316.c:717:	chip->config3 = config3;
./drivers/staging/iio/addac/adt7316.c:736:		!!(chip->config3 & ADT7316_EN_IN_TEMP_PROP_DACA));
./drivers/staging/iio/addac/adt7316.c:749:	config3 = chip->config3 & (~ADT7316_EN_IN_TEMP_PROP_DACA);
./drivers/staging/iio/addac/adt7316.c:753:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG3, config3);
./drivers/staging/iio/addac/adt7316.c:757:	chip->config3 = config3;
./drivers/staging/iio/addac/adt7316.c:775:		!!(chip->config3 & ADT7316_EN_EX_TEMP_PROP_DACB));
./drivers/staging/iio/addac/adt7316.c:788:	config3 = chip->config3 & (~ADT7316_EN_EX_TEMP_PROP_DACB);
./drivers/staging/iio/addac/adt7316.c:792:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG3, config3);
./drivers/staging/iio/addac/adt7316.c:796:	chip->config3 = config3;
./drivers/staging/iio/addac/adt7316.c:814:		chip->dac_config & ADT7316_DA_2VREF_CH_MASK);
./drivers/staging/iio/addac/adt7316.c:832:	dac_config = chip->dac_config & (~ADT7316_DA_2VREF_CH_MASK);
./drivers/staging/iio/addac/adt7316.c:835:	ret = chip->bus.write(chip->bus.client, ADT7316_DAC_CONFIG, dac_config);
./drivers/staging/iio/addac/adt7316.c:839:	chip->dac_config = dac_config;
./drivers/staging/iio/addac/adt7316.c:856:	if (!(chip->config3 & ADT7316_DA_EN_VIA_DAC_LDCA))
./drivers/staging/iio/addac/adt7316.c:859:	switch (chip->dac_config & ADT7316_DA_EN_MODE_MASK) {
./drivers/staging/iio/addac/adt7316.c:885:	if (!(chip->config3 & ADT7316_DA_EN_VIA_DAC_LDCA))
./drivers/staging/iio/addac/adt7316.c:892:	dac_config = chip->dac_config & (~ADT7316_DA_EN_MODE_MASK);
./drivers/staging/iio/addac/adt7316.c:895:	ret = chip->bus.write(chip->bus.client, ADT7316_DAC_CONFIG, dac_config);
./drivers/staging/iio/addac/adt7316.c:899:	chip->dac_config = dac_config;
./drivers/staging/iio/addac/adt7316.c:916:	if (chip->config3 & ADT7316_DA_EN_VIA_DAC_LDCA)
./drivers/staging/iio/addac/adt7316.c:939:	if (chip->config3 & ADT7316_DA_EN_VIA_DAC_LDCA) {
./drivers/staging/iio/addac/adt7316.c:940:		if ((chip->dac_config & ADT7316_DA_EN_MODE_MASK) !=
./drivers/staging/iio/addac/adt7316.c:948:		ldac_config = chip->ldac_config & (~ADT7316_LDAC_EN_DA_MASK);
./drivers/staging/iio/addac/adt7316.c:951:		ret = chip->bus.write(chip->bus.client, ADT7316_LDAC_CONFIG,
./drivers/staging/iio/addac/adt7316.c:956:		gpio_set_value(chip->ldac_pin, 0);
./drivers/staging/iio/addac/adt7316.c:957:		gpio_set_value(chip->ldac_pin, 1);
./drivers/staging/iio/addac/adt7316.c:975:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:979:		!!(chip->dac_config & ADT7316_VREF_BYPASS_DAC_AB));
./drivers/staging/iio/addac/adt7316.c:992:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:995:	dac_config = chip->dac_config & (~ADT7316_VREF_BYPASS_DAC_AB);
./drivers/staging/iio/addac/adt7316.c:999:	ret = chip->bus.write(chip->bus.client, ADT7316_DAC_CONFIG, dac_config);
./drivers/staging/iio/addac/adt7316.c:1003:	chip->dac_config = dac_config;
./drivers/staging/iio/addac/adt7316.c:1020:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:1024:		!!(chip->dac_config & ADT7316_VREF_BYPASS_DAC_CD));
./drivers/staging/iio/addac/adt7316.c:1037:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:1040:	dac_config = chip->dac_config & (~ADT7316_VREF_BYPASS_DAC_CD);
./drivers/staging/iio/addac/adt7316.c:1044:	ret = chip->bus.write(chip->bus.client, ADT7316_DAC_CONFIG, dac_config);
./drivers/staging/iio/addac/adt7316.c:1048:	chip->dac_config = dac_config;
./drivers/staging/iio/addac/adt7316.c:1065:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:1067:			(chip->dac_config & ADT7516_DAC_IN_VREF_MASK) >>
./drivers/staging/iio/addac/adt7316.c:1070:		       !!(chip->dac_config & ADT7316_DAC_IN_VREF));
./drivers/staging/iio/addac/adt7316.c:1084:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX) {
./drivers/staging/iio/addac/adt7316.c:1089:		ldac_config = chip->ldac_config & (~ADT7516_DAC_IN_VREF_MASK);
./drivers/staging/iio/addac/adt7316.c:1099:		ldac_config = chip->ldac_config & (~ADT7316_DAC_IN_VREF);
./drivers/staging/iio/addac/adt7316.c:1101:			ldac_config = chip->ldac_config | ADT7316_DAC_IN_VREF;
./drivers/staging/iio/addac/adt7316.c:1104:	ret = chip->bus.write(chip->bus.client, ADT7316_LDAC_CONFIG,
./drivers/staging/iio/addac/adt7316.c:1109:	chip->ldac_config = ldac_config;
./drivers/staging/iio/addac/adt7316.c:1127:	if ((chip->config2 & ADT7316_AD_SINGLE_CH_MODE) &&
./drivers/staging/iio/addac/adt7316.c:1128:		channel != (chip->config2 & ADT7516_AD_SINGLE_CH_MASK))
./drivers/staging/iio/addac/adt7316.c:1133:		ret = chip->bus.read(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1138:		ret = chip->bus.read(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1147:		ret = chip->bus.read(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1152:		ret = chip->bus.read(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1162:		ret = chip->bus.read(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1167:		ret = chip->bus.read(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1177:		if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:1271:	ret = chip->bus.read(chip->bus.client, offset_addr, &val);
./drivers/staging/iio/addac/adt7316.c:1298:	ret = chip->bus.write(chip->bus.client, offset_addr, val);
./drivers/staging/iio/addac/adt7316.c:1420:		(chip->config3 & ADT7316_EN_IN_TEMP_PROP_DACA)) ||
./drivers/staging/iio/addac/adt7316.c:1422:		(chip->config3 & ADT7316_EN_EX_TEMP_PROP_DACB)))
./drivers/staging/iio/addac/adt7316.c:1425:	offset = chip->dac_bits - 8;
./drivers/staging/iio/addac/adt7316.c:1427:	if (chip->dac_bits > 8) {
./drivers/staging/iio/addac/adt7316.c:1428:		ret = chip->bus.read(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1434:	ret = chip->bus.read(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1453:		(chip->config3 & ADT7316_EN_IN_TEMP_PROP_DACA)) ||
./drivers/staging/iio/addac/adt7316.c:1455:		(chip->config3 & ADT7316_EN_EX_TEMP_PROP_DACB)))
./drivers/staging/iio/addac/adt7316.c:1458:	offset = chip->dac_bits - 8;
./drivers/staging/iio/addac/adt7316.c:1461:	if (ret || data >= (1 << chip->dac_bits))
./drivers/staging/iio/addac/adt7316.c:1464:	if (chip->dac_bits > 8) {
./drivers/staging/iio/addac/adt7316.c:1466:		ret = chip->bus.write(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1473:	ret = chip->bus.write(chip->bus.client,
./drivers/staging/iio/addac/adt7316.c:1586:	ret = chip->bus.read(chip->bus.client, ADT7316_DEVICE_ID, &id);
./drivers/staging/iio/addac/adt7316.c:1604:	ret = chip->bus.read(chip->bus.client, ADT7316_MANUFACTURE_ID, &id);
./drivers/staging/iio/addac/adt7316.c:1623:	ret = chip->bus.read(chip->bus.client, ADT7316_DEVICE_REV, &rev);
./drivers/staging/iio/addac/adt7316.c:1641:	ret = chip->bus.read(chip->bus.client, ADT7316_SPI_LOCK_STAT, &stat);
./drivers/staging/iio/addac/adt7316.c:1750:	ret = chip->bus.read(chip->bus.client, ADT7316_INT_STAT1, &stat1);
./drivers/staging/iio/addac/adt7316.c:1752:		if ((chip->id & ID_FAMILY_MASK) != ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:1799:	ret = chip->bus.read(chip->bus.client, ADT7316_INT_STAT2, &stat2);
./drivers/staging/iio/addac/adt7316.c:1823:	return sprintf(buf, "0x%x\n", chip->int_mask);
./drivers/staging/iio/addac/adt7316.c:1849:	ret = chip->bus.write(chip->bus.client, ADT7316_INT_MASK2, mask);
./drivers/staging/iio/addac/adt7316.c:1851:		chip->int_mask &= ~ADT7316_VDD_INT_MASK;
./drivers/staging/iio/addac/adt7316.c:1852:		chip->int_mask |= data & ADT7316_VDD_INT_MASK;
./drivers/staging/iio/addac/adt7316.c:1856:		if ((chip->id & ID_FAMILY_MASK) == ID_ADT73XX)
./drivers/staging/iio/addac/adt7316.c:1863:	ret = chip->bus.write(chip->bus.client, ADT7316_INT_MASK1, mask);
./drivers/staging/iio/addac/adt7316.c:1865:	chip->int_mask = mask;
./drivers/staging/iio/addac/adt7316.c:1880:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT73XX &&
./drivers/staging/iio/addac/adt7316.c:1884:	ret = chip->bus.read(chip->bus.client, this_attr->address, &val);
./drivers/staging/iio/addac/adt7316.c:1890:	if (!((chip->id & ID_FAMILY_MASK) == ID_ADT75XX &&
./drivers/staging/iio/addac/adt7316.c:1891:		(chip->config1 & ADT7516_SEL_AIN1_2_EX_TEMP_MASK) == 0)) {
./drivers/staging/iio/addac/adt7316.c:1911:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT73XX &&
./drivers/staging/iio/addac/adt7316.c:1919:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX &&
./drivers/staging/iio/addac/adt7316.c:1920:		(chip->config1 & ADT7516_SEL_AIN1_2_EX_TEMP_MASK) == 0) {
./drivers/staging/iio/addac/adt7316.c:1933:	ret = chip->bus.write(chip->bus.client, this_attr->address, val);
./drivers/staging/iio/addac/adt7316.c:1947:	return sprintf(buf, "%d\n", !!(chip->config1 & ADT7316_INT_EN));
./drivers/staging/iio/addac/adt7316.c:1960:	config1 = chip->config1 & (~ADT7316_INT_EN);
./drivers/staging/iio/addac/adt7316.c:1964:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG1, config1);
./drivers/staging/iio/addac/adt7316.c:1968:	chip->config1 = config1;
./drivers/staging/iio/addac/adt7316.c:2119:	chip->bus = *bus;
./drivers/staging/iio/addac/adt7316.c:2122:		chip->id = ID_ADT7316 + (name[6] - '6');
./drivers/staging/iio/addac/adt7316.c:2124:		chip->id = ID_ADT7516 + (name[6] - '6');
./drivers/staging/iio/addac/adt7316.c:2128:	chip->ldac_pin = adt7316_platform_data[1];
./drivers/staging/iio/addac/adt7316.c:2129:	if (chip->ldac_pin) {
./drivers/staging/iio/addac/adt7316.c:2130:		chip->config3 |= ADT7316_DA_EN_VIA_DAC_LDCA;
./drivers/staging/iio/addac/adt7316.c:2131:		if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:2132:			chip->config1 |= ADT7516_SEL_AIN3;
./drivers/staging/iio/addac/adt7316.c:2134:	chip->int_mask = ADT7316_TEMP_INT_MASK | ADT7316_VDD_INT_MASK;
./drivers/staging/iio/addac/adt7316.c:2135:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:2136:		chip->int_mask |= ADT7516_AIN_INT_MASK;
./drivers/staging/iio/addac/adt7316.c:2139:	if ((chip->id & ID_FAMILY_MASK) == ID_ADT75XX)
./drivers/staging/iio/addac/adt7316.c:2146:	if (chip->bus.irq > 0) {
./drivers/staging/iio/addac/adt7316.c:2148:			chip->bus.irq_flags = adt7316_platform_data[0];
./drivers/staging/iio/addac/adt7316.c:2150:		ret = devm_request_threaded_irq(dev, chip->bus.irq,
./drivers/staging/iio/addac/adt7316.c:2153:						chip->bus.irq_flags |
./drivers/staging/iio/addac/adt7316.c:2160:		if (chip->bus.irq_flags & IRQF_TRIGGER_HIGH)
./drivers/staging/iio/addac/adt7316.c:2161:			chip->config1 |= ADT7316_INT_POLARITY;
./drivers/staging/iio/addac/adt7316.c:2164:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG1, chip->config1);
./drivers/staging/iio/addac/adt7316.c:2168:	ret = chip->bus.write(chip->bus.client, ADT7316_CONFIG3, chip->config3);
./drivers/staging/iio/cdc/ad7746.c:224:		vt_setup = chip->vt_setup & ~AD7746_VTSETUP_VTEN;
./drivers/staging/iio/cdc/ad7746.c:225:		delay = ad7746_cap_filter_rate_table[(chip->config >> 3) &
./drivers/staging/iio/cdc/ad7746.c:228:		if (chip->capdac_set != chan->channel) {
./drivers/staging/iio/cdc/ad7746.c:229:			ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7746.c:231:				chip->capdac[chan->channel][0]);
./drivers/staging/iio/cdc/ad7746.c:234:			ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7746.c:236:				chip->capdac[chan->channel][1]);
./drivers/staging/iio/cdc/ad7746.c:240:			chip->capdac_set = chan->channel;
./drivers/staging/iio/cdc/ad7746.c:246:		cap_setup = chip->cap_setup & ~AD7746_CAPSETUP_CAPEN;
./drivers/staging/iio/cdc/ad7746.c:247:		delay = ad7746_cap_filter_rate_table[(chip->config >> 6) &
./drivers/staging/iio/cdc/ad7746.c:254:	if (chip->cap_setup != cap_setup) {
./drivers/staging/iio/cdc/ad7746.c:255:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7746.c:261:		chip->cap_setup = cap_setup;
./drivers/staging/iio/cdc/ad7746.c:264:	if (chip->vt_setup != vt_setup) {
./drivers/staging/iio/cdc/ad7746.c:265:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7746.c:271:		chip->vt_setup = vt_setup;
./drivers/staging/iio/cdc/ad7746.c:296:	regval |= chip->config;
./drivers/staging/iio/cdc/ad7746.c:297:	ret = i2c_smbus_write_byte_data(chip->client, AD7746_REG_CFG, regval);
./drivers/staging/iio/cdc/ad7746.c:305:		ret = i2c_smbus_read_byte_data(chip->client, AD7746_REG_CFG);
./drivers/staging/iio/cdc/ad7746.c:366:			(chip->config >> 3) & 0x7][0]);
./drivers/staging/iio/cdc/ad7746.c:391:	chip->config &= ~AD7746_CONF_CAPFS(0x7);
./drivers/staging/iio/cdc/ad7746.c:392:	chip->config |= AD7746_CONF_CAPFS(i);
./drivers/staging/iio/cdc/ad7746.c:406:			(chip->config >> 6) & 0x3][0]);
./drivers/staging/iio/cdc/ad7746.c:431:	chip->config &= ~AD7746_CONF_VTFS(0x3);
./drivers/staging/iio/cdc/ad7746.c:432:	chip->config |= AD7746_CONF_VTFS(i);
./drivers/staging/iio/cdc/ad7746.c:500:		ret = i2c_smbus_write_word_data(chip->client, reg, swab16(val));
./drivers/staging/iio/cdc/ad7746.c:511:		ret = i2c_smbus_write_word_data(chip->client,
./drivers/staging/iio/cdc/ad7746.c:532:		chip->capdac[chan->channel][chan->differential] = val > 0 ?
./drivers/staging/iio/cdc/ad7746.c:535:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7746.c:537:			chip->capdac[chan->channel][0]);
./drivers/staging/iio/cdc/ad7746.c:540:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7746.c:542:			chip->capdac[chan->channel][1]);
./drivers/staging/iio/cdc/ad7746.c:546:		chip->capdac_set = chan->channel;
./drivers/staging/iio/cdc/ad7746.c:578:		regval = chip->config | AD7746_CONF_MODE_SINGLE_CONV;
./drivers/staging/iio/cdc/ad7746.c:579:		ret = i2c_smbus_write_byte_data(chip->client, AD7746_REG_CFG,
./drivers/staging/iio/cdc/ad7746.c:587:		ret = i2c_smbus_read_i2c_block_data(chip->client,
./drivers/staging/iio/cdc/ad7746.c:588:			chan->address >> 8, 3, &chip->data.d8[1]);
./drivers/staging/iio/cdc/ad7746.c:593:		*val = (be32_to_cpu(chip->data.d32) & 0xFFFFFF) - 0x800000;
./drivers/staging/iio/cdc/ad7746.c:626:		ret = i2c_smbus_read_word_data(chip->client, reg);
./drivers/staging/iio/cdc/ad7746.c:636:		ret = i2c_smbus_read_word_data(chip->client,
./drivers/staging/iio/cdc/ad7746.c:645:		*val = AD7746_CAPDAC_DACP(chip->capdac[chan->channel]
./drivers/staging/iio/cdc/ad7746.c:705:	chip->client = client;
./drivers/staging/iio/cdc/ad7746.c:706:	chip->capdac_set = -1;
./drivers/staging/iio/cdc/ad7746.c:742:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:119:	ret = i2c_smbus_write_byte_data(chip->client, AD7152_REG_CFG, regval);
./drivers/staging/iio/cdc/ad7152.c:127:		ret = i2c_smbus_read_byte_data(chip->client, AD7152_REG_CFG);
./drivers/staging/iio/cdc/ad7152.c:176:		       ad7152_filter_rate_table[chip->filter_rate_setup][0]);
./drivers/staging/iio/cdc/ad7152.c:201:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:208:	chip->filter_rate_setup = i;
./drivers/staging/iio/cdc/ad7152.c:270:		ret = i2c_smbus_write_word_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:284:		ret = i2c_smbus_write_word_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:301:		chip->setup[chan->channel] &= ~AD7152_SETUP_RANGE_4pF;
./drivers/staging/iio/cdc/ad7152.c:302:		chip->setup[chan->channel] |= AD7152_SETUP_RANGE(i);
./drivers/staging/iio/cdc/ad7152.c:304:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:306:				chip->setup[chan->channel]);
./drivers/staging/iio/cdc/ad7152.c:335:		regval = chip->setup[chan->channel];
./drivers/staging/iio/cdc/ad7152.c:338:			chip->setup[chan->channel] |= AD7152_SETUP_CAPDIFF;
./drivers/staging/iio/cdc/ad7152.c:340:			chip->setup[chan->channel] &= ~AD7152_SETUP_CAPDIFF;
./drivers/staging/iio/cdc/ad7152.c:342:		if (regval != chip->setup[chan->channel]) {
./drivers/staging/iio/cdc/ad7152.c:343:			ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:345:				chip->setup[chan->channel]);
./drivers/staging/iio/cdc/ad7152.c:357:		ret = i2c_smbus_write_byte_data(chip->client, AD7152_REG_CFG,
./drivers/staging/iio/cdc/ad7152.c:362:		msleep(ad7152_filter_rate_table[chip->filter_rate_setup][1]);
./drivers/staging/iio/cdc/ad7152.c:364:		ret = i2c_smbus_read_word_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:377:		ret = i2c_smbus_read_word_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:388:		ret = i2c_smbus_read_word_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:397:		ret = i2c_smbus_read_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7152.c:491:	chip->client = client;
./drivers/staging/iio/cdc/ad7150.c:108:		ret = i2c_smbus_read_word_data(chip->client,
./drivers/staging/iio/cdc/ad7150.c:115:		ret = i2c_smbus_read_word_data(chip->client,
./drivers/staging/iio/cdc/ad7150.c:135:	ret = i2c_smbus_read_byte_data(chip->client, AD7150_CFG);
./drivers/staging/iio/cdc/ad7150.c:176:	if (event_code != chip->current_event)
./drivers/staging/iio/cdc/ad7150.c:182:		value = chip->threshold[rising][chan];
./drivers/staging/iio/cdc/ad7150.c:183:		return i2c_smbus_write_word_data(chip->client,
./drivers/staging/iio/cdc/ad7150.c:187:		sens = chip->mag_sensitivity[rising][chan];
./drivers/staging/iio/cdc/ad7150.c:188:		timeout = chip->mag_timeout[rising][chan];
./drivers/staging/iio/cdc/ad7150.c:191:		sens = chip->thresh_sensitivity[rising][chan];
./drivers/staging/iio/cdc/ad7150.c:192:		timeout = chip->thresh_timeout[rising][chan];
./drivers/staging/iio/cdc/ad7150.c:197:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7150.c:203:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/cdc/ad7150.c:228:	if (event_code == chip->current_event)
./drivers/staging/iio/cdc/ad7150.c:230:	mutex_lock(&chip->state_lock);
./drivers/staging/iio/cdc/ad7150.c:231:	ret = i2c_smbus_read_byte_data(chip->client, AD7150_CFG);
./drivers/staging/iio/cdc/ad7150.c:266:	ret = i2c_smbus_write_byte_data(chip->client, AD7150_CFG, cfg);
./drivers/staging/iio/cdc/ad7150.c:270:	chip->current_event = event_code;
./drivers/staging/iio/cdc/ad7150.c:275:	mutex_unlock(&chip->state_lock);
./drivers/staging/iio/cdc/ad7150.c:293:		*val = chip->mag_sensitivity[rising][chan->channel];
./drivers/staging/iio/cdc/ad7150.c:296:		*val = chip->thresh_sensitivity[rising][chan->channel];
./drivers/staging/iio/cdc/ad7150.c:299:		*val = chip->threshold[rising][chan->channel];
./drivers/staging/iio/cdc/ad7150.c:317:	mutex_lock(&chip->state_lock);
./drivers/staging/iio/cdc/ad7150.c:320:		chip->mag_sensitivity[rising][chan->channel] = val;
./drivers/staging/iio/cdc/ad7150.c:323:		chip->thresh_sensitivity[rising][chan->channel] = val;
./drivers/staging/iio/cdc/ad7150.c:326:		chip->threshold[rising][chan->channel] = val;
./drivers/staging/iio/cdc/ad7150.c:337:	mutex_unlock(&chip->state_lock);
./drivers/staging/iio/cdc/ad7150.c:357:		value = chip->mag_timeout[rising][chan];
./drivers/staging/iio/cdc/ad7150.c:360:		value = chip->thresh_timeout[rising][chan];
./drivers/staging/iio/cdc/ad7150.c:392:	mutex_lock(&chip->state_lock);
./drivers/staging/iio/cdc/ad7150.c:395:		chip->mag_timeout[rising][chan] = data;
./drivers/staging/iio/cdc/ad7150.c:398:		chip->thresh_timeout[rising][chan] = data;
./drivers/staging/iio/cdc/ad7150.c:407:	mutex_unlock(&chip->state_lock);
./drivers/staging/iio/cdc/ad7150.c:499:	ret = i2c_smbus_read_byte_data(chip->client, AD7150_STATUS);
./drivers/staging/iio/cdc/ad7150.c:506:	    !(chip->old_state & AD7150_STATUS_OUT1))
./drivers/staging/iio/cdc/ad7150.c:514:		 (chip->old_state & AD7150_STATUS_OUT1))
./drivers/staging/iio/cdc/ad7150.c:523:	    !(chip->old_state & AD7150_STATUS_OUT2))
./drivers/staging/iio/cdc/ad7150.c:531:		 (chip->old_state & AD7150_STATUS_OUT2))
./drivers/staging/iio/cdc/ad7150.c:539:	chip->old_state = int_status;
./drivers/staging/iio/cdc/ad7150.c:595:	mutex_init(&chip->state_lock);
./drivers/staging/iio/cdc/ad7150.c:599:	chip->client = client;
./drivers/staging/iio/light/isl29028.c:93:	return regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,
./drivers/staging/iio/light/isl29028.c:104:	ret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,
./drivers/staging/iio/light/isl29028.c:110:	mdelay(DIV_ROUND_UP(1000, chip->prox_sampling));
./drivers/staging/iio/light/isl29028.c:119:	return regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,
./drivers/staging/iio/light/isl29028.c:130:		ret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,
./drivers/staging/iio/light/isl29028.c:136:		ret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,
./drivers/staging/iio/light/isl29028.c:142:		ret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,
./drivers/staging/iio/light/isl29028.c:148:		return regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,
./drivers/staging/iio/light/isl29028.c:156:	ret = regmap_update_bits(chip->regmap, ISL29028_REG_CONFIGURE,
./drivers/staging/iio/light/isl29028.c:168:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29028.c:173:	ret = regmap_read(chip->regmap, ISL29028_REG_ALSIR_L, &lsb);
./drivers/staging/iio/light/isl29028.c:180:	ret = regmap_read(chip->regmap, ISL29028_REG_ALSIR_U, &msb);
./drivers/staging/iio/light/isl29028.c:193:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29028.c:197:	ret = regmap_read(chip->regmap, ISL29028_REG_PROX_DATA, &data);
./drivers/staging/iio/light/isl29028.c:211:	if (!chip->enable_prox) {
./drivers/staging/iio/light/isl29028.c:215:		chip->enable_prox = true;
./drivers/staging/iio/light/isl29028.c:222:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29028.c:226:	if (chip->als_ir_mode != MODE_ALS) {
./drivers/staging/iio/light/isl29028.c:233:		chip->als_ir_mode = MODE_ALS;
./drivers/staging/iio/light/isl29028.c:245:	if (chip->lux_scale == 125)
./drivers/staging/iio/light/isl29028.c:256:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29028.c:259:	if (chip->als_ir_mode != MODE_IR) {
./drivers/staging/iio/light/isl29028.c:266:		chip->als_ir_mode = MODE_IR;
./drivers/staging/iio/light/isl29028.c:277:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29028.c:280:	mutex_lock(&chip->lock);
./drivers/staging/iio/light/isl29028.c:301:		chip->prox_sampling = val;
./drivers/staging/iio/light/isl29028.c:322:		chip->lux_scale = val;
./drivers/staging/iio/light/isl29028.c:329:	mutex_unlock(&chip->lock);
./drivers/staging/iio/light/isl29028.c:338:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29028.c:341:	mutex_lock(&chip->lock);
./drivers/staging/iio/light/isl29028.c:366:		*val = chip->prox_sampling;
./drivers/staging/iio/light/isl29028.c:373:		*val = chip->lux_scale;
./drivers/staging/iio/light/isl29028.c:381:	mutex_unlock(&chip->lock);
./drivers/staging/iio/light/isl29028.c:425:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29028.c:428:	chip->enable_prox  = false;
./drivers/staging/iio/light/isl29028.c:429:	chip->prox_sampling = 20;
./drivers/staging/iio/light/isl29028.c:430:	chip->lux_scale = 2000;
./drivers/staging/iio/light/isl29028.c:431:	chip->als_ir_mode = MODE_NONE;
./drivers/staging/iio/light/isl29028.c:433:	ret = regmap_write(chip->regmap, ISL29028_REG_TEST1_MODE, 0x0);
./drivers/staging/iio/light/isl29028.c:439:	ret = regmap_write(chip->regmap, ISL29028_REG_TEST2_MODE, 0x0);
./drivers/staging/iio/light/isl29028.c:446:	ret = regmap_write(chip->regmap, ISL29028_REG_CONFIGURE, 0x0);
./drivers/staging/iio/light/isl29028.c:453:	ret = isl29028_set_proxim_sampling(chip, chip->prox_sampling);
./drivers/staging/iio/light/isl29028.c:459:	ret = isl29028_set_als_scale(chip, chip->lux_scale);
./drivers/staging/iio/light/isl29028.c:503:	mutex_init(&chip->lock);
./drivers/staging/iio/light/isl29028.c:505:	chip->regmap = devm_regmap_init_i2c(client, &isl29028_regmap_config);
./drivers/staging/iio/light/isl29028.c:506:	if (IS_ERR(chip->regmap)) {
./drivers/staging/iio/light/isl29028.c:507:		ret = PTR_ERR(chip->regmap);
./drivers/staging/iio/light/isl29018.c:120:	for (i = 0; i < ARRAY_SIZE(isl29018_int_utimes[chip->type]); ++i) {
./drivers/staging/iio/light/isl29018.c:121:		if (utime == isl29018_int_utimes[chip->type][i]) {
./drivers/staging/iio/light/isl29018.c:127:	if (i >= ARRAY_SIZE(isl29018_int_utimes[chip->type]))
./drivers/staging/iio/light/isl29018.c:130:	ret = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMANDII,
./drivers/staging/iio/light/isl29018.c:137:	int_time = chip->int_time;
./drivers/staging/iio/light/isl29018.c:139:		if (chip->scale.scale == isl29018_scales[int_time][i].scale &&
./drivers/staging/iio/light/isl29018.c:140:		    chip->scale.uscale == isl29018_scales[int_time][i].uscale) {
./drivers/staging/iio/light/isl29018.c:141:			chip->scale = isl29018_scales[new_int_time][i];
./drivers/staging/iio/light/isl29018.c:145:	chip->int_time = new_int_time;
./drivers/staging/iio/light/isl29018.c:155:	for (i = 0; i < ARRAY_SIZE(isl29018_scales[chip->int_time]); ++i) {
./drivers/staging/iio/light/isl29018.c:156:		if (scale == isl29018_scales[chip->int_time][i].scale &&
./drivers/staging/iio/light/isl29018.c:157:		    uscale == isl29018_scales[chip->int_time][i].uscale) {
./drivers/staging/iio/light/isl29018.c:158:			new_scale = isl29018_scales[chip->int_time][i];
./drivers/staging/iio/light/isl29018.c:163:	if (i >= ARRAY_SIZE(isl29018_scales[chip->int_time]))
./drivers/staging/iio/light/isl29018.c:166:	ret = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMANDII,
./drivers/staging/iio/light/isl29018.c:172:	chip->scale = new_scale;
./drivers/staging/iio/light/isl29018.c:182:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29018.c:185:	status = regmap_write(chip->regmap, ISL29018_REG_ADD_COMMAND1,
./drivers/staging/iio/light/isl29018.c:193:	status = regmap_read(chip->regmap, ISL29018_REG_ADD_DATA_LSB, &lsb);
./drivers/staging/iio/light/isl29018.c:200:	status = regmap_read(chip->regmap, ISL29018_REG_ADD_DATA_MSB, &msb);
./drivers/staging/iio/light/isl29018.c:221:	data_x_range = lux_data * chip->scale.scale +
./drivers/staging/iio/light/isl29018.c:222:		       lux_data * chip->scale.uscale / 1000000;
./drivers/staging/iio/light/isl29018.c:223:	*lux = data_x_range * chip->calibscale +
./drivers/staging/iio/light/isl29018.c:224:	       data_x_range * chip->ucalibscale / 1000000;
./drivers/staging/iio/light/isl29018.c:249:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29018.c:252:	status = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMANDII,
./drivers/staging/iio/light/isl29018.c:290:	for (i = 0; i < ARRAY_SIZE(isl29018_scales[chip->int_time]); ++i)
./drivers/staging/iio/light/isl29018.c:292:			       isl29018_scales[chip->int_time][i].scale,
./drivers/staging/iio/light/isl29018.c:293:			       isl29018_scales[chip->int_time][i].uscale);
./drivers/staging/iio/light/isl29018.c:307:	for (i = 0; i < ARRAY_SIZE(isl29018_int_utimes[chip->type]); ++i)
./drivers/staging/iio/light/isl29018.c:309:			       isl29018_int_utimes[chip->type][i]);
./drivers/staging/iio/light/isl29018.c:328:	return sprintf(buf, "%d\n", chip->prox_scheme);
./drivers/staging/iio/light/isl29018.c:350:	mutex_lock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:351:	chip->prox_scheme = val;
./drivers/staging/iio/light/isl29018.c:352:	mutex_unlock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:367:	mutex_lock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:371:			chip->calibscale = val;
./drivers/staging/iio/light/isl29018.c:372:			chip->ucalibscale = val2;
./drivers/staging/iio/light/isl29018.c:379:				mutex_unlock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:392:	mutex_unlock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:406:	mutex_lock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:407:	if (chip->suspended) {
./drivers/staging/iio/light/isl29018.c:408:		mutex_unlock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:423:							 chip->prox_scheme,
./drivers/staging/iio/light/isl29018.c:435:			*val2 = isl29018_int_utimes[chip->type][chip->int_time];
./drivers/staging/iio/light/isl29018.c:441:			*val = chip->scale.scale;
./drivers/staging/iio/light/isl29018.c:442:			*val2 = chip->scale.uscale;
./drivers/staging/iio/light/isl29018.c:448:			*val = chip->calibscale;
./drivers/staging/iio/light/isl29018.c:449:			*val2 = chip->ucalibscale;
./drivers/staging/iio/light/isl29018.c:456:	mutex_unlock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:529:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29018.c:531:	status = regmap_read(chip->regmap, ISL29035_REG_DEVICE_ID, &id);
./drivers/staging/iio/light/isl29018.c:545:	return regmap_update_bits(chip->regmap, ISL29035_REG_DEVICE_ID,
./drivers/staging/iio/light/isl29018.c:558:	struct device *dev = regmap_get_device(chip->regmap);
./drivers/staging/iio/light/isl29018.c:560:	if (chip->type == isl29035) {
./drivers/staging/iio/light/isl29018.c:586:	status = regmap_write(chip->regmap, ISL29018_REG_TEST, 0x0);
./drivers/staging/iio/light/isl29018.c:597:	status = regmap_write(chip->regmap, ISL29018_REG_ADD_COMMAND1, 0);
./drivers/staging/iio/light/isl29018.c:607:	status = isl29018_set_scale(chip, chip->scale.scale,
./drivers/staging/iio/light/isl29018.c:608:				    chip->scale.uscale);
./drivers/staging/iio/light/isl29018.c:615:			isl29018_int_utimes[chip->type][chip->int_time]);
./drivers/staging/iio/light/isl29018.c:743:	mutex_init(&chip->lock);
./drivers/staging/iio/light/isl29018.c:745:	chip->type = dev_id;
./drivers/staging/iio/light/isl29018.c:746:	chip->calibscale = 1;
./drivers/staging/iio/light/isl29018.c:747:	chip->ucalibscale = 0;
./drivers/staging/iio/light/isl29018.c:748:	chip->int_time = ISL29018_INT_TIME_16;
./drivers/staging/iio/light/isl29018.c:749:	chip->scale = isl29018_scales[chip->int_time][0];
./drivers/staging/iio/light/isl29018.c:750:	chip->suspended = false;
./drivers/staging/iio/light/isl29018.c:752:	chip->regmap = devm_regmap_init_i2c(client,
./drivers/staging/iio/light/isl29018.c:754:	if (IS_ERR(chip->regmap)) {
./drivers/staging/iio/light/isl29018.c:755:		err = PTR_ERR(chip->regmap);
./drivers/staging/iio/light/isl29018.c:784:	mutex_lock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:790:	chip->suspended = true;
./drivers/staging/iio/light/isl29018.c:792:	mutex_unlock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:801:	mutex_lock(&chip->lock);
./drivers/staging/iio/light/isl29018.c:805:		chip->suspended = false;
./drivers/staging/iio/light/isl29018.c:807:	mutex_unlock(&chip->lock);
./drivers/staging/iio/light/tsl2583.c:144:	chip->taos_settings.als_time = 100;
./drivers/staging/iio/light/tsl2583.c:146:	chip->taos_settings.als_gain = 0;
./drivers/staging/iio/light/tsl2583.c:149:	chip->taos_settings.als_gain_trim = 1000;
./drivers/staging/iio/light/tsl2583.c:151:	chip->taos_settings.als_cal_target = 130;
./drivers/staging/iio/light/tsl2583.c:207:	if (mutex_trylock(&chip->als_mutex) == 0) {
./drivers/staging/iio/light/tsl2583.c:208:		dev_info(&chip->client->dev, "taos_get_lux device is busy\n");
./drivers/staging/iio/light/tsl2583.c:209:		return chip->als_cur_info.lux; /* busy, so return LAST VALUE */
./drivers/staging/iio/light/tsl2583.c:212:	if (chip->taos_chip_status != TSL258X_CHIP_WORKING) {
./drivers/staging/iio/light/tsl2583.c:214:		dev_err(&chip->client->dev, "taos_get_lux device is not enabled\n");
./drivers/staging/iio/light/tsl2583.c:219:	ret = taos_i2c_read(chip->client, (TSL258X_CMD_REG), &buf[0], 1);
./drivers/staging/iio/light/tsl2583.c:221:		dev_err(&chip->client->dev, "taos_get_lux failed to read CMD_REG\n");
./drivers/staging/iio/light/tsl2583.c:226:		dev_err(&chip->client->dev, "taos_get_lux data not valid\n");
./drivers/staging/iio/light/tsl2583.c:227:		ret = chip->als_cur_info.lux; /* return LAST VALUE */
./drivers/staging/iio/light/tsl2583.c:234:		ret = taos_i2c_read(chip->client, reg, &buf[i], 1);
./drivers/staging/iio/light/tsl2583.c:236:			dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2583.c:247:	ret = i2c_smbus_write_byte(chip->client,
./drivers/staging/iio/light/tsl2583.c:252:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2583.c:262:	chip->als_cur_info.als_ch0 = ch0;
./drivers/staging/iio/light/tsl2583.c:263:	chip->als_cur_info.als_ch1 = ch1;
./drivers/staging/iio/light/tsl2583.c:265:	if ((ch0 >= chip->als_saturation) || (ch1 >= chip->als_saturation))
./drivers/staging/iio/light/tsl2583.c:271:		chip->als_cur_info.lux = 0;
./drivers/staging/iio/light/tsl2583.c:285:			  (gainadj[chip->taos_settings.als_gain].ch0 >> 1))
./drivers/staging/iio/light/tsl2583.c:286:			 / gainadj[chip->taos_settings.als_gain].ch0;
./drivers/staging/iio/light/tsl2583.c:288:			  (gainadj[chip->taos_settings.als_gain].ch1 >> 1))
./drivers/staging/iio/light/tsl2583.c:289:			 / gainadj[chip->taos_settings.als_gain].ch1;
./drivers/staging/iio/light/tsl2583.c:295:		dev_dbg(&chip->client->dev, "No Data - Return last value\n");
./drivers/staging/iio/light/tsl2583.c:297:		chip->als_cur_info.lux = 0;
./drivers/staging/iio/light/tsl2583.c:302:	if (chip->als_time_scale == 0)
./drivers/staging/iio/light/tsl2583.c:305:		lux = (lux + (chip->als_time_scale >> 1)) /
./drivers/staging/iio/light/tsl2583.c:306:			chip->als_time_scale;
./drivers/staging/iio/light/tsl2583.c:317:	lux64 = lux64 * chip->taos_settings.als_gain_trim;
./drivers/staging/iio/light/tsl2583.c:327:	chip->als_cur_info.lux = lux;
./drivers/staging/iio/light/tsl2583.c:331:	mutex_unlock(&chip->als_mutex);
./drivers/staging/iio/light/tsl2583.c:348:	ret = i2c_smbus_write_byte(chip->client,
./drivers/staging/iio/light/tsl2583.c:351:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2583.c:357:	reg_val = i2c_smbus_read_byte(chip->client);
./drivers/staging/iio/light/tsl2583.c:360:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2583.c:365:	ret = i2c_smbus_write_byte(chip->client,
./drivers/staging/iio/light/tsl2583.c:368:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2583.c:373:	reg_val = i2c_smbus_read_byte(chip->client);
./drivers/staging/iio/light/tsl2583.c:376:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2583.c:382:		dev_err(&chip->client->dev, "taos_als_calibrate failed to get lux\n");
./drivers/staging/iio/light/tsl2583.c:385:	gain_trim_val = (unsigned int)(((chip->taos_settings.als_cal_target)
./drivers/staging/iio/light/tsl2583.c:386:			* chip->taos_settings.als_gain_trim) / lux_val);
./drivers/staging/iio/light/tsl2583.c:389:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2583.c:394:	chip->taos_settings.als_gain_trim = (int)gain_trim_val;
./drivers/staging/iio/light/tsl2583.c:414:	if (chip->taos_chip_status == TSL258X_CHIP_WORKING) {
./drivers/staging/iio/light/tsl2583.c:416:		dev_info(&chip->client->dev, "device is already enabled\n");
./drivers/staging/iio/light/tsl2583.c:421:	als_count = (chip->taos_settings.als_time * 100 + 135) / 270;
./drivers/staging/iio/light/tsl2583.c:427:	chip->taos_config[TSL258X_ALS_TIME] = 256 - als_count;
./drivers/staging/iio/light/tsl2583.c:430:	chip->taos_config[TSL258X_GAIN] = chip->taos_settings.als_gain;
./drivers/staging/iio/light/tsl2583.c:433:	chip->als_saturation = als_count * 922; /* 90% of full scale */
./drivers/staging/iio/light/tsl2583.c:434:	chip->als_time_scale = (als_time + 25) / 50;
./drivers/staging/iio/light/tsl2583.c:441:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/light/tsl2583.c:444:		dev_err(&chip->client->dev, "taos_chip_on failed on CNTRL reg.\n");
./drivers/staging/iio/light/tsl2583.c:452:	for (i = 0, uP = chip->taos_config; i < TSL258X_REG_MAX; i++) {
./drivers/staging/iio/light/tsl2583.c:453:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/light/tsl2583.c:457:			dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2583.c:469:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/light/tsl2583.c:473:		dev_err(&chip->client->dev, "taos_chip_on failed on 2nd CTRL reg.\n");
./drivers/staging/iio/light/tsl2583.c:476:	chip->taos_chip_status = TSL258X_CHIP_WORKING;
./drivers/staging/iio/light/tsl2583.c:486:	chip->taos_chip_status = TSL258X_CHIP_SUSPENDED;
./drivers/staging/iio/light/tsl2583.c:487:	return i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/light/tsl2583.c:500:	return sprintf(buf, "%d\n", chip->taos_chip_status);
./drivers/staging/iio/light/tsl2583.c:528:	switch (chip->taos_settings.als_gain) {
./drivers/staging/iio/light/tsl2583.c:559:		chip->taos_settings.als_gain = 0;
./drivers/staging/iio/light/tsl2583.c:562:		chip->taos_settings.als_gain = 1;
./drivers/staging/iio/light/tsl2583.c:565:		chip->taos_settings.als_gain = 2;
./drivers/staging/iio/light/tsl2583.c:568:		chip->taos_settings.als_gain = 3;
./drivers/staging/iio/light/tsl2583.c:591:	return sprintf(buf, "%d\n", chip->taos_settings.als_time);
./drivers/staging/iio/light/tsl2583.c:611:	chip->taos_settings.als_time = value;
./drivers/staging/iio/light/tsl2583.c:630:	return sprintf(buf, "%d\n", chip->taos_settings.als_gain_trim);
./drivers/staging/iio/light/tsl2583.c:645:		chip->taos_settings.als_gain_trim = value;
./drivers/staging/iio/light/tsl2583.c:657:	return sprintf(buf, "%d\n", chip->taos_settings.als_cal_target);
./drivers/staging/iio/light/tsl2583.c:672:		chip->taos_settings.als_cal_target = value;
./drivers/staging/iio/light/tsl2583.c:756:	if (chip->taos_chip_status == TSL258X_CHIP_WORKING)
./drivers/staging/iio/light/tsl2583.c:843:	chip->client = clientp;
./drivers/staging/iio/light/tsl2583.c:846:	mutex_init(&chip->als_mutex);
./drivers/staging/iio/light/tsl2583.c:847:	chip->taos_chip_status = TSL258X_CHIP_UNKNOWN;
./drivers/staging/iio/light/tsl2583.c:848:	memcpy(chip->taos_config, taos_config, sizeof(chip->taos_config));
./drivers/staging/iio/light/tsl2583.c:886:	indio_dev->name = chip->client->name;
./drivers/staging/iio/light/tsl2583.c:910:	mutex_lock(&chip->als_mutex);
./drivers/staging/iio/light/tsl2583.c:912:	if (chip->taos_chip_status == TSL258X_CHIP_WORKING) {
./drivers/staging/iio/light/tsl2583.c:914:		chip->taos_chip_status = TSL258X_CHIP_SUSPENDED;
./drivers/staging/iio/light/tsl2583.c:917:	mutex_unlock(&chip->als_mutex);
./drivers/staging/iio/light/tsl2583.c:927:	mutex_lock(&chip->als_mutex);
./drivers/staging/iio/light/tsl2583.c:929:	if (chip->taos_chip_status == TSL258X_CHIP_SUSPENDED)
./drivers/staging/iio/light/tsl2583.c:932:	mutex_unlock(&chip->als_mutex);
./drivers/staging/iio/light/tsl2x7x_core.c:348:	if (mutex_trylock(&chip->als_mutex) == 0)
./drivers/staging/iio/light/tsl2x7x_core.c:349:		return chip->als_cur_info.lux; /* busy, so return LAST VALUE */
./drivers/staging/iio/light/tsl2x7x_core.c:351:	if (chip->tsl2x7x_chip_status != TSL2X7X_CHIP_WORKING) {
./drivers/staging/iio/light/tsl2x7x_core.c:353:		dev_err(&chip->client->dev, "%s: device is not enabled\n",
./drivers/staging/iio/light/tsl2x7x_core.c:359:	ret = tsl2x7x_i2c_read(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:362:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:368:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:370:		ret = chip->als_cur_info.lux; /* return LAST VALUE */
./drivers/staging/iio/light/tsl2x7x_core.c:375:		ret = tsl2x7x_i2c_read(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:379:			dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:386:	ret = i2c_smbus_write_byte(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:391:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:400:	chip->als_cur_info.als_ch0 = ch0;
./drivers/staging/iio/light/tsl2x7x_core.c:401:	chip->als_cur_info.als_ch1 = ch1;
./drivers/staging/iio/light/tsl2x7x_core.c:403:	if ((ch0 >= chip->als_saturation) || (ch1 >= chip->als_saturation)) {
./drivers/staging/iio/light/tsl2x7x_core.c:410:		ret = chip->als_cur_info.lux;
./drivers/staging/iio/light/tsl2x7x_core.c:416:	p = (struct tsl2x7x_lux *)chip->tsl2x7x_device_lux;
./drivers/staging/iio/light/tsl2x7x_core.c:424:			tsl2X7X_als_gainadj[chip->tsl2x7x_settings.als_gain]);
./drivers/staging/iio/light/tsl2x7x_core.c:426:			tsl2X7X_als_gainadj[chip->tsl2x7x_settings.als_gain]);
./drivers/staging/iio/light/tsl2x7x_core.c:432:		dev_dbg(&chip->client->dev, "ch1lux > ch0lux-return last value\n");
./drivers/staging/iio/light/tsl2x7x_core.c:433:		ret = chip->als_cur_info.lux;
./drivers/staging/iio/light/tsl2x7x_core.c:438:	if (chip->als_time_scale == 0)
./drivers/staging/iio/light/tsl2x7x_core.c:441:		lux = (lux + (chip->als_time_scale >> 1)) /
./drivers/staging/iio/light/tsl2x7x_core.c:442:			chip->als_time_scale;
./drivers/staging/iio/light/tsl2x7x_core.c:453:	lux64 = lux64 * chip->tsl2x7x_settings.als_gain_trim;
./drivers/staging/iio/light/tsl2x7x_core.c:463:	chip->als_cur_info.lux = lux;
./drivers/staging/iio/light/tsl2x7x_core.c:467:	mutex_unlock(&chip->als_mutex);
./drivers/staging/iio/light/tsl2x7x_core.c:474: *                      chip->prox_data.
./drivers/staging/iio/light/tsl2x7x_core.c:486:	if (mutex_trylock(&chip->prox_mutex) == 0) {
./drivers/staging/iio/light/tsl2x7x_core.c:487:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:492:	ret = tsl2x7x_i2c_read(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:495:		dev_err(&chip->client->dev, "i2c err=%d\n", ret);
./drivers/staging/iio/light/tsl2x7x_core.c:499:	switch (chip->id) {
./drivers/staging/iio/light/tsl2x7x_core.c:519:		ret = tsl2x7x_i2c_read(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:526:	chip->prox_data =
./drivers/staging/iio/light/tsl2x7x_core.c:531:	mutex_unlock(&chip->prox_mutex);
./drivers/staging/iio/light/tsl2x7x_core.c:533:	return chip->prox_data;
./drivers/staging/iio/light/tsl2x7x_core.c:546:	if (chip->pdata && chip->pdata->platform_default_settings)
./drivers/staging/iio/light/tsl2x7x_core.c:547:		memcpy(&chip->tsl2x7x_settings,
./drivers/staging/iio/light/tsl2x7x_core.c:548:		       chip->pdata->platform_default_settings,
./drivers/staging/iio/light/tsl2x7x_core.c:551:		memcpy(&chip->tsl2x7x_settings,
./drivers/staging/iio/light/tsl2x7x_core.c:556:	if (chip->pdata && chip->pdata->platform_lux_table[0].ratio != 0)
./drivers/staging/iio/light/tsl2x7x_core.c:557:		memcpy(chip->tsl2x7x_device_lux,
./drivers/staging/iio/light/tsl2x7x_core.c:558:		       chip->pdata->platform_lux_table,
./drivers/staging/iio/light/tsl2x7x_core.c:559:		       sizeof(chip->pdata->platform_lux_table));
./drivers/staging/iio/light/tsl2x7x_core.c:561:		memcpy(chip->tsl2x7x_device_lux,
./drivers/staging/iio/light/tsl2x7x_core.c:562:		(struct tsl2x7x_lux *)tsl2x7x_default_lux_table_group[chip->id],
./drivers/staging/iio/light/tsl2x7x_core.c:580:	ret = i2c_smbus_write_byte(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:583:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:588:	reg_val = i2c_smbus_read_byte(chip->client);
./drivers/staging/iio/light/tsl2x7x_core.c:591:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:596:	ret = i2c_smbus_write_byte(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:599:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:604:	reg_val = i2c_smbus_read_byte(chip->client);
./drivers/staging/iio/light/tsl2x7x_core.c:606:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:613:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:618:	gain_trim_val =  ((chip->tsl2x7x_settings.als_cal_target)
./drivers/staging/iio/light/tsl2x7x_core.c:619:			* chip->tsl2x7x_settings.als_gain_trim) / lux_val;
./drivers/staging/iio/light/tsl2x7x_core.c:623:	chip->tsl2x7x_settings.als_gain_trim = gain_trim_val;
./drivers/staging/iio/light/tsl2x7x_core.c:624:	dev_info(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:625:		 "%s als_calibrate completed\n", chip->client->name);
./drivers/staging/iio/light/tsl2x7x_core.c:641:	if (chip->pdata && chip->pdata->power_on)
./drivers/staging/iio/light/tsl2x7x_core.c:642:		chip->pdata->power_on(indio_dev);
./drivers/staging/iio/light/tsl2x7x_core.c:645:	chip->tsl2x7x_config[TSL2X7X_PRX_TIME] =
./drivers/staging/iio/light/tsl2x7x_core.c:646:			chip->tsl2x7x_settings.prx_time;
./drivers/staging/iio/light/tsl2x7x_core.c:647:	chip->tsl2x7x_config[TSL2X7X_WAIT_TIME] =
./drivers/staging/iio/light/tsl2x7x_core.c:648:			chip->tsl2x7x_settings.wait_time;
./drivers/staging/iio/light/tsl2x7x_core.c:649:	chip->tsl2x7x_config[TSL2X7X_PRX_CONFIG] =
./drivers/staging/iio/light/tsl2x7x_core.c:650:			chip->tsl2x7x_settings.prox_config;
./drivers/staging/iio/light/tsl2x7x_core.c:652:	chip->tsl2x7x_config[TSL2X7X_ALS_MINTHRESHLO] =
./drivers/staging/iio/light/tsl2x7x_core.c:653:		(chip->tsl2x7x_settings.als_thresh_low) & 0xFF;
./drivers/staging/iio/light/tsl2x7x_core.c:654:	chip->tsl2x7x_config[TSL2X7X_ALS_MINTHRESHHI] =
./drivers/staging/iio/light/tsl2x7x_core.c:655:		(chip->tsl2x7x_settings.als_thresh_low >> 8) & 0xFF;
./drivers/staging/iio/light/tsl2x7x_core.c:656:	chip->tsl2x7x_config[TSL2X7X_ALS_MAXTHRESHLO] =
./drivers/staging/iio/light/tsl2x7x_core.c:657:		(chip->tsl2x7x_settings.als_thresh_high) & 0xFF;
./drivers/staging/iio/light/tsl2x7x_core.c:658:	chip->tsl2x7x_config[TSL2X7X_ALS_MAXTHRESHHI] =
./drivers/staging/iio/light/tsl2x7x_core.c:659:		(chip->tsl2x7x_settings.als_thresh_high >> 8) & 0xFF;
./drivers/staging/iio/light/tsl2x7x_core.c:660:	chip->tsl2x7x_config[TSL2X7X_PERSISTENCE] =
./drivers/staging/iio/light/tsl2x7x_core.c:661:		chip->tsl2x7x_settings.persistence;
./drivers/staging/iio/light/tsl2x7x_core.c:663:	chip->tsl2x7x_config[TSL2X7X_PRX_COUNT] =
./drivers/staging/iio/light/tsl2x7x_core.c:664:			chip->tsl2x7x_settings.prox_pulse_count;
./drivers/staging/iio/light/tsl2x7x_core.c:665:	chip->tsl2x7x_config[TSL2X7X_PRX_MINTHRESHLO] =
./drivers/staging/iio/light/tsl2x7x_core.c:666:			(chip->tsl2x7x_settings.prox_thres_low) & 0xFF;
./drivers/staging/iio/light/tsl2x7x_core.c:667:	chip->tsl2x7x_config[TSL2X7X_PRX_MINTHRESHHI] =
./drivers/staging/iio/light/tsl2x7x_core.c:668:			(chip->tsl2x7x_settings.prox_thres_low >> 8) & 0xFF;
./drivers/staging/iio/light/tsl2x7x_core.c:669:	chip->tsl2x7x_config[TSL2X7X_PRX_MAXTHRESHLO] =
./drivers/staging/iio/light/tsl2x7x_core.c:670:			(chip->tsl2x7x_settings.prox_thres_high) & 0xFF;
./drivers/staging/iio/light/tsl2x7x_core.c:671:	chip->tsl2x7x_config[TSL2X7X_PRX_MAXTHRESHHI] =
./drivers/staging/iio/light/tsl2x7x_core.c:672:			(chip->tsl2x7x_settings.prox_thres_high >> 8) & 0xFF;
./drivers/staging/iio/light/tsl2x7x_core.c:675:	if (chip->tsl2x7x_chip_status == TSL2X7X_CHIP_WORKING) {
./drivers/staging/iio/light/tsl2x7x_core.c:677:		dev_info(&chip->client->dev, "device is already enabled\n");
./drivers/staging/iio/light/tsl2x7x_core.c:682:	als_count = (chip->tsl2x7x_settings.als_time * 100 + 135) / 270;
./drivers/staging/iio/light/tsl2x7x_core.c:688:	chip->tsl2x7x_config[TSL2X7X_ALS_TIME] = 256 - als_count;
./drivers/staging/iio/light/tsl2x7x_core.c:691:	chip->tsl2x7x_config[TSL2X7X_GAIN] =
./drivers/staging/iio/light/tsl2x7x_core.c:692:		chip->tsl2x7x_settings.als_gain |
./drivers/staging/iio/light/tsl2x7x_core.c:694:			| ((chip->tsl2x7x_settings.prox_gain) << 2);
./drivers/staging/iio/light/tsl2x7x_core.c:697:	chip->als_saturation = als_count * 922; /* 90% of full scale */
./drivers/staging/iio/light/tsl2x7x_core.c:698:	chip->als_time_scale = (als_time + 25) / 50;
./drivers/staging/iio/light/tsl2x7x_core.c:705:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:708:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:717:	for (i = 0, dev_reg = chip->tsl2x7x_config;
./drivers/staging/iio/light/tsl2x7x_core.c:719:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:723:			dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:738:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:741:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:746:	chip->tsl2x7x_chip_status = TSL2X7X_CHIP_WORKING;
./drivers/staging/iio/light/tsl2x7x_core.c:748:	if (chip->tsl2x7x_settings.interrupts_en != 0) {
./drivers/staging/iio/light/tsl2x7x_core.c:749:		dev_info(&chip->client->dev, "Setting Up Interrupt(s)\n");
./drivers/staging/iio/light/tsl2x7x_core.c:752:		if ((chip->tsl2x7x_settings.interrupts_en == 0x20) ||
./drivers/staging/iio/light/tsl2x7x_core.c:753:		    (chip->tsl2x7x_settings.interrupts_en == 0x30))
./drivers/staging/iio/light/tsl2x7x_core.c:756:		reg_val |= chip->tsl2x7x_settings.interrupts_en;
./drivers/staging/iio/light/tsl2x7x_core.c:757:		ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:761:			dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:766:		ret = i2c_smbus_write_byte(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:771:			dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:787:	chip->tsl2x7x_chip_status = TSL2X7X_CHIP_SUSPENDED;
./drivers/staging/iio/light/tsl2x7x_core.c:789:	ret = i2c_smbus_write_byte_data(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:792:	if (chip->pdata && chip->pdata->power_off)
./drivers/staging/iio/light/tsl2x7x_core.c:793:		chip->pdata->power_off(chip->client);
./drivers/staging/iio/light/tsl2x7x_core.c:812:	int device_status = chip->tsl2x7x_chip_status;
./drivers/staging/iio/light/tsl2x7x_core.c:814:	mutex_lock(&chip->als_mutex);
./drivers/staging/iio/light/tsl2x7x_core.c:815:	mutex_lock(&chip->prox_mutex);
./drivers/staging/iio/light/tsl2x7x_core.c:825:	mutex_unlock(&chip->prox_mutex);
./drivers/staging/iio/light/tsl2x7x_core.c:826:	mutex_unlock(&chip->als_mutex);
./drivers/staging/iio/light/tsl2x7x_core.c:875:	u8 current_state = chip->tsl2x7x_chip_status;
./drivers/staging/iio/light/tsl2x7x_core.c:877:	if (chip->tsl2x7x_settings.prox_max_samples_cal > MAX_SAMPLES_CAL) {
./drivers/staging/iio/light/tsl2x7x_core.c:878:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:880:			chip->tsl2x7x_settings.prox_max_samples_cal);
./drivers/staging/iio/light/tsl2x7x_core.c:881:		chip->tsl2x7x_settings.prox_max_samples_cal = MAX_SAMPLES_CAL;
./drivers/staging/iio/light/tsl2x7x_core.c:888:	tmp_irq_settings = chip->tsl2x7x_settings.interrupts_en;
./drivers/staging/iio/light/tsl2x7x_core.c:889:	chip->tsl2x7x_settings.interrupts_en |= TSL2X7X_CNTL_PROX_INT_ENBL;
./drivers/staging/iio/light/tsl2x7x_core.c:895:	for (i = 0; i < chip->tsl2x7x_settings.prox_max_samples_cal; i++) {
./drivers/staging/iio/light/tsl2x7x_core.c:898:		prox_history[i] = chip->prox_data;
./drivers/staging/iio/light/tsl2x7x_core.c:899:		dev_info(&chip->client->dev, "2 i=%d prox data= %d\n",
./drivers/staging/iio/light/tsl2x7x_core.c:900:			 i, chip->prox_data);
./drivers/staging/iio/light/tsl2x7x_core.c:906:			       chip->tsl2x7x_settings.prox_max_samples_cal,
./drivers/staging/iio/light/tsl2x7x_core.c:908:	chip->tsl2x7x_settings.prox_thres_high = (calP->max << 1) - calP->mean;
./drivers/staging/iio/light/tsl2x7x_core.c:910:	dev_info(&chip->client->dev, " cal min=%d mean=%d max=%d\n",
./drivers/staging/iio/light/tsl2x7x_core.c:912:	dev_info(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:914:		 chip->client->name, chip->tsl2x7x_settings.prox_thres_high);
./drivers/staging/iio/light/tsl2x7x_core.c:917:	chip->tsl2x7x_settings.interrupts_en = tmp_irq_settings;
./drivers/staging/iio/light/tsl2x7x_core.c:928:	return snprintf(buf, PAGE_SIZE, "%d\n", chip->tsl2x7x_chip_status);
./drivers/staging/iio/light/tsl2x7x_core.c:955:	switch (chip->id) {
./drivers/staging/iio/light/tsl2x7x_core.c:981:	y = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.als_time) + 1;
./drivers/staging/iio/light/tsl2x7x_core.c:1003:	chip->tsl2x7x_settings.als_time =
./drivers/staging/iio/light/tsl2x7x_core.c:1006:	dev_info(&chip->client->dev, "%s: als time = %d",
./drivers/staging/iio/light/tsl2x7x_core.c:1007:		 __func__, chip->tsl2x7x_settings.als_time);
./drivers/staging/iio/light/tsl2x7x_core.c:1024:			chip->tsl2x7x_settings.als_cal_target);
./drivers/staging/iio/light/tsl2x7x_core.c:1039:		chip->tsl2x7x_settings.als_cal_target = value;
./drivers/staging/iio/light/tsl2x7x_core.c:1055:	y = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.als_time) + 1;
./drivers/staging/iio/light/tsl2x7x_core.c:1057:	filter_delay = z * (chip->tsl2x7x_settings.persistence & 0x0F);
./drivers/staging/iio/light/tsl2x7x_core.c:1078:	y = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.als_time) + 1;
./drivers/staging/iio/light/tsl2x7x_core.c:1084:	chip->tsl2x7x_settings.persistence &= 0xF0;
./drivers/staging/iio/light/tsl2x7x_core.c:1085:	chip->tsl2x7x_settings.persistence |= (filter_delay & 0x0F);
./drivers/staging/iio/light/tsl2x7x_core.c:1087:	dev_info(&chip->client->dev, "%s: als persistence = %d",
./drivers/staging/iio/light/tsl2x7x_core.c:1103:	y = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.prx_time) + 1;
./drivers/staging/iio/light/tsl2x7x_core.c:1105:	filter_delay = z * ((chip->tsl2x7x_settings.persistence & 0xF0) >> 4);
./drivers/staging/iio/light/tsl2x7x_core.c:1126:	y = (TSL2X7X_MAX_TIMER_CNT - (u8)chip->tsl2x7x_settings.prx_time) + 1;
./drivers/staging/iio/light/tsl2x7x_core.c:1132:	chip->tsl2x7x_settings.persistence &= 0x0F;
./drivers/staging/iio/light/tsl2x7x_core.c:1133:	chip->tsl2x7x_settings.persistence |= ((filter_delay << 4) & 0xF0);
./drivers/staging/iio/light/tsl2x7x_core.c:1135:	dev_info(&chip->client->dev, "%s: prox persistence = %d",
./drivers/staging/iio/light/tsl2x7x_core.c:1171:			chip->tsl2x7x_device_lux[i].ratio,
./drivers/staging/iio/light/tsl2x7x_core.c:1172:			chip->tsl2x7x_device_lux[i].ch0,
./drivers/staging/iio/light/tsl2x7x_core.c:1173:			chip->tsl2x7x_device_lux[i].ch1);
./drivers/staging/iio/light/tsl2x7x_core.c:1174:		if (chip->tsl2x7x_device_lux[i].ratio == 0) {
./drivers/staging/iio/light/tsl2x7x_core.c:1195:	int value[ARRAY_SIZE(chip->tsl2x7x_device_lux) * 3 + 1];
./drivers/staging/iio/light/tsl2x7x_core.c:1207:	    n > ((ARRAY_SIZE(chip->tsl2x7x_device_lux) - 1) * 3)) {
./drivers/staging/iio/light/tsl2x7x_core.c:1217:	if (chip->tsl2x7x_chip_status == TSL2X7X_CHIP_WORKING)
./drivers/staging/iio/light/tsl2x7x_core.c:1221:	memset(chip->tsl2x7x_device_lux, 0, sizeof(chip->tsl2x7x_device_lux));
./drivers/staging/iio/light/tsl2x7x_core.c:1222:	memcpy(chip->tsl2x7x_device_lux, &value[1], (value[0] * 4));
./drivers/staging/iio/light/tsl2x7x_core.c:1256:		ret = !!(chip->tsl2x7x_settings.interrupts_en & 0x10);
./drivers/staging/iio/light/tsl2x7x_core.c:1258:		ret = !!(chip->tsl2x7x_settings.interrupts_en & 0x20);
./drivers/staging/iio/light/tsl2x7x_core.c:1273:			chip->tsl2x7x_settings.interrupts_en |= 0x10;
./drivers/staging/iio/light/tsl2x7x_core.c:1275:			chip->tsl2x7x_settings.interrupts_en &= 0x20;
./drivers/staging/iio/light/tsl2x7x_core.c:1278:			chip->tsl2x7x_settings.interrupts_en |= 0x20;
./drivers/staging/iio/light/tsl2x7x_core.c:1280:			chip->tsl2x7x_settings.interrupts_en &= 0x10;
./drivers/staging/iio/light/tsl2x7x_core.c:1300:			chip->tsl2x7x_settings.als_thresh_high = val;
./drivers/staging/iio/light/tsl2x7x_core.c:1303:			chip->tsl2x7x_settings.als_thresh_low = val;
./drivers/staging/iio/light/tsl2x7x_core.c:1311:			chip->tsl2x7x_settings.prox_thres_high = val;
./drivers/staging/iio/light/tsl2x7x_core.c:1314:			chip->tsl2x7x_settings.prox_thres_low = val;
./drivers/staging/iio/light/tsl2x7x_core.c:1338:			*val = chip->tsl2x7x_settings.als_thresh_high;
./drivers/staging/iio/light/tsl2x7x_core.c:1341:			*val = chip->tsl2x7x_settings.als_thresh_low;
./drivers/staging/iio/light/tsl2x7x_core.c:1349:			*val = chip->tsl2x7x_settings.prox_thres_high;
./drivers/staging/iio/light/tsl2x7x_core.c:1352:			*val = chip->tsl2x7x_settings.prox_thres_low;
./drivers/staging/iio/light/tsl2x7x_core.c:1376:			*val = chip->als_cur_info.lux;
./drivers/staging/iio/light/tsl2x7x_core.c:1388:				*val = chip->als_cur_info.als_ch0;
./drivers/staging/iio/light/tsl2x7x_core.c:1390:				*val = chip->als_cur_info.als_ch1;
./drivers/staging/iio/light/tsl2x7x_core.c:1395:			*val = chip->prox_data;
./drivers/staging/iio/light/tsl2x7x_core.c:1405:			tsl2X7X_als_gainadj[chip->tsl2x7x_settings.als_gain];
./drivers/staging/iio/light/tsl2x7x_core.c:1408:			tsl2X7X_prx_gainadj[chip->tsl2x7x_settings.prox_gain];
./drivers/staging/iio/light/tsl2x7x_core.c:1412:		*val = chip->tsl2x7x_settings.als_gain_trim;
./drivers/staging/iio/light/tsl2x7x_core.c:1436:				chip->tsl2x7x_settings.als_gain = 0;
./drivers/staging/iio/light/tsl2x7x_core.c:1439:				chip->tsl2x7x_settings.als_gain = 1;
./drivers/staging/iio/light/tsl2x7x_core.c:1442:				chip->tsl2x7x_settings.als_gain = 2;
./drivers/staging/iio/light/tsl2x7x_core.c:1445:				switch (chip->id) {
./drivers/staging/iio/light/tsl2x7x_core.c:1453:				chip->tsl2x7x_settings.als_gain = 3;
./drivers/staging/iio/light/tsl2x7x_core.c:1456:				switch (chip->id) {
./drivers/staging/iio/light/tsl2x7x_core.c:1464:				chip->tsl2x7x_settings.als_gain = 3;
./drivers/staging/iio/light/tsl2x7x_core.c:1472:				chip->tsl2x7x_settings.prox_gain = 0;
./drivers/staging/iio/light/tsl2x7x_core.c:1475:				chip->tsl2x7x_settings.prox_gain = 1;
./drivers/staging/iio/light/tsl2x7x_core.c:1478:				chip->tsl2x7x_settings.prox_gain = 2;
./drivers/staging/iio/light/tsl2x7x_core.c:1481:				chip->tsl2x7x_settings.prox_gain = 3;
./drivers/staging/iio/light/tsl2x7x_core.c:1489:		chip->tsl2x7x_settings.als_gain_trim = val;
./drivers/staging/iio/light/tsl2x7x_core.c:1561:	value = i2c_smbus_read_byte_data(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:1585:	ret = i2c_smbus_write_byte(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:1589:		dev_err(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:1903:	chip->client = clientp;
./drivers/staging/iio/light/tsl2x7x_core.c:1906:	ret = tsl2x7x_i2c_read(chip->client,
./drivers/staging/iio/light/tsl2x7x_core.c:1913:		dev_info(&chip->client->dev,
./drivers/staging/iio/light/tsl2x7x_core.c:1930:	mutex_init(&chip->als_mutex);
./drivers/staging/iio/light/tsl2x7x_core.c:1931:	mutex_init(&chip->prox_mutex);
./drivers/staging/iio/light/tsl2x7x_core.c:1933:	chip->tsl2x7x_chip_status = TSL2X7X_CHIP_UNKNOWN;
./drivers/staging/iio/light/tsl2x7x_core.c:1934:	chip->pdata = dev_get_platdata(&clientp->dev);
./drivers/staging/iio/light/tsl2x7x_core.c:1935:	chip->id = id->driver_data;
./drivers/staging/iio/light/tsl2x7x_core.c:1936:	chip->chip_info =
./drivers/staging/iio/light/tsl2x7x_core.c:1939:	indio_dev->info = chip->chip_info->info;
./drivers/staging/iio/light/tsl2x7x_core.c:1942:	indio_dev->name = chip->client->name;
./drivers/staging/iio/light/tsl2x7x_core.c:1943:	indio_dev->channels = chip->chip_info->channel;
./drivers/staging/iio/light/tsl2x7x_core.c:1944:	indio_dev->num_channels = chip->chip_info->chan_table_elements;
./drivers/staging/iio/light/tsl2x7x_core.c:1984:	if (chip->tsl2x7x_chip_status == TSL2X7X_CHIP_WORKING) {
./drivers/staging/iio/light/tsl2x7x_core.c:1986:		chip->tsl2x7x_chip_status = TSL2X7X_CHIP_SUSPENDED;
./drivers/staging/iio/light/tsl2x7x_core.c:1989:	if (chip->pdata && chip->pdata->platform_power) {
./drivers/staging/iio/light/tsl2x7x_core.c:1992:		chip->pdata->platform_power(dev, pmm);
./drivers/staging/iio/light/tsl2x7x_core.c:2004:	if (chip->pdata && chip->pdata->platform_power) {
./drivers/staging/iio/light/tsl2x7x_core.c:2007:		chip->pdata->platform_power(dev, pmm);
./drivers/staging/iio/light/tsl2x7x_core.c:2010:	if (chip->tsl2x7x_chip_status == TSL2X7X_CHIP_SUSPENDED)
./drivers/staging/iio/adc/ad7816.c:60:	struct spi_device *spi_dev = chip->spi_dev;
./drivers/staging/iio/adc/ad7816.c:64:	gpio_set_value(chip->rdwr_pin, 1);
./drivers/staging/iio/adc/ad7816.c:65:	gpio_set_value(chip->rdwr_pin, 0);
./drivers/staging/iio/adc/ad7816.c:66:	ret = spi_write(spi_dev, &chip->channel_id, sizeof(chip->channel_id));
./drivers/staging/iio/adc/ad7816.c:71:	gpio_set_value(chip->rdwr_pin, 1);
./drivers/staging/iio/adc/ad7816.c:73:	if (chip->mode == AD7816_PD) { /* operating mode 2 */
./drivers/staging/iio/adc/ad7816.c:74:		gpio_set_value(chip->convert_pin, 1);
./drivers/staging/iio/adc/ad7816.c:75:		gpio_set_value(chip->convert_pin, 0);
./drivers/staging/iio/adc/ad7816.c:77:		gpio_set_value(chip->convert_pin, 0);
./drivers/staging/iio/adc/ad7816.c:78:		gpio_set_value(chip->convert_pin, 1);
./drivers/staging/iio/adc/ad7816.c:81:	while (gpio_get_value(chip->busy_pin))
./drivers/staging/iio/adc/ad7816.c:84:	gpio_set_value(chip->rdwr_pin, 0);
./drivers/staging/iio/adc/ad7816.c:85:	gpio_set_value(chip->rdwr_pin, 1);
./drivers/staging/iio/adc/ad7816.c:99:	struct spi_device *spi_dev = chip->spi_dev;
./drivers/staging/iio/adc/ad7816.c:102:	gpio_set_value(chip->rdwr_pin, 1);
./drivers/staging/iio/adc/ad7816.c:103:	gpio_set_value(chip->rdwr_pin, 0);
./drivers/staging/iio/adc/ad7816.c:118:	if (chip->mode)
./drivers/staging/iio/adc/ad7816.c:132:		gpio_set_value(chip->rdwr_pin, 1);
./drivers/staging/iio/adc/ad7816.c:133:		chip->mode = AD7816_FULL;
./drivers/staging/iio/adc/ad7816.c:135:		gpio_set_value(chip->rdwr_pin, 0);
./drivers/staging/iio/adc/ad7816.c:136:		chip->mode = AD7816_PD;
./drivers/staging/iio/adc/ad7816.c:164:	return sprintf(buf, "%d\n", chip->channel_id);
./drivers/staging/iio/adc/ad7816.c:182:		dev_err(&chip->spi_dev->dev, "Invalid channel id %lu for %s.\n",
./drivers/staging/iio/adc/ad7816.c:186:		dev_err(&chip->spi_dev->dev,
./drivers/staging/iio/adc/ad7816.c:190:		dev_err(&chip->spi_dev->dev,
./drivers/staging/iio/adc/ad7816.c:195:	chip->channel_id = data;
./drivers/staging/iio/adc/ad7816.c:221:	if (chip->channel_id == 0) {
./drivers/staging/iio/adc/ad7816.c:268:	if (chip->channel_id > AD7816_CS_MAX) {
./drivers/staging/iio/adc/ad7816.c:269:		dev_err(dev, "Invalid oti channel id %d.\n", chip->channel_id);
./drivers/staging/iio/adc/ad7816.c:271:	} else if (chip->channel_id == 0) {
./drivers/staging/iio/adc/ad7816.c:273:			(chip->oti_data[chip->channel_id] -
./drivers/staging/iio/adc/ad7816.c:277:	return sprintf(buf, "%u\n", chip->oti_data[chip->channel_id]);
./drivers/staging/iio/adc/ad7816.c:295:	if (chip->channel_id > AD7816_CS_MAX) {
./drivers/staging/iio/adc/ad7816.c:296:		dev_err(dev, "Invalid oti channel id %d.\n", chip->channel_id);
./drivers/staging/iio/adc/ad7816.c:298:	} else if (chip->channel_id == 0) {
./drivers/staging/iio/adc/ad7816.c:316:	chip->oti_data[chip->channel_id] = data;
./drivers/staging/iio/adc/ad7816.c:364:	chip->spi_dev = spi_dev;
./drivers/staging/iio/adc/ad7816.c:366:		chip->oti_data[i] = 203;
./drivers/staging/iio/adc/ad7816.c:367:	chip->rdwr_pin = pins[0];
./drivers/staging/iio/adc/ad7816.c:368:	chip->convert_pin = pins[1];
./drivers/staging/iio/adc/ad7816.c:369:	chip->busy_pin = pins[2];
./drivers/staging/iio/adc/ad7816.c:371:	ret = devm_gpio_request(&spi_dev->dev, chip->rdwr_pin,
./drivers/staging/iio/adc/ad7816.c:375:			chip->rdwr_pin);
./drivers/staging/iio/adc/ad7816.c:378:	gpio_direction_input(chip->rdwr_pin);
./drivers/staging/iio/adc/ad7816.c:379:	ret = devm_gpio_request(&spi_dev->dev, chip->convert_pin,
./drivers/staging/iio/adc/ad7816.c:383:			chip->convert_pin);
./drivers/staging/iio/adc/ad7816.c:386:	gpio_direction_input(chip->convert_pin);
./drivers/staging/iio/adc/ad7816.c:387:	ret = devm_gpio_request(&spi_dev->dev, chip->busy_pin,
./drivers/staging/iio/adc/ad7816.c:391:			chip->busy_pin);
./drivers/staging/iio/adc/ad7816.c:394:	gpio_direction_input(chip->busy_pin);
./drivers/staging/rts5208/xd.c:40:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:47:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:54:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:57:	if (chip->asic_code)
./drivers/staging/rts5208/xd.c:73:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:125:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:489:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:503:	if (chip->asic_code) {
./drivers/staging/rts5208/xd.c:513:	if (!chip->ft2_fast_mode)
./drivers/staging/rts5208/xd.c:525:	if (!chip->ft2_fast_mode) {
./drivers/staging/rts5208/xd.c:536:		if (chip->asic_code) {
./drivers/staging/rts5208/xd.c:558:		if (chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER)) {
./drivers/staging/rts5208/xd.c:560:				chip->ocp_stat);
./drivers/staging/rts5208/xd.c:569:	if (chip->ft2_fast_mode) {
./drivers/staging/rts5208/xd.c:570:		if (chip->asic_code) {
./drivers/staging/rts5208/xd.c:588:	if (!chip->ft2_fast_mode)
./drivers/staging/rts5208/xd.c:819:	chip->capacity[chip->card2lun[XD_CARD]] = xd_card->capacity;
./drivers/staging/rts5208/xd.c:865:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:914:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:949:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:988:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:997:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1045:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1081:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1136:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1195:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1346:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1408:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1580:		chip->card_wp |= XD_CARD;
./drivers/staging/rts5208/xd.c:1621:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1663:	trans_dma_enable(chip->srb->sc_data_direction, chip,
./drivers/staging/rts5208/xd.c:1674:					scsi_sg_count(chip->srb),
./drivers/staging/rts5208/xd.c:1676:					chip->xd_timeout);
./drivers/staging/rts5208/xd.c:1756:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1839:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1880:	trans_dma_enable(chip->srb->sc_data_direction, chip,
./drivers/staging/rts5208/xd.c:1891:					scsi_sg_count(chip->srb),
./drivers/staging/rts5208/xd.c:1892:			index, offset, DMA_TO_DEVICE, chip->xd_timeout);
./drivers/staging/rts5208/xd.c:1946:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:1976:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:2005:		chip->card_fail |= XD_CARD;
./drivers/staging/rts5208/xd.c:2019:			chip->card_fail |= XD_CARD;
./drivers/staging/rts5208/xd.c:2119:			chip->card_fail |= XD_CARD;
./drivers/staging/rts5208/xd.c:2168:				chip->card_fail |= XD_CARD;
./drivers/staging/rts5208/xd.c:2212:			chip->card_fail |= XD_CARD;
./drivers/staging/rts5208/xd.c:2241:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:2259:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:2285:	if (!chip->ft2_fast_mode) {
./drivers/staging/rts5208/xd.c:2295:	if (chip->asic_code) {
./drivers/staging/rts5208/xd.c:2314:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/xd.c:2317:	chip->card_ready &= ~XD_CARD;
./drivers/staging/rts5208/xd.c:2318:	chip->card_fail &= ~XD_CARD;
./drivers/staging/rts5208/xd.c:2319:	chip->card_wp &= ~XD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:51:	for (i = 0; i <= chip->max_lun; i++) {
./drivers/staging/rts5208/rtsx_chip.c:52:		if (chip->lun2card[i] & XD_CARD)
./drivers/staging/rts5208/rtsx_chip.c:54:		if (chip->lun2card[i] & SD_CARD)
./drivers/staging/rts5208/rtsx_chip.c:56:		if (chip->lun2card[i] & MS_CARD)
./drivers/staging/rts5208/rtsx_chip.c:59:	if (chip->hw_bypass_sd)
./drivers/staging/rts5208/rtsx_chip.c:75:	for (i = 0; i <= chip->max_lun; i++) {
./drivers/staging/rts5208/rtsx_chip.c:77:			i, chip->lun2card[i]);
./drivers/staging/rts5208/rtsx_chip.c:79:		if (chip->lun2card[i] & XD_CARD)
./drivers/staging/rts5208/rtsx_chip.c:81:		if (chip->lun2card[i] & SD_CARD)
./drivers/staging/rts5208/rtsx_chip.c:83:		if (chip->lun2card[i] & MS_CARD)
./drivers/staging/rts5208/rtsx_chip.c:86:	if (chip->hw_bypass_sd)
./drivers/staging/rts5208/rtsx_chip.c:90:	if (chip->ic_version >= IC_VER_C)
./drivers/staging/rts5208/rtsx_chip.c:95:	if (!chip->adma_mode)
./drivers/staging/rts5208/rtsx_chip.c:113:	if (chip->ignore_sd && CHK_SDIO_EXIST(chip)) {
./drivers/staging/rts5208/rtsx_chip.c:114:		if (chip->asic_code) {
./drivers/staging/rts5208/rtsx_chip.c:152:		chip->sd_int = 1;
./drivers/staging/rts5208/rtsx_chip.c:153:		chip->sd_io = 1;
./drivers/staging/rts5208/rtsx_chip.c:155:		chip->need_reset |= SD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:168:	if (chip->driver_first_load) {
./drivers/staging/rts5208/rtsx_chip.c:187:		if (chip->sdio_in_charge)
./drivers/staging/rts5208/rtsx_chip.c:190:	dev_dbg(rtsx_dev(chip), "chip->sdio_in_charge = %d\n",
./drivers/staging/rts5208/rtsx_chip.c:191:		chip->sdio_in_charge);
./drivers/staging/rts5208/rtsx_chip.c:192:	dev_dbg(rtsx_dev(chip), "chip->driver_first_load = %d\n",
./drivers/staging/rts5208/rtsx_chip.c:193:		chip->driver_first_load);
./drivers/staging/rts5208/rtsx_chip.c:232:			chip->need_reset |= SD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:236:			if (chip->asic_code) {
./drivers/staging/rts5208/rtsx_chip.c:275:			chip->chip_insert_with_sdio = 1;
./drivers/staging/rts5208/rtsx_chip.c:276:			chip->sd_io = 1;
./drivers/staging/rts5208/rtsx_chip.c:285:		chip->need_reset |= SD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:296:	if (chip->dynamic_aspm) {
./drivers/staging/rts5208/rtsx_chip.c:301:					chip->aspm_l0s_l1_en);
./drivers/staging/rts5208/rtsx_chip.c:317:	ret = rtsx_write_config_byte(chip, LCTLR, chip->aspm_l0s_l1_en);
./drivers/staging/rts5208/rtsx_chip.c:323:	chip->aspm_level[0] = chip->aspm_l0s_l1_en;
./drivers/staging/rts5208/rtsx_chip.c:325:		chip->aspm_level[1] = chip->aspm_l0s_l1_en;
./drivers/staging/rts5208/rtsx_chip.c:327:					0xC0, 0xFF, chip->aspm_l0s_l1_en);
./drivers/staging/rts5208/rtsx_chip.c:334:	chip->aspm_enabled = 1;
./drivers/staging/rts5208/rtsx_chip.c:343:	if (!chip->asic_code || !CHECK_PID(chip, 0x5208)) {
./drivers/staging/rts5208/rtsx_chip.c:348:	if (chip->phy_debug_mode) {
./drivers/staging/rts5208/rtsx_chip.c:359:	if (chip->ic_version >= IC_VER_D) {
./drivers/staging/rts5208/rtsx_chip.c:390:	if (chip->driver_first_load && (chip->ic_version < IC_VER_C))
./drivers/staging/rts5208/rtsx_chip.c:400:	rtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);
./drivers/staging/rts5208/rtsx_chip.c:486:				     chip->card_drive_sel);
./drivers/staging/rts5208/rtsx_chip.c:501:	if (chip->asic_code) {
./drivers/staging/rts5208/rtsx_chip.c:531:	if (chip->aspm_l0s_l1_en) {
./drivers/staging/rts5208/rtsx_chip.c:538:		if (chip->asic_code && CHECK_PID(chip, 0x5208)) {
./drivers/staging/rts5208/rtsx_chip.c:546:						chip->aspm_l0s_l1_en);
./drivers/staging/rts5208/rtsx_chip.c:603:	chip->need_reset = 0;
./drivers/staging/rts5208/rtsx_chip.c:605:	chip->int_reg = rtsx_readl(chip, RTSX_BIPR);
./drivers/staging/rts5208/rtsx_chip.c:607:	if (chip->hw_bypass_sd)
./drivers/staging/rts5208/rtsx_chip.c:609:	dev_dbg(rtsx_dev(chip), "In %s, chip->int_reg = 0x%x\n", __func__,
./drivers/staging/rts5208/rtsx_chip.c:610:		chip->int_reg);
./drivers/staging/rts5208/rtsx_chip.c:611:	if (chip->int_reg & SD_EXIST) {
./drivers/staging/rts5208/rtsx_chip.c:613:		if (CHECK_PID(chip, 0x5208) && (chip->ic_version < IC_VER_C))
./drivers/staging/rts5208/rtsx_chip.c:618:		dev_dbg(rtsx_dev(chip), "chip->need_reset = 0x%x (rtsx_reset_chip)\n",
./drivers/staging/rts5208/rtsx_chip.c:619:			(unsigned int)(chip->need_reset));
./drivers/staging/rts5208/rtsx_chip.c:629:		chip->sd_io = 0;
./drivers/staging/rts5208/rtsx_chip.c:639:	if (chip->int_reg & XD_EXIST)
./drivers/staging/rts5208/rtsx_chip.c:640:		chip->need_reset |= XD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:641:	if (chip->int_reg & MS_EXIST)
./drivers/staging/rts5208/rtsx_chip.c:642:		chip->need_reset |= MS_CARD;
./drivers/staging/rts5208/rtsx_chip.c:643:	if (chip->int_reg & CARD_EXIST) {
./drivers/staging/rts5208/rtsx_chip.c:652:	dev_dbg(rtsx_dev(chip), "In %s, chip->need_reset = 0x%x\n", __func__,
./drivers/staging/rts5208/rtsx_chip.c:653:		(unsigned int)(chip->need_reset));
./drivers/staging/rts5208/rtsx_chip.c:671:	if (chip->remote_wakeup_en && !chip->auto_delink_en) {
./drivers/staging/rts5208/rtsx_chip.c:677:		if (chip->aux_pwr_exist) {
./drivers/staging/rts5208/rtsx_chip.c:698:	if (CHECK_PID(chip, 0x5208) && (chip->ic_version >= IC_VER_D)) {
./drivers/staging/rts5208/rtsx_chip.c:706:	if (chip->asic_code && CHECK_PID(chip, 0x5208)) {
./drivers/staging/rts5208/rtsx_chip.c:714:	if (chip->ft2_fast_mode) {
./drivers/staging/rts5208/rtsx_chip.c:721:		udelay(chip->pmos_pwr_on_interval);
./drivers/staging/rts5208/rtsx_chip.c:735:	chip->driver_first_load = 0;
./drivers/staging/rts5208/rtsx_chip.c:790:	chip->asic_code = val == 0 ? 1 : 0;
./drivers/staging/rts5208/rtsx_chip.c:792:	if (chip->asic_code) {
./drivers/staging/rts5208/rtsx_chip.c:801:		chip->ic_version = (reg >> 4) & 0x07;
./drivers/staging/rts5208/rtsx_chip.c:802:		chip->phy_debug_mode = reg & PHY_DEBUG_MODE ? 1 : 0;
./drivers/staging/rts5208/rtsx_chip.c:810:		chip->ic_version = val;
./drivers/staging/rts5208/rtsx_chip.c:811:		chip->phy_debug_mode = 0;
./drivers/staging/rts5208/rtsx_chip.c:820:	chip->aux_pwr_exist = val & AUX_PWR_DETECTED ? 1 : 0;
./drivers/staging/rts5208/rtsx_chip.c:827:	chip->hw_bypass_sd = val & 0x01 ? 1 : 0;
./drivers/staging/rts5208/rtsx_chip.c:835:	if (chip->use_hw_setting) {
./drivers/staging/rts5208/rtsx_chip.c:841:		chip->auto_delink_en = val & 0x80 ? 1 : 0;
./drivers/staging/rts5208/rtsx_chip.c:863:	chip->asic_code = val == 0 ? 1 : 0;
./drivers/staging/rts5208/rtsx_chip.c:865:	chip->ic_version = 0;
./drivers/staging/rts5208/rtsx_chip.c:866:	chip->phy_debug_mode = 0;
./drivers/staging/rts5208/rtsx_chip.c:874:	chip->aux_pwr_exist = val & AUX_PWR_DETECTED ? 1 : 0;
./drivers/staging/rts5208/rtsx_chip.c:882:	chip->baro_pkg = val & 0x04 ? QFN : LQFP;
./drivers/staging/rts5208/rtsx_chip.c:889:	chip->hw_bypass_sd = val & 0x10 ? 1 : 0;
./drivers/staging/rts5208/rtsx_chip.c:904:	if (chip->use_hw_setting) {
./drivers/staging/rts5208/rtsx_chip.c:910:		chip->auto_delink_en = val & 0x80 ? 1 : 0;
./drivers/staging/rts5208/rtsx_chip.c:913:			chip->lun_mode = SD_MS_1LUN;
./drivers/staging/rts5208/rtsx_chip.c:915:			chip->lun_mode = DEFAULT_SINGLE;
./drivers/staging/rts5208/rtsx_chip.c:923:	struct sd_info *sd_card = &chip->sd_card;
./drivers/staging/rts5208/rtsx_chip.c:924:	struct xd_info *xd_card = &chip->xd_card;
./drivers/staging/rts5208/rtsx_chip.c:925:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/rtsx_chip.c:930:		chip->vendor_id, chip->product_id);
./drivers/staging/rts5208/rtsx_chip.c:932:	chip->ic_version = 0;
./drivers/staging/rts5208/rtsx_chip.c:935:	chip->msg_idx = 0;
./drivers/staging/rts5208/rtsx_chip.c:942:	chip->xd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:943:	chip->sd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:944:	chip->ms_reset_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:946:	chip->xd_show_cnt = MAX_SHOW_CNT;
./drivers/staging/rts5208/rtsx_chip.c:947:	chip->sd_show_cnt = MAX_SHOW_CNT;
./drivers/staging/rts5208/rtsx_chip.c:948:	chip->ms_show_cnt = MAX_SHOW_CNT;
./drivers/staging/rts5208/rtsx_chip.c:950:	chip->sd_io = 0;
./drivers/staging/rts5208/rtsx_chip.c:951:	chip->auto_delink_cnt = 0;
./drivers/staging/rts5208/rtsx_chip.c:952:	chip->auto_delink_allowed = 1;
./drivers/staging/rts5208/rtsx_chip.c:955:	chip->aspm_enabled = 0;
./drivers/staging/rts5208/rtsx_chip.c:956:	chip->chip_insert_with_sdio = 0;
./drivers/staging/rts5208/rtsx_chip.c:957:	chip->sdio_aspm = 0;
./drivers/staging/rts5208/rtsx_chip.c:958:	chip->sdio_idle = 0;
./drivers/staging/rts5208/rtsx_chip.c:959:	chip->sdio_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:960:	chip->cur_card = 0;
./drivers/staging/rts5208/rtsx_chip.c:961:	chip->phy_debug_mode = 0;
./drivers/staging/rts5208/rtsx_chip.c:962:	chip->sdio_func_exist = 0;
./drivers/staging/rts5208/rtsx_chip.c:963:	memset(chip->sdio_raw_data, 0, 12);
./drivers/staging/rts5208/rtsx_chip.c:967:		chip->rw_fail_cnt[i] = 0;
./drivers/staging/rts5208/rtsx_chip.c:970:	if (!check_sd_speed_prior(chip->sd_speed_prior))
./drivers/staging/rts5208/rtsx_chip.c:971:		chip->sd_speed_prior = 0x01040203;
./drivers/staging/rts5208/rtsx_chip.c:974:		chip->sd_speed_prior);
./drivers/staging/rts5208/rtsx_chip.c:976:	if (!check_sd_current_prior(chip->sd_current_prior))
./drivers/staging/rts5208/rtsx_chip.c:977:		chip->sd_current_prior = 0x00010203;
./drivers/staging/rts5208/rtsx_chip.c:980:		chip->sd_current_prior);
./drivers/staging/rts5208/rtsx_chip.c:982:	if ((chip->sd_ddr_tx_phase > 31) || (chip->sd_ddr_tx_phase < 0))
./drivers/staging/rts5208/rtsx_chip.c:983:		chip->sd_ddr_tx_phase = 0;
./drivers/staging/rts5208/rtsx_chip.c:985:	if ((chip->mmc_ddr_tx_phase > 31) || (chip->mmc_ddr_tx_phase < 0))
./drivers/staging/rts5208/rtsx_chip.c:986:		chip->mmc_ddr_tx_phase = 0;
./drivers/staging/rts5208/rtsx_chip.c:999:	dev_dbg(rtsx_dev(chip), "chip->use_hw_setting = %d\n",
./drivers/staging/rts5208/rtsx_chip.c:1000:		chip->use_hw_setting);
./drivers/staging/rts5208/rtsx_chip.c:1017:	if (chip->ss_en == 2)
./drivers/staging/rts5208/rtsx_chip.c:1018:		chip->ss_en = 0;
./drivers/staging/rts5208/rtsx_chip.c:1020:	dev_dbg(rtsx_dev(chip), "chip->asic_code = %d\n", chip->asic_code);
./drivers/staging/rts5208/rtsx_chip.c:1021:	dev_dbg(rtsx_dev(chip), "chip->ic_version = 0x%x\n", chip->ic_version);
./drivers/staging/rts5208/rtsx_chip.c:1022:	dev_dbg(rtsx_dev(chip), "chip->phy_debug_mode = %d\n",
./drivers/staging/rts5208/rtsx_chip.c:1023:		chip->phy_debug_mode);
./drivers/staging/rts5208/rtsx_chip.c:1024:	dev_dbg(rtsx_dev(chip), "chip->aux_pwr_exist = %d\n",
./drivers/staging/rts5208/rtsx_chip.c:1025:		chip->aux_pwr_exist);
./drivers/staging/rts5208/rtsx_chip.c:1026:	dev_dbg(rtsx_dev(chip), "chip->sdio_func_exist = %d\n",
./drivers/staging/rts5208/rtsx_chip.c:1027:		chip->sdio_func_exist);
./drivers/staging/rts5208/rtsx_chip.c:1028:	dev_dbg(rtsx_dev(chip), "chip->hw_bypass_sd = %d\n",
./drivers/staging/rts5208/rtsx_chip.c:1029:		chip->hw_bypass_sd);
./drivers/staging/rts5208/rtsx_chip.c:1030:	dev_dbg(rtsx_dev(chip), "chip->aspm_l0s_l1_en = %d\n",
./drivers/staging/rts5208/rtsx_chip.c:1031:		chip->aspm_l0s_l1_en);
./drivers/staging/rts5208/rtsx_chip.c:1032:	dev_dbg(rtsx_dev(chip), "chip->lun_mode = %d\n", chip->lun_mode);
./drivers/staging/rts5208/rtsx_chip.c:1033:	dev_dbg(rtsx_dev(chip), "chip->auto_delink_en = %d\n",
./drivers/staging/rts5208/rtsx_chip.c:1034:		chip->auto_delink_en);
./drivers/staging/rts5208/rtsx_chip.c:1035:	dev_dbg(rtsx_dev(chip), "chip->ss_en = %d\n", chip->ss_en);
./drivers/staging/rts5208/rtsx_chip.c:1036:	dev_dbg(rtsx_dev(chip), "chip->baro_pkg = %d\n", chip->baro_pkg);
./drivers/staging/rts5208/rtsx_chip.c:1039:		chip->card2lun[SD_CARD] = 0;
./drivers/staging/rts5208/rtsx_chip.c:1040:		chip->card2lun[MS_CARD] = 1;
./drivers/staging/rts5208/rtsx_chip.c:1041:		chip->card2lun[XD_CARD] = 0xFF;
./drivers/staging/rts5208/rtsx_chip.c:1042:		chip->lun2card[0] = SD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1043:		chip->lun2card[1] = MS_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1044:		chip->max_lun = 1;
./drivers/staging/rts5208/rtsx_chip.c:1047:		chip->card2lun[SD_CARD] = 0;
./drivers/staging/rts5208/rtsx_chip.c:1048:		chip->card2lun[MS_CARD] = 0;
./drivers/staging/rts5208/rtsx_chip.c:1049:		chip->card2lun[XD_CARD] = 0xFF;
./drivers/staging/rts5208/rtsx_chip.c:1050:		chip->lun2card[0] = SD_CARD | MS_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1051:		chip->max_lun = 0;
./drivers/staging/rts5208/rtsx_chip.c:1053:		chip->card2lun[XD_CARD] = 0;
./drivers/staging/rts5208/rtsx_chip.c:1054:		chip->card2lun[SD_CARD] = 0;
./drivers/staging/rts5208/rtsx_chip.c:1055:		chip->card2lun[MS_CARD] = 0;
./drivers/staging/rts5208/rtsx_chip.c:1056:		chip->lun2card[0] = XD_CARD | SD_CARD | MS_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1057:		chip->max_lun = 0;
./drivers/staging/rts5208/rtsx_chip.c:1073:	chip->card_exist = 0;
./drivers/staging/rts5208/rtsx_chip.c:1074:	chip->card_ready = 0;
./drivers/staging/rts5208/rtsx_chip.c:1080:	if (chip->card_exist && chip->blink_led) {
./drivers/staging/rts5208/rtsx_chip.c:1081:		if (chip->led_toggle_counter < LED_TOGGLE_INTERVAL) {
./drivers/staging/rts5208/rtsx_chip.c:1082:			chip->led_toggle_counter++;
./drivers/staging/rts5208/rtsx_chip.c:1084:			chip->led_toggle_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:1100:	if (chip->aspm_level[0] != reg0) {
./drivers/staging/rts5208/rtsx_chip.c:1102:		chip->aspm_level[0] = reg0;
./drivers/staging/rts5208/rtsx_chip.c:1107:		if (chip->aspm_level[1] != reg1) {
./drivers/staging/rts5208/rtsx_chip.c:1109:			chip->aspm_level[1] = reg1;
./drivers/staging/rts5208/rtsx_chip.c:1122:			chip->aspm_l0s_l1_en = 0x03;
./drivers/staging/rts5208/rtsx_chip.c:1125:			chip->aspm_level[0], chip->aspm_level[1]);
./drivers/staging/rts5208/rtsx_chip.c:1127:		if (chip->aspm_l0s_l1_en) {
./drivers/staging/rts5208/rtsx_chip.c:1128:			chip->aspm_enabled = 1;
./drivers/staging/rts5208/rtsx_chip.c:1130:			chip->aspm_enabled = 0;
./drivers/staging/rts5208/rtsx_chip.c:1131:			chip->sdio_aspm = 0;
./drivers/staging/rts5208/rtsx_chip.c:1134:				    0x30 | chip->aspm_level[0] |
./drivers/staging/rts5208/rtsx_chip.c:1135:				    (chip->aspm_level[1] << 2));
./drivers/staging/rts5208/rtsx_chip.c:1142:	if (!chip->ocp_int)
./drivers/staging/rts5208/rtsx_chip.c:1145:	rtsx_read_register(chip, OCPSTAT, &chip->ocp_stat);
./drivers/staging/rts5208/rtsx_chip.c:1147:	if (chip->card_exist & SD_CARD)
./drivers/staging/rts5208/rtsx_chip.c:1149:	else if (chip->card_exist & MS_CARD)
./drivers/staging/rts5208/rtsx_chip.c:1151:	else if (chip->card_exist & XD_CARD)
./drivers/staging/rts5208/rtsx_chip.c:1154:	chip->ocp_int = 0;
./drivers/staging/rts5208/rtsx_chip.c:1161:	struct sd_info *sd_card = &chip->sd_card;
./drivers/staging/rts5208/rtsx_chip.c:1167:	if (chip->card_exist & SD_CARD) {
./drivers/staging/rts5208/rtsx_chip.c:1172:			chip->need_reinit |= SD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1184:	if (!chip->ss_en || CHECK_PID(chip, 0x5288))
./drivers/staging/rts5208/rtsx_chip.c:1198:	if (!rtsx_is_ss_allowed(chip) || chip->sd_io)
./drivers/staging/rts5208/rtsx_chip.c:1202:		chip->ss_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:1206:	if (chip->ss_counter < (chip->ss_idle_period / POLLING_INTERVAL))
./drivers/staging/rts5208/rtsx_chip.c:1207:		chip->ss_counter++;
./drivers/staging/rts5208/rtsx_chip.c:1223:	    !chip->aspm_l0s_l1_en || !chip->dynamic_aspm)
./drivers/staging/rts5208/rtsx_chip.c:1226:	if (chip->sd_io) {
./drivers/staging/rts5208/rtsx_chip.c:1231:	if (chip->sdio_aspm)
./drivers/staging/rts5208/rtsx_chip.c:1235:	data = 0x30 | (chip->aspm_level[1] << 2);
./drivers/staging/rts5208/rtsx_chip.c:1237:	chip->sdio_aspm = 1;
./drivers/staging/rts5208/rtsx_chip.c:1243:	if (chip->idle_counter < IDLE_MAX_COUNT) {
./drivers/staging/rts5208/rtsx_chip.c:1244:		chip->idle_counter++;
./drivers/staging/rts5208/rtsx_chip.c:1255:	chip->led_toggle_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:1261:	if (chip->auto_power_down && !chip->card_ready && !chip->sd_io)
./drivers/staging/rts5208/rtsx_chip.c:1270:	sd_oc = chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER);
./drivers/staging/rts5208/rtsx_chip.c:1271:	ms_oc = chip->ocp_stat & (MS_OC_NOW | MS_OC_EVER);
./drivers/staging/rts5208/rtsx_chip.c:1275:			chip->ocp_stat);
./drivers/staging/rts5208/rtsx_chip.c:1277:	if (sd_oc && (chip->card_exist & SD_CARD)) {
./drivers/staging/rts5208/rtsx_chip.c:1280:		chip->card_fail |= SD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1283:	if (ms_oc && (chip->card_exist & MS_CARD)) {
./drivers/staging/rts5208/rtsx_chip.c:1286:		chip->card_fail |= MS_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1294:	if (!(chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER)))
./drivers/staging/rts5208/rtsx_chip.c:1298:		chip->ocp_stat);
./drivers/staging/rts5208/rtsx_chip.c:1300:	if (chip->card_exist & SD_CARD) {
./drivers/staging/rts5208/rtsx_chip.c:1302:		chip->card_fail |= SD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1303:	} else if (chip->card_exist & MS_CARD) {
./drivers/staging/rts5208/rtsx_chip.c:1305:		chip->card_fail |= MS_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1306:	} else if (chip->card_exist & XD_CARD) {
./drivers/staging/rts5208/rtsx_chip.c:1308:		chip->card_fail |= XD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:1321:	if (chip->asic_code && CHECK_PID(chip, 0x5208))
./drivers/staging/rts5208/rtsx_chip.c:1324:	if (chip->card_exist)
./drivers/staging/rts5208/rtsx_chip.c:1332:	if (chip->card_exist)
./drivers/staging/rts5208/rtsx_chip.c:1342:	if (chip->card_exist)
./drivers/staging/rts5208/rtsx_chip.c:1343:		chip->auto_delink_cnt = stage3_cnt + 1;
./drivers/staging/rts5208/rtsx_chip.c:1351:	if (!chip->auto_delink_en || !chip->auto_delink_allowed ||
./drivers/staging/rts5208/rtsx_chip.c:1352:	    chip->card_ready || chip->card_ejected || chip->sd_io) {
./drivers/staging/rts5208/rtsx_chip.c:1353:		chip->auto_delink_cnt = 0;
./drivers/staging/rts5208/rtsx_chip.c:1357:	enter_L1 = chip->auto_delink_in_L1 &&
./drivers/staging/rts5208/rtsx_chip.c:1358:		(chip->aspm_l0s_l1_en || chip->ss_en);
./drivers/staging/rts5208/rtsx_chip.c:1360:	delink_stage1_cnt = chip->delink_stage1_step;
./drivers/staging/rts5208/rtsx_chip.c:1361:	delink_stage2_cnt = delink_stage1_cnt + chip->delink_stage2_step;
./drivers/staging/rts5208/rtsx_chip.c:1362:	delink_stage3_cnt = delink_stage2_cnt + chip->delink_stage3_step;
./drivers/staging/rts5208/rtsx_chip.c:1364:	if (chip->auto_delink_cnt > delink_stage3_cnt)
./drivers/staging/rts5208/rtsx_chip.c:1367:	if (chip->auto_delink_cnt == delink_stage1_cnt)
./drivers/staging/rts5208/rtsx_chip.c:1370:	if (chip->auto_delink_cnt == delink_stage2_cnt) {
./drivers/staging/rts5208/rtsx_chip.c:1376:		if (chip->asic_code && CHECK_PID(chip, 0x5208))
./drivers/staging/rts5208/rtsx_chip.c:1382:	chip->auto_delink_cnt++;
./drivers/staging/rts5208/rtsx_chip.c:1393:	if (chip->polling_config) {
./drivers/staging/rts5208/rtsx_chip.c:1423:		if (chip->sd_io && !chip->sd_int)
./drivers/staging/rts5208/rtsx_chip.c:1994:		chip->product_id, dstate);
./drivers/staging/rts5208/rtsx_chip.c:2031:	if (chip->power_down_in_ss) {
./drivers/staging/rts5208/rtsx_chip.c:2040:	if (chip->auto_delink_en) {
./drivers/staging/rts5208/rtsx_chip.c:2043:		if (!chip->phy_debug_mode) {
./drivers/staging/rts5208/rtsx_chip.c:2066:	if (chip->power_down_in_ss) {
./drivers/staging/rts5208/rtsx_chip.c:2072:		chip->need_reinit = SD_CARD | MS_CARD | XD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:2075:	} else if (chip->power_down_in_ss) {
./drivers/staging/rts5208/rtsx_chip.c:2076:		chip->need_reinit = SD_CARD | MS_CARD | XD_CARD;
./drivers/staging/rts5208/rtsx_chip.c:2091:	if (chip->ss_en) {
./drivers/staging/rts5208/rtsx_chip.c:2092:		chip->ss_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:2101:	chip->int_reg = rtsx_readl(chip, RTSX_BIPR);
./drivers/staging/rts5208/rtsx_chip.c:2103:	if (((chip->int_reg & int_enable) == 0) ||
./drivers/staging/rts5208/rtsx_chip.c:2104:	    (chip->int_reg == 0xFFFFFFFF))
./drivers/staging/rts5208/rtsx_chip.c:2107:	status = chip->int_reg &= (int_enable | 0x7FFFFF);
./drivers/staging/rts5208/rtsx_chip.c:2110:		chip->auto_delink_cnt = 0;
./drivers/staging/rts5208/rtsx_chip.c:2114:				set_bit(SD_NR, &chip->need_reset);
./drivers/staging/rts5208/rtsx_chip.c:2116:				set_bit(SD_NR, &chip->need_release);
./drivers/staging/rts5208/rtsx_chip.c:2117:				chip->sd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:2118:				chip->sd_show_cnt = 0;
./drivers/staging/rts5208/rtsx_chip.c:2119:				clear_bit(SD_NR, &chip->need_reset);
./drivers/staging/rts5208/rtsx_chip.c:2130:				set_bit(SD_NR, &chip->need_reinit);
./drivers/staging/rts5208/rtsx_chip.c:2135:					set_bit(XD_NR, &chip->need_reset);
./drivers/staging/rts5208/rtsx_chip.c:2137:					set_bit(XD_NR, &chip->need_release);
./drivers/staging/rts5208/rtsx_chip.c:2138:					chip->xd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:2139:					chip->xd_show_cnt = 0;
./drivers/staging/rts5208/rtsx_chip.c:2140:					clear_bit(XD_NR, &chip->need_reset);
./drivers/staging/rts5208/rtsx_chip.c:2144:					set_bit(XD_NR, &chip->need_reinit);
./drivers/staging/rts5208/rtsx_chip.c:2149:				set_bit(MS_NR, &chip->need_reset);
./drivers/staging/rts5208/rtsx_chip.c:2151:				set_bit(MS_NR, &chip->need_release);
./drivers/staging/rts5208/rtsx_chip.c:2152:				chip->ms_reset_counter = 0;
./drivers/staging/rts5208/rtsx_chip.c:2153:				chip->ms_show_cnt = 0;
./drivers/staging/rts5208/rtsx_chip.c:2154:				clear_bit(MS_NR, &chip->need_reset);
./drivers/staging/rts5208/rtsx_chip.c:2158:				set_bit(MS_NR, &chip->need_reinit);
./drivers/staging/rts5208/rtsx_chip.c:2163:	chip->ocp_int = ocp_int & status;
./drivers/staging/rts5208/rtsx_chip.c:2166:	if (chip->sd_io && (chip->int_reg & DATA_DONE_INT))
./drivers/staging/rts5208/rtsx_chip.c:2167:		chip->int_reg &= ~(u32)DATA_DONE_INT;
./drivers/staging/rts5208/rtsx_chip.c:2189:	if (chip->sd_io) {
./drivers/staging/rts5208/rtsx_chip.c:2190:		chip->sdio_in_charge = 1;
./drivers/staging/rts5208/rtsx_chip.c:2203:	if (CHECK_PID(chip, 0x5208) && (chip->ic_version >= IC_VER_D)) {
./drivers/staging/rts5208/rtsx_chip.c:2213:		if (chip->s3_pwr_off_delay > 0)
./drivers/staging/rts5208/rtsx_chip.c:2214:			wait_timeout(chip->s3_pwr_off_delay);
./drivers/staging/rts5208/rtsx_chip.c:2221:	if (chip->do_delink_before_power_down && chip->auto_delink_en)
./drivers/staging/rts5208/rtsx_chip.c:2226:	chip->cur_clk = 0;
./drivers/staging/rts5208/rtsx_chip.c:2227:	chip->cur_card = 0;
./drivers/staging/rts5208/rtsx_chip.c:2228:	chip->card_exist = 0;
./drivers/staging/rts5208/rtsx_chip.c:2233:	if (chip->aspm_l0s_l1_en && chip->dynamic_aspm && !chip->aspm_enabled) {
./drivers/staging/rts5208/rtsx_chip.c:2235:		chip->aspm_enabled = 1;
./drivers/staging/rts5208/rtsx_chip.c:2237:		if (chip->asic_code && CHECK_PID(chip, 0x5208))
./drivers/staging/rts5208/rtsx_chip.c:2241:					    0x30 | chip->aspm_level[0]);
./drivers/staging/rts5208/rtsx_chip.c:2244:					       chip->aspm_l0s_l1_en);
./drivers/staging/rts5208/rtsx_chip.c:2248:			u16 val = chip->aspm_l0s_l1_en | 0x0100;
./drivers/staging/rts5208/rtsx_chip.c:2261:	if (chip->aspm_l0s_l1_en && chip->dynamic_aspm && chip->aspm_enabled) {
./drivers/staging/rts5208/rtsx_chip.c:2263:		chip->aspm_enabled = 0;
./drivers/staging/rts5208/rtsx_chip.c:2265:		if (chip->asic_code && CHECK_PID(chip, 0x5208))
./drivers/staging/rts5208/ms.c:33:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:40:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:54:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:160:				    use_sg, dir, chip->mspro_timeout);
./drivers/staging/rts5208/ms.c:188:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:258:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:372:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:376:		if (chip->asic_code)
./drivers/staging/rts5208/ms.c:377:			ms_card->ms_clock = chip->asic_ms_hg_clk;
./drivers/staging/rts5208/ms.c:379:			ms_card->ms_clock = chip->fpga_ms_hg_clk;
./drivers/staging/rts5208/ms.c:382:		if (chip->asic_code)
./drivers/staging/rts5208/ms.c:383:			ms_card->ms_clock = chip->asic_ms_4bit_clk;
./drivers/staging/rts5208/ms.c:385:			ms_card->ms_clock = chip->fpga_ms_4bit_clk;
./drivers/staging/rts5208/ms.c:388:		if (chip->asic_code)
./drivers/staging/rts5208/ms.c:389:			ms_card->ms_clock = chip->asic_ms_1bit_clk;
./drivers/staging/rts5208/ms.c:391:			ms_card->ms_clock = chip->fpga_ms_1bit_clk;
./drivers/staging/rts5208/ms.c:411:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:545:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:562:	if (!chip->ft2_fast_mode)
./drivers/staging/rts5208/ms.c:571:	if (chip->asic_code) {
./drivers/staging/rts5208/ms.c:586:	if (!chip->ft2_fast_mode) {
./drivers/staging/rts5208/ms.c:601:		if (chip->ocp_stat & oc_mask) {
./drivers/staging/rts5208/ms.c:603:				chip->ocp_stat);
./drivers/staging/rts5208/ms.c:617:	if (chip->asic_code) {
./drivers/staging/rts5208/ms.c:656:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:716:			chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:718:			chip->card_wp &= ~MS_CARD;
./drivers/staging/rts5208/ms.c:721:		chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:798:			chip->card_wp |= (MS_CARD);
./drivers/staging/rts5208/ms.c:832:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:876:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:936:	if (CHK_MSHG(ms_card) && chip->support_ms_8bit && switch_8bit_bus) {
./drivers/staging/rts5208/ms.c:997:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:1268:			chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:1285:		chip->capacity[chip->card2lun[MS_CARD]] =
./drivers/staging/rts5208/ms.c:1288:		chip->capacity[chip->card2lun[MS_CARD]] =
./drivers/staging/rts5208/ms.c:1293:	chip->capacity[chip->card2lun[MS_CARD]] = ms_card->capacity;
./drivers/staging/rts5208/ms.c:1306:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:1311:	if (chip->ms_power_class_en & 0x02)
./drivers/staging/rts5208/ms.c:1313:	else if (chip->ms_power_class_en & 0x01)
./drivers/staging/rts5208/ms.c:1347:		u8 power_class_en = chip->ms_power_class_en;
./drivers/staging/rts5208/ms.c:1387:		chip->card_bus_width[chip->card2lun[MS_CARD]] = 8;
./drivers/staging/rts5208/ms.c:1389:		chip->card_bus_width[chip->card2lun[MS_CARD]] = 4;
./drivers/staging/rts5208/ms.c:1424:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:1519:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:1588:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:1673:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:1744:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:1865:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2158:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2192:		chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:2194:		chip->card_wp &= ~MS_CARD;
./drivers/staging/rts5208/ms.c:2304:		chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:2348:	chip->capacity[chip->card2lun[MS_CARD]] = ms_card->capacity;
./drivers/staging/rts5208/ms.c:2388:		chip->card_bus_width[chip->card2lun[MS_CARD]] = 4;
./drivers/staging/rts5208/ms.c:2390:		chip->card_bus_width[chip->card2lun[MS_CARD]] = 1;
./drivers/staging/rts5208/ms.c:2397:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2468:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2485:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2498:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2514:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2541:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2552:			if (!(chip->card_wp & MS_CARD))
./drivers/staging/rts5208/ms.c:2558:			if (!(chip->card_wp & MS_CARD))
./drivers/staging/rts5208/ms.c:2565:			if (!(chip->card_wp & MS_CARD))
./drivers/staging/rts5208/ms.c:2570:			if (!(chip->card_wp & MS_CARD))
./drivers/staging/rts5208/ms.c:2583:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2664:				if (!(chip->card_wp & MS_CARD)) {
./drivers/staging/rts5208/ms.c:2684:			if (!(chip->card_wp & MS_CARD)) {
./drivers/staging/rts5208/ms.c:2695:			if (!(chip->card_wp & MS_CARD)) {
./drivers/staging/rts5208/ms.c:2732:			chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:2735:			chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:2738:	if (chip->card_wp & MS_CARD)
./drivers/staging/rts5208/ms.c:2747:				chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:2759:					chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:2764:					chip->card_wp |= MS_CARD;
./drivers/staging/rts5208/ms.c:2778:				if (chip->card_wp & MS_CARD)
./drivers/staging/rts5208/ms.c:2815:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2902:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2920:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:2923:	if (chip->asic_code) {
./drivers/staging/rts5208/ms.c:2946:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:3057:			chip->rw_need_retry = 0;
./drivers/staging/rts5208/ms.c:3068:			chip->rw_need_retry = 1;
./drivers/staging/rts5208/ms.c:3089:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:3211:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:3229:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:3321:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:3399:					if (!(chip->card_wp & MS_CARD)) {
./drivers/staging/rts5208/ms.c:3467:						512, scsi_sg_count(chip->srb),
./drivers/staging/rts5208/ms.c:3469:						chip->ms_timeout);
./drivers/staging/rts5208/ms.c:3493:		if (scsi_sg_count(chip->srb) == 0)
./drivers/staging/rts5208/ms.c:3505:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:3658:						512, scsi_sg_count(chip->srb),
./drivers/staging/rts5208/ms.c:3660:						chip->ms_timeout);
./drivers/staging/rts5208/ms.c:3715:		if (scsi_sg_count(chip->srb) == 0)
./drivers/staging/rts5208/ms.c:3726:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:3772:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:3811:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:3846:			chip->card_fail |= MS_CARD;
./drivers/staging/rts5208/ms.c:4006:				chip->card_fail |= MS_CARD;
./drivers/staging/rts5208/ms.c:4072:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:4088:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:4344:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:4428:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:4488:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:4540:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:4597:	struct ms_info *ms_card = &chip->ms_card;
./drivers/staging/rts5208/ms.c:4708:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/ms.c:4740:	if (chip->asic_code) {
./drivers/staging/rts5208/ms.c:4760:	if (!chip->ft2_fast_mode) {
./drivers/staging/rts5208/ms.c:4773:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/ms.c:4781:	chip->card_ready &= ~MS_CARD;
./drivers/staging/rts5208/ms.c:4782:	chip->card_fail &= ~MS_CARD;
./drivers/staging/rts5208/ms.c:4783:	chip->card_wp &= ~MS_CARD;
./drivers/staging/rts5208/sd.c:59:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:66:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:73:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:129:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:288:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:359:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:427:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:462:			if (chip->asic_code)
./drivers/staging/rts5208/sd.c:468:			if (chip->asic_code)
./drivers/staging/rts5208/sd.c:474:			if (chip->asic_code)
./drivers/staging/rts5208/sd.c:480:			if (chip->asic_code)
./drivers/staging/rts5208/sd.c:486:			if (chip->asic_code)
./drivers/staging/rts5208/sd.c:526:			chip->card_wp |= SD_CARD;
./drivers/staging/rts5208/sd.c:537:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:540:	if ((chip->sd_ctl & SD_PUSH_POINT_CTL_MASK) == SD_PUSH_POINT_DELAY)
./drivers/staging/rts5208/sd.c:543:	if ((chip->sd_ctl & SD_SAMPLE_POINT_CTL_MASK) == SD_SAMPLE_POINT_AUTO) {
./drivers/staging/rts5208/sd.c:544:		if (chip->asic_code) {
./drivers/staging/rts5208/sd.c:557:	} else if ((chip->sd_ctl & SD_SAMPLE_POINT_CTL_MASK) ==
./drivers/staging/rts5208/sd.c:576:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:579:		if (chip->asic_code)
./drivers/staging/rts5208/sd.c:580:			sd_card->sd_clock = chip->asic_sd_sdr104_clk;
./drivers/staging/rts5208/sd.c:582:			sd_card->sd_clock = chip->fpga_sd_sdr104_clk;
./drivers/staging/rts5208/sd.c:585:		if (chip->asic_code)
./drivers/staging/rts5208/sd.c:586:			sd_card->sd_clock = chip->asic_sd_ddr50_clk;
./drivers/staging/rts5208/sd.c:588:			sd_card->sd_clock = chip->fpga_sd_ddr50_clk;
./drivers/staging/rts5208/sd.c:591:		if (chip->asic_code)
./drivers/staging/rts5208/sd.c:592:			sd_card->sd_clock = chip->asic_sd_sdr50_clk;
./drivers/staging/rts5208/sd.c:594:			sd_card->sd_clock = chip->fpga_sd_sdr50_clk;
./drivers/staging/rts5208/sd.c:597:		if (chip->asic_code)
./drivers/staging/rts5208/sd.c:598:			sd_card->sd_clock = chip->asic_sd_hs_clk;
./drivers/staging/rts5208/sd.c:600:			sd_card->sd_clock = chip->fpga_sd_hs_clk;
./drivers/staging/rts5208/sd.c:603:		if (chip->asic_code)
./drivers/staging/rts5208/sd.c:604:			sd_card->sd_clock = chip->asic_mmc_52m_clk;
./drivers/staging/rts5208/sd.c:606:			sd_card->sd_clock = chip->fpga_mmc_52m_clk;
./drivers/staging/rts5208/sd.c:609:		if (chip->asic_code)
./drivers/staging/rts5208/sd.c:640:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:662:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:689:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:720:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:747:		if (chip->asic_code) {
./drivers/staging/rts5208/sd.c:750:							chip->phy_voltage);
./drivers/staging/rts5208/sd.c:764:		if (chip->asic_code) {
./drivers/staging/rts5208/sd.c:767:							chip->phy_voltage);
./drivers/staging/rts5208/sd.c:809:	udelay(chip->sd_voltage_switch_delay);
./drivers/staging/rts5208/sd.c:906:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:925:	if (chip->asic_code) {
./drivers/staging/rts5208/sd.c:1063:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:1220:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:1296:						     chip->sd_800mA_ocp_thd);
./drivers/staging/rts5208/sd.c:1382:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:1399:		switch ((u8)(chip->sd_speed_prior >> (i*8))) {
./drivers/staging/rts5208/sd.c:1402:					&& chip->sdr104_en) {
./drivers/staging/rts5208/sd.c:1409:					&& chip->ddr50_en) {
./drivers/staging/rts5208/sd.c:1416:					&& chip->sdr50_en) {
./drivers/staging/rts5208/sd.c:1500:		switch ((u8)(chip->sd_current_prior >> (i*8))) {
./drivers/staging/rts5208/sd.c:1615:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:1655:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:1695:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:1734:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:1799:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:1808:			final_phase = (u8)chip->sd_default_rx_phase;
./drivers/staging/rts5208/sd.c:1810:			final_phase = (u8)chip->sd_default_tx_phase;
./drivers/staging/rts5208/sd.c:1917:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:1978:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:2043:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:2127:	if (!(chip->sd_ctl & SD_DDR_TX_PHASE_SET_BY_USER)) {
./drivers/staging/rts5208/sd.c:2134:		retval = sd_change_phase(chip, (u8)chip->sd_ddr_tx_phase,
./drivers/staging/rts5208/sd.c:2148:	if (!(chip->sd_ctl & SD_DDR_TX_PHASE_SET_BY_USER)) {
./drivers/staging/rts5208/sd.c:2163:	if (!(chip->sd_ctl & MMC_DDR_TX_PHASE_SET_BY_USER)) {
./drivers/staging/rts5208/sd.c:2170:		retval = sd_change_phase(chip, (u8)chip->mmc_ddr_tx_phase,
./drivers/staging/rts5208/sd.c:2184:	if (!(chip->sd_ctl & MMC_DDR_TX_PHASE_SET_BY_USER)) {
./drivers/staging/rts5208/sd.c:2197:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:2235:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:2238:	if (chip->asic_code)
./drivers/staging/rts5208/sd.c:2253:	chip->capacity[chip->card2lun[SD_CARD]] = 0;
./drivers/staging/rts5208/sd.c:2254:	chip->sd_io = 0;
./drivers/staging/rts5208/sd.c:2408:	if (!chip->ft2_fast_mode)
./drivers/staging/rts5208/sd.c:2417:	if (chip->asic_code) {
./drivers/staging/rts5208/sd.c:2432:	if (!chip->ft2_fast_mode) {
./drivers/staging/rts5208/sd.c:2442:		if (chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER)) {
./drivers/staging/rts5208/sd.c:2444:				chip->ocp_stat);
./drivers/staging/rts5208/sd.c:2482:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:2516:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:2553:		chip->card_wp |= SD_CARD;
./drivers/staging/rts5208/sd.c:2559:		chip->card_wp |= SD_CARD;
./drivers/staging/rts5208/sd.c:2566:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:2606:		for (; rty_cnt < chip->sdio_retry_cnt; rty_cnt++) {
./drivers/staging/rts5208/sd.c:2621:					chip->sd_io = 1;
./drivers/staging/rts5208/sd.c:2886:					     chip->sd30_drive_sel_1v8);
./drivers/staging/rts5208/sd.c:2956:	chip->card_bus_width[chip->card2lun[SD_CARD]] = 4;
./drivers/staging/rts5208/sd.c:2981:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:3111:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:3206:		chip->card_bus_width[chip->card2lun[SD_CARD]] = 8;
./drivers/staging/rts5208/sd.c:3214:			chip->card_bus_width[chip->card2lun[SD_CARD]] = 4;
./drivers/staging/rts5208/sd.c:3236:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:3363:	chip->card_bus_width[chip->card2lun[SD_CARD]] = 1;
./drivers/staging/rts5208/sd.c:3443:		chip->card_wp |= SD_CARD;
./drivers/staging/rts5208/sd.c:3450:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:3456:	chip->capacity[chip->card2lun[SD_CARD]] = 0;
./drivers/staging/rts5208/sd.c:3464:	if (chip->ignore_sd && CHK_SDIO_EXIST(chip) &&
./drivers/staging/rts5208/sd.c:3466:		if (chip->asic_code) {
./drivers/staging/rts5208/sd.c:3486:		chip->sd_io = 1;
./drivers/staging/rts5208/sd.c:3497:	if (chip->sd_ctl & RESET_MMC_FIRST) {
./drivers/staging/rts5208/sd.c:3519:			if (chip->sd_io) {
./drivers/staging/rts5208/sd.c:3548:	chip->capacity[chip->card2lun[SD_CARD]] = sd_card->capacity;
./drivers/staging/rts5208/sd.c:3563:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:3577:	chip->capacity[chip->card2lun[SD_CARD]] = sd_card->capacity = 0;
./drivers/staging/rts5208/sd.c:3614:	chip->capacity[chip->card2lun[SD_CARD]] = sd_card->capacity;
./drivers/staging/rts5208/sd.c:3632:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:3665:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:3690:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:3693:	if (chip->asic_code) {
./drivers/staging/rts5208/sd.c:3739:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:3756:	if (!(chip->card_ready & SD_CARD)) {
./drivers/staging/rts5208/sd.c:3761:			chip->card_ready |= SD_CARD;
./drivers/staging/rts5208/sd.c:3762:			chip->card_fail &= ~SD_CARD;
./drivers/staging/rts5208/sd.c:3764:			chip->card_ready &= ~SD_CARD;
./drivers/staging/rts5208/sd.c:3765:			chip->card_fail |= SD_CARD;
./drivers/staging/rts5208/sd.c:3766:			chip->capacity[chip->card2lun[SD_CARD]] = 0;
./drivers/staging/rts5208/sd.c:3767:			chip->rw_need_retry = 1;
./drivers/staging/rts5208/sd.c:3803:			chip->rw_need_retry = 1;
./drivers/staging/rts5208/sd.c:3904:				chip->rw_need_retry = 1;
./drivers/staging/rts5208/sd.c:3912:				chip->rw_need_retry = 1;
./drivers/staging/rts5208/sd.c:3921:				chip->rw_need_retry = 1;
./drivers/staging/rts5208/sd.c:3950:				srb->sc_data_direction, chip->sd_timeout);
./drivers/staging/rts5208/sd.c:3965:			chip->rw_need_retry = 0;
./drivers/staging/rts5208/sd.c:3971:		chip->rw_need_retry = 1;
./drivers/staging/rts5208/sd.c:4008:		chip->rw_need_retry = 0;
./drivers/staging/rts5208/sd.c:4026:			chip->card_ready &= ~SD_CARD;
./drivers/staging/rts5208/sd.c:4027:			chip->card_fail |= SD_CARD;
./drivers/staging/rts5208/sd.c:4028:			chip->capacity[chip->card2lun[SD_CARD]] = 0;
./drivers/staging/rts5208/sd.c:4230:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:4256:	if (!(CHK_BIT(chip->lun_mc, lun))) {
./drivers/staging/rts5208/sd.c:4257:		SET_BIT(chip->lun_mc, lun);
./drivers/staging/rts5208/sd.c:4288:	if (chip->card_wp & SD_CARD)
./drivers/staging/rts5208/sd.c:4294:	buf[15] = chip->max_lun;
./drivers/staging/rts5208/sd.c:4343:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:4469:	if (!(chip->card_ready & SD_CARD))
./drivers/staging/rts5208/sd.c:4478:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:4731:	if (!(chip->card_ready & SD_CARD))
./drivers/staging/rts5208/sd.c:4740:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:5111:	if (!(chip->card_ready & SD_CARD))
./drivers/staging/rts5208/sd.c:5120:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:5162:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:5232:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:5257:	if (!chip->ft2_fast_mode) {
./drivers/staging/rts5208/sd.c:5267:	if (chip->asic_code) {
./drivers/staging/rts5208/sd.c:5288:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/sd.c:5291:	chip->card_ready &= ~SD_CARD;
./drivers/staging/rts5208/sd.c:5292:	chip->card_fail &= ~SD_CARD;
./drivers/staging/rts5208/sd.c:5293:	chip->card_wp &= ~SD_CARD;
./drivers/staging/rts5208/sd.c:5295:	chip->sd_io = 0;
./drivers/staging/rts5208/sd.c:5296:	chip->sd_int = 0;
./drivers/staging/rts5208/spi.c:32:	struct spi_info *spi = &(chip->spi);
./drivers/staging/rts5208/spi.c:59:	struct spi_info *spi = &(chip->spi);
./drivers/staging/rts5208/spi.c:136:	struct spi_info *spi = &(chip->spi);
./drivers/staging/rts5208/spi.c:165:	struct spi_info *spi = &(chip->spi);
./drivers/staging/rts5208/spi.c:256:	if (chip->asic_code)
./drivers/staging/rts5208/spi.c:520:	struct spi_info *spi = &(chip->spi);
./drivers/staging/rts5208/spi.c:533:	struct spi_info *spi = &(chip->spi);
./drivers/staging/rts5208/spi.c:537:	if (chip->asic_code)
./drivers/staging/rts5208/rtsx.c:133:	if (chip->srb != NULL) {
./drivers/staging/rts5208/rtsx.c:134:		dev_err(&dev->pci->dev, "Error: chip->srb = %p\n",
./drivers/staging/rts5208/rtsx.c:135:			chip->srb);
./drivers/staging/rts5208/rtsx.c:149:	chip->srb = srb;
./drivers/staging/rts5208/rtsx.c:173:	if (chip->srb != srb) {
./drivers/staging/rts5208/rtsx.c:267:	dev_info(&dev->pci->dev, "%s: chip->msi_en = %d, pci->irq = %d\n",
./drivers/staging/rts5208/rtsx.c:268:		 __func__, chip->msi_en, dev->pci->irq);
./drivers/staging/rts5208/rtsx.c:271:			chip->msi_en ? 0 : IRQF_SHARED,
./drivers/staging/rts5208/rtsx.c:280:	pci_intx(dev->pci, !chip->msi_en);
./drivers/staging/rts5208/rtsx.c:327:	if (chip->msi_en)
./drivers/staging/rts5208/rtsx.c:366:	if (chip->msi_en) {
./drivers/staging/rts5208/rtsx.c:368:			chip->msi_en = 0;
./drivers/staging/rts5208/rtsx.c:404:	if (chip->msi_en)
./drivers/staging/rts5208/rtsx.c:435:			chip->srb->result = DID_ABORT << 16;
./drivers/staging/rts5208/rtsx.c:444:		if (chip->srb->sc_data_direction == DMA_BIDIRECTIONAL) {
./drivers/staging/rts5208/rtsx.c:446:			chip->srb->result = DID_ERROR << 16;
./drivers/staging/rts5208/rtsx.c:452:		else if (chip->srb->device->id) {
./drivers/staging/rts5208/rtsx.c:454:				chip->srb->device->id,
./drivers/staging/rts5208/rtsx.c:455:				(u8)chip->srb->device->lun);
./drivers/staging/rts5208/rtsx.c:456:			chip->srb->result = DID_BAD_TARGET << 16;
./drivers/staging/rts5208/rtsx.c:459:		else if (chip->srb->device->lun > chip->max_lun) {
./drivers/staging/rts5208/rtsx.c:461:				chip->srb->device->id,
./drivers/staging/rts5208/rtsx.c:462:				(u8)chip->srb->device->lun);
./drivers/staging/rts5208/rtsx.c:463:			chip->srb->result = DID_BAD_TARGET << 16;
./drivers/staging/rts5208/rtsx.c:469:			rtsx_invoke_transport(chip->srb, chip);
./drivers/staging/rts5208/rtsx.c:476:		if (!chip->srb)
./drivers/staging/rts5208/rtsx.c:480:		else if (chip->srb->result != DID_ABORT << 16) {
./drivers/staging/rts5208/rtsx.c:481:			chip->srb->scsi_done(chip->srb);
./drivers/staging/rts5208/rtsx.c:494:		chip->srb = NULL;
./drivers/staging/rts5208/rtsx.c:523:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx.c:524:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/rtsx.c:525:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx.c:588:		if (chip->int_reg == 0xFFFFFFFF)
./drivers/staging/rts5208/rtsx.c:593:	status = chip->int_reg;
./drivers/staging/rts5208/rtsx.c:648:		dev->chip->host_cmds_ptr = NULL;
./drivers/staging/rts5208/rtsx.c:649:		dev->chip->host_sg_tbl_ptr = NULL;
./drivers/staging/rts5208/rtsx.c:654:	if (dev->chip->msi_en)
./drivers/staging/rts5208/rtsx.c:687:	if (chip->srb) {
./drivers/staging/rts5208/rtsx.c:688:		chip->srb->result = DID_NO_CONNECT << 16;
./drivers/staging/rts5208/rtsx.c:690:		chip->srb->scsi_done(dev->chip->srb);
./drivers/staging/rts5208/rtsx.c:691:		chip->srb = NULL;
./drivers/staging/rts5208/rtsx.c:740:	chip->vendor_id = chip->rtsx->pci->vendor;
./drivers/staging/rts5208/rtsx.c:741:	chip->product_id = chip->rtsx->pci->device;
./drivers/staging/rts5208/rtsx.c:742:	chip->adma_mode = 1;
./drivers/staging/rts5208/rtsx.c:743:	chip->lun_mc = 0;
./drivers/staging/rts5208/rtsx.c:744:	chip->driver_first_load = 1;
./drivers/staging/rts5208/rtsx.c:746:	chip->sdio_in_charge = 0;
./drivers/staging/rts5208/rtsx.c:749:	chip->mspro_formatter_enable = 1;
./drivers/staging/rts5208/rtsx.c:750:	chip->ignore_sd = 0;
./drivers/staging/rts5208/rtsx.c:751:	chip->use_hw_setting = 0;
./drivers/staging/rts5208/rtsx.c:752:	chip->lun_mode = DEFAULT_SINGLE;
./drivers/staging/rts5208/rtsx.c:753:	chip->auto_delink_en = auto_delink_en;
./drivers/staging/rts5208/rtsx.c:754:	chip->ss_en = ss_en;
./drivers/staging/rts5208/rtsx.c:755:	chip->ss_idle_period = ss_interval * 1000;
./drivers/staging/rts5208/rtsx.c:756:	chip->remote_wakeup_en = 0;
./drivers/staging/rts5208/rtsx.c:757:	chip->aspm_l0s_l1_en = aspm_l0s_l1_en;
./drivers/staging/rts5208/rtsx.c:758:	chip->dynamic_aspm = 1;
./drivers/staging/rts5208/rtsx.c:759:	chip->fpga_sd_sdr104_clk = CLK_200;
./drivers/staging/rts5208/rtsx.c:760:	chip->fpga_sd_ddr50_clk = CLK_100;
./drivers/staging/rts5208/rtsx.c:761:	chip->fpga_sd_sdr50_clk = CLK_100;
./drivers/staging/rts5208/rtsx.c:762:	chip->fpga_sd_hs_clk = CLK_100;
./drivers/staging/rts5208/rtsx.c:763:	chip->fpga_mmc_52m_clk = CLK_80;
./drivers/staging/rts5208/rtsx.c:764:	chip->fpga_ms_hg_clk = CLK_80;
./drivers/staging/rts5208/rtsx.c:765:	chip->fpga_ms_4bit_clk = CLK_80;
./drivers/staging/rts5208/rtsx.c:766:	chip->fpga_ms_1bit_clk = CLK_40;
./drivers/staging/rts5208/rtsx.c:767:	chip->asic_sd_sdr104_clk = 203;
./drivers/staging/rts5208/rtsx.c:768:	chip->asic_sd_sdr50_clk = 98;
./drivers/staging/rts5208/rtsx.c:769:	chip->asic_sd_ddr50_clk = 98;
./drivers/staging/rts5208/rtsx.c:770:	chip->asic_sd_hs_clk = 98;
./drivers/staging/rts5208/rtsx.c:771:	chip->asic_mmc_52m_clk = 98;
./drivers/staging/rts5208/rtsx.c:772:	chip->asic_ms_hg_clk = 117;
./drivers/staging/rts5208/rtsx.c:773:	chip->asic_ms_4bit_clk = 78;
./drivers/staging/rts5208/rtsx.c:774:	chip->asic_ms_1bit_clk = 39;
./drivers/staging/rts5208/rtsx.c:775:	chip->ssc_depth_sd_sdr104 = SSC_DEPTH_2M;
./drivers/staging/rts5208/rtsx.c:776:	chip->ssc_depth_sd_sdr50 = SSC_DEPTH_2M;
./drivers/staging/rts5208/rtsx.c:777:	chip->ssc_depth_sd_ddr50 = SSC_DEPTH_1M;
./drivers/staging/rts5208/rtsx.c:778:	chip->ssc_depth_sd_hs = SSC_DEPTH_1M;
./drivers/staging/rts5208/rtsx.c:779:	chip->ssc_depth_mmc_52m = SSC_DEPTH_1M;
./drivers/staging/rts5208/rtsx.c:780:	chip->ssc_depth_ms_hg = SSC_DEPTH_1M;
./drivers/staging/rts5208/rtsx.c:781:	chip->ssc_depth_ms_4bit = SSC_DEPTH_512K;
./drivers/staging/rts5208/rtsx.c:782:	chip->ssc_depth_low_speed = SSC_DEPTH_512K;
./drivers/staging/rts5208/rtsx.c:783:	chip->ssc_en = 1;
./drivers/staging/rts5208/rtsx.c:784:	chip->sd_speed_prior = 0x01040203;
./drivers/staging/rts5208/rtsx.c:785:	chip->sd_current_prior = 0x00010203;
./drivers/staging/rts5208/rtsx.c:786:	chip->sd_ctl = SD_PUSH_POINT_AUTO |
./drivers/staging/rts5208/rtsx.c:789:	chip->sd_ddr_tx_phase = 0;
./drivers/staging/rts5208/rtsx.c:790:	chip->mmc_ddr_tx_phase = 1;
./drivers/staging/rts5208/rtsx.c:791:	chip->sd_default_tx_phase = 15;
./drivers/staging/rts5208/rtsx.c:792:	chip->sd_default_rx_phase = 15;
./drivers/staging/rts5208/rtsx.c:793:	chip->pmos_pwr_on_interval = 200;
./drivers/staging/rts5208/rtsx.c:794:	chip->sd_voltage_switch_delay = 1000;
./drivers/staging/rts5208/rtsx.c:795:	chip->ms_power_class_en = 3;
./drivers/staging/rts5208/rtsx.c:797:	chip->sd_400mA_ocp_thd = 1;
./drivers/staging/rts5208/rtsx.c:798:	chip->sd_800mA_ocp_thd = 5;
./drivers/staging/rts5208/rtsx.c:799:	chip->ms_ocp_thd = 2;
./drivers/staging/rts5208/rtsx.c:801:	chip->card_drive_sel = 0x55;
./drivers/staging/rts5208/rtsx.c:802:	chip->sd30_drive_sel_1v8 = 0x03;
./drivers/staging/rts5208/rtsx.c:803:	chip->sd30_drive_sel_3v3 = 0x01;
./drivers/staging/rts5208/rtsx.c:805:	chip->do_delink_before_power_down = 1;
./drivers/staging/rts5208/rtsx.c:806:	chip->auto_power_down = 1;
./drivers/staging/rts5208/rtsx.c:807:	chip->polling_config = 0;
./drivers/staging/rts5208/rtsx.c:809:	chip->force_clkreq_0 = 1;
./drivers/staging/rts5208/rtsx.c:810:	chip->ft2_fast_mode = 0;
./drivers/staging/rts5208/rtsx.c:812:	chip->sdio_retry_cnt = 1;
./drivers/staging/rts5208/rtsx.c:814:	chip->xd_timeout = 2000;
./drivers/staging/rts5208/rtsx.c:815:	chip->sd_timeout = 10000;
./drivers/staging/rts5208/rtsx.c:816:	chip->ms_timeout = 2000;
./drivers/staging/rts5208/rtsx.c:817:	chip->mspro_timeout = 15000;
./drivers/staging/rts5208/rtsx.c:819:	chip->power_down_in_ss = 1;
./drivers/staging/rts5208/rtsx.c:821:	chip->sdr104_en = 1;
./drivers/staging/rts5208/rtsx.c:822:	chip->sdr50_en = 1;
./drivers/staging/rts5208/rtsx.c:823:	chip->ddr50_en = 1;
./drivers/staging/rts5208/rtsx.c:825:	chip->delink_stage1_step = 100;
./drivers/staging/rts5208/rtsx.c:826:	chip->delink_stage2_step = 40;
./drivers/staging/rts5208/rtsx.c:827:	chip->delink_stage3_step = 20;
./drivers/staging/rts5208/rtsx.c:829:	chip->auto_delink_in_L1 = 1;
./drivers/staging/rts5208/rtsx.c:830:	chip->blink_led = 1;
./drivers/staging/rts5208/rtsx.c:831:	chip->msi_en = msi_en;
./drivers/staging/rts5208/rtsx.c:832:	chip->hp_watch_bios_hotplug = 0;
./drivers/staging/rts5208/rtsx.c:833:	chip->max_payload = 0;
./drivers/staging/rts5208/rtsx.c:834:	chip->phy_voltage = 0;
./drivers/staging/rts5208/rtsx.c:836:	chip->support_ms_8bit = 1;
./drivers/staging/rts5208/rtsx.c:837:	chip->s3_pwr_off_delay = 1000;
./drivers/staging/rts5208/rtsx.c:918:	dev->chip->host_cmds_ptr = dev->rtsx_resv_buf;
./drivers/staging/rts5208/rtsx.c:919:	dev->chip->host_cmds_addr = dev->rtsx_resv_buf_addr;
./drivers/staging/rts5208/rtsx.c:920:	dev->chip->host_sg_tbl_ptr = dev->rtsx_resv_buf + HOST_CMDS_BUF_LEN;
./drivers/staging/rts5208/rtsx.c:921:	dev->chip->host_sg_tbl_addr = dev->rtsx_resv_buf_addr +
./drivers/staging/rts5208/rtsx.c:924:	dev->chip->rtsx = dev;
./drivers/staging/rts5208/rtsx.c:930:	if (dev->chip->msi_en) {
./drivers/staging/rts5208/rtsx.c:932:			dev->chip->msi_en = 0;
./drivers/staging/rts5208/rtsx.c:948:	host->max_lun = dev->chip->max_lun;
./drivers/staging/rts5208/trace.c:11:	struct trace_msg_t *msg = &chip->trace_msg[chip->msg_idx];
./drivers/staging/rts5208/trace.c:22:	chip->msg_idx++;
./drivers/staging/rts5208/trace.c:23:	if (chip->msg_idx >= TRACE_ITEM_CNT)
./drivers/staging/rts5208/trace.c:24:		chip->msg_idx = 0;
./drivers/staging/rts5208/rtsx_transport.c:197:		       (unsigned char *)&chip->sense_buffer[SCSI_LUN(srb)],
./drivers/staging/rts5208/rtsx_transport.c:210:	u32 *cb = (u32 *)(chip->host_cmds_ptr);
./drivers/staging/rts5208/rtsx_transport.c:218:	spin_lock_irq(&chip->rtsx->reg_lock);
./drivers/staging/rts5208/rtsx_transport.c:219:	if (chip->ci < (HOST_CMDS_BUF_LEN / 4))
./drivers/staging/rts5208/rtsx_transport.c:220:		cb[(chip->ci)++] = cpu_to_le32(val);
./drivers/staging/rts5208/rtsx_transport.c:222:	spin_unlock_irq(&chip->rtsx->reg_lock);
./drivers/staging/rts5208/rtsx_transport.c:229:	rtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);
./drivers/staging/rts5208/rtsx_transport.c:231:	val |= (u32)(chip->ci * 4) & 0x00FFFFFF;
./drivers/staging/rts5208/rtsx_transport.c:239:	struct rtsx_dev *rtsx = chip->rtsx;
./drivers/staging/rts5208/rtsx_transport.c:262:	rtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);
./drivers/staging/rts5208/rtsx_transport.c:264:	val |= (u32)(chip->ci * 4) & 0x00FFFFFF;
./drivers/staging/rts5208/rtsx_transport.c:275:		dev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",
./drivers/staging/rts5208/rtsx_transport.c:276:			chip->int_reg);
./drivers/staging/rts5208/rtsx_transport.c:303:	u64 *sgb = (u64 *)(chip->host_sg_tbl_ptr);
./drivers/staging/rts5208/rtsx_transport.c:318:		if (chip->sgi < (HOST_SG_TBL_BUF_LEN / 8))
./drivers/staging/rts5208/rtsx_transport.c:319:			sgb[(chip->sgi)++] = cpu_to_le64(val);
./drivers/staging/rts5208/rtsx_transport.c:333:	struct rtsx_dev *rtsx = chip->rtsx;
./drivers/staging/rts5208/rtsx_transport.c:375:	chip->sgi = 0;
./drivers/staging/rts5208/rtsx_transport.c:422:	dev_dbg(rtsx_dev(chip), "SG table count = %d\n", chip->sgi);
./drivers/staging/rts5208/rtsx_transport.c:431:	rtsx_writel(chip, RTSX_HDBAR, chip->host_sg_tbl_addr);
./drivers/staging/rts5208/rtsx_transport.c:441:		dev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",
./drivers/staging/rts5208/rtsx_transport.c:442:			chip->int_reg);
./drivers/staging/rts5208/rtsx_transport.c:465:			dev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",
./drivers/staging/rts5208/rtsx_transport.c:466:				chip->int_reg);
./drivers/staging/rts5208/rtsx_transport.c:498:	struct rtsx_dev *rtsx = chip->rtsx;
./drivers/staging/rts5208/rtsx_transport.c:548:		chip->sgi = 0;
./drivers/staging/rts5208/rtsx_transport.c:567:		dev_dbg(rtsx_dev(chip), "SG table count = %d\n", chip->sgi);
./drivers/staging/rts5208/rtsx_transport.c:576:		rtsx_writel(chip, RTSX_HDBAR, chip->host_sg_tbl_addr);
./drivers/staging/rts5208/rtsx_transport.c:586:			dev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",
./drivers/staging/rts5208/rtsx_transport.c:587:				chip->int_reg);
./drivers/staging/rts5208/rtsx_transport.c:613:			dev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",
./drivers/staging/rts5208/rtsx_transport.c:614:				chip->int_reg);
./drivers/staging/rts5208/rtsx_transport.c:645:	struct rtsx_dev *rtsx = chip->rtsx;
./drivers/staging/rts5208/rtsx_transport.c:700:		dev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",
./drivers/staging/rts5208/rtsx_transport.c:701:			chip->int_reg);
./drivers/staging/rts5208/rtsx_transport.c:749:			chip->need_reinit = SD_CARD | MS_CARD | XD_CARD;
./drivers/staging/rts5208/rtsx_transport.c:779:			chip->need_reinit = SD_CARD | MS_CARD | XD_CARD;
./drivers/staging/rts5208/rtsx_scsi.c:35:	struct scsi_cmnd *srb = chip->srb;
./drivers/staging/rts5208/rtsx_scsi.c:403:	struct sense_data_t *sense = &(chip->sense_buffer[lun]);
./drivers/staging/rts5208/rtsx_scsi.c:431:	if (!(CHK_BIT(chip->lun_mc, lun))) {
./drivers/staging/rts5208/rtsx_scsi.c:432:		SET_BIT(chip->lun_mc, lun);
./drivers/staging/rts5208/rtsx_scsi.c:439:		struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx_scsi.c:498:		if (chip->lun2card[lun] == SD_CARD)
./drivers/staging/rts5208/rtsx_scsi.c:516:	if ((chip->mspro_formatter_enable) &&
./drivers/staging/rts5208/rtsx_scsi.c:517:			(chip->lun2card[lun] & MS_CARD))
./drivers/staging/rts5208/rtsx_scsi.c:519:	if (chip->mspro_formatter_enable)
./drivers/staging/rts5208/rtsx_scsi.c:621:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:624:	sense = &(chip->sense_buffer[lun]);
./drivers/staging/rts5208/rtsx_scsi.c:667:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:778:	if ((chip->lun2card[lun] & MS_CARD)) {
./drivers/staging/rts5208/rtsx_scsi.c:781:			if (chip->mspro_formatter_enable)
./drivers/staging/rts5208/rtsx_scsi.c:787:		if (chip->mspro_formatter_enable) {
./drivers/staging/rts5208/rtsx_scsi.c:860:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx_scsi.c:869:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:881:	if (!(CHK_BIT(chip->lun_mc, lun))) {
./drivers/staging/rts5208/rtsx_scsi.c:882:		SET_BIT(chip->lun_mc, lun);
./drivers/staging/rts5208/rtsx_scsi.c:949:	if (chip->rw_fail_cnt[lun] == 3) {
./drivers/staging/rts5208/rtsx_scsi.c:973:		if (chip->need_release & chip->lun2card[lun]) {
./drivers/staging/rts5208/rtsx_scsi.c:974:			chip->rw_fail_cnt[lun] = 0;
./drivers/staging/rts5208/rtsx_scsi.c:977:			chip->rw_fail_cnt[lun]++;
./drivers/staging/rts5208/rtsx_scsi.c:989:		chip->rw_fail_cnt[lun] = 0;
./drivers/staging/rts5208/rtsx_scsi.c:1010:		if (!chip->mspro_formatter_enable) {
./drivers/staging/rts5208/rtsx_scsi.c:1030:	if ((buf_len > 12) && chip->mspro_formatter_enable &&
./drivers/staging/rts5208/rtsx_scsi.c:1031:			(chip->lun2card[lun] & MS_CARD) &&
./drivers/staging/rts5208/rtsx_scsi.c:1092:	if (!(CHK_BIT(chip->lun_mc, lun))) {
./drivers/staging/rts5208/rtsx_scsi.c:1093:		SET_BIT(chip->lun_mc, lun);
./drivers/staging/rts5208/rtsx_scsi.c:1131:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:1182:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:1242:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:1300:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:1352:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx_scsi.c:1379:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:1419:	if (chip->trace_msg[chip->msg_idx].valid)
./drivers/staging/rts5208/rtsx_scsi.c:1422:		msg_cnt = chip->msg_idx;
./drivers/staging/rts5208/rtsx_scsi.c:1433:		idx = chip->msg_idx - i;
./drivers/staging/rts5208/rtsx_scsi.c:1437:		*(ptr++) = (u8)(chip->trace_msg[idx].line >> 8);
./drivers/staging/rts5208/rtsx_scsi.c:1438:		*(ptr++) = (u8)(chip->trace_msg[idx].line);
./drivers/staging/rts5208/rtsx_scsi.c:1440:			*(ptr++) = chip->trace_msg[idx].func[j];
./drivers/staging/rts5208/rtsx_scsi.c:1443:			*(ptr++) = chip->trace_msg[idx].file[j];
./drivers/staging/rts5208/rtsx_scsi.c:1446:			*(ptr++) = chip->trace_msg[idx].timeval_buf[j];
./drivers/staging/rts5208/rtsx_scsi.c:1453:		chip->msg_idx = 0;
./drivers/staging/rts5208/rtsx_scsi.c:1455:			chip->trace_msg[i].valid = 0;
./drivers/staging/rts5208/rtsx_scsi.c:1471:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:1502:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:1528:		struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/rtsx_scsi.c:1529:		struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx_scsi.c:1530:		struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:1553:			chip->blink_led = 1;
./drivers/staging/rts5208/rtsx_scsi.c:1557:			chip->blink_led = 0;
./drivers/staging/rts5208/rtsx_scsi.c:1561:			if (chip->ss_en &&
./drivers/staging/rts5208/rtsx_scsi.c:1592:		struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/rtsx_scsi.c:1593:		struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx_scsi.c:1594:		struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:1619:		u8 tmp = chip->blink_led;
./drivers/staging/rts5208/rtsx_scsi.c:1639:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:1673:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx_scsi.c:1674:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:1685:	status[0] = (u8)(chip->product_id);
./drivers/staging/rts5208/rtsx_scsi.c:1686:	status[1] = chip->ic_version;
./drivers/staging/rts5208/rtsx_scsi.c:1688:	if (chip->auto_delink_en)
./drivers/staging/rts5208/rtsx_scsi.c:1698:	if (chip->card_wp)
./drivers/staging/rts5208/rtsx_scsi.c:1706:		SD_MS_2LUN) && (chip->lun2card[lun] == MS_CARD)) {
./drivers/staging/rts5208/rtsx_scsi.c:1714:	if (chip->ocp_stat & oc_now_mask)
./drivers/staging/rts5208/rtsx_scsi.c:1717:	if (chip->ocp_stat & oc_ever_mask)
./drivers/staging/rts5208/rtsx_scsi.c:1818:		chip->phy_debug_mode = 1;
./drivers/staging/rts5208/rtsx_scsi.c:1840:		chip->phy_debug_mode = 0;
./drivers/staging/rts5208/rtsx_scsi.c:1875:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:1954:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2016:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2076:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2126:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2178:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2229:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2282:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2308:	if (chip->asic_code) {
./drivers/staging/rts5208/rtsx_scsi.c:2327:						0x4C00 | chip->phy_voltage);
./drivers/staging/rts5208/rtsx_scsi.c:2374:	if (chip->asic_code) {
./drivers/staging/rts5208/rtsx_scsi.c:2411:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2470:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2614:	rtsx_status[0] = (u8)(chip->vendor_id >> 8);
./drivers/staging/rts5208/rtsx_scsi.c:2615:	rtsx_status[1] = (u8)(chip->vendor_id);
./drivers/staging/rts5208/rtsx_scsi.c:2617:	rtsx_status[2] = (u8)(chip->product_id >> 8);
./drivers/staging/rts5208/rtsx_scsi.c:2618:	rtsx_status[3] = (u8)(chip->product_id);
./drivers/staging/rts5208/rtsx_scsi.c:2623:		if (chip->lun2card[lun] == SD_CARD)
./drivers/staging/rts5208/rtsx_scsi.c:2628:		if (chip->card_exist) {
./drivers/staging/rts5208/rtsx_scsi.c:2629:			if (chip->card_exist & XD_CARD)
./drivers/staging/rts5208/rtsx_scsi.c:2631:			else if (chip->card_exist & SD_CARD)
./drivers/staging/rts5208/rtsx_scsi.c:2633:			else if (chip->card_exist & MS_CARD)
./drivers/staging/rts5208/rtsx_scsi.c:2647:	rtsx_status[7] = (u8)(chip->product_id);
./drivers/staging/rts5208/rtsx_scsi.c:2648:	rtsx_status[8] = chip->ic_version;
./drivers/staging/rts5208/rtsx_scsi.c:2661:		if (chip->lun2card[lun] == SD_CARD)
./drivers/staging/rts5208/rtsx_scsi.c:2677:		struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx_scsi.c:2693:		struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:2709:			if (chip->sd_io && chip->sd_int)
./drivers/staging/rts5208/rtsx_scsi.c:2717:			if (chip->lun2card[lun] == SD_CARD)
./drivers/staging/rts5208/rtsx_scsi.c:2750:		bus_width = chip->card_bus_width[lun];
./drivers/staging/rts5208/rtsx_scsi.c:2777:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2911:	if (chip->rw_cap[lun] >= GPIO_TOGGLE_THRESHOLD) {
./drivers/staging/rts5208/rtsx_scsi.c:2913:		chip->rw_cap[lun] = 0;
./drivers/staging/rts5208/rtsx_scsi.c:2915:		chip->rw_cap[lun] += sec_cnt;
./drivers/staging/rts5208/rtsx_scsi.c:2922:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:2943:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:2961:	if (!(chip->card_ready & MS_CARD)) {
./drivers/staging/rts5208/rtsx_scsi.c:2967:	if (chip->card_wp & MS_CARD) {
./drivers/staging/rts5208/rtsx_scsi.c:2993:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:3114:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:3171:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:3178:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:3284:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_scsi.c:3291:	if (chip->ss_en && (rtsx_get_stat(chip) == RTSX_STAT_SS)) {
./drivers/staging/rts5208/rtsx_scsi.c:3422:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx_scsi.c:3424:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_card.c:36:	struct sd_info *sd_card = &(chip->sd_card);
./drivers/staging/rts5208/rtsx_card.c:38:	struct xd_info *xd_card = &(chip->xd_card);
./drivers/staging/rts5208/rtsx_card.c:40:	struct ms_info *ms_card = &(chip->ms_card);
./drivers/staging/rts5208/rtsx_card.c:42:	if (chip->card_ready & SD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:52:	if (chip->card_ready & XD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:62:	if (chip->card_ready & MS_CARD) {
./drivers/staging/rts5208/rtsx_card.c:101:		chip->sd_int = 1;
./drivers/staging/rts5208/rtsx_card.c:118:	if ((memcmp(buf, chip->sdio_raw_data, 12) != 0) || (reg & 0x03)) {
./drivers/staging/rts5208/rtsx_card.c:119:		chip->sdio_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:120:		chip->sdio_idle = 0;
./drivers/staging/rts5208/rtsx_card.c:122:		if (!chip->sdio_idle) {
./drivers/staging/rts5208/rtsx_card.c:123:			chip->sdio_counter++;
./drivers/staging/rts5208/rtsx_card.c:124:			if (chip->sdio_counter >= SDIO_IDLE_COUNT) {
./drivers/staging/rts5208/rtsx_card.c:125:				chip->sdio_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:126:				chip->sdio_idle = 1;
./drivers/staging/rts5208/rtsx_card.c:130:	memcpy(chip->sdio_raw_data, buf, 12);
./drivers/staging/rts5208/rtsx_card.c:132:	if (chip->sdio_idle) {
./drivers/staging/rts5208/rtsx_card.c:133:		if (!chip->sdio_aspm) {
./drivers/staging/rts5208/rtsx_card.c:136:					0x30 | (chip->aspm_level[1] << 2));
./drivers/staging/rts5208/rtsx_card.c:137:			chip->sdio_aspm = 1;
./drivers/staging/rts5208/rtsx_card.c:140:		if (chip->sdio_aspm) {
./drivers/staging/rts5208/rtsx_card.c:143:			chip->sdio_aspm = 0;
./drivers/staging/rts5208/rtsx_card.c:154:		chip->sd_reset_counter, chip->card2lun[SD_CARD]);
./drivers/staging/rts5208/rtsx_card.c:156:	if (chip->card2lun[SD_CARD] >= MAX_ALLOWED_LUN_CNT) {
./drivers/staging/rts5208/rtsx_card.c:157:		clear_bit(SD_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:158:		chip->sd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:159:		chip->sd_show_cnt = 0;
./drivers/staging/rts5208/rtsx_card.c:163:	chip->rw_fail_cnt[chip->card2lun[SD_CARD]] = 0;
./drivers/staging/rts5208/rtsx_card.c:169:	if (chip->need_release & SD_CARD)
./drivers/staging/rts5208/rtsx_card.c:172:		clear_bit(SD_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:173:		chip->sd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:174:		chip->sd_show_cnt = 0;
./drivers/staging/rts5208/rtsx_card.c:175:		chip->card_ready |= SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:176:		chip->card_fail &= ~SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:177:		chip->rw_card[chip->card2lun[SD_CARD]] = sd_rw;
./drivers/staging/rts5208/rtsx_card.c:179:		if (chip->sd_io || (chip->sd_reset_counter >= MAX_RESET_CNT)) {
./drivers/staging/rts5208/rtsx_card.c:180:			clear_bit(SD_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:181:			chip->sd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:182:			chip->sd_show_cnt = 0;
./drivers/staging/rts5208/rtsx_card.c:184:			chip->sd_reset_counter++;
./drivers/staging/rts5208/rtsx_card.c:186:		chip->card_ready &= ~SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:187:		chip->card_fail |= SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:188:		chip->capacity[chip->card2lun[SD_CARD]] = 0;
./drivers/staging/rts5208/rtsx_card.c:189:		chip->rw_card[chip->card2lun[SD_CARD]] = NULL;
./drivers/staging/rts5208/rtsx_card.c:192:		if (!chip->ft2_fast_mode)
./drivers/staging/rts5208/rtsx_card.c:194:		if (chip->sd_io) {
./drivers/staging/rts5208/rtsx_card.c:195:			chip->sd_int = 0;
./drivers/staging/rts5208/rtsx_card.c:208:		chip->xd_reset_counter, chip->card2lun[XD_CARD]);
./drivers/staging/rts5208/rtsx_card.c:210:	if (chip->card2lun[XD_CARD] >= MAX_ALLOWED_LUN_CNT) {
./drivers/staging/rts5208/rtsx_card.c:211:		clear_bit(XD_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:212:		chip->xd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:213:		chip->xd_show_cnt = 0;
./drivers/staging/rts5208/rtsx_card.c:217:	chip->rw_fail_cnt[chip->card2lun[XD_CARD]] = 0;
./drivers/staging/rts5208/rtsx_card.c:223:	if (chip->need_release & XD_CARD)
./drivers/staging/rts5208/rtsx_card.c:226:		clear_bit(XD_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:227:		chip->xd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:228:		chip->card_ready |= XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:229:		chip->card_fail &= ~XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:230:		chip->rw_card[chip->card2lun[XD_CARD]] = xd_rw;
./drivers/staging/rts5208/rtsx_card.c:232:		if (chip->xd_reset_counter >= MAX_RESET_CNT) {
./drivers/staging/rts5208/rtsx_card.c:233:			clear_bit(XD_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:234:			chip->xd_reset_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:235:			chip->xd_show_cnt = 0;
./drivers/staging/rts5208/rtsx_card.c:237:			chip->xd_reset_counter++;
./drivers/staging/rts5208/rtsx_card.c:239:		chip->card_ready &= ~XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:240:		chip->card_fail |= XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:241:		chip->capacity[chip->card2lun[XD_CARD]] = 0;
./drivers/staging/rts5208/rtsx_card.c:242:		chip->rw_card[chip->card2lun[XD_CARD]] = NULL;
./drivers/staging/rts5208/rtsx_card.c:245:		if (!chip->ft2_fast_mode)
./drivers/staging/rts5208/rtsx_card.c:256:		chip->ms_reset_counter, chip->card2lun[MS_CARD]);
./drivers/staging/rts5208/rtsx_card.c:258:	if (chip->card2lun[MS_CARD] >= MAX_ALLOWED_LUN_CNT) {
./drivers/staging/rts5208/rtsx_card.c:259:		clear_bit(MS_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:260:		chip->ms_reset_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:261:		chip->ms_show_cnt = 0;
./drivers/staging/rts5208/rtsx_card.c:265:	chip->rw_fail_cnt[chip->card2lun[MS_CARD]] = 0;
./drivers/staging/rts5208/rtsx_card.c:271:	if (chip->need_release & MS_CARD)
./drivers/staging/rts5208/rtsx_card.c:274:		clear_bit(MS_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:275:		chip->ms_reset_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:276:		chip->card_ready |= MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:277:		chip->card_fail &= ~MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:278:		chip->rw_card[chip->card2lun[MS_CARD]] = ms_rw;
./drivers/staging/rts5208/rtsx_card.c:280:		if (chip->ms_reset_counter >= MAX_RESET_CNT) {
./drivers/staging/rts5208/rtsx_card.c:281:			clear_bit(MS_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:282:			chip->ms_reset_counter = 0;
./drivers/staging/rts5208/rtsx_card.c:283:			chip->ms_show_cnt = 0;
./drivers/staging/rts5208/rtsx_card.c:285:			chip->ms_reset_counter++;
./drivers/staging/rts5208/rtsx_card.c:287:		chip->card_ready &= ~MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:288:		chip->card_fail |= MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:289:		chip->capacity[chip->card2lun[MS_CARD]] = 0;
./drivers/staging/rts5208/rtsx_card.c:290:		chip->rw_card[chip->card2lun[MS_CARD]] = NULL;
./drivers/staging/rts5208/rtsx_card.c:293:		if (!chip->ft2_fast_mode)
./drivers/staging/rts5208/rtsx_card.c:301:	if (chip->sd_io) {
./drivers/staging/rts5208/rtsx_card.c:305:		if (chip->chip_insert_with_sdio) {
./drivers/staging/rts5208/rtsx_card.c:306:			chip->chip_insert_with_sdio = 0;
./drivers/staging/rts5208/rtsx_card.c:315:		chip->sd_io = 0;
./drivers/staging/rts5208/rtsx_card.c:321:	if ((chip->card_ready & SD_CARD) || chip->sd_io) {
./drivers/staging/rts5208/rtsx_card.c:326:	if (chip->card_ready & XD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:331:	if (chip->card_ready & MS_CARD) {
./drivers/staging/rts5208/rtsx_card.c:339:	chip->int_reg = rtsx_readl(chip, RTSX_BIPR);
./drivers/staging/rts5208/rtsx_card.c:341:	if ((chip->card_ready & SD_CARD) || chip->sd_io) {
./drivers/staging/rts5208/rtsx_card.c:342:		if (chip->int_reg & SD_EXIST)
./drivers/staging/rts5208/rtsx_card.c:347:	if (chip->card_ready & XD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:348:		if (chip->int_reg & XD_EXIST)
./drivers/staging/rts5208/rtsx_card.c:353:	if (chip->card_ready & MS_CARD) {
./drivers/staging/rts5208/rtsx_card.c:354:		if (chip->int_reg & MS_EXIST)
./drivers/staging/rts5208/rtsx_card.c:362:	if (!chip->need_reset)
./drivers/staging/rts5208/rtsx_card.c:371:	if ((chip->need_reset & SD_CARD) && chip->chip_insert_with_sdio)
./drivers/staging/rts5208/rtsx_card.c:372:		clear_bit(SD_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:374:	if (chip->need_reset & XD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:375:		chip->card_exist |= XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:377:		if (chip->xd_show_cnt >= MAX_SHOW_CNT)
./drivers/staging/rts5208/rtsx_card.c:380:			chip->xd_show_cnt++;
./drivers/staging/rts5208/rtsx_card.c:383:		if (chip->card_exist & XD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:384:			clear_bit(SD_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:385:			clear_bit(MS_NR, &(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:388:	if (chip->need_reset & SD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:389:		chip->card_exist |= SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:391:		if (chip->sd_show_cnt >= MAX_SHOW_CNT) {
./drivers/staging/rts5208/rtsx_card.c:395:			chip->sd_show_cnt++;
./drivers/staging/rts5208/rtsx_card.c:398:	if (chip->need_reset & MS_CARD) {
./drivers/staging/rts5208/rtsx_card.c:399:		chip->card_exist |= MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:401:		if (chip->ms_show_cnt >= MAX_SHOW_CNT)
./drivers/staging/rts5208/rtsx_card.c:404:			chip->ms_show_cnt++;
./drivers/staging/rts5208/rtsx_card.c:417:	chip->int_reg = rtsx_readl(chip, RTSX_BIPR);
./drivers/staging/rts5208/rtsx_card.c:419:	if ((chip->int_reg & SD_EXIST) && (chip->need_reinit & SD_CARD)) {
./drivers/staging/rts5208/rtsx_card.c:425:		chip->card_exist |= SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:429:	if ((chip->int_reg & XD_EXIST) && (chip->need_reinit & XD_CARD)) {
./drivers/staging/rts5208/rtsx_card.c:434:		chip->card_exist |= XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:438:	if ((chip->int_reg & MS_EXIST) && (chip->need_reinit & MS_CARD)) {
./drivers/staging/rts5208/rtsx_card.c:443:		chip->card_exist |= MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:447:	chip->need_reinit = 0;
./drivers/staging/rts5208/rtsx_card.c:456:	chip->int_reg = rtsx_readl(chip, RTSX_BIPR);
./drivers/staging/rts5208/rtsx_card.c:458:	if (chip->card_exist) {
./drivers/staging/rts5208/rtsx_card.c:459:		if (chip->card_exist & XD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:460:			if (!(chip->int_reg & XD_EXIST))
./drivers/staging/rts5208/rtsx_card.c:462:		} else if (chip->card_exist & SD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:463:			if (!(chip->int_reg & SD_EXIST))
./drivers/staging/rts5208/rtsx_card.c:465:		} else if (chip->card_exist & MS_CARD) {
./drivers/staging/rts5208/rtsx_card.c:466:			if (!(chip->int_reg & MS_EXIST))
./drivers/staging/rts5208/rtsx_card.c:470:		if (chip->int_reg & XD_EXIST)
./drivers/staging/rts5208/rtsx_card.c:472:		else if (chip->int_reg & SD_EXIST)
./drivers/staging/rts5208/rtsx_card.c:474:		else if (chip->int_reg & MS_EXIST)
./drivers/staging/rts5208/rtsx_card.c:483:			chip->int_reg = rtsx_readl(chip, RTSX_BIPR);
./drivers/staging/rts5208/rtsx_card.c:485:			if (chip->int_reg & XD_EXIST)
./drivers/staging/rts5208/rtsx_card.c:490:			if (chip->int_reg & SD_EXIST)
./drivers/staging/rts5208/rtsx_card.c:495:			if (chip->int_reg & MS_EXIST)
./drivers/staging/rts5208/rtsx_card.c:504:		if (!(chip->card_exist & XD_CARD) &&
./drivers/staging/rts5208/rtsx_card.c:507:		if (!(chip->card_exist & SD_CARD) &&
./drivers/staging/rts5208/rtsx_card.c:510:		if (!(chip->card_exist & MS_CARD) &&
./drivers/staging/rts5208/rtsx_card.c:534:	card_cd_debounce(chip, &(chip->need_reset), &(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:537:	if (chip->need_release) {
./drivers/staging/rts5208/rtsx_card.c:539:			if (chip->int_reg & XD_EXIST) {
./drivers/staging/rts5208/rtsx_card.c:540:				clear_bit(SD_NR, &(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:541:				clear_bit(MS_NR, &(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:545:		if (!(chip->card_exist & SD_CARD) && !chip->sd_io)
./drivers/staging/rts5208/rtsx_card.c:546:			clear_bit(SD_NR, &(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:547:		if (!(chip->card_exist & XD_CARD))
./drivers/staging/rts5208/rtsx_card.c:548:			clear_bit(XD_NR, &(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:549:		if (!(chip->card_exist & MS_CARD))
./drivers/staging/rts5208/rtsx_card.c:550:			clear_bit(MS_NR, &(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:552:		dev_dbg(rtsx_dev(chip), "chip->need_release = 0x%x\n",
./drivers/staging/rts5208/rtsx_card.c:553:			(unsigned int)(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:556:		if (chip->need_release) {
./drivers/staging/rts5208/rtsx_card.c:557:			if (chip->ocp_stat & (CARD_OC_NOW | CARD_OC_EVER))
./drivers/staging/rts5208/rtsx_card.c:561:			chip->ocp_stat = 0;
./drivers/staging/rts5208/rtsx_card.c:564:		if (chip->need_release) {
./drivers/staging/rts5208/rtsx_card.c:569:		if (chip->need_release & SD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:570:			clear_bit(SD_NR, &(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:571:			chip->card_exist &= ~SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:572:			chip->card_ejected &= ~SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:573:			chip->card_fail &= ~SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:574:			CLR_BIT(chip->lun_mc, chip->card2lun[SD_CARD]);
./drivers/staging/rts5208/rtsx_card.c:575:			chip->rw_fail_cnt[chip->card2lun[SD_CARD]] = 0;
./drivers/staging/rts5208/rtsx_card.c:582:		if (chip->need_release & XD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:583:			clear_bit(XD_NR, &(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:584:			chip->card_exist &= ~XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:585:			chip->card_ejected &= ~XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:586:			chip->card_fail &= ~XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:587:			CLR_BIT(chip->lun_mc, chip->card2lun[XD_CARD]);
./drivers/staging/rts5208/rtsx_card.c:588:			chip->rw_fail_cnt[chip->card2lun[XD_CARD]] = 0;
./drivers/staging/rts5208/rtsx_card.c:598:		if (chip->need_release & MS_CARD) {
./drivers/staging/rts5208/rtsx_card.c:599:			clear_bit(MS_NR, &(chip->need_release));
./drivers/staging/rts5208/rtsx_card.c:600:			chip->card_exist &= ~MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:601:			chip->card_ejected &= ~MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:602:			chip->card_fail &= ~MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:603:			CLR_BIT(chip->lun_mc, chip->card2lun[MS_CARD]);
./drivers/staging/rts5208/rtsx_card.c:604:			chip->rw_fail_cnt[chip->card2lun[MS_CARD]] = 0;
./drivers/staging/rts5208/rtsx_card.c:609:		dev_dbg(rtsx_dev(chip), "chip->card_exist = 0x%x\n",
./drivers/staging/rts5208/rtsx_card.c:610:			chip->card_exist);
./drivers/staging/rts5208/rtsx_card.c:612:		if (!chip->card_exist)
./drivers/staging/rts5208/rtsx_card.c:616:	if (chip->need_reset) {
./drivers/staging/rts5208/rtsx_card.c:617:		dev_dbg(rtsx_dev(chip), "chip->need_reset = 0x%x\n",
./drivers/staging/rts5208/rtsx_card.c:618:			(unsigned int)(chip->need_reset));
./drivers/staging/rts5208/rtsx_card.c:623:	if (chip->need_reinit) {
./drivers/staging/rts5208/rtsx_card.c:624:		dev_dbg(rtsx_dev(chip), "chip->need_reinit = 0x%x\n",
./drivers/staging/rts5208/rtsx_card.c:625:			(unsigned int)(chip->need_reinit));
./drivers/staging/rts5208/rtsx_card.c:638:	if (chip->cur_clk == clk)
./drivers/staging/rts5208/rtsx_card.c:646:		clk, chip->cur_clk);
./drivers/staging/rts5208/rtsx_card.c:664:	if (chip->ssc_en) {
./drivers/staging/rts5208/rtsx_card.c:702:	chip->cur_clk = clk;
./drivers/staging/rts5208/rtsx_card.c:713:	if (chip->cur_clk == clk)
./drivers/staging/rts5208/rtsx_card.c:847:	chip->cur_clk = clk;
./drivers/staging/rts5208/rtsx_card.c:944:	udelay(chip->pmos_pwr_on_interval);
./drivers/staging/rts5208/rtsx_card.c:987:	if (chip->rw_card[lun] == NULL) {
./drivers/staging/rts5208/rtsx_card.c:993:		chip->rw_need_retry = 0;
./drivers/staging/rts5208/rtsx_card.c:995:		retval = chip->rw_card[lun](srb, chip, sec_addr, sec_cnt);
./drivers/staging/rts5208/rtsx_card.c:1002:			if (detect_card_cd(chip, chip->cur_card) !=
./drivers/staging/rts5208/rtsx_card.c:1008:			if (!chip->rw_need_retry) {
./drivers/staging/rts5208/rtsx_card.c:1013:			chip->rw_need_retry = 0;
./drivers/staging/rts5208/rtsx_card.c:1073:	if (chip->cur_card != card) {
./drivers/staging/rts5208/rtsx_card.c:1094:		chip->cur_card = card;
./drivers/staging/rts5208/rtsx_card.c:1160:	if (chip->card_exist & chip->lun2card[lun])
./drivers/staging/rts5208/rtsx_card.c:1168:	if (chip->card_ready & chip->lun2card[lun])
./drivers/staging/rts5208/rtsx_card.c:1176:	if (chip->card_wp & chip->lun2card[lun])
./drivers/staging/rts5208/rtsx_card.c:1184:	if ((chip->card_ready & chip->lun2card[lun]) == XD_CARD)
./drivers/staging/rts5208/rtsx_card.c:1186:	else if ((chip->card_ready & chip->lun2card[lun]) == SD_CARD)
./drivers/staging/rts5208/rtsx_card.c:1188:	else if ((chip->card_ready & chip->lun2card[lun]) == MS_CARD)
./drivers/staging/rts5208/rtsx_card.c:1198:	if ((chip->card_ready & chip->lun2card[lun]) == SD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:1200:		chip->card_ejected |= SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:1201:		chip->card_ready &= ~SD_CARD;
./drivers/staging/rts5208/rtsx_card.c:1202:		chip->capacity[lun] = 0;
./drivers/staging/rts5208/rtsx_card.c:1203:	} else if ((chip->card_ready & chip->lun2card[lun]) == XD_CARD) {
./drivers/staging/rts5208/rtsx_card.c:1205:		chip->card_ejected |= XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:1206:		chip->card_ready &= ~XD_CARD;
./drivers/staging/rts5208/rtsx_card.c:1207:		chip->capacity[lun] = 0;
./drivers/staging/rts5208/rtsx_card.c:1208:	} else if ((chip->card_ready & chip->lun2card[lun]) == MS_CARD) {
./drivers/staging/rts5208/rtsx_card.c:1210:		chip->card_ejected |= MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:1211:		chip->card_ready &= ~MS_CARD;
./drivers/staging/rts5208/rtsx_card.c:1212:		chip->capacity[lun] = 0;
./drivers/staging/wlan-ng/prism2usb.c:92:	/* Do a chip-level reset on the MAC */
./drivers/staging/wlan-ng/prism2usb.c:255:	/* Do a chip-level reset on the MAC */
./drivers/staging/fbtft/flexfb.c:346:		width = chip->width;
./drivers/staging/fbtft/flexfb.c:348:		height = chip->height;
./drivers/staging/fbtft/flexfb.c:349:	setaddrwin = chip->setaddrwin;
./drivers/staging/fbtft/flexfb.c:350:	if (chip->regwidth)
./drivers/staging/fbtft/flexfb.c:351:		regwidth = chip->regwidth;
./drivers/staging/fbtft/flexfb.c:353:		initp = chip->init_seq;
./drivers/staging/fbtft/flexfb.c:354:		initp_num = chip->init_seq_sz;
./drivers/staging/fsl-mc/bus/mc-msi.c:130:	if (chip->irq_write_msi_msg == NULL)
./drivers/staging/fsl-mc/bus/mc-msi.c:131:		chip->irq_write_msi_msg = fsl_mc_msi_write_msg;
./drivers/staging/comedi/drivers/pcmuio.c:170:	spin_lock_irqsave(&chip->pagelock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:182:	spin_unlock_irqrestore(&chip->pagelock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:194:	spin_lock_irqsave(&chip->pagelock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:206:	spin_unlock_irqrestore(&chip->pagelock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:292:/* chip->spinlock is already locked */
./drivers/staging/comedi/drivers/pcmuio.c:300:	chip->enabled_mask = 0;
./drivers/staging/comedi/drivers/pcmuio.c:301:	chip->active = 0;
./drivers/staging/comedi/drivers/pcmuio.c:320:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:322:	if (!chip->active)
./drivers/staging/comedi/drivers/pcmuio.c:325:	if (!(triggered & chip->enabled_mask))
./drivers/staging/comedi/drivers/pcmuio.c:342:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:383:/* chip->spinlock is already locked */
./drivers/staging/comedi/drivers/pcmuio.c:395:	chip->enabled_mask = 0;
./drivers/staging/comedi/drivers/pcmuio.c:396:	chip->active = 1;
./drivers/staging/comedi/drivers/pcmuio.c:409:	chip->enabled_mask = bits;
./drivers/staging/comedi/drivers/pcmuio.c:423:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:424:	if (chip->active)
./drivers/staging/comedi/drivers/pcmuio.c:426:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:444:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:446:	if (chip->active)
./drivers/staging/comedi/drivers/pcmuio.c:449:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:465:	spin_lock_irqsave(&chip->spinlock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:466:	chip->active = 1;
./drivers/staging/comedi/drivers/pcmuio.c:474:	spin_unlock_irqrestore(&chip->spinlock, flags);
./drivers/staging/comedi/drivers/pcmuio.c:549:		spin_lock_init(&chip->pagelock);
./drivers/staging/comedi/drivers/pcmuio.c:550:		spin_lock_init(&chip->spinlock);
./drivers/char/tpm/tpm2-cmd.c:600:		dev_warn(chip->pdev, "0x%08x was not flushed, out of memory\n",
./drivers/char/tpm/tpm2-cmd.c:609:		dev_warn(chip->pdev, "0x%08x was not flushed, rc=%d\n", handle,
./drivers/char/tpm/tpm2-cmd.c:773:		dev_warn(chip->pdev, "transmit returned %d while stopping the TPM",
./drivers/char/tpm/tpm2-cmd.c:796:		duration = chip->vendor.duration[index];
./drivers/char/tpm/tpm2-cmd.c:840:		dev_warn(chip->pdev, "Got RC_TESTING, ignoring\n");
./drivers/char/tpm/tpm2-cmd.c:941:		chip->flags |= TPM_CHIP_FLAG_TPM2;
./drivers/char/tpm/tpm_tis.c:129:	unsigned long stop = jiffies + chip->vendor.timeout_a;
./drivers/char/tpm/tpm_tis.c:131:		if (ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &
./drivers/char/tpm/tpm_tis.c:141:	if ((ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &
./drivers/char/tpm/tpm_tis.c:144:		return chip->vendor.locality = l;
./drivers/char/tpm/tpm_tis.c:151:	if (force || (ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &
./drivers/char/tpm/tpm_tis.c:155:			 chip->vendor.iobase + TPM_ACCESS(l));
./drivers/char/tpm/tpm_tis.c:167:		 chip->vendor.iobase + TPM_ACCESS(l));
./drivers/char/tpm/tpm_tis.c:169:	stop = jiffies + chip->vendor.timeout_a;
./drivers/char/tpm/tpm_tis.c:171:	if (chip->vendor.irq) {
./drivers/char/tpm/tpm_tis.c:176:		rc = wait_event_interruptible_timeout(chip->vendor.int_queue,
./drivers/char/tpm/tpm_tis.c:200:	return ioread8(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:201:		       TPM_STS(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:208:		 chip->vendor.iobase + TPM_STS(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:218:	stop = jiffies + chip->vendor.timeout_d;
./drivers/char/tpm/tpm_tis.c:220:		burstcnt = ioread8(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:221:				   TPM_STS(chip->vendor.locality) + 1);
./drivers/char/tpm/tpm_tis.c:222:		burstcnt += ioread8(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:223:				    TPM_STS(chip->vendor.locality) +
./drivers/char/tpm/tpm_tis.c:238:				 chip->vendor.timeout_c,
./drivers/char/tpm/tpm_tis.c:239:				 &chip->vendor.read_queue, true)
./drivers/char/tpm/tpm_tis.c:243:			buf[size++] = ioread8(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:244:					      TPM_DATA_FIFO(chip->vendor.
./drivers/char/tpm/tpm_tis.c:263:		dev_err(chip->pdev, "Unable to read header\n");
./drivers/char/tpm/tpm_tis.c:276:		dev_err(chip->pdev, "Unable to read remainder of result\n");
./drivers/char/tpm/tpm_tis.c:281:	wait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,
./drivers/char/tpm/tpm_tis.c:282:			  &chip->vendor.int_queue, false);
./drivers/char/tpm/tpm_tis.c:285:		dev_err(chip->pdev, "Error left over data\n");
./drivers/char/tpm/tpm_tis.c:292:	release_locality(chip, chip->vendor.locality, 0);
./drivers/char/tpm/tpm_tis.c:317:		    (chip, TPM_STS_COMMAND_READY, chip->vendor.timeout_b,
./drivers/char/tpm/tpm_tis.c:318:		     &chip->vendor.int_queue, false) < 0) {
./drivers/char/tpm/tpm_tis.c:327:			iowrite8(buf[count], chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:328:				 TPM_DATA_FIFO(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:332:		wait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,
./drivers/char/tpm/tpm_tis.c:333:				  &chip->vendor.int_queue, false);
./drivers/char/tpm/tpm_tis.c:343:		 chip->vendor.iobase + TPM_DATA_FIFO(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:344:	wait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,
./drivers/char/tpm/tpm_tis.c:345:			  &chip->vendor.int_queue, false);
./drivers/char/tpm/tpm_tis.c:356:	release_locality(chip, chip->vendor.locality, 0);
./drivers/char/tpm/tpm_tis.c:365:	    ioread32(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:366:		     TPM_INT_ENABLE(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:369:		  chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:370:		  TPM_INT_ENABLE(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:371:	devm_free_irq(chip->pdev, chip->vendor.irq, chip);
./drivers/char/tpm/tpm_tis.c:372:	chip->vendor.irq = 0;
./drivers/char/tpm/tpm_tis.c:392:		 chip->vendor.iobase + TPM_STS(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:394:	if (chip->vendor.irq) {
./drivers/char/tpm/tpm_tis.c:397:		if (chip->flags & TPM_CHIP_FLAG_TPM2)
./drivers/char/tpm/tpm_tis.c:404:		     &chip->vendor.read_queue, false) < 0) {
./drivers/char/tpm/tpm_tis.c:412:	release_locality(chip, chip->vendor.locality, 0);
./drivers/char/tpm/tpm_tis.c:419:	struct priv_data *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_tis.c:421:	if (!chip->vendor.irq || priv->irq_tested)
./drivers/char/tpm/tpm_tis.c:425:	irq = chip->vendor.irq;
./drivers/char/tpm/tpm_tis.c:426:	chip->vendor.irq = 0;
./drivers/char/tpm/tpm_tis.c:428:	chip->vendor.irq = irq;
./drivers/char/tpm/tpm_tis.c:454:	did_vid = ioread32(chip->vendor.iobase + TPM_DID_VID(0));
./drivers/char/tpm/tpm_tis.c:481:	u16 vendor = ioread16(chip->vendor.iobase + TPM_DID_VID(0));
./drivers/char/tpm/tpm_tis.c:494:	release_locality(chip, chip->vendor.locality, 0);
./drivers/char/tpm/tpm_tis.c:500:		dev_info(chip->pdev, "Detected an iTPM.\n");
./drivers/char/tpm/tpm_tis.c:508:	release_locality(chip, chip->vendor.locality, 0);
./drivers/char/tpm/tpm_tis.c:515:	switch (chip->vendor.manufacturer_id) {
./drivers/char/tpm/tpm_tis.c:543:	interrupt = ioread32(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:544:			     TPM_INT_STATUS(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:549:	((struct priv_data *)chip->vendor.priv)->irq_tested = true;
./drivers/char/tpm/tpm_tis.c:551:		wake_up_interruptible(&chip->vendor.read_queue);
./drivers/char/tpm/tpm_tis.c:559:		wake_up_interruptible(&chip->vendor.int_queue);
./drivers/char/tpm/tpm_tis.c:563:		  chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:564:		  TPM_INT_STATUS(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:565:	ioread32(chip->vendor.iobase + TPM_INT_STATUS(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:576:	struct priv_data *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_tis.c:579:	if (devm_request_irq(chip->pdev, irq, tis_int_handler, flags,
./drivers/char/tpm/tpm_tis.c:580:			     chip->devname, chip) != 0) {
./drivers/char/tpm/tpm_tis.c:581:		dev_info(chip->pdev, "Unable to request irq: %d for probe\n",
./drivers/char/tpm/tpm_tis.c:585:	chip->vendor.irq = irq;
./drivers/char/tpm/tpm_tis.c:587:	original_int_vec = ioread8(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:588:				   TPM_INT_VECTOR(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:590:		 chip->vendor.iobase + TPM_INT_VECTOR(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:593:	iowrite32(ioread32(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:594:			   TPM_INT_STATUS(chip->vendor.locality)),
./drivers/char/tpm/tpm_tis.c:595:		  chip->vendor.iobase + TPM_INT_STATUS(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:599:		  chip->vendor.iobase + TPM_INT_ENABLE(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:606:	if (chip->flags & TPM_CHIP_FLAG_TPM2)
./drivers/char/tpm/tpm_tis.c:614:	if (!chip->vendor.irq) {
./drivers/char/tpm/tpm_tis.c:616:			 chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:617:			     TPM_INT_VECTOR(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:633:	original_int_vec = ioread8(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:634:				   TPM_INT_VECTOR(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:653:	if (chip->flags & TPM_CHIP_FLAG_TPM2)
./drivers/char/tpm/tpm_tis.c:657:		  ioread32(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:658:			   TPM_INT_ENABLE(chip->vendor.
./drivers/char/tpm/tpm_tis.c:660:		  chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:661:		  TPM_INT_ENABLE(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:662:	release_locality(chip, chip->vendor.locality, 1);
./drivers/char/tpm/tpm_tis.c:681:	chip->vendor.priv = priv;
./drivers/char/tpm/tpm_tis.c:683:	chip->acpi_dev_handle = acpi_dev_handle;
./drivers/char/tpm/tpm_tis.c:686:	chip->vendor.iobase = devm_ioremap_resource(dev, &tpm_info->res);
./drivers/char/tpm/tpm_tis.c:687:	if (IS_ERR(chip->vendor.iobase))
./drivers/char/tpm/tpm_tis.c:688:		return PTR_ERR(chip->vendor.iobase);
./drivers/char/tpm/tpm_tis.c:691:	chip->vendor.timeout_a = TIS_TIMEOUT_A_MAX;
./drivers/char/tpm/tpm_tis.c:692:	chip->vendor.timeout_b = TIS_TIMEOUT_B_MAX;
./drivers/char/tpm/tpm_tis.c:693:	chip->vendor.timeout_c = TIS_TIMEOUT_C_MAX;
./drivers/char/tpm/tpm_tis.c:694:	chip->vendor.timeout_d = TIS_TIMEOUT_D_MAX;
./drivers/char/tpm/tpm_tis.c:702:	intmask = ioread32(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:703:			   TPM_INT_ENABLE(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:708:		  chip->vendor.iobase + TPM_INT_ENABLE(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:719:	vendor = ioread32(chip->vendor.iobase + TPM_DID_VID(0));
./drivers/char/tpm/tpm_tis.c:720:	chip->vendor.manufacturer_id = vendor;
./drivers/char/tpm/tpm_tis.c:723:		 (chip->flags & TPM_CHIP_FLAG_TPM2) ? "2.0" : "1.2",
./drivers/char/tpm/tpm_tis.c:724:		 vendor >> 16, ioread8(chip->vendor.iobase + TPM_RID(0)));
./drivers/char/tpm/tpm_tis.c:741:	    ioread32(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:742:		     TPM_INTF_CAPS(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:775:	init_waitqueue_head(&chip->vendor.read_queue);
./drivers/char/tpm/tpm_tis.c:776:	init_waitqueue_head(&chip->vendor.int_queue);
./drivers/char/tpm/tpm_tis.c:781:			if (!chip->vendor.irq)
./drivers/char/tpm/tpm_tis.c:782:				dev_err(chip->pdev, FW_BUG
./drivers/char/tpm/tpm_tis.c:788:	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
./drivers/char/tpm/tpm_tis.c:824:	iowrite8(chip->vendor.irq, chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:825:		 TPM_INT_VECTOR(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:828:	    ioread32(chip->vendor.iobase +
./drivers/char/tpm/tpm_tis.c:829:		     TPM_INT_ENABLE(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:836:		  chip->vendor.iobase + TPM_INT_ENABLE(chip->vendor.locality));
./drivers/char/tpm/tpm_tis.c:844:	if (chip->vendor.irq)
./drivers/char/tpm/tpm_tis.c:854:	if (!(chip->flags & TPM_CHIP_FLAG_TPM2))
./drivers/char/tpm/st33zp24/st33zp24.c:147:		return chip->vendor.locality;
./drivers/char/tpm/st33zp24/st33zp24.c:164:	if (check_locality(chip) == chip->vendor.locality)
./drivers/char/tpm/st33zp24/st33zp24.c:165:		return chip->vendor.locality;
./drivers/char/tpm/st33zp24/st33zp24.c:174:	stop = jiffies + chip->vendor.timeout_a;
./drivers/char/tpm/st33zp24/st33zp24.c:179:			return chip->vendor.locality;
./drivers/char/tpm/st33zp24/st33zp24.c:216:	stop = jiffies + chip->vendor.timeout_d;
./drivers/char/tpm/st33zp24/st33zp24.c:250:	u8 status = chip->ops->status(chip);
./drivers/char/tpm/st33zp24/st33zp24.c:255:	if (check_cancel && chip->ops->req_canceled(chip, status)) {
./drivers/char/tpm/st33zp24/st33zp24.c:291:	if (chip->vendor.irq) {
./drivers/char/tpm/st33zp24/st33zp24.c:294:		enable_irq(chip->vendor.irq);
./drivers/char/tpm/st33zp24/st33zp24.c:317:		disable_irq_nosync(chip->vendor.irq);
./drivers/char/tpm/st33zp24/st33zp24.c:322:			status = chip->ops->status(chip);
./drivers/char/tpm/st33zp24/st33zp24.c:348:			     chip->vendor.timeout_c,
./drivers/char/tpm/st33zp24/st33zp24.c:349:			     &chip->vendor.read_queue, true) == 0) {
./drivers/char/tpm/st33zp24/st33zp24.c:378:	wake_up_interruptible(&chip->vendor.read_queue);
./drivers/char/tpm/st33zp24/st33zp24.c:379:	disable_irq_nosync(chip->vendor.irq);
./drivers/char/tpm/st33zp24/st33zp24.c:417:		    (chip, TPM_STS_COMMAND_READY, chip->vendor.timeout_b,
./drivers/char/tpm/st33zp24/st33zp24.c:418:		     &chip->vendor.read_queue, false) < 0) {
./drivers/char/tpm/st33zp24/st33zp24.c:459:	if (chip->vendor.irq) {
./drivers/char/tpm/st33zp24/st33zp24.c:464:				&chip->vendor.read_queue, false);
./drivers/char/tpm/st33zp24/st33zp24.c:500:		dev_err(&chip->dev, "Unable to read header\n");
./drivers/char/tpm/st33zp24/st33zp24.c:513:		dev_err(&chip->dev, "Unable to read remainder of result\n");
./drivers/char/tpm/st33zp24/st33zp24.c:572:	chip->vendor.timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);
./drivers/char/tpm/st33zp24/st33zp24.c:573:	chip->vendor.timeout_b = msecs_to_jiffies(TIS_LONG_TIMEOUT);
./drivers/char/tpm/st33zp24/st33zp24.c:574:	chip->vendor.timeout_c = msecs_to_jiffies(TIS_SHORT_TIMEOUT);
./drivers/char/tpm/st33zp24/st33zp24.c:575:	chip->vendor.timeout_d = msecs_to_jiffies(TIS_SHORT_TIMEOUT);
./drivers/char/tpm/st33zp24/st33zp24.c:577:	chip->vendor.locality = LOCALITY0;
./drivers/char/tpm/st33zp24/st33zp24.c:581:		init_waitqueue_head(&chip->vendor.read_queue);
./drivers/char/tpm/st33zp24/st33zp24.c:594:			dev_err(&chip->dev, "TPM SERIRQ signals %d not available\n",
./drivers/char/tpm/st33zp24/st33zp24.c:614:		chip->vendor.irq = irq;
./drivers/char/tpm/st33zp24/st33zp24.c:616:		disable_irq_nosync(chip->vendor.irq);
./drivers/char/tpm/st33zp24/st33zp24.c:626:	dev_info(&chip->dev, "TPM initialization fail\n");
./drivers/char/tpm/st33zp24/st33zp24.c:683:				TPM_STS_VALID, chip->vendor.timeout_b,
./drivers/char/tpm/st33zp24/st33zp24.c:684:				&chip->vendor.read_queue, false);
./drivers/char/tpm/tpm_i2c_atmel.c:54:	struct priv_data *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_i2c_atmel.c:55:	struct i2c_client *client = to_i2c_client(chip->pdev);
./drivers/char/tpm/tpm_i2c_atmel.c:65:	dev_dbg(chip->pdev,
./drivers/char/tpm/tpm_i2c_atmel.c:73:	struct priv_data *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_i2c_atmel.c:74:	struct i2c_client *client = to_i2c_client(chip->pdev);
./drivers/char/tpm/tpm_i2c_atmel.c:91:		dev_dbg(chip->pdev,
./drivers/char/tpm/tpm_i2c_atmel.c:100:	dev_dbg(chip->pdev,
./drivers/char/tpm/tpm_i2c_atmel.c:109:	dev_err(chip->pdev, "TPM operation cancellation was requested, but is not supported");
./drivers/char/tpm/tpm_i2c_atmel.c:114:	struct priv_data *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_i2c_atmel.c:115:	struct i2c_client *client = to_i2c_client(chip->pdev);
./drivers/char/tpm/tpm_i2c_atmel.c:128:	dev_dbg(chip->pdev,
./drivers/char/tpm/tpm_i2c_atmel.c:166:	chip->vendor.priv = devm_kzalloc(dev, sizeof(struct priv_data),
./drivers/char/tpm/tpm_i2c_atmel.c:168:	if (!chip->vendor.priv)
./drivers/char/tpm/tpm_i2c_atmel.c:172:	chip->vendor.timeout_a = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);
./drivers/char/tpm/tpm_i2c_atmel.c:173:	chip->vendor.timeout_b = msecs_to_jiffies(TPM_I2C_LONG_TIMEOUT);
./drivers/char/tpm/tpm_i2c_atmel.c:174:	chip->vendor.timeout_c = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);
./drivers/char/tpm/tpm_i2c_atmel.c:175:	chip->vendor.timeout_d = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);
./drivers/char/tpm/tpm_i2c_atmel.c:176:	chip->vendor.irq = 0;
./drivers/char/tpm/tpm_nsc.c:75:	*data = inb(chip->vendor.base + NSC_STATUS);
./drivers/char/tpm/tpm_nsc.c:83:		*data = inb(chip->vendor.base + 1);
./drivers/char/tpm/tpm_nsc.c:98:	status = inb(chip->vendor.base + NSC_STATUS);
./drivers/char/tpm/tpm_nsc.c:100:		status = inb(chip->vendor.base + NSC_DATA);
./drivers/char/tpm/tpm_nsc.c:108:		status = inb(chip->vendor.base + NSC_STATUS);
./drivers/char/tpm/tpm_nsc.c:110:			status = inb(chip->vendor.base + NSC_DATA);
./drivers/char/tpm/tpm_nsc.c:116:	dev_info(chip->pdev, "wait for ready failed\n");
./drivers/char/tpm/tpm_nsc.c:132:		dev_err(chip->pdev, "F0 timeout\n");
./drivers/char/tpm/tpm_nsc.c:136:	     inb(chip->vendor.base + NSC_DATA)) != NSC_COMMAND_NORMAL) {
./drivers/char/tpm/tpm_nsc.c:137:		dev_err(chip->pdev, "not in normal mode (0x%x)\n",
./drivers/char/tpm/tpm_nsc.c:146:			dev_err(chip->pdev,
./drivers/char/tpm/tpm_nsc.c:152:		*p = inb(chip->vendor.base + NSC_DATA);
./drivers/char/tpm/tpm_nsc.c:157:		dev_err(chip->pdev, "F0 not set\n");
./drivers/char/tpm/tpm_nsc.c:160:	if ((data = inb(chip->vendor.base + NSC_DATA)) != NSC_COMMAND_EOC) {
./drivers/char/tpm/tpm_nsc.c:161:		dev_err(chip->pdev,
./drivers/char/tpm/tpm_nsc.c:186:	outb(NSC_COMMAND_CANCEL, chip->vendor.base + NSC_COMMAND);
./drivers/char/tpm/tpm_nsc.c:192:		dev_err(chip->pdev, "IBF timeout\n");
./drivers/char/tpm/tpm_nsc.c:196:	outb(NSC_COMMAND_NORMAL, chip->vendor.base + NSC_COMMAND);
./drivers/char/tpm/tpm_nsc.c:198:		dev_err(chip->pdev, "IBR timeout\n");
./drivers/char/tpm/tpm_nsc.c:204:			dev_err(chip->pdev,
./drivers/char/tpm/tpm_nsc.c:208:		outb(buf[i], chip->vendor.base + NSC_DATA);
./drivers/char/tpm/tpm_nsc.c:212:		dev_err(chip->pdev, "IBF timeout\n");
./drivers/char/tpm/tpm_nsc.c:215:	outb(NSC_COMMAND_EOC, chip->vendor.base + NSC_COMMAND);
./drivers/char/tpm/tpm_nsc.c:222:	outb(NSC_COMMAND_CANCEL, chip->vendor.base + NSC_COMMAND);
./drivers/char/tpm/tpm_nsc.c:227:	return inb(chip->vendor.base + NSC_STATUS);
./drivers/char/tpm/tpm_nsc.c:252:	release_region(chip->vendor.base, 2);
./drivers/char/tpm/tpm_nsc.c:352:	chip->vendor.base = base;
./drivers/char/tpm/tpm_infineon.c:198:			dev_err(chip->pdev, "Timeout in wait(STAT_XFE)\n");
./drivers/char/tpm/tpm_infineon.c:200:			dev_err(chip->pdev, "Timeout in wait(STAT_RDA)\n");
./drivers/char/tpm/tpm_infineon.c:223:	dev_info(chip->pdev, "Granting WTX (%02d / %02d)\n",
./drivers/char/tpm/tpm_infineon.c:234:	dev_info(chip->pdev, "Aborting WTX\n");
./drivers/char/tpm/tpm_infineon.c:260:		dev_err(chip->pdev,
./drivers/char/tpm/tpm_infineon.c:275:			dev_err(chip->pdev, "Error handling on vendor layer!\n");
./drivers/char/tpm/tpm_infineon.c:287:		dev_info(chip->pdev, "WTX-package received\n");
./drivers/char/tpm/tpm_infineon.c:298:		dev_info(chip->pdev, "WTX-abort acknowledged\n");
./drivers/char/tpm/tpm_infineon.c:303:		dev_err(chip->pdev, "ERROR-package received:\n");
./drivers/char/tpm/tpm_infineon.c:305:			dev_err(chip->pdev,
./drivers/char/tpm/tpm_infineon.c:324:		dev_err(chip->pdev, "Timeout while clearing FIFO\n");
./drivers/char/tpm/tpm-dev.c:63:	if (test_and_set_bit(0, &chip->is_open)) {
./drivers/char/tpm/tpm-dev.c:64:		dev_dbg(chip->pdev, "Another process owns this TPM\n");
./drivers/char/tpm/tpm-dev.c:70:		clear_bit(0, &chip->is_open);
./drivers/char/tpm/tpm-dev.c:82:	get_device(chip->pdev);
./drivers/char/tpm/tpm-dev.c:168:	clear_bit(0, &priv->chip->is_open);
./drivers/char/tpm/tpm-dev.c:169:	put_device(priv->chip->pdev);
./drivers/char/tpm/tpm_atmel.c:50:		status = ioread8(chip->vendor.iobase + 1);
./drivers/char/tpm/tpm_atmel.c:52:			dev_err(chip->pdev, "error reading header\n");
./drivers/char/tpm/tpm_atmel.c:55:		*buf++ = ioread8(chip->vendor.iobase);
./drivers/char/tpm/tpm_atmel.c:63:		dev_err(chip->pdev,
./drivers/char/tpm/tpm_atmel.c:66:			status = ioread8(chip->vendor.iobase + 1);
./drivers/char/tpm/tpm_atmel.c:68:				dev_err(chip->pdev, "error reading data\n");
./drivers/char/tpm/tpm_atmel.c:77:		status = ioread8(chip->vendor.iobase + 1);
./drivers/char/tpm/tpm_atmel.c:79:			dev_err(chip->pdev, "error reading data\n");
./drivers/char/tpm/tpm_atmel.c:82:		*buf++ = ioread8(chip->vendor.iobase);
./drivers/char/tpm/tpm_atmel.c:86:	status = ioread8(chip->vendor.iobase + 1);
./drivers/char/tpm/tpm_atmel.c:89:		dev_err(chip->pdev, "data available is stuck\n");
./drivers/char/tpm/tpm_atmel.c:100:	dev_dbg(chip->pdev, "tpm_atml_send:\n");
./drivers/char/tpm/tpm_atmel.c:102:		dev_dbg(chip->pdev, "%d 0x%x(%d)\n",  i, buf[i], buf[i]);
./drivers/char/tpm/tpm_atmel.c:103: 		iowrite8(buf[i], chip->vendor.iobase);
./drivers/char/tpm/tpm_atmel.c:111:	iowrite8(ATML_STATUS_ABORT, chip->vendor.iobase + 1);
./drivers/char/tpm/tpm_atmel.c:116:	return ioread8(chip->vendor.iobase + 1);
./drivers/char/tpm/tpm_atmel.c:142:		if (chip->vendor.have_region)
./drivers/char/tpm/tpm_atmel.c:143:			atmel_release_region(chip->vendor.base,
./drivers/char/tpm/tpm_atmel.c:144:					     chip->vendor.region_size);
./drivers/char/tpm/tpm_atmel.c:145:		atmel_put_base_addr(chip->vendor.iobase);
./drivers/char/tpm/tpm_atmel.c:192:	chip->vendor.iobase = iobase;
./drivers/char/tpm/tpm_atmel.c:193:	chip->vendor.base = base;
./drivers/char/tpm/tpm_atmel.c:194:	chip->vendor.have_region = have_region;
./drivers/char/tpm/tpm_atmel.c:195:	chip->vendor.region_size = region_size;
./drivers/char/tpm/tpm_i2c_nuvoton.c:99:	struct i2c_client *client = to_i2c_client(chip->pdev);
./drivers/char/tpm/tpm_i2c_nuvoton.c:105:		dev_err(chip->pdev, "%s() error return %d\n", __func__,
./drivers/char/tpm/tpm_i2c_nuvoton.c:130:	struct i2c_client *client = to_i2c_client(chip->pdev);
./drivers/char/tpm/tpm_i2c_nuvoton.c:136:		dev_err(chip->pdev,
./drivers/char/tpm/tpm_i2c_nuvoton.c:145:	unsigned long stop = jiffies + chip->vendor.timeout_d;
./drivers/char/tpm/tpm_i2c_nuvoton.c:179:	if (chip->vendor.irq && queue) {
./drivers/char/tpm/tpm_i2c_nuvoton.c:181:		struct priv_data *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_i2c_nuvoton.c:184:		enable_irq(chip->vendor.irq);
./drivers/char/tpm/tpm_i2c_nuvoton.c:215:	dev_err(chip->pdev, "%s(%02x, %02x) -> timeout\n", __func__, mask,
./drivers/char/tpm/tpm_i2c_nuvoton.c:239:					       chip->vendor.timeout_c,
./drivers/char/tpm/tpm_i2c_nuvoton.c:240:					       &chip->vendor.read_queue) == 0) {
./drivers/char/tpm/tpm_i2c_nuvoton.c:243:			dev_err(chip->pdev,
./drivers/char/tpm/tpm_i2c_nuvoton.c:252:			dev_err(chip->pdev,
./drivers/char/tpm/tpm_i2c_nuvoton.c:257:		dev_dbg(chip->pdev, "%s(%d):", __func__, bytes2read);
./drivers/char/tpm/tpm_i2c_nuvoton.c:267:	struct device *dev = chip->pdev;
./drivers/char/tpm/tpm_i2c_nuvoton.c:288:			chip, chip->vendor.timeout_c, &chip->vendor.read_queue);
./drivers/char/tpm/tpm_i2c_nuvoton.c:328:			    TPM_STS_VALID, chip->vendor.timeout_c,
./drivers/char/tpm/tpm_i2c_nuvoton.c:337:	dev_dbg(chip->pdev, "%s() -> %d\n", __func__, size);
./drivers/char/tpm/tpm_i2c_nuvoton.c:350:	struct device *dev = chip->pdev;
./drivers/char/tpm/tpm_i2c_nuvoton.c:360:					      chip->vendor.timeout_b, NULL)) {
./drivers/char/tpm/tpm_i2c_nuvoton.c:392:						       chip->vendor.timeout_c,
./drivers/char/tpm/tpm_i2c_nuvoton.c:417:					       chip->vendor.timeout_c, NULL);
./drivers/char/tpm/tpm_i2c_nuvoton.c:442:					     &chip->vendor.read_queue);
./drivers/char/tpm/tpm_i2c_nuvoton.c:476:	struct priv_data *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_i2c_nuvoton.c:479:	wake_up(&chip->vendor.read_queue);
./drivers/char/tpm/tpm_i2c_nuvoton.c:480:	disable_irq_nosync(chip->vendor.irq);
./drivers/char/tpm/tpm_i2c_nuvoton.c:537:	chip->vendor.priv = devm_kzalloc(dev, sizeof(struct priv_data),
./drivers/char/tpm/tpm_i2c_nuvoton.c:539:	if (!chip->vendor.priv)
./drivers/char/tpm/tpm_i2c_nuvoton.c:542:	init_waitqueue_head(&chip->vendor.read_queue);
./drivers/char/tpm/tpm_i2c_nuvoton.c:543:	init_waitqueue_head(&chip->vendor.int_queue);
./drivers/char/tpm/tpm_i2c_nuvoton.c:546:	chip->vendor.timeout_a = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);
./drivers/char/tpm/tpm_i2c_nuvoton.c:547:	chip->vendor.timeout_b = msecs_to_jiffies(TPM_I2C_LONG_TIMEOUT);
./drivers/char/tpm/tpm_i2c_nuvoton.c:548:	chip->vendor.timeout_c = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);
./drivers/char/tpm/tpm_i2c_nuvoton.c:549:	chip->vendor.timeout_d = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);
./drivers/char/tpm/tpm_i2c_nuvoton.c:556:	chip->vendor.irq = client->irq;
./drivers/char/tpm/tpm_i2c_nuvoton.c:558:	if (chip->vendor.irq) {
./drivers/char/tpm/tpm_i2c_nuvoton.c:559:		dev_dbg(dev, "%s() chip-vendor.irq\n", __func__);
./drivers/char/tpm/tpm_i2c_nuvoton.c:560:		rc = devm_request_irq(dev, chip->vendor.irq,
./drivers/char/tpm/tpm_i2c_nuvoton.c:563:				      chip->devname,
./drivers/char/tpm/tpm_i2c_nuvoton.c:567:				__func__, chip->vendor.irq);
./drivers/char/tpm/tpm_i2c_nuvoton.c:568:			chip->vendor.irq = 0;
./drivers/char/tpm/tpm_i2c_nuvoton.c:576:						       chip->vendor.timeout_b,
./drivers/char/tpm/tpm-interface.c:322:		duration = chip->vendor.duration[duration_idx];
./drivers/char/tpm/tpm-interface.c:348:		dev_err(chip->pdev,
./drivers/char/tpm/tpm-interface.c:353:	mutex_lock(&chip->tpm_mutex);
./drivers/char/tpm/tpm-interface.c:355:	rc = chip->ops->send(chip, (u8 *) buf, count);
./drivers/char/tpm/tpm-interface.c:357:		dev_err(chip->pdev,
./drivers/char/tpm/tpm-interface.c:362:	if (chip->vendor.irq)
./drivers/char/tpm/tpm-interface.c:365:	if (chip->flags & TPM_CHIP_FLAG_TPM2)
./drivers/char/tpm/tpm-interface.c:370:		u8 status = chip->ops->status(chip);
./drivers/char/tpm/tpm-interface.c:371:		if ((status & chip->ops->req_complete_mask) ==
./drivers/char/tpm/tpm-interface.c:372:		    chip->ops->req_complete_val)
./drivers/char/tpm/tpm-interface.c:375:		if (chip->ops->req_canceled(chip, status)) {
./drivers/char/tpm/tpm-interface.c:376:			dev_err(chip->pdev, "Operation Canceled\n");
./drivers/char/tpm/tpm-interface.c:385:	chip->ops->cancel(chip);
./drivers/char/tpm/tpm-interface.c:386:	dev_err(chip->pdev, "Operation Timed out\n");
./drivers/char/tpm/tpm-interface.c:391:	rc = chip->ops->recv(chip, (u8 *) buf, bufsiz);
./drivers/char/tpm/tpm-interface.c:393:		dev_err(chip->pdev,
./drivers/char/tpm/tpm-interface.c:396:	mutex_unlock(&chip->tpm_mutex);
./drivers/char/tpm/tpm-interface.c:419:		dev_err(chip->pdev, "A TPM error (%d) occurred %s\n", err,
./drivers/char/tpm/tpm-interface.c:506:	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
./drivers/char/tpm/tpm-interface.c:508:		chip->vendor.timeout_a = msecs_to_jiffies(TPM2_TIMEOUT_A);
./drivers/char/tpm/tpm-interface.c:509:		chip->vendor.timeout_b = msecs_to_jiffies(TPM2_TIMEOUT_B);
./drivers/char/tpm/tpm-interface.c:510:		chip->vendor.timeout_c = msecs_to_jiffies(TPM2_TIMEOUT_C);
./drivers/char/tpm/tpm-interface.c:511:		chip->vendor.timeout_d = msecs_to_jiffies(TPM2_TIMEOUT_D);
./drivers/char/tpm/tpm-interface.c:512:		chip->vendor.duration[TPM_SHORT] =
./drivers/char/tpm/tpm-interface.c:514:		chip->vendor.duration[TPM_MEDIUM] =
./drivers/char/tpm/tpm-interface.c:516:		chip->vendor.duration[TPM_LONG] =
./drivers/char/tpm/tpm-interface.c:530:		dev_info(chip->pdev, "Issuing TPM_STARTUP");
./drivers/char/tpm/tpm-interface.c:542:		dev_err(chip->pdev,
./drivers/char/tpm/tpm-interface.c:563:	if (chip->ops->update_timeouts != NULL)
./drivers/char/tpm/tpm-interface.c:564:		chip->vendor.timeout_adjusted =
./drivers/char/tpm/tpm-interface.c:565:			chip->ops->update_timeouts(chip, new_timeout);
./drivers/char/tpm/tpm-interface.c:567:	if (!chip->vendor.timeout_adjusted) {
./drivers/char/tpm/tpm-interface.c:575:			chip->vendor.timeout_adjusted = true;
./drivers/char/tpm/tpm-interface.c:580:	if (chip->vendor.timeout_adjusted) {
./drivers/char/tpm/tpm-interface.c:581:		dev_info(chip->pdev,
./drivers/char/tpm/tpm-interface.c:589:	chip->vendor.timeout_a = usecs_to_jiffies(new_timeout[0]);
./drivers/char/tpm/tpm-interface.c:590:	chip->vendor.timeout_b = usecs_to_jiffies(new_timeout[1]);
./drivers/char/tpm/tpm-interface.c:591:	chip->vendor.timeout_c = usecs_to_jiffies(new_timeout[2]);
./drivers/char/tpm/tpm-interface.c:592:	chip->vendor.timeout_d = usecs_to_jiffies(new_timeout[3]);
./drivers/char/tpm/tpm-interface.c:611:	chip->vendor.duration[TPM_SHORT] =
./drivers/char/tpm/tpm-interface.c:613:	chip->vendor.duration[TPM_MEDIUM] =
./drivers/char/tpm/tpm-interface.c:615:	chip->vendor.duration[TPM_LONG] =
./drivers/char/tpm/tpm-interface.c:623:	if (chip->vendor.duration[TPM_SHORT] < (HZ / 100)) {
./drivers/char/tpm/tpm-interface.c:624:		chip->vendor.duration[TPM_SHORT] = HZ;
./drivers/char/tpm/tpm-interface.c:625:		chip->vendor.duration[TPM_MEDIUM] *= 1000;
./drivers/char/tpm/tpm-interface.c:626:		chip->vendor.duration[TPM_LONG] *= 1000;
./drivers/char/tpm/tpm-interface.c:627:		chip->vendor.duration_adjusted = true;
./drivers/char/tpm/tpm-interface.c:628:		dev_info(chip->pdev, "Adjusting TPM timeout parameters.");
./drivers/char/tpm/tpm-interface.c:701:	rc = (chip->flags & TPM_CHIP_FLAG_TPM2) != 0;
./drivers/char/tpm/tpm-interface.c:728:	if (chip->flags & TPM_CHIP_FLAG_TPM2)
./drivers/char/tpm/tpm-interface.c:765:	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
./drivers/char/tpm/tpm-interface.c:818:			dev_info(chip->pdev, HW_ERR "TPM command timed out during continue self test");
./drivers/char/tpm/tpm-interface.c:828:			dev_info(chip->pdev,
./drivers/char/tpm/tpm-interface.c:864:	u8 status = chip->ops->status(chip);
./drivers/char/tpm/tpm-interface.c:869:	if (check_cancel && chip->ops->req_canceled(chip, status)) {
./drivers/char/tpm/tpm-interface.c:885:	status = chip->ops->status(chip);
./drivers/char/tpm/tpm-interface.c:891:	if (chip->vendor.irq) {
./drivers/char/tpm/tpm-interface.c:912:			status = chip->ops->status(chip);
./drivers/char/tpm/tpm-interface.c:945:	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
./drivers/char/tpm/tpm-interface.c:981:		dev_err(chip->pdev,
./drivers/char/tpm/tpm-interface.c:984:		dev_warn(chip->pdev, "TPM savestate took %dms\n",
./drivers/char/tpm/tpm-interface.c:1036:	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
./drivers/char/tpm/tpm-interface.c:1081:	if (chip == NULL || !(chip->flags & TPM_CHIP_FLAG_TPM2))
./drivers/char/tpm/tpm-interface.c:1107:	if (chip == NULL || !(chip->flags & TPM_CHIP_FLAG_TPM2))
./drivers/char/tpm/tpm-sysfs.c:229:	chip->ops->cancel(chip);
./drivers/char/tpm/tpm-sysfs.c:239:	if (chip->vendor.duration[TPM_LONG] == 0)
./drivers/char/tpm/tpm-sysfs.c:243:		       jiffies_to_usecs(chip->vendor.duration[TPM_SHORT]),
./drivers/char/tpm/tpm-sysfs.c:244:		       jiffies_to_usecs(chip->vendor.duration[TPM_MEDIUM]),
./drivers/char/tpm/tpm-sysfs.c:245:		       jiffies_to_usecs(chip->vendor.duration[TPM_LONG]),
./drivers/char/tpm/tpm-sysfs.c:246:		       chip->vendor.duration_adjusted
./drivers/char/tpm/tpm-sysfs.c:257:		       jiffies_to_usecs(chip->vendor.timeout_a),
./drivers/char/tpm/tpm-sysfs.c:258:		       jiffies_to_usecs(chip->vendor.timeout_b),
./drivers/char/tpm/tpm-sysfs.c:259:		       jiffies_to_usecs(chip->vendor.timeout_c),
./drivers/char/tpm/tpm-sysfs.c:260:		       jiffies_to_usecs(chip->vendor.timeout_d),
./drivers/char/tpm/tpm-sysfs.c:261:		       chip->vendor.timeout_adjusted
./drivers/char/tpm/tpm-sysfs.c:287:	err = sysfs_create_group(&chip->pdev->kobj,
./drivers/char/tpm/tpm-sysfs.c:291:		dev_err(chip->pdev,
./drivers/char/tpm/tpm-sysfs.c:298:	sysfs_remove_group(&chip->pdev->kobj, &tpm_dev_group);
./drivers/char/tpm/tpm-chip.c:72:	clear_bit(chip->dev_num, dev_mask);
./drivers/char/tpm/tpm-chip.c:97:	mutex_init(&chip->tpm_mutex);
./drivers/char/tpm/tpm-chip.c:98:	INIT_LIST_HEAD(&chip->list);
./drivers/char/tpm/tpm-chip.c:100:	chip->ops = ops;
./drivers/char/tpm/tpm-chip.c:103:	chip->dev_num = find_first_zero_bit(dev_mask, TPM_NUM_DEVICES);
./drivers/char/tpm/tpm-chip.c:106:	if (chip->dev_num >= TPM_NUM_DEVICES) {
./drivers/char/tpm/tpm-chip.c:112:	set_bit(chip->dev_num, dev_mask);
./drivers/char/tpm/tpm-chip.c:114:	scnprintf(chip->devname, sizeof(chip->devname), "tpm%d", chip->dev_num);
./drivers/char/tpm/tpm-chip.c:116:	chip->pdev = dev;
./drivers/char/tpm/tpm-chip.c:120:	chip->dev.class = tpm_class;
./drivers/char/tpm/tpm-chip.c:121:	chip->dev.release = tpm_dev_release;
./drivers/char/tpm/tpm-chip.c:122:	chip->dev.parent = chip->pdev;
./drivers/char/tpm/tpm-chip.c:124:	chip->dev.groups = chip->groups;
./drivers/char/tpm/tpm-chip.c:127:	if (chip->dev_num == 0)
./drivers/char/tpm/tpm-chip.c:128:		chip->dev.devt = MKDEV(MISC_MAJOR, TPM_MINOR);
./drivers/char/tpm/tpm-chip.c:130:		chip->dev.devt = MKDEV(MAJOR(tpm_devt), chip->dev_num);
./drivers/char/tpm/tpm-chip.c:132:	dev_set_name(&chip->dev, "%s", chip->devname);
./drivers/char/tpm/tpm-chip.c:134:	device_initialize(&chip->dev);
./drivers/char/tpm/tpm-chip.c:136:	cdev_init(&chip->cdev, &tpm_fops);
./drivers/char/tpm/tpm-chip.c:137:	chip->cdev.owner = chip->pdev->driver->owner;
./drivers/char/tpm/tpm-chip.c:138:	chip->cdev.kobj.parent = &chip->dev.kobj;
./drivers/char/tpm/tpm-chip.c:140:	rc = devm_add_action(dev, (void (*)(void *)) put_device, &chip->dev);
./drivers/char/tpm/tpm-chip.c:142:		put_device(&chip->dev);
./drivers/char/tpm/tpm-chip.c:154:	rc = cdev_add(&chip->cdev, chip->dev.devt, 1);
./drivers/char/tpm/tpm-chip.c:156:		dev_err(&chip->dev,
./drivers/char/tpm/tpm-chip.c:158:			chip->devname, MAJOR(chip->dev.devt),
./drivers/char/tpm/tpm-chip.c:159:			MINOR(chip->dev.devt), rc);
./drivers/char/tpm/tpm-chip.c:164:	rc = device_add(&chip->dev);
./drivers/char/tpm/tpm-chip.c:166:		dev_err(&chip->dev,
./drivers/char/tpm/tpm-chip.c:168:			chip->devname, MAJOR(chip->dev.devt),
./drivers/char/tpm/tpm-chip.c:169:			MINOR(chip->dev.devt), rc);
./drivers/char/tpm/tpm-chip.c:171:		cdev_del(&chip->cdev);
./drivers/char/tpm/tpm-chip.c:180:	cdev_del(&chip->cdev);
./drivers/char/tpm/tpm-chip.c:181:	device_del(&chip->dev);
./drivers/char/tpm/tpm-chip.c:188:	if (chip->flags & TPM_CHIP_FLAG_TPM2)
./drivers/char/tpm/tpm-chip.c:195:	chip->bios_dir = tpm_bios_log_setup(chip->devname);
./drivers/char/tpm/tpm-chip.c:202:	if (chip->flags & TPM_CHIP_FLAG_TPM2)
./drivers/char/tpm/tpm-chip.c:205:	if (chip->bios_dir)
./drivers/char/tpm/tpm-chip.c:206:		tpm_bios_log_teardown(chip->bios_dir);
./drivers/char/tpm/tpm-chip.c:238:	list_add_tail_rcu(&chip->list, &tpm_chip_list);
./drivers/char/tpm/tpm-chip.c:241:	chip->flags |= TPM_CHIP_FLAG_REGISTERED;
./drivers/char/tpm/tpm-chip.c:243:	if (!(chip->flags & TPM_CHIP_FLAG_TPM2)) {
./drivers/char/tpm/tpm-chip.c:244:		rc = __compat_only_sysfs_link_entry_to_kobj(&chip->pdev->kobj,
./drivers/char/tpm/tpm-chip.c:245:							    &chip->dev.kobj,
./drivers/char/tpm/tpm-chip.c:272:	if (!(chip->flags & TPM_CHIP_FLAG_REGISTERED))
./drivers/char/tpm/tpm-chip.c:276:	list_del_rcu(&chip->list);
./drivers/char/tpm/tpm-chip.c:280:	if (!(chip->flags & TPM_CHIP_FLAG_TPM2))
./drivers/char/tpm/tpm-chip.c:281:		sysfs_remove_link(&chip->pdev->kobj, "ppi");
./drivers/char/tpm/tpm_i2c_infineon.c:291:		chip->vendor.locality = loc;
./drivers/char/tpm/tpm_i2c_infineon.c:323:	stop = jiffies + chip->vendor.timeout_a;
./drivers/char/tpm/tpm_i2c_infineon.c:340:		if (iic_tpm_read(TPM_STS(chip->vendor.locality), &buf, 1) < 0)
./drivers/char/tpm/tpm_i2c_infineon.c:354:	iic_tpm_write_long(TPM_STS(chip->vendor.locality), &buf, 1);
./drivers/char/tpm/tpm_i2c_infineon.c:365:	stop = jiffies + chip->vendor.timeout_d;
./drivers/char/tpm/tpm_i2c_infineon.c:368:		if (iic_tpm_read(TPM_STS(chip->vendor.locality)+1, buf, 3) < 0)
./drivers/char/tpm/tpm_i2c_infineon.c:422:		rc = iic_tpm_read(TPM_DATA_FIFO(chip->vendor.locality),
./drivers/char/tpm/tpm_i2c_infineon.c:449:		dev_err(chip->pdev, "Unable to read header\n");
./drivers/char/tpm/tpm_i2c_infineon.c:462:		dev_err(chip->pdev, "Unable to read remainder of result\n");
./drivers/char/tpm/tpm_i2c_infineon.c:467:	wait_for_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c, &status);
./drivers/char/tpm/tpm_i2c_infineon.c:469:		dev_err(chip->pdev, "Error left over data\n");
./drivers/char/tpm/tpm_i2c_infineon.c:480:	release_locality(chip, chip->vendor.locality, 0);
./drivers/char/tpm/tpm_i2c_infineon.c:503:		     chip->vendor.timeout_b, &status) < 0) {
./drivers/char/tpm/tpm_i2c_infineon.c:519:		rc = iic_tpm_write(TPM_DATA_FIFO(chip->vendor.locality),
./drivers/char/tpm/tpm_i2c_infineon.c:533:			      chip->vendor.timeout_c, &status);
./drivers/char/tpm/tpm_i2c_infineon.c:542:	iic_tpm_write(TPM_DATA_FIFO(chip->vendor.locality), &(buf[count]), 1);
./drivers/char/tpm/tpm_i2c_infineon.c:543:	wait_for_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c, &status);
./drivers/char/tpm/tpm_i2c_infineon.c:550:	iic_tpm_write(TPM_STS(chip->vendor.locality), &sts, 1);
./drivers/char/tpm/tpm_i2c_infineon.c:559:	release_locality(chip, chip->vendor.locality, 0);
./drivers/char/tpm/tpm_i2c_infineon.c:589:	chip->vendor.irq = 0;
./drivers/char/tpm/tpm_i2c_infineon.c:592:	chip->vendor.timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);
./drivers/char/tpm/tpm_i2c_infineon.c:593:	chip->vendor.timeout_b = msecs_to_jiffies(TIS_LONG_TIMEOUT);
./drivers/char/tpm/tpm_i2c_infineon.c:594:	chip->vendor.timeout_c = msecs_to_jiffies(TIS_SHORT_TIMEOUT);
./drivers/char/tpm/tpm_i2c_infineon.c:595:	chip->vendor.timeout_d = msecs_to_jiffies(TIS_SHORT_TIMEOUT);
./drivers/char/tpm/tpm_i2c_infineon.c:622:	INIT_LIST_HEAD(&chip->vendor.list);
./drivers/char/tpm/tpm_i2c_infineon.c:630:	release_locality(chip, chip->vendor.locality, 1);
./drivers/char/tpm/tpm_i2c_infineon.c:702:	release_locality(chip, chip->vendor.locality, 1);
./drivers/char/tpm/tpm_crb.c:91:	struct crb_priv *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_crb.c:103:	struct crb_priv *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_crb.c:129:	obj = acpi_evaluate_dsm(chip->acpi_dev_handle,
./drivers/char/tpm/tpm_crb.c:143:	struct crb_priv *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_crb.c:147:		dev_err(&chip->dev,
./drivers/char/tpm/tpm_crb.c:170:	struct crb_priv *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_crb.c:178:		dev_err(&chip->dev, "ACPI Start failed\n");
./drivers/char/tpm/tpm_crb.c:185:	struct crb_priv *priv = chip->vendor.priv;
./drivers/char/tpm/tpm_crb.c:210:	chip->vendor.priv = priv;
./drivers/char/tpm/tpm_crb.c:211:	chip->acpi_dev_handle = device->handle;
./drivers/char/tpm/tpm_crb.c:212:	chip->flags = TPM_CHIP_FLAG_TPM2;
./drivers/char/tpm/tpm_crb.c:347:	if (chip->flags & TPM_CHIP_FLAG_TPM2)
./drivers/char/tpm/xen-tpmfront.c:90:	if (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, chip->vendor.timeout_c,
./drivers/char/tpm/xen-tpmfront.c:91:			&chip->vendor.read_queue, true) < 0) {
./drivers/char/tpm/xen-tpmfront.c:107:			&chip->vendor.read_queue, true) < 0) {
./drivers/char/tpm/xen-tpmfront.c:127:	if (wait_for_tpm_stat(chip, VTPM_STATUS_RESULT, chip->vendor.timeout_c,
./drivers/char/tpm/xen-tpmfront.c:128:			&chip->vendor.read_queue, true) < 0) {
./drivers/char/tpm/xen-tpmfront.c:164:		wake_up_interruptible(&priv->chip->vendor.read_queue);
./drivers/char/tpm/xen-tpmfront.c:182:	init_waitqueue_head(&chip->vendor.read_queue);
./drivers/char/tpm/xen-tpmfront.c:220:	priv->chip->vendor.irq = rv;
./drivers/char/tpm/xen-tpmfront.c:280:	if (priv->chip && priv->chip->vendor.irq)
./drivers/char/tpm/xen-tpmfront.c:281:		unbind_from_irqhandler(priv->chip->vendor.irq, priv);
./drivers/char/tpm/tpm_ppi.c:58:	return scnprintf(buf, PAGE_SIZE, "%s\n", chip->ppi_version);
./drivers/char/tpm/tpm_ppi.c:68:	obj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETREQ,
./drivers/char/tpm/tpm_ppi.c:110:	if (acpi_check_dsm(chip->acpi_dev_handle, tpm_ppi_uuid,
./drivers/char/tpm/tpm_ppi.c:120:	if (strcmp(chip->ppi_version, "1.2") < 0) {
./drivers/char/tpm/tpm_ppi.c:132:	obj = tpm_eval_dsm(chip->acpi_dev_handle, func, ACPI_TYPE_INTEGER,
./drivers/char/tpm/tpm_ppi.c:174:	if (strcmp(chip->ppi_version, "1.2") < 0)
./drivers/char/tpm/tpm_ppi.c:176:	obj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETACT,
./drivers/char/tpm/tpm_ppi.c:202:	obj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETRSP,
./drivers/char/tpm/tpm_ppi.c:301:	return show_ppi_operations(chip->acpi_dev_handle, buf, 0,
./drivers/char/tpm/tpm_ppi.c:311:	return show_ppi_operations(chip->acpi_dev_handle, buf, PPI_VS_REQ_START,
./drivers/char/tpm/tpm_ppi.c:341:	if (!chip->acpi_dev_handle)
./drivers/char/tpm/tpm_ppi.c:344:	if (!acpi_check_dsm(chip->acpi_dev_handle, tpm_ppi_uuid,
./drivers/char/tpm/tpm_ppi.c:349:	obj = acpi_evaluate_dsm_typed(chip->acpi_dev_handle, tpm_ppi_uuid,
./drivers/char/tpm/tpm_ppi.c:353:		strlcpy(chip->ppi_version, obj->string.pointer,
./drivers/char/tpm/tpm_ppi.c:354:			sizeof(chip->ppi_version));
./drivers/char/tpm/tpm_ppi.c:358:	chip->groups[chip->groups_cnt++] = &ppi_attr_grp;
./drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:3306:/* 10Gb/s-BT PHY Support. chip-external 10Gb/s-BT PHYs are complex chips
./drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:3369:/* Handle updating of chip-external 10Gb/s-BT PHY firmware.  This needs to
./drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:3466:	/* If this is a 10Gb/s-BT adapter make sure the chip-external
./drivers/net/ethernet/via/via-rhine.c:970:	/* The chip-specific entries in the device structure. */
./drivers/net/ethernet/dec/tulip/winbond-840.c:432:	/* The chip-specific entries in the device structure. */
./drivers/net/ethernet/dlink/sundance.c:578:	/* The chip-specific entries in the device structure. */
./drivers/net/ethernet/8390/lib8390.c:17:  This is the chip-specific code for many 8390-based ethernet adaptors.
./drivers/net/ethernet/8390/axnet_cs.c:749:  This is the chip-specific code for many 8390-based ethernet adaptors.
./drivers/net/ethernet/3com/typhoon.c:2433:	/* The chip-specific entries in the device structure. */
./drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:5727: * bnx2x_func_init_cmn_chip - performs HW init at chip-common stage
./drivers/net/ethernet/broadcom/tg3.c:7479:	 * chip-internal interrupt pending events.
./drivers/net/ethernet/broadcom/tg3.c:7513:	 * chip-internal interrupt pending events.
./drivers/net/ethernet/broadcom/tg3.c:7562:	 * chip-internal interrupt pending events.
./drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c:1866:	/* Enable chip-wide vendor alarm */
./drivers/net/ethernet/smsc/smc9194.c:454: .    Attempt to allocate memory for a packet, if chip-memory is not
./drivers/net/ethernet/smsc/smc9194.c:1118: . chip-memory.
./drivers/net/irda/nsc-ircc.c:228:	for (chip = chips; chip->name ; chip++) {
./drivers/net/irda/nsc-ircc.c:230:			 chip->name);
./drivers/net/irda/nsc-ircc.c:233:		for (cfg = 0; cfg < ARRAY_SIZE(chip->cfg); cfg++) {
./drivers/net/irda/nsc-ircc.c:234:			cfg_base = chip->cfg[cfg];
./drivers/net/irda/nsc-ircc.c:247:			outb(chip->cid_index, cfg_base);
./drivers/net/irda/nsc-ircc.c:249:			if ((id & chip->cid_mask) == chip->cid_value) {
./drivers/net/irda/nsc-ircc.c:251:					 __func__, chip->name,
./drivers/net/irda/nsc-ircc.c:252:					 id & ~chip->cid_mask);
./drivers/net/irda/nsc-ircc.c:266:						net_info_ratelimited("%s, chip->init\n",
./drivers/net/irda/nsc-ircc.c:268:						chip->init(chip, &info);
./drivers/net/irda/nsc-ircc.c:270:						chip->probe(chip, &info);
./drivers/net/irda/nsc-ircc.c:296:						chip->init(chip, &info);
./drivers/net/irda/nsc-ircc.c:298:						chip->probe(chip, &info);
./drivers/net/irda/smsc-ircc2.c:2329:	while (chip->devid != devid) {
./drivers/net/irda/smsc-ircc2.c:2333:		if (chip->name == NULL)
./drivers/net/irda/smsc-ircc2.c:2338:			     devid, rev, cfg_base, type, chip->name);
./drivers/net/irda/smsc-ircc2.c:2340:	if (chip->rev > rev) {
./drivers/net/irda/smsc-ircc2.c:2345:	if (chip->flags & NoIRDA)
./drivers/net/irda/ali-ircc.c:166:	for (chip= chips; chip->name; chip++, i++) 
./drivers/net/irda/ali-ircc.c:168:		pr_debug("%s(), Probing for %s ...\n", __func__, chip->name);
./drivers/net/irda/ali-ircc.c:173:			cfg_base = chip->cfg[cfg];
./drivers/net/irda/ali-ircc.c:185:			outb(chip->entr1, cfg_base);
./drivers/net/irda/ali-ircc.c:186:			outb(chip->entr2, cfg_base);
./drivers/net/irda/ali-ircc.c:193:			outb(chip->cid_index, cfg_base);	
./drivers/net/irda/ali-ircc.c:196:			if (reg == chip->cid_value)
./drivers/net/irda/ali-ircc.c:204:					 __func__, chip->name, revision);
./drivers/net/irda/ali-ircc.c:213:					chip->init(chip, &info);
./drivers/net/irda/ali-ircc.c:217:					chip->probe(chip, &info);	
./drivers/net/irda/ali-ircc.c:227:					 __func__, chip->name, cfg_base);
./drivers/net/irda/ali-ircc.c:483:	outb(chip->entr1, cfg_base);
./drivers/net/irda/ali-ircc.c:484:	outb(chip->entr2, cfg_base);
./drivers/net/wireless/zydas/zd1211rw/zd_mac.c:286:	struct zd_usb *usb = &chip->usb;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:39:	mutex_init(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:40:	zd_usb_init(&chip->usb, hw, intf);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:41:	zd_rf_init(&chip->rf);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:46:	ZD_ASSERT(!mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:47:	zd_usb_clear(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:48:	zd_rf_clear(&chip->rf);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:49:	mutex_destroy(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:67:	i += zd_usb_scnprint_id(&chip->usb, buffer+i, size-i);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:71:	i += zd_rf_scnprint_id(&chip->rf, buffer+i, size-i);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:72:	i += scnprintf(buffer+i, size-i, " pa%1x %c%c%c%c%c", chip->pa_type,
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:73:		chip->patch_cck_gain ? 'g' : '-',
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:74:		chip->patch_cr157 ? '7' : '-',
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:75:		chip->patch_6m_band_edge ? '6' : '-',
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:76:		chip->new_phy_layout ? 'N' : '-',
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:77:		chip->al2230s_bit ? 'S' : '-');
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:154:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:173:	r = zd_usb_iowrite16v_async(&chip->usb, ioreqs16, count16);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:188:	zd_usb_iowrite16v_async_start(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:191:		zd_usb_iowrite16v_async_end(&chip->usb, 0);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:194:	return zd_usb_iowrite16v_async_end(&chip->usb, 50 /* ms */);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:203:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:204:	zd_usb_iowrite16v_async_start(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:218:		r = zd_usb_iowrite16v_async(&chip->usb, &ioreqs[i], j);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:220:			zd_usb_iowrite16v_async_end(&chip->usb, 0);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:228:	return zd_usb_iowrite16v_async_end(&chip->usb, 50 /* ms */);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:241:	zd_usb_iowrite16v_async_start(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:257:			zd_usb_iowrite16v_async_end(&chip->usb, 0);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:265:	return zd_usb_iowrite16v_async_end(&chip->usb, 50 /* ms */);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:272:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:274:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:282:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:284:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:292:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:294:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:302:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:304:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:313:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:315:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:324:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:326:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:335:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:343:	chip->pa_type = (value >> 16) & 0x0f;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:344:	chip->patch_cck_gain = (value >> 8) & 0x1;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:345:	chip->patch_cr157 = (value >> 13) & 0x1;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:346:	chip->patch_6m_band_edge = (value >> 21) & 0x1;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:347:	chip->new_phy_layout = (value >> 31) & 0x1;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:348:	chip->al2230s_bit = (value >> 7) & 0x1;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:349:	chip->link_led = ((value >> 4) & 1) ? LED1 : LED2;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:350:	chip->supports_tx_led = 1;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:353:			chip->supports_tx_led = 0;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:360:		chip->pa_type, chip->patch_cck_gain,
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:361:		chip->patch_cr157, chip->patch_6m_band_edge,
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:362:		chip->new_phy_layout,
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:363:		chip->link_led == LED1 ? 1 : 2,
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:364:		chip->supports_tx_led);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:368:	chip->pa_type = 0;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:369:	chip->patch_cck_gain = 0;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:370:	chip->patch_cr157 = 0;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:371:	chip->patch_6m_band_edge = 0;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:372:	chip->new_phy_layout = 0;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:395:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:397:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:429:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:431:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:448:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:470:	return read_values(chip, chip->pwr_cal_values,
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:477:	return read_values(chip, chip->pwr_int_values,
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:493:		r = read_values(chip, chip->ofdm_cal_values[i],
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:523:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:543:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:565:	if (!chip->patch_cr157)
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:583:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:584:	if (!chip->patch_6m_band_edge)
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:587:	return zd_rf_patch_6m_band_edge(&chip->rf, channel);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:787:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:806:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:836:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:901:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:937:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:939:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:948:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:962:	return (zd_addr_t)((u16)chip->fw_regs_base + offset);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1046:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1082:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1084:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1097:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1099:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1107:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1108:	r = zd_ioread16_locked(chip, (u16*)&chip->fw_regs_base,
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1113:		  (u16)chip->fw_regs_base);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1122:	return zd_usb_read_fw(&chip->usb, E2P_MAC_ADDR_P1, addr,
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1133:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1174:	r = zd_rf_init_hw(&chip->rf, rf_type);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1195:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1201:	u8 value = chip->pwr_int_values[channel - 1];
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1207:	u8 value = chip->pwr_cal_values[channel-1];
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1216:	ioreqs[0].value = chip->ofdm_cal_values[OFDM_36M_INDEX][channel-1];
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1218:	ioreqs[1].value = chip->ofdm_cal_values[OFDM_48M_INDEX][channel-1];
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1220:	ioreqs[2].value = chip->ofdm_cal_values[OFDM_54M_INDEX][channel-1];
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1230:	if (!zd_rf_should_update_pwr_int(&chip->rf))
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1263:	if (!chip->patch_cck_gain || !zd_rf_should_patch_cck_gain(&chip->rf))
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1266:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1278:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1282:	r = zd_rf_set_channel(&chip->rf, channel);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1300:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1308:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1309:	channel = chip->rf.channel;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1310:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1329:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1334:	other_led = chip->link_led == LED1 ? LED2 : LED1;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1345:			ioreqs[1].value &= ~chip->link_led;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1347:			ioreqs[1].value |= chip->link_led;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1353:		ioreqs[1].value |= chip->link_led;
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1367:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1378:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1380:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1428:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1429:	r = zd_switch_radio_on(&chip->rf);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1430:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1438:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1439:	r = zd_switch_radio_off(&chip->rf);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1440:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1448:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1449:	r = zd_usb_enable_int(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1450:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1456:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1457:	zd_usb_disable_int(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1458:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1468:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1469:	zd_usb_enable_tx(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1470:	r = zd_usb_enable_rx(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1471:	zd_tx_watchdog_enable(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1472:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1478:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1479:	zd_tx_watchdog_disable(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1480:	zd_usb_disable_rx(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1481:	zd_usb_disable_tx(&chip->usb);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1482:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1511:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1549:	mutex_lock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_chip.c:1552:	mutex_unlock(&chip->mutex);
./drivers/net/wireless/zydas/zd1211rw/zd_rf_al2230.c:95:	if (chip->new_phy_layout) {
./drivers/net/wireless/zydas/zd1211rw/zd_rf_uw2453.c:296:	u8 int_value = chip->pwr_int_values[channel - 1];
./drivers/net/wireless/zydas/zd1211rw/zd_rf.c:76:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_rf.c:141:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_rf.c:158:	ZD_ASSERT(mutex_is_locked(&chip->mutex));
./drivers/net/wireless/zydas/zd1211rw/zd_rf_al7230b.c:89:	if (chip->new_phy_layout) {
./drivers/net/wireless/zydas/zd1211rw/zd_rf_al7230b.c:289:	if (chip->new_phy_layout)
./drivers/net/wireless/ti/wl1251/io.c:44:	 * a chip-specific register address, so look it up in the registers
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:542:	return core->chip->ops->read32(core->chip->ctx, core->pub.base + reg);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:548:	core->chip->ops->write32(core->chip->ctx, core->pub.base + reg, val);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:605:	switch (sr->chip->pub.chip) {
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:607:		if (sr->chip->pub.chiprev < 2)
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:989:	core = brcmf_chip_get_core(&chip->pub, id);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1002:		val = chip->ops->read32(chip->ctx, cpu->wrapbase + BCMA_IOCTL);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1022:	pub = &chip->pub;
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1023:	cc = list_first_entry(&chip->cores, struct brcmf_core_priv, list);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1027:	pub->cc_caps = chip->ops->read32(chip->ctx,
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1029:	pub->cc_caps_ext = chip->ops->read32(chip->ctx,
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1036:		val = chip->ops->read32(chip->ctx,
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1046:	if (chip->ops->setup)
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1047:		ret = chip->ops->setup(chip->ctx, pub);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1073:	INIT_LIST_HEAD(&chip->cores);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1074:	chip->num_cores = 0;
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1075:	chip->ops = ops;
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1076:	chip->ctx = ctx;
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1090:	return &chip->pub;
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1093:	brcmf_chip_detach(&chip->pub);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1104:	list_for_each_entry_safe(core, tmp, &chip->cores, list) {
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1117:	list_for_each_entry(core, &chip->cores, list)
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1130:	cc = list_first_entry(&chip->cores, struct brcmf_core_priv, list);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1158:	return core->chip->iscoreup(core);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1166:	core->chip->coredisable(core, prereset, reset);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1175:	core->chip->resetcore(core, prereset, reset, postreset);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1185:	core = brcmf_chip_get_core(&chip->pub, BCMA_CORE_80211);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1190:	core = brcmf_chip_get_core(&chip->pub, BCMA_CORE_INTERNAL_MEM);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1194:	if (chip->pub.chip == BRCM_CC_43430_CHIP_ID) {
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1205:	core = brcmf_chip_get_core(&chip->pub, BCMA_CORE_INTERNAL_MEM);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1211:	chip->ops->activate(chip->ctx, &chip->pub, 0);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1213:	core = brcmf_chip_get_core(&chip->pub, BCMA_CORE_ARM_CM3);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1226:	core = brcmf_chip_get_core(&chip->pub, BCMA_CORE_80211);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1237:	chip->ops->activate(chip->ctx, &chip->pub, rstvec);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1240:	core = brcmf_chip_get_core(&chip->pub, BCMA_CORE_ARM_CR4);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1253:	core = brcmf_chip_get_core(&chip->pub, BCMA_CORE_80211);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1264:	chip->ops->activate(chip->ctx, &chip->pub, rstvec);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1267:	core = brcmf_chip_get_core(&chip->pub, BCMA_CORE_ARM_CA7);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1345:		chip->ops->write32(chip->ctx, addr, 3);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1347:		reg = chip->ops->read32(chip->ctx, addr);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1351:		reg = chip->ops->read32(chip->ctx, addr);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1355:		reg = chip->ops->read32(chip->ctx, addr);
./drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:1360:		reg = chip->ops->read32(chip->ctx, addr);
./drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c:90:/* 43224 chip-specific ChipControl register bits */
./drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c:109:/* 4331 chip-specific ChipControl register bits */
./drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c:147:/* 4319 chip-specific ChipStatus register bits */
./drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c:178:/* 4336 chip-specific ChipStatus register bits */
./drivers/net/wireless/broadcom/brcm80211/brcmsmac/aiutils.c:194:/* 4313 chip-specific ChipStatus register bits */
./drivers/net/wireless/broadcom/b43/main.c:3981:	 * the chip-internal counter. */
./drivers/net/wireless/broadcom/b43legacy/main.c:2686:	 * the chip-internal counter. */
./drivers/net/wireless/ath/ath10k/pci.c:2925:		if (supp_chip->dev_id == dev_id &&
./drivers/net/wireless/ath/ath10k/pci.c:2926:		    supp_chip->rev_id == rev_id)
./drivers/net/wireless/ath/ath10k/core.c:935:			  "bus=%s,bmi-chip-id=%d,bmi-board-id=%d",
./drivers/net/wireless/ath/ath9k/ar9003_phy.c:2072:		/* disable IRQ, disable chip-reset for BB panic */
./drivers/net/wireless/ath/ath9k/ar9003_phy.c:2088:	/* enable IRQ, disable chip-reset for BB watchdog */
./drivers/net/wireless/ath/ath5k/initvals.c:1431: * ath5k_hw_write_initvals() - Write initial chip-specific register dump
./drivers/net/wireless/ath/ath5k/initvals.c:1436: * Write initial chip-specific register dump, to get the chipset on a
./drivers/net/wireless/ath/ath5k/phy.c:975:	/* Bank Modifications (chip-specific) */
./drivers/net/phy/spi_ks8995.c:192:	result <<= ks->chip->addr_width + ks->chip->addr_shift;
./drivers/net/phy/spi_ks8995.c:194:	result |= address << ks->chip->addr_shift;
./drivers/net/phy/spi_ks8995.c:334:	if (id0 != ks->chip->family_id) {
./drivers/net/phy/spi_ks8995.c:336:			ks->chip->family_id, id0);
./drivers/net/phy/spi_ks8995.c:341:	switch (ks->chip->family_id) {
./drivers/net/phy/spi_ks8995.c:352:		    (get_chip_id(id1) == ks->chip->chip_id)) {
./drivers/net/phy/spi_ks8995.c:364:			    (ks->chip->chip_id == KSZ8864_CHIP_ID)) {
./drivers/net/phy/spi_ks8995.c:382:		if (get_chip_id(id1) == ks->chip->chip_id) {
./drivers/net/phy/spi_ks8995.c:494:	ks->regs_attr.size = ks->chip->regs_size;
./drivers/net/phy/spi_ks8995.c:509:		 ks->chip->name, ks->chip->chip_id, ks->revision_id);
./drivers/net/usb/sr9700.c:558:MODULE_DESCRIPTION("SR9700 one chip USB 1.1 USB to Ethernet device from http://www.corechip-sz.com/");
./drivers/net/usb/sr9800.c:870:MODULE_DESCRIPTION("SR9800 USB 2.0 USB2NET Dev : http://www.corechip-sz.com");
./drivers/net/usb/cdc_subset.c:59: * well tends to require chip-specific vendor requests.  Also, Windows
./drivers/i2c/muxes/i2c-mux-pca954x.c:159:	if (chip->muxtype == pca954x_ismux)
./drivers/i2c/muxes/i2c-mux-pca954x.c:160:		regval = chan | chip->enable;
./drivers/i2c/muxes/i2c-mux-gpio.c:56:	return !strcmp(chip->label, data);
./drivers/i2c/i2c-stub.c:103:	list_for_each_entry(b, &chip->smbus_blocks, node) {
./drivers/i2c/i2c-stub.c:114:		list_add(&rb->node, &chip->smbus_blocks);
./drivers/i2c/i2c-stub.c:121:	if (chip->bank_sel &&
./drivers/i2c/i2c-stub.c:122:	    offset >= chip->bank_start && offset <= chip->bank_end)
./drivers/i2c/i2c-stub.c:123:		return chip->bank_words +
./drivers/i2c/i2c-stub.c:124:		       (chip->bank_sel - 1) * chip->bank_size +
./drivers/i2c/i2c-stub.c:125:		       offset - chip->bank_start;
./drivers/i2c/i2c-stub.c:127:		return chip->words + offset;
./drivers/i2c/i2c-stub.c:159:			chip->pointer = command;
./drivers/i2c/i2c-stub.c:164:			wordp = stub_get_wordp(chip, chip->pointer++);
./drivers/i2c/i2c-stub.c:184:			if (chip->bank_words && command == chip->bank_reg) {
./drivers/i2c/i2c-stub.c:185:				chip->bank_sel =
./drivers/i2c/i2c-stub.c:186:					(data->byte >> chip->bank_shift)
./drivers/i2c/i2c-stub.c:187:					& chip->bank_mask;
./drivers/i2c/i2c-stub.c:190:					chip->bank_sel);
./drivers/i2c/i2c-stub.c:198:		chip->pointer = command + 1;
./drivers/i2c/i2c-stub.c:230:				chip->words[command + i] &= 0xff00;
./drivers/i2c/i2c-stub.c:231:				chip->words[command + i] |= data->block[1 + i];
./drivers/i2c/i2c-stub.c:239:					chip->words[command + i] & 0xff;
./drivers/i2c/i2c-stub.c:275:			chip->words[command] = (b->block[0] << 8) | b->len;
./drivers/i2c/i2c-stub.c:328:	chip->bank_reg = bank_reg[i];
./drivers/i2c/i2c-stub.c:329:	chip->bank_start = bank_start[i];
./drivers/i2c/i2c-stub.c:330:	chip->bank_end = bank_end[i];
./drivers/i2c/i2c-stub.c:331:	chip->bank_size = bank_end[i] - bank_start[i] + 1;
./drivers/i2c/i2c-stub.c:334:	chip->bank_mask = bank_mask[i];
./drivers/i2c/i2c-stub.c:335:	while (!(chip->bank_mask & 1)) {
./drivers/i2c/i2c-stub.c:336:		chip->bank_shift++;
./drivers/i2c/i2c-stub.c:337:		chip->bank_mask >>= 1;
./drivers/i2c/i2c-stub.c:340:	chip->bank_words = kzalloc(chip->bank_mask * chip->bank_size *
./drivers/i2c/i2c-stub.c:342:	if (!chip->bank_words)
./drivers/i2c/i2c-stub.c:346:		 chip->bank_mask, chip->bank_size, chip->bank_start,
./drivers/i2c/i2c-stub.c:347:		 chip->bank_end);
./drivers/i2c/busses/i2c-i801.c:220:	unsigned gpios[2];		/* Relative to gpio_chip->base */
./drivers/infiniband/hw/qib/qib_intr.c:98:	 * call the chip-specific code to take appropriate actions.
./drivers/infiniband/hw/qib/qib_intr.c:108:			goto skip_ibchange; /* chip-code handled */
./drivers/infiniband/hw/qib/qib_intr.c:114:			goto skip_ibchange; /* chip-code handled */
./drivers/infiniband/hw/qib/qib_twsi.c:47: * have been moved to chip-specific files.
./drivers/infiniband/hw/qib/qib_file_ops.c:1735:	 * array for time being.  If rcd->ctxt > chip-supported,
./drivers/infiniband/hw/qib/qib_init.c:565:	 * calculated in chip-specific code because it may cause some
./drivers/infiniband/hw/qib/qib_init.c:566:	 * chip-specific adjustments to be made.
./drivers/infiniband/hw/qib/qib_init.c:687:	/* Bypass most chip-init, to get to device creation */
./drivers/infiniband/hw/qib/qib_init.c:1124: * "extra" is for chip-specific data.
./drivers/infiniband/hw/qib/qib_init.c:1277: * Do all the generic driver unit- and chip-independent memory
./drivers/infiniband/hw/qib/qib_init.c:1445:	 * Clean up chip-specific stuff.
./drivers/infiniband/hw/qib/qib_sd7220.c:257:		 * Suppress it around the reset, both in chip-level
./drivers/infiniband/hw/qib/qib_sd7220.c:703:			 * loc encodes chip-select as well as address
./drivers/infiniband/hw/qib/qib_iba7220.c:58: * This file contains almost all the chip-specific register information and
./drivers/infiniband/hw/qib/qib_iba7220.c:630:	/* chip-specific hardware errors */
./drivers/infiniband/hw/qib/qib_iba7220.c:1254: * This is in chip-specific code because of all of the register accesses,
./drivers/infiniband/hw/qib/qib_iba7220.c:1475: * Only chip-specific because it's all register accesses
./drivers/infiniband/hw/qib/qib_iba7220.c:1792: * qib_setup_7220_cleanup - clean up any per-chip chip-specific stuff
./drivers/infiniband/hw/qib/qib_iba7220.c:2019: * Set up our chip-specific interrupt handler.
./drivers/infiniband/hw/qib/qib_iba7220.c:2270: * qib_init_7220_get_base_info - set chip-specific flags for user code
./drivers/infiniband/hw/qib/qib_iba7220.c:2755: * Modify the RCVCTRL register in chip-specific way. This
./drivers/infiniband/hw/qib/qib_iba7220.c:2757: * location is chip-specifc, but the needed operations are
./drivers/infiniband/hw/qib/qib_iba7220.c:2841: * Modify the SENDCTRL register in chip-specific way. This
./drivers/infiniband/hw/qib/qib_iba7220.c:4528: * qib_init_iba7220_funcs - set up the chip-specific function pointers
./drivers/infiniband/hw/qib/qib_iba7220.c:4533: * chip-specific function pointers for later use.
./drivers/infiniband/hw/qib/qib_iba7220.c:4608:	/* initialize chip-specific variables */
./drivers/infiniband/hw/qib/qib_diag.c:212: * @offs: the offset in chip-space
./drivers/infiniband/hw/qib/qib_diag.c:275:	 * chip-specific code here, so should not make many assumptions.
./drivers/infiniband/hw/qib/qib_eeprom.c:194:	 * figures out device. This will migrate to chip-specific.
./drivers/infiniband/hw/qib/qib_pcie.c:50: * from qib_pcie_params, which every chip-specific
./drivers/infiniband/hw/qib/qib_pcie.c:167: * Do PCIe cleanup, after chip-specific cleanup, etc.  Just prior
./drivers/infiniband/hw/qib/qib_pcie.c:446: * to move all the pcie code out of the chip-specific driver code.
./drivers/infiniband/hw/qib/qib_iba6120.c:54: * This file contains all the chip-specific register information and
./drivers/infiniband/hw/qib/qib_iba6120.c:538:	/* chip-specific hardware errors */
./drivers/infiniband/hw/qib/qib_iba6120.c:702: * This is in chip-specific code because of all of the register accesses,
./drivers/infiniband/hw/qib/qib_iba6120.c:1183: * Only chip-specific because it's all register accesses
./drivers/infiniband/hw/qib/qib_iba6120.c:1498: * qib_6120_setup_cleanup - clean up any per-chip chip-specific stuff
./drivers/infiniband/hw/qib/qib_iba6120.c:1703: * Set up our chip-specific interrupt handler
./drivers/infiniband/hw/qib/qib_iba6120.c:2047: * qib_6120_get_base_info - set chip-specific flags for user code
./drivers/infiniband/hw/qib/qib_iba6120.c:2127: * Modify the RCVCTRL register in chip-specific way. This
./drivers/infiniband/hw/qib/qib_iba6120.c:2129: * location is chip-specific, but the needed operations are
./drivers/infiniband/hw/qib/qib_iba6120.c:2228: * Modify the SENDCTRL register in chip-specific way. This
./drivers/infiniband/hw/qib/qib_iba6120.c:3483: * qib_init_iba6120_funcs - set up the chip-specific function pointers
./drivers/infiniband/hw/qib/qib_iba6120.c:3488: * chip-specific function pointers for later use.
./drivers/infiniband/hw/qib/qib_iba6120.c:3565:	/* initialize chip-specific variables */
./drivers/infiniband/hw/qib/qib_iba7322.c:237: * This file contains almost all the chip-specific register information and
./drivers/infiniband/hw/qib/qib_iba7322.c:2041: * This is in chip-specific code because of all of the register accesses,
./drivers/infiniband/hw/qib/qib_iba7322.c:2239: * Only chip-specific because it's all register accesses
./drivers/infiniband/hw/qib/qib_iba7322.c:3379: * Set up our chip-specific interrupt handler.
./drivers/infiniband/hw/qib/qib_iba7322.c:3897: * qib_init_7322_get_base_info - set chip-specific flags for user code
./drivers/infiniband/hw/qib/qib_iba7322.c:4510: * Modify the RCVCTRL register in chip-specific way. This
./drivers/infiniband/hw/qib/qib_iba7322.c:4512: * location is chip-specifc, but the needed operations are
./drivers/infiniband/hw/qib/qib_iba7322.c:4630: * Modify the SENDCTRL register in chip-specific way. This
./drivers/infiniband/hw/qib/qib_iba7322.c:7226: * qib_init_iba7322_funcs - set up the chip-specific function pointers
./drivers/infiniband/hw/qib/qib_iba7322.c:7234: * chip-specific function pointers for later use.
./drivers/infiniband/hw/qib/qib_iba7322.c:7313:	/* initialize chip-specific variables */
./drivers/infiniband/hw/qib/qib_iba7322.c:7402:	/* Get correct offset in chip-space, and in source table */
./drivers/infiniband/hw/hfi1/pcie.c:227: * Do PCIe cleanup related to dd, after chip-specific cleanup, etc.  Just prior
./drivers/infiniband/hw/hfi1/chip.c:14226: * chip-specific function pointers for later use.
./drivers/infiniband/hw/hfi1/twsi.c:62: * have been moved to chip-specific files.
./drivers/infiniband/hw/hfi1/init.c:1025: * "extra" is for chip-specific data.
./drivers/infiniband/hw/hfi1/init.c:1190: * Do all the generic driver unit- and chip-independent memory
